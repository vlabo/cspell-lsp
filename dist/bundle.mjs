#!/usr/bin/env node
import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/vscode-languageserver/lib/common/utils/is.js
var require_is = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.thenable = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = undefined;
  function boolean(value) {
    return value === true || value === false;
  }
  exports.boolean = boolean;
  function string(value) {
    return typeof value === "string" || value instanceof String;
  }
  exports.string = string;
  function number(value) {
    return typeof value === "number" || value instanceof Number;
  }
  exports.number = number;
  function error(value) {
    return value instanceof Error;
  }
  exports.error = error;
  function func(value) {
    return typeof value === "function";
  }
  exports.func = func;
  function array(value) {
    return Array.isArray(value);
  }
  exports.array = array;
  function stringArray(value) {
    return array(value) && value.every((elem) => string(elem));
  }
  exports.stringArray = stringArray;
  function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
  }
  exports.typedArray = typedArray;
  function thenable(value) {
    return value && func(value.then);
  }
  exports.thenable = thenable;
});

// node_modules/vscode-jsonrpc/lib/common/is.js
var require_is2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = undefined;
  function boolean(value) {
    return value === true || value === false;
  }
  exports.boolean = boolean;
  function string(value) {
    return typeof value === "string" || value instanceof String;
  }
  exports.string = string;
  function number(value) {
    return typeof value === "number" || value instanceof Number;
  }
  exports.number = number;
  function error(value) {
    return value instanceof Error;
  }
  exports.error = error;
  function func(value) {
    return typeof value === "function";
  }
  exports.func = func;
  function array(value) {
    return Array.isArray(value);
  }
  exports.array = array;
  function stringArray(value) {
    return array(value) && value.every((elem) => string(elem));
  }
  exports.stringArray = stringArray;
});

// node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Message = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = undefined;
  var is = require_is2();
  var ErrorCodes;
  (function(ErrorCodes2) {
    ErrorCodes2.ParseError = -32700;
    ErrorCodes2.InvalidRequest = -32600;
    ErrorCodes2.MethodNotFound = -32601;
    ErrorCodes2.InvalidParams = -32602;
    ErrorCodes2.InternalError = -32603;
    ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
    ErrorCodes2.serverErrorStart = -32099;
    ErrorCodes2.MessageWriteError = -32099;
    ErrorCodes2.MessageReadError = -32098;
    ErrorCodes2.PendingResponseRejected = -32097;
    ErrorCodes2.ConnectionInactive = -32096;
    ErrorCodes2.ServerNotInitialized = -32002;
    ErrorCodes2.UnknownErrorCode = -32001;
    ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32000;
    ErrorCodes2.serverErrorEnd = -32000;
  })(ErrorCodes || (exports.ErrorCodes = ErrorCodes = {}));

  class ResponseError extends Error {
    constructor(code, message, data) {
      super(message);
      this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
      this.data = data;
      Object.setPrototypeOf(this, ResponseError.prototype);
    }
    toJson() {
      const result = {
        code: this.code,
        message: this.message
      };
      if (this.data !== undefined) {
        result.data = this.data;
      }
      return result;
    }
  }
  exports.ResponseError = ResponseError;

  class ParameterStructures {
    constructor(kind) {
      this.kind = kind;
    }
    static is(value) {
      return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
    }
    toString() {
      return this.kind;
    }
  }
  exports.ParameterStructures = ParameterStructures;
  ParameterStructures.auto = new ParameterStructures("auto");
  ParameterStructures.byPosition = new ParameterStructures("byPosition");
  ParameterStructures.byName = new ParameterStructures("byName");

  class AbstractMessageSignature {
    constructor(method, numberOfParams) {
      this.method = method;
      this.numberOfParams = numberOfParams;
    }
    get parameterStructures() {
      return ParameterStructures.auto;
    }
  }
  exports.AbstractMessageSignature = AbstractMessageSignature;

  class RequestType0 extends AbstractMessageSignature {
    constructor(method) {
      super(method, 0);
    }
  }
  exports.RequestType0 = RequestType0;

  class RequestType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
      super(method, 1);
      this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
      return this._parameterStructures;
    }
  }
  exports.RequestType = RequestType;

  class RequestType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
      super(method, 1);
      this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
      return this._parameterStructures;
    }
  }
  exports.RequestType1 = RequestType1;

  class RequestType2 extends AbstractMessageSignature {
    constructor(method) {
      super(method, 2);
    }
  }
  exports.RequestType2 = RequestType2;

  class RequestType3 extends AbstractMessageSignature {
    constructor(method) {
      super(method, 3);
    }
  }
  exports.RequestType3 = RequestType3;

  class RequestType4 extends AbstractMessageSignature {
    constructor(method) {
      super(method, 4);
    }
  }
  exports.RequestType4 = RequestType4;

  class RequestType5 extends AbstractMessageSignature {
    constructor(method) {
      super(method, 5);
    }
  }
  exports.RequestType5 = RequestType5;

  class RequestType6 extends AbstractMessageSignature {
    constructor(method) {
      super(method, 6);
    }
  }
  exports.RequestType6 = RequestType6;

  class RequestType7 extends AbstractMessageSignature {
    constructor(method) {
      super(method, 7);
    }
  }
  exports.RequestType7 = RequestType7;

  class RequestType8 extends AbstractMessageSignature {
    constructor(method) {
      super(method, 8);
    }
  }
  exports.RequestType8 = RequestType8;

  class RequestType9 extends AbstractMessageSignature {
    constructor(method) {
      super(method, 9);
    }
  }
  exports.RequestType9 = RequestType9;

  class NotificationType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
      super(method, 1);
      this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
      return this._parameterStructures;
    }
  }
  exports.NotificationType = NotificationType;

  class NotificationType0 extends AbstractMessageSignature {
    constructor(method) {
      super(method, 0);
    }
  }
  exports.NotificationType0 = NotificationType0;

  class NotificationType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
      super(method, 1);
      this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
      return this._parameterStructures;
    }
  }
  exports.NotificationType1 = NotificationType1;

  class NotificationType2 extends AbstractMessageSignature {
    constructor(method) {
      super(method, 2);
    }
  }
  exports.NotificationType2 = NotificationType2;

  class NotificationType3 extends AbstractMessageSignature {
    constructor(method) {
      super(method, 3);
    }
  }
  exports.NotificationType3 = NotificationType3;

  class NotificationType4 extends AbstractMessageSignature {
    constructor(method) {
      super(method, 4);
    }
  }
  exports.NotificationType4 = NotificationType4;

  class NotificationType5 extends AbstractMessageSignature {
    constructor(method) {
      super(method, 5);
    }
  }
  exports.NotificationType5 = NotificationType5;

  class NotificationType6 extends AbstractMessageSignature {
    constructor(method) {
      super(method, 6);
    }
  }
  exports.NotificationType6 = NotificationType6;

  class NotificationType7 extends AbstractMessageSignature {
    constructor(method) {
      super(method, 7);
    }
  }
  exports.NotificationType7 = NotificationType7;

  class NotificationType8 extends AbstractMessageSignature {
    constructor(method) {
      super(method, 8);
    }
  }
  exports.NotificationType8 = NotificationType8;

  class NotificationType9 extends AbstractMessageSignature {
    constructor(method) {
      super(method, 9);
    }
  }
  exports.NotificationType9 = NotificationType9;
  var Message;
  (function(Message2) {
    function isRequest(message) {
      const candidate = message;
      return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
    }
    Message2.isRequest = isRequest;
    function isNotification(message) {
      const candidate = message;
      return candidate && is.string(candidate.method) && message.id === undefined;
    }
    Message2.isNotification = isNotification;
    function isResponse(message) {
      const candidate = message;
      return candidate && (candidate.result !== undefined || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
    }
    Message2.isResponse = isResponse;
  })(Message || (exports.Message = Message = {}));
});

// node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS((exports) => {
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LRUCache = exports.LinkedMap = exports.Touch = undefined;
  var Touch;
  (function(Touch2) {
    Touch2.None = 0;
    Touch2.First = 1;
    Touch2.AsOld = Touch2.First;
    Touch2.Last = 2;
    Touch2.AsNew = Touch2.Last;
  })(Touch || (exports.Touch = Touch = {}));

  class LinkedMap {
    constructor() {
      this[_a] = "LinkedMap";
      this._map = new Map;
      this._head = undefined;
      this._tail = undefined;
      this._size = 0;
      this._state = 0;
    }
    clear() {
      this._map.clear();
      this._head = undefined;
      this._tail = undefined;
      this._size = 0;
      this._state++;
    }
    isEmpty() {
      return !this._head && !this._tail;
    }
    get size() {
      return this._size;
    }
    get first() {
      return this._head?.value;
    }
    get last() {
      return this._tail?.value;
    }
    has(key) {
      return this._map.has(key);
    }
    get(key, touch = Touch.None) {
      const item = this._map.get(key);
      if (!item) {
        return;
      }
      if (touch !== Touch.None) {
        this.touch(item, touch);
      }
      return item.value;
    }
    set(key, value, touch = Touch.None) {
      let item = this._map.get(key);
      if (item) {
        item.value = value;
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
      } else {
        item = { key, value, next: undefined, previous: undefined };
        switch (touch) {
          case Touch.None:
            this.addItemLast(item);
            break;
          case Touch.First:
            this.addItemFirst(item);
            break;
          case Touch.Last:
            this.addItemLast(item);
            break;
          default:
            this.addItemLast(item);
            break;
        }
        this._map.set(key, item);
        this._size++;
      }
      return this;
    }
    delete(key) {
      return !!this.remove(key);
    }
    remove(key) {
      const item = this._map.get(key);
      if (!item) {
        return;
      }
      this._map.delete(key);
      this.removeItem(item);
      this._size--;
      return item.value;
    }
    shift() {
      if (!this._head && !this._tail) {
        return;
      }
      if (!this._head || !this._tail) {
        throw new Error("Invalid list");
      }
      const item = this._head;
      this._map.delete(item.key);
      this.removeItem(item);
      this._size--;
      return item.value;
    }
    forEach(callbackfn, thisArg) {
      const state = this._state;
      let current = this._head;
      while (current) {
        if (thisArg) {
          callbackfn.bind(thisArg)(current.value, current.key, this);
        } else {
          callbackfn(current.value, current.key, this);
        }
        if (this._state !== state) {
          throw new Error(`LinkedMap got modified during iteration.`);
        }
        current = current.next;
      }
    }
    keys() {
      const state = this._state;
      let current = this._head;
      const iterator = {
        [Symbol.iterator]: () => {
          return iterator;
        },
        next: () => {
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          if (current) {
            const result = { value: current.key, done: false };
            current = current.next;
            return result;
          } else {
            return { value: undefined, done: true };
          }
        }
      };
      return iterator;
    }
    values() {
      const state = this._state;
      let current = this._head;
      const iterator = {
        [Symbol.iterator]: () => {
          return iterator;
        },
        next: () => {
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          if (current) {
            const result = { value: current.value, done: false };
            current = current.next;
            return result;
          } else {
            return { value: undefined, done: true };
          }
        }
      };
      return iterator;
    }
    entries() {
      const state = this._state;
      let current = this._head;
      const iterator = {
        [Symbol.iterator]: () => {
          return iterator;
        },
        next: () => {
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          if (current) {
            const result = { value: [current.key, current.value], done: false };
            current = current.next;
            return result;
          } else {
            return { value: undefined, done: true };
          }
        }
      };
      return iterator;
    }
    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
      return this.entries();
    }
    trimOld(newSize) {
      if (newSize >= this.size) {
        return;
      }
      if (newSize === 0) {
        this.clear();
        return;
      }
      let current = this._head;
      let currentSize = this.size;
      while (current && currentSize > newSize) {
        this._map.delete(current.key);
        current = current.next;
        currentSize--;
      }
      this._head = current;
      this._size = currentSize;
      if (current) {
        current.previous = undefined;
      }
      this._state++;
    }
    addItemFirst(item) {
      if (!this._head && !this._tail) {
        this._tail = item;
      } else if (!this._head) {
        throw new Error("Invalid list");
      } else {
        item.next = this._head;
        this._head.previous = item;
      }
      this._head = item;
      this._state++;
    }
    addItemLast(item) {
      if (!this._head && !this._tail) {
        this._head = item;
      } else if (!this._tail) {
        throw new Error("Invalid list");
      } else {
        item.previous = this._tail;
        this._tail.next = item;
      }
      this._tail = item;
      this._state++;
    }
    removeItem(item) {
      if (item === this._head && item === this._tail) {
        this._head = undefined;
        this._tail = undefined;
      } else if (item === this._head) {
        if (!item.next) {
          throw new Error("Invalid list");
        }
        item.next.previous = undefined;
        this._head = item.next;
      } else if (item === this._tail) {
        if (!item.previous) {
          throw new Error("Invalid list");
        }
        item.previous.next = undefined;
        this._tail = item.previous;
      } else {
        const next = item.next;
        const previous = item.previous;
        if (!next || !previous) {
          throw new Error("Invalid list");
        }
        next.previous = previous;
        previous.next = next;
      }
      item.next = undefined;
      item.previous = undefined;
      this._state++;
    }
    touch(item, touch) {
      if (!this._head || !this._tail) {
        throw new Error("Invalid list");
      }
      if (touch !== Touch.First && touch !== Touch.Last) {
        return;
      }
      if (touch === Touch.First) {
        if (item === this._head) {
          return;
        }
        const next = item.next;
        const previous = item.previous;
        if (item === this._tail) {
          previous.next = undefined;
          this._tail = previous;
        } else {
          next.previous = previous;
          previous.next = next;
        }
        item.previous = undefined;
        item.next = this._head;
        this._head.previous = item;
        this._head = item;
        this._state++;
      } else if (touch === Touch.Last) {
        if (item === this._tail) {
          return;
        }
        const next = item.next;
        const previous = item.previous;
        if (item === this._head) {
          next.previous = undefined;
          this._head = next;
        } else {
          next.previous = previous;
          previous.next = next;
        }
        item.next = undefined;
        item.previous = this._tail;
        this._tail.next = item;
        this._tail = item;
        this._state++;
      }
    }
    toJSON() {
      const data = [];
      this.forEach((value, key) => {
        data.push([key, value]);
      });
      return data;
    }
    fromJSON(data) {
      this.clear();
      for (const [key, value] of data) {
        this.set(key, value);
      }
    }
  }
  exports.LinkedMap = LinkedMap;

  class LRUCache extends LinkedMap {
    constructor(limit, ratio = 1) {
      super();
      this._limit = limit;
      this._ratio = Math.min(Math.max(0, ratio), 1);
    }
    get limit() {
      return this._limit;
    }
    set limit(limit) {
      this._limit = limit;
      this.checkTrim();
    }
    get ratio() {
      return this._ratio;
    }
    set ratio(ratio) {
      this._ratio = Math.min(Math.max(0, ratio), 1);
      this.checkTrim();
    }
    get(key, touch = Touch.AsNew) {
      return super.get(key, touch);
    }
    peek(key) {
      return super.get(key, Touch.None);
    }
    set(key, value) {
      super.set(key, value, Touch.Last);
      this.checkTrim();
      return this;
    }
    checkTrim() {
      if (this.size > this._limit) {
        this.trimOld(Math.round(this._limit * this._ratio));
      }
    }
  }
  exports.LRUCache = LRUCache;
});

// node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Disposable = undefined;
  var Disposable;
  (function(Disposable2) {
    function create(func) {
      return {
        dispose: func
      };
    }
    Disposable2.create = create;
  })(Disposable || (exports.Disposable = Disposable = {}));
});

// node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var _ral;
  function RAL() {
    if (_ral === undefined) {
      throw new Error(`No runtime abstraction layer installed`);
    }
    return _ral;
  }
  (function(RAL2) {
    function install(ral) {
      if (ral === undefined) {
        throw new Error(`No runtime abstraction layer provided`);
      }
      _ral = ral;
    }
    RAL2.install = install;
  })(RAL || (RAL = {}));
  exports.default = RAL;
});

// node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Emitter = exports.Event = undefined;
  var ral_1 = require_ral();
  var Event;
  (function(Event2) {
    const _disposable = { dispose() {
    } };
    Event2.None = function() {
      return _disposable;
    };
  })(Event || (exports.Event = Event = {}));

  class CallbackList {
    add(callback, context = null, bucket) {
      if (!this._callbacks) {
        this._callbacks = [];
        this._contexts = [];
      }
      this._callbacks.push(callback);
      this._contexts.push(context);
      if (Array.isArray(bucket)) {
        bucket.push({ dispose: () => this.remove(callback, context) });
      }
    }
    remove(callback, context = null) {
      if (!this._callbacks) {
        return;
      }
      let foundCallbackWithDifferentContext = false;
      for (let i = 0, len = this._callbacks.length;i < len; i++) {
        if (this._callbacks[i] === callback) {
          if (this._contexts[i] === context) {
            this._callbacks.splice(i, 1);
            this._contexts.splice(i, 1);
            return;
          } else {
            foundCallbackWithDifferentContext = true;
          }
        }
      }
      if (foundCallbackWithDifferentContext) {
        throw new Error("When adding a listener with a context, you should remove it with the same context");
      }
    }
    invoke(...args) {
      if (!this._callbacks) {
        return [];
      }
      const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
      for (let i = 0, len = callbacks.length;i < len; i++) {
        try {
          ret.push(callbacks[i].apply(contexts[i], args));
        } catch (e) {
          (0, ral_1.default)().console.error(e);
        }
      }
      return ret;
    }
    isEmpty() {
      return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
      this._callbacks = undefined;
      this._contexts = undefined;
    }
  }

  class Emitter {
    constructor(_options) {
      this._options = _options;
    }
    get event() {
      if (!this._event) {
        this._event = (listener, thisArgs, disposables) => {
          if (!this._callbacks) {
            this._callbacks = new CallbackList;
          }
          if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
            this._options.onFirstListenerAdd(this);
          }
          this._callbacks.add(listener, thisArgs);
          const result = {
            dispose: () => {
              if (!this._callbacks) {
                return;
              }
              this._callbacks.remove(listener, thisArgs);
              result.dispose = Emitter._noop;
              if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                this._options.onLastListenerRemove(this);
              }
            }
          };
          if (Array.isArray(disposables)) {
            disposables.push(result);
          }
          return result;
        };
      }
      return this._event;
    }
    fire(event) {
      if (this._callbacks) {
        this._callbacks.invoke.call(this._callbacks, event);
      }
    }
    dispose() {
      if (this._callbacks) {
        this._callbacks.dispose();
        this._callbacks = undefined;
      }
    }
  }
  exports.Emitter = Emitter;
  Emitter._noop = function() {
  };
});

// node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CancellationTokenSource = exports.CancellationToken = undefined;
  var ral_1 = require_ral();
  var Is = require_is2();
  var events_1 = require_events();
  var CancellationToken;
  (function(CancellationToken2) {
    CancellationToken2.None = Object.freeze({
      isCancellationRequested: false,
      onCancellationRequested: events_1.Event.None
    });
    CancellationToken2.Cancelled = Object.freeze({
      isCancellationRequested: true,
      onCancellationRequested: events_1.Event.None
    });
    function is(value) {
      const candidate = value;
      return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
    }
    CancellationToken2.is = is;
  })(CancellationToken || (exports.CancellationToken = CancellationToken = {}));
  var shortcutEvent = Object.freeze(function(callback, context) {
    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
    return { dispose() {
      handle.dispose();
    } };
  });

  class MutableToken {
    constructor() {
      this._isCancelled = false;
    }
    cancel() {
      if (!this._isCancelled) {
        this._isCancelled = true;
        if (this._emitter) {
          this._emitter.fire(undefined);
          this.dispose();
        }
      }
    }
    get isCancellationRequested() {
      return this._isCancelled;
    }
    get onCancellationRequested() {
      if (this._isCancelled) {
        return shortcutEvent;
      }
      if (!this._emitter) {
        this._emitter = new events_1.Emitter;
      }
      return this._emitter.event;
    }
    dispose() {
      if (this._emitter) {
        this._emitter.dispose();
        this._emitter = undefined;
      }
    }
  }

  class CancellationTokenSource {
    get token() {
      if (!this._token) {
        this._token = new MutableToken;
      }
      return this._token;
    }
    cancel() {
      if (!this._token) {
        this._token = CancellationToken.Cancelled;
      } else {
        this._token.cancel();
      }
    }
    dispose() {
      if (!this._token) {
        this._token = CancellationToken.None;
      } else if (this._token instanceof MutableToken) {
        this._token.dispose();
      }
    }
  }
  exports.CancellationTokenSource = CancellationTokenSource;
});

// node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js
var require_sharedArrayCancellation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = undefined;
  var cancellation_1 = require_cancellation();
  var CancellationState;
  (function(CancellationState2) {
    CancellationState2.Continue = 0;
    CancellationState2.Cancelled = 1;
  })(CancellationState || (CancellationState = {}));

  class SharedArraySenderStrategy {
    constructor() {
      this.buffers = new Map;
    }
    enableCancellation(request) {
      if (request.id === null) {
        return;
      }
      const buffer = new SharedArrayBuffer(4);
      const data = new Int32Array(buffer, 0, 1);
      data[0] = CancellationState.Continue;
      this.buffers.set(request.id, buffer);
      request.$cancellationData = buffer;
    }
    async sendCancellation(_conn, id) {
      const buffer = this.buffers.get(id);
      if (buffer === undefined) {
        return;
      }
      const data = new Int32Array(buffer, 0, 1);
      Atomics.store(data, 0, CancellationState.Cancelled);
    }
    cleanup(id) {
      this.buffers.delete(id);
    }
    dispose() {
      this.buffers.clear();
    }
  }
  exports.SharedArraySenderStrategy = SharedArraySenderStrategy;

  class SharedArrayBufferCancellationToken {
    constructor(buffer) {
      this.data = new Int32Array(buffer, 0, 1);
    }
    get isCancellationRequested() {
      return Atomics.load(this.data, 0) === CancellationState.Cancelled;
    }
    get onCancellationRequested() {
      throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
    }
  }

  class SharedArrayBufferCancellationTokenSource {
    constructor(buffer) {
      this.token = new SharedArrayBufferCancellationToken(buffer);
    }
    cancel() {
    }
    dispose() {
    }
  }

  class SharedArrayReceiverStrategy {
    constructor() {
      this.kind = "request";
    }
    createCancellationTokenSource(request) {
      const buffer = request.$cancellationData;
      if (buffer === undefined) {
        return new cancellation_1.CancellationTokenSource;
      }
      return new SharedArrayBufferCancellationTokenSource(buffer);
    }
  }
  exports.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
});

// node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Semaphore = undefined;
  var ral_1 = require_ral();

  class Semaphore {
    constructor(capacity = 1) {
      if (capacity <= 0) {
        throw new Error("Capacity must be greater than 0");
      }
      this._capacity = capacity;
      this._active = 0;
      this._waiting = [];
    }
    lock(thunk) {
      return new Promise((resolve, reject) => {
        this._waiting.push({ thunk, resolve, reject });
        this.runNext();
      });
    }
    get active() {
      return this._active;
    }
    runNext() {
      if (this._waiting.length === 0 || this._active === this._capacity) {
        return;
      }
      (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
    }
    doRunNext() {
      if (this._waiting.length === 0 || this._active === this._capacity) {
        return;
      }
      const next = this._waiting.shift();
      this._active++;
      if (this._active > this._capacity) {
        throw new Error(`To many thunks active`);
      }
      try {
        const result = next.thunk();
        if (result instanceof Promise) {
          result.then((value) => {
            this._active--;
            next.resolve(value);
            this.runNext();
          }, (err) => {
            this._active--;
            next.reject(err);
            this.runNext();
          });
        } else {
          this._active--;
          next.resolve(result);
          this.runNext();
        }
      } catch (err) {
        this._active--;
        next.reject(err);
        this.runNext();
      }
    }
  }
  exports.Semaphore = Semaphore;
});

// node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = undefined;
  var ral_1 = require_ral();
  var Is = require_is2();
  var events_1 = require_events();
  var semaphore_1 = require_semaphore();
  var MessageReader;
  (function(MessageReader2) {
    function is(value) {
      let candidate = value;
      return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
    }
    MessageReader2.is = is;
  })(MessageReader || (exports.MessageReader = MessageReader = {}));

  class AbstractMessageReader {
    constructor() {
      this.errorEmitter = new events_1.Emitter;
      this.closeEmitter = new events_1.Emitter;
      this.partialMessageEmitter = new events_1.Emitter;
    }
    dispose() {
      this.errorEmitter.dispose();
      this.closeEmitter.dispose();
    }
    get onError() {
      return this.errorEmitter.event;
    }
    fireError(error) {
      this.errorEmitter.fire(this.asError(error));
    }
    get onClose() {
      return this.closeEmitter.event;
    }
    fireClose() {
      this.closeEmitter.fire(undefined);
    }
    get onPartialMessage() {
      return this.partialMessageEmitter.event;
    }
    firePartialMessage(info) {
      this.partialMessageEmitter.fire(info);
    }
    asError(error) {
      if (error instanceof Error) {
        return error;
      } else {
        return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
      }
    }
  }
  exports.AbstractMessageReader = AbstractMessageReader;
  var ResolvedMessageReaderOptions;
  (function(ResolvedMessageReaderOptions2) {
    function fromOptions(options) {
      let charset;
      let result;
      let contentDecoder;
      const contentDecoders = new Map;
      let contentTypeDecoder;
      const contentTypeDecoders = new Map;
      if (options === undefined || typeof options === "string") {
        charset = options ?? "utf-8";
      } else {
        charset = options.charset ?? "utf-8";
        if (options.contentDecoder !== undefined) {
          contentDecoder = options.contentDecoder;
          contentDecoders.set(contentDecoder.name, contentDecoder);
        }
        if (options.contentDecoders !== undefined) {
          for (const decoder of options.contentDecoders) {
            contentDecoders.set(decoder.name, decoder);
          }
        }
        if (options.contentTypeDecoder !== undefined) {
          contentTypeDecoder = options.contentTypeDecoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        if (options.contentTypeDecoders !== undefined) {
          for (const decoder of options.contentTypeDecoders) {
            contentTypeDecoders.set(decoder.name, decoder);
          }
        }
      }
      if (contentTypeDecoder === undefined) {
        contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
        contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
      }
      return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
    }
    ResolvedMessageReaderOptions2.fromOptions = fromOptions;
  })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));

  class ReadableStreamMessageReader extends AbstractMessageReader {
    constructor(readable, options) {
      super();
      this.readable = readable;
      this.options = ResolvedMessageReaderOptions.fromOptions(options);
      this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
      this._partialMessageTimeout = 1e4;
      this.nextMessageLength = -1;
      this.messageToken = 0;
      this.readSemaphore = new semaphore_1.Semaphore(1);
    }
    set partialMessageTimeout(timeout) {
      this._partialMessageTimeout = timeout;
    }
    get partialMessageTimeout() {
      return this._partialMessageTimeout;
    }
    listen(callback) {
      this.nextMessageLength = -1;
      this.messageToken = 0;
      this.partialMessageTimer = undefined;
      this.callback = callback;
      const result = this.readable.onData((data) => {
        this.onData(data);
      });
      this.readable.onError((error) => this.fireError(error));
      this.readable.onClose(() => this.fireClose());
      return result;
    }
    onData(data) {
      try {
        this.buffer.append(data);
        while (true) {
          if (this.nextMessageLength === -1) {
            const headers = this.buffer.tryReadHeaders(true);
            if (!headers) {
              return;
            }
            const contentLength = headers.get("content-length");
            if (!contentLength) {
              this.fireError(new Error(`Header must provide a Content-Length property.
${JSON.stringify(Object.fromEntries(headers))}`));
              return;
            }
            const length = parseInt(contentLength);
            if (isNaN(length)) {
              this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
              return;
            }
            this.nextMessageLength = length;
          }
          const body = this.buffer.tryReadBody(this.nextMessageLength);
          if (body === undefined) {
            this.setPartialMessageTimer();
            return;
          }
          this.clearPartialMessageTimer();
          this.nextMessageLength = -1;
          this.readSemaphore.lock(async () => {
            const bytes = this.options.contentDecoder !== undefined ? await this.options.contentDecoder.decode(body) : body;
            const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
            this.callback(message);
          }).catch((error) => {
            this.fireError(error);
          });
        }
      } catch (error) {
        this.fireError(error);
      }
    }
    clearPartialMessageTimer() {
      if (this.partialMessageTimer) {
        this.partialMessageTimer.dispose();
        this.partialMessageTimer = undefined;
      }
    }
    setPartialMessageTimer() {
      this.clearPartialMessageTimer();
      if (this._partialMessageTimeout <= 0) {
        return;
      }
      this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
        this.partialMessageTimer = undefined;
        if (token === this.messageToken) {
          this.firePartialMessage({ messageToken: token, waitingTime: timeout });
          this.setPartialMessageTimer();
        }
      }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
    }
  }
  exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
});

// node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = undefined;
  var ral_1 = require_ral();
  var Is = require_is2();
  var semaphore_1 = require_semaphore();
  var events_1 = require_events();
  var ContentLength = "Content-Length: ";
  var CRLF = `\r
`;
  var MessageWriter;
  (function(MessageWriter2) {
    function is(value) {
      let candidate = value;
      return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
    }
    MessageWriter2.is = is;
  })(MessageWriter || (exports.MessageWriter = MessageWriter = {}));

  class AbstractMessageWriter {
    constructor() {
      this.errorEmitter = new events_1.Emitter;
      this.closeEmitter = new events_1.Emitter;
    }
    dispose() {
      this.errorEmitter.dispose();
      this.closeEmitter.dispose();
    }
    get onError() {
      return this.errorEmitter.event;
    }
    fireError(error, message, count) {
      this.errorEmitter.fire([this.asError(error), message, count]);
    }
    get onClose() {
      return this.closeEmitter.event;
    }
    fireClose() {
      this.closeEmitter.fire(undefined);
    }
    asError(error) {
      if (error instanceof Error) {
        return error;
      } else {
        return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
      }
    }
  }
  exports.AbstractMessageWriter = AbstractMessageWriter;
  var ResolvedMessageWriterOptions;
  (function(ResolvedMessageWriterOptions2) {
    function fromOptions(options) {
      if (options === undefined || typeof options === "string") {
        return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
      } else {
        return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
      }
    }
    ResolvedMessageWriterOptions2.fromOptions = fromOptions;
  })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));

  class WriteableStreamMessageWriter extends AbstractMessageWriter {
    constructor(writable, options) {
      super();
      this.writable = writable;
      this.options = ResolvedMessageWriterOptions.fromOptions(options);
      this.errorCount = 0;
      this.writeSemaphore = new semaphore_1.Semaphore(1);
      this.writable.onError((error) => this.fireError(error));
      this.writable.onClose(() => this.fireClose());
    }
    async write(msg) {
      return this.writeSemaphore.lock(async () => {
        const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
          if (this.options.contentEncoder !== undefined) {
            return this.options.contentEncoder.encode(buffer);
          } else {
            return buffer;
          }
        });
        return payload.then((buffer) => {
          const headers = [];
          headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
          headers.push(CRLF);
          return this.doWrite(msg, headers, buffer);
        }, (error) => {
          this.fireError(error);
          throw error;
        });
      });
    }
    async doWrite(msg, headers, data) {
      try {
        await this.writable.write(headers.join(""), "ascii");
        return this.writable.write(data);
      } catch (error) {
        this.handleError(error, msg);
        return Promise.reject(error);
      }
    }
    handleError(error, msg) {
      this.errorCount++;
      this.fireError(error, msg, this.errorCount);
    }
    end() {
      this.writable.end();
    }
  }
  exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
});

// node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbstractMessageBuffer = undefined;
  var CR = 13;
  var LF = 10;
  var CRLF = `\r
`;

  class AbstractMessageBuffer {
    constructor(encoding = "utf-8") {
      this._encoding = encoding;
      this._chunks = [];
      this._totalLength = 0;
    }
    get encoding() {
      return this._encoding;
    }
    append(chunk) {
      const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
      this._chunks.push(toAppend);
      this._totalLength += toAppend.byteLength;
    }
    tryReadHeaders(lowerCaseKeys = false) {
      if (this._chunks.length === 0) {
        return;
      }
      let state = 0;
      let chunkIndex = 0;
      let offset = 0;
      let chunkBytesRead = 0;
      row:
        while (chunkIndex < this._chunks.length) {
          const chunk = this._chunks[chunkIndex];
          offset = 0;
          column:
            while (offset < chunk.length) {
              const value = chunk[offset];
              switch (value) {
                case CR:
                  switch (state) {
                    case 0:
                      state = 1;
                      break;
                    case 2:
                      state = 3;
                      break;
                    default:
                      state = 0;
                  }
                  break;
                case LF:
                  switch (state) {
                    case 1:
                      state = 2;
                      break;
                    case 3:
                      state = 4;
                      offset++;
                      break row;
                    default:
                      state = 0;
                  }
                  break;
                default:
                  state = 0;
              }
              offset++;
            }
          chunkBytesRead += chunk.byteLength;
          chunkIndex++;
        }
      if (state !== 4) {
        return;
      }
      const buffer = this._read(chunkBytesRead + offset);
      const result = new Map;
      const headers = this.toString(buffer, "ascii").split(CRLF);
      if (headers.length < 2) {
        return result;
      }
      for (let i = 0;i < headers.length - 2; i++) {
        const header = headers[i];
        const index = header.indexOf(":");
        if (index === -1) {
          throw new Error(`Message header must separate key and value using ':'
${header}`);
        }
        const key = header.substr(0, index);
        const value = header.substr(index + 1).trim();
        result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
      }
      return result;
    }
    tryReadBody(length) {
      if (this._totalLength < length) {
        return;
      }
      return this._read(length);
    }
    get numberOfBytes() {
      return this._totalLength;
    }
    _read(byteCount) {
      if (byteCount === 0) {
        return this.emptyBuffer();
      }
      if (byteCount > this._totalLength) {
        throw new Error(`Cannot read so many bytes!`);
      }
      if (this._chunks[0].byteLength === byteCount) {
        const chunk = this._chunks[0];
        this._chunks.shift();
        this._totalLength -= byteCount;
        return this.asNative(chunk);
      }
      if (this._chunks[0].byteLength > byteCount) {
        const chunk = this._chunks[0];
        const result2 = this.asNative(chunk, byteCount);
        this._chunks[0] = chunk.slice(byteCount);
        this._totalLength -= byteCount;
        return result2;
      }
      const result = this.allocNative(byteCount);
      let resultOffset = 0;
      let chunkIndex = 0;
      while (byteCount > 0) {
        const chunk = this._chunks[chunkIndex];
        if (chunk.byteLength > byteCount) {
          const chunkPart = chunk.slice(0, byteCount);
          result.set(chunkPart, resultOffset);
          resultOffset += byteCount;
          this._chunks[chunkIndex] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          byteCount -= byteCount;
        } else {
          result.set(chunk, resultOffset);
          resultOffset += chunk.byteLength;
          this._chunks.shift();
          this._totalLength -= chunk.byteLength;
          byteCount -= chunk.byteLength;
        }
      }
      return result;
    }
  }
  exports.AbstractMessageBuffer = AbstractMessageBuffer;
});

// node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createMessageConnection = exports.ConnectionOptions = exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = undefined;
  var ral_1 = require_ral();
  var Is = require_is2();
  var messages_1 = require_messages();
  var linkedMap_1 = require_linkedMap();
  var events_1 = require_events();
  var cancellation_1 = require_cancellation();
  var CancelNotification;
  (function(CancelNotification2) {
    CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
  })(CancelNotification || (CancelNotification = {}));
  var ProgressToken;
  (function(ProgressToken2) {
    function is(value) {
      return typeof value === "string" || typeof value === "number";
    }
    ProgressToken2.is = is;
  })(ProgressToken || (exports.ProgressToken = ProgressToken = {}));
  var ProgressNotification;
  (function(ProgressNotification2) {
    ProgressNotification2.type = new messages_1.NotificationType("$/progress");
  })(ProgressNotification || (ProgressNotification = {}));

  class ProgressType {
    constructor() {
    }
  }
  exports.ProgressType = ProgressType;
  var StarRequestHandler;
  (function(StarRequestHandler2) {
    function is(value) {
      return Is.func(value);
    }
    StarRequestHandler2.is = is;
  })(StarRequestHandler || (StarRequestHandler = {}));
  exports.NullLogger = Object.freeze({
    error: () => {
    },
    warn: () => {
    },
    info: () => {
    },
    log: () => {
    }
  });
  var Trace;
  (function(Trace2) {
    Trace2[Trace2["Off"] = 0] = "Off";
    Trace2[Trace2["Messages"] = 1] = "Messages";
    Trace2[Trace2["Compact"] = 2] = "Compact";
    Trace2[Trace2["Verbose"] = 3] = "Verbose";
  })(Trace || (exports.Trace = Trace = {}));
  var TraceValues;
  (function(TraceValues2) {
    TraceValues2.Off = "off";
    TraceValues2.Messages = "messages";
    TraceValues2.Compact = "compact";
    TraceValues2.Verbose = "verbose";
  })(TraceValues || (exports.TraceValues = TraceValues = {}));
  (function(Trace2) {
    function fromString(value) {
      if (!Is.string(value)) {
        return Trace2.Off;
      }
      value = value.toLowerCase();
      switch (value) {
        case "off":
          return Trace2.Off;
        case "messages":
          return Trace2.Messages;
        case "compact":
          return Trace2.Compact;
        case "verbose":
          return Trace2.Verbose;
        default:
          return Trace2.Off;
      }
    }
    Trace2.fromString = fromString;
    function toString(value) {
      switch (value) {
        case Trace2.Off:
          return "off";
        case Trace2.Messages:
          return "messages";
        case Trace2.Compact:
          return "compact";
        case Trace2.Verbose:
          return "verbose";
        default:
          return "off";
      }
    }
    Trace2.toString = toString;
  })(Trace || (exports.Trace = Trace = {}));
  var TraceFormat;
  (function(TraceFormat2) {
    TraceFormat2["Text"] = "text";
    TraceFormat2["JSON"] = "json";
  })(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
  (function(TraceFormat2) {
    function fromString(value) {
      if (!Is.string(value)) {
        return TraceFormat2.Text;
      }
      value = value.toLowerCase();
      if (value === "json") {
        return TraceFormat2.JSON;
      } else {
        return TraceFormat2.Text;
      }
    }
    TraceFormat2.fromString = fromString;
  })(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
  var SetTraceNotification;
  (function(SetTraceNotification2) {
    SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
  })(SetTraceNotification || (exports.SetTraceNotification = SetTraceNotification = {}));
  var LogTraceNotification;
  (function(LogTraceNotification2) {
    LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
  })(LogTraceNotification || (exports.LogTraceNotification = LogTraceNotification = {}));
  var ConnectionErrors;
  (function(ConnectionErrors2) {
    ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
    ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
    ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
  })(ConnectionErrors || (exports.ConnectionErrors = ConnectionErrors = {}));

  class ConnectionError extends Error {
    constructor(code, message) {
      super(message);
      this.code = code;
      Object.setPrototypeOf(this, ConnectionError.prototype);
    }
  }
  exports.ConnectionError = ConnectionError;
  var ConnectionStrategy;
  (function(ConnectionStrategy2) {
    function is(value) {
      const candidate = value;
      return candidate && Is.func(candidate.cancelUndispatched);
    }
    ConnectionStrategy2.is = is;
  })(ConnectionStrategy || (exports.ConnectionStrategy = ConnectionStrategy = {}));
  var IdCancellationReceiverStrategy;
  (function(IdCancellationReceiverStrategy2) {
    function is(value) {
      const candidate = value;
      return candidate && (candidate.kind === undefined || candidate.kind === "id") && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
    }
    IdCancellationReceiverStrategy2.is = is;
  })(IdCancellationReceiverStrategy || (exports.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
  var RequestCancellationReceiverStrategy;
  (function(RequestCancellationReceiverStrategy2) {
    function is(value) {
      const candidate = value;
      return candidate && candidate.kind === "request" && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
    }
    RequestCancellationReceiverStrategy2.is = is;
  })(RequestCancellationReceiverStrategy || (exports.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
  var CancellationReceiverStrategy;
  (function(CancellationReceiverStrategy2) {
    CancellationReceiverStrategy2.Message = Object.freeze({
      createCancellationTokenSource(_) {
        return new cancellation_1.CancellationTokenSource;
      }
    });
    function is(value) {
      return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
    }
    CancellationReceiverStrategy2.is = is;
  })(CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
  var CancellationSenderStrategy;
  (function(CancellationSenderStrategy2) {
    CancellationSenderStrategy2.Message = Object.freeze({
      sendCancellation(conn, id) {
        return conn.sendNotification(CancelNotification.type, { id });
      },
      cleanup(_) {
      }
    });
    function is(value) {
      const candidate = value;
      return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
    }
    CancellationSenderStrategy2.is = is;
  })(CancellationSenderStrategy || (exports.CancellationSenderStrategy = CancellationSenderStrategy = {}));
  var CancellationStrategy;
  (function(CancellationStrategy2) {
    CancellationStrategy2.Message = Object.freeze({
      receiver: CancellationReceiverStrategy.Message,
      sender: CancellationSenderStrategy.Message
    });
    function is(value) {
      const candidate = value;
      return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
    }
    CancellationStrategy2.is = is;
  })(CancellationStrategy || (exports.CancellationStrategy = CancellationStrategy = {}));
  var MessageStrategy;
  (function(MessageStrategy2) {
    function is(value) {
      const candidate = value;
      return candidate && Is.func(candidate.handleMessage);
    }
    MessageStrategy2.is = is;
  })(MessageStrategy || (exports.MessageStrategy = MessageStrategy = {}));
  var ConnectionOptions;
  (function(ConnectionOptions2) {
    function is(value) {
      const candidate = value;
      return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
    }
    ConnectionOptions2.is = is;
  })(ConnectionOptions || (exports.ConnectionOptions = ConnectionOptions = {}));
  var ConnectionState;
  (function(ConnectionState2) {
    ConnectionState2[ConnectionState2["New"] = 1] = "New";
    ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
    ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
    ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
  })(ConnectionState || (ConnectionState = {}));
  function createMessageConnection(messageReader, messageWriter, _logger, options) {
    const logger = _logger !== undefined ? _logger : exports.NullLogger;
    let sequenceNumber = 0;
    let notificationSequenceNumber = 0;
    let unknownResponseSequenceNumber = 0;
    const version = "2.0";
    let starRequestHandler = undefined;
    const requestHandlers = new Map;
    let starNotificationHandler = undefined;
    const notificationHandlers = new Map;
    const progressHandlers = new Map;
    let timer;
    let messageQueue = new linkedMap_1.LinkedMap;
    let responsePromises = new Map;
    let knownCanceledRequests = new Set;
    let requestTokens = new Map;
    let trace = Trace.Off;
    let traceFormat = TraceFormat.Text;
    let tracer;
    let state = ConnectionState.New;
    const errorEmitter = new events_1.Emitter;
    const closeEmitter = new events_1.Emitter;
    const unhandledNotificationEmitter = new events_1.Emitter;
    const unhandledProgressEmitter = new events_1.Emitter;
    const disposeEmitter = new events_1.Emitter;
    const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
    function createRequestQueueKey(id) {
      if (id === null) {
        throw new Error(`Can't send requests with id null since the response can't be correlated.`);
      }
      return "req-" + id.toString();
    }
    function createResponseQueueKey(id) {
      if (id === null) {
        return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
      } else {
        return "res-" + id.toString();
      }
    }
    function createNotificationQueueKey() {
      return "not-" + (++notificationSequenceNumber).toString();
    }
    function addMessageToQueue(queue, message) {
      if (messages_1.Message.isRequest(message)) {
        queue.set(createRequestQueueKey(message.id), message);
      } else if (messages_1.Message.isResponse(message)) {
        queue.set(createResponseQueueKey(message.id), message);
      } else {
        queue.set(createNotificationQueueKey(), message);
      }
    }
    function cancelUndispatched(_message) {
      return;
    }
    function isListening() {
      return state === ConnectionState.Listening;
    }
    function isClosed() {
      return state === ConnectionState.Closed;
    }
    function isDisposed() {
      return state === ConnectionState.Disposed;
    }
    function closeHandler() {
      if (state === ConnectionState.New || state === ConnectionState.Listening) {
        state = ConnectionState.Closed;
        closeEmitter.fire(undefined);
      }
    }
    function readErrorHandler(error) {
      errorEmitter.fire([error, undefined, undefined]);
    }
    function writeErrorHandler(data) {
      errorEmitter.fire(data);
    }
    messageReader.onClose(closeHandler);
    messageReader.onError(readErrorHandler);
    messageWriter.onClose(closeHandler);
    messageWriter.onError(writeErrorHandler);
    function triggerMessageQueue() {
      if (timer || messageQueue.size === 0) {
        return;
      }
      timer = (0, ral_1.default)().timer.setImmediate(() => {
        timer = undefined;
        processMessageQueue();
      });
    }
    function handleMessage(message) {
      if (messages_1.Message.isRequest(message)) {
        handleRequest(message);
      } else if (messages_1.Message.isNotification(message)) {
        handleNotification(message);
      } else if (messages_1.Message.isResponse(message)) {
        handleResponse(message);
      } else {
        handleInvalidMessage(message);
      }
    }
    function processMessageQueue() {
      if (messageQueue.size === 0) {
        return;
      }
      const message = messageQueue.shift();
      try {
        const messageStrategy = options?.messageStrategy;
        if (MessageStrategy.is(messageStrategy)) {
          messageStrategy.handleMessage(message, handleMessage);
        } else {
          handleMessage(message);
        }
      } finally {
        triggerMessageQueue();
      }
    }
    const callback = (message) => {
      try {
        if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
          const cancelId = message.params.id;
          const key = createRequestQueueKey(cancelId);
          const toCancel = messageQueue.get(key);
          if (messages_1.Message.isRequest(toCancel)) {
            const strategy = options?.connectionStrategy;
            const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
            if (response && (response.error !== undefined || response.result !== undefined)) {
              messageQueue.delete(key);
              requestTokens.delete(cancelId);
              response.id = toCancel.id;
              traceSendingResponse(response, message.method, Date.now());
              messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
              return;
            }
          }
          const cancellationToken = requestTokens.get(cancelId);
          if (cancellationToken !== undefined) {
            cancellationToken.cancel();
            traceReceivedNotification(message);
            return;
          } else {
            knownCanceledRequests.add(cancelId);
          }
        }
        addMessageToQueue(messageQueue, message);
      } finally {
        triggerMessageQueue();
      }
    };
    function handleRequest(requestMessage) {
      if (isDisposed()) {
        return;
      }
      function reply(resultOrError, method, startTime2) {
        const message = {
          jsonrpc: version,
          id: requestMessage.id
        };
        if (resultOrError instanceof messages_1.ResponseError) {
          message.error = resultOrError.toJson();
        } else {
          message.result = resultOrError === undefined ? null : resultOrError;
        }
        traceSendingResponse(message, method, startTime2);
        messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
      }
      function replyError(error, method, startTime2) {
        const message = {
          jsonrpc: version,
          id: requestMessage.id,
          error: error.toJson()
        };
        traceSendingResponse(message, method, startTime2);
        messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
      }
      function replySuccess(result, method, startTime2) {
        if (result === undefined) {
          result = null;
        }
        const message = {
          jsonrpc: version,
          id: requestMessage.id,
          result
        };
        traceSendingResponse(message, method, startTime2);
        messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
      }
      traceReceivedRequest(requestMessage);
      const element = requestHandlers.get(requestMessage.method);
      let type;
      let requestHandler;
      if (element) {
        type = element.type;
        requestHandler = element.handler;
      }
      const startTime = Date.now();
      if (requestHandler || starRequestHandler) {
        const tokenKey = requestMessage.id ?? String(Date.now());
        const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
        if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
          cancellationSource.cancel();
        }
        if (requestMessage.id !== null) {
          requestTokens.set(tokenKey, cancellationSource);
        }
        try {
          let handlerResult;
          if (requestHandler) {
            if (requestMessage.params === undefined) {
              if (type !== undefined && type.numberOfParams !== 0) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                return;
              }
              handlerResult = requestHandler(cancellationSource.token);
            } else if (Array.isArray(requestMessage.params)) {
              if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                return;
              }
              handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
            } else {
              if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                return;
              }
              handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
            }
          } else if (starRequestHandler) {
            handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
          }
          const promise = handlerResult;
          if (!handlerResult) {
            requestTokens.delete(tokenKey);
            replySuccess(handlerResult, requestMessage.method, startTime);
          } else if (promise.then) {
            promise.then((resultOrError) => {
              requestTokens.delete(tokenKey);
              reply(resultOrError, requestMessage.method, startTime);
            }, (error) => {
              requestTokens.delete(tokenKey);
              if (error instanceof messages_1.ResponseError) {
                replyError(error, requestMessage.method, startTime);
              } else if (error && Is.string(error.message)) {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
              } else {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
              }
            });
          } else {
            requestTokens.delete(tokenKey);
            reply(handlerResult, requestMessage.method, startTime);
          }
        } catch (error) {
          requestTokens.delete(tokenKey);
          if (error instanceof messages_1.ResponseError) {
            reply(error, requestMessage.method, startTime);
          } else if (error && Is.string(error.message)) {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
          } else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
          }
        }
      } else {
        replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
      }
    }
    function handleResponse(responseMessage) {
      if (isDisposed()) {
        return;
      }
      if (responseMessage.id === null) {
        if (responseMessage.error) {
          logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, undefined, 4)}`);
        } else {
          logger.error(`Received response message without id. No further error information provided.`);
        }
      } else {
        const key = responseMessage.id;
        const responsePromise = responsePromises.get(key);
        traceReceivedResponse(responseMessage, responsePromise);
        if (responsePromise !== undefined) {
          responsePromises.delete(key);
          try {
            if (responseMessage.error) {
              const error = responseMessage.error;
              responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
            } else if (responseMessage.result !== undefined) {
              responsePromise.resolve(responseMessage.result);
            } else {
              throw new Error("Should never happen.");
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
            }
          }
        }
      }
    }
    function handleNotification(message) {
      if (isDisposed()) {
        return;
      }
      let type = undefined;
      let notificationHandler;
      if (message.method === CancelNotification.type.method) {
        const cancelId = message.params.id;
        knownCanceledRequests.delete(cancelId);
        traceReceivedNotification(message);
        return;
      } else {
        const element = notificationHandlers.get(message.method);
        if (element) {
          notificationHandler = element.handler;
          type = element.type;
        }
      }
      if (notificationHandler || starNotificationHandler) {
        try {
          traceReceivedNotification(message);
          if (notificationHandler) {
            if (message.params === undefined) {
              if (type !== undefined) {
                if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                  logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                }
              }
              notificationHandler();
            } else if (Array.isArray(message.params)) {
              const params = message.params;
              if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                notificationHandler({ token: params[0], value: params[1] });
              } else {
                if (type !== undefined) {
                  if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                  }
                  if (type.numberOfParams !== message.params.length) {
                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                  }
                }
                notificationHandler(...params);
              }
            } else {
              if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
              }
              notificationHandler(message.params);
            }
          } else if (starNotificationHandler) {
            starNotificationHandler(message.method, message.params);
          }
        } catch (error) {
          if (error.message) {
            logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
          } else {
            logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
          }
        }
      } else {
        unhandledNotificationEmitter.fire(message);
      }
    }
    function handleInvalidMessage(message) {
      if (!message) {
        logger.error("Received empty message.");
        return;
      }
      logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
      const responseMessage = message;
      if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
        const key = responseMessage.id;
        const responseHandler = responsePromises.get(key);
        if (responseHandler) {
          responseHandler.reject(new Error("The received response has neither a result nor an error property."));
        }
      }
    }
    function stringifyTrace(params) {
      if (params === undefined || params === null) {
        return;
      }
      switch (trace) {
        case Trace.Verbose:
          return JSON.stringify(params, null, 4);
        case Trace.Compact:
          return JSON.stringify(params);
        default:
          return;
      }
    }
    function traceSendingRequest(message) {
      if (trace === Trace.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = undefined;
        if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
          data = `Params: ${stringifyTrace(message.params)}

`;
        }
        tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
      } else {
        logLSPMessage("send-request", message);
      }
    }
    function traceSendingNotification(message) {
      if (trace === Trace.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = undefined;
        if (trace === Trace.Verbose || trace === Trace.Compact) {
          if (message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          } else {
            data = `No parameters provided.

`;
          }
        }
        tracer.log(`Sending notification '${message.method}'.`, data);
      } else {
        logLSPMessage("send-notification", message);
      }
    }
    function traceSendingResponse(message, method, startTime) {
      if (trace === Trace.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = undefined;
        if (trace === Trace.Verbose || trace === Trace.Compact) {
          if (message.error && message.error.data) {
            data = `Error data: ${stringifyTrace(message.error.data)}

`;
          } else {
            if (message.result) {
              data = `Result: ${stringifyTrace(message.result)}

`;
            } else if (message.error === undefined) {
              data = `No result returned.

`;
            }
          }
        }
        tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
      } else {
        logLSPMessage("send-response", message);
      }
    }
    function traceReceivedRequest(message) {
      if (trace === Trace.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = undefined;
        if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
          data = `Params: ${stringifyTrace(message.params)}

`;
        }
        tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
      } else {
        logLSPMessage("receive-request", message);
      }
    }
    function traceReceivedNotification(message) {
      if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = undefined;
        if (trace === Trace.Verbose || trace === Trace.Compact) {
          if (message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          } else {
            data = `No parameters provided.

`;
          }
        }
        tracer.log(`Received notification '${message.method}'.`, data);
      } else {
        logLSPMessage("receive-notification", message);
      }
    }
    function traceReceivedResponse(message, responsePromise) {
      if (trace === Trace.Off || !tracer) {
        return;
      }
      if (traceFormat === TraceFormat.Text) {
        let data = undefined;
        if (trace === Trace.Verbose || trace === Trace.Compact) {
          if (message.error && message.error.data) {
            data = `Error data: ${stringifyTrace(message.error.data)}

`;
          } else {
            if (message.result) {
              data = `Result: ${stringifyTrace(message.result)}

`;
            } else if (message.error === undefined) {
              data = `No result returned.

`;
            }
          }
        }
        if (responsePromise) {
          const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
          tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
        } else {
          tracer.log(`Received response ${message.id} without active response promise.`, data);
        }
      } else {
        logLSPMessage("receive-response", message);
      }
    }
    function logLSPMessage(type, message) {
      if (!tracer || trace === Trace.Off) {
        return;
      }
      const lspMessage = {
        isLSPMessage: true,
        type,
        message,
        timestamp: Date.now()
      };
      tracer.log(lspMessage);
    }
    function throwIfClosedOrDisposed() {
      if (isClosed()) {
        throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
      }
      if (isDisposed()) {
        throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
      }
    }
    function throwIfListening() {
      if (isListening()) {
        throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
      }
    }
    function throwIfNotListening() {
      if (!isListening()) {
        throw new Error("Call listen() first.");
      }
    }
    function undefinedToNull(param) {
      if (param === undefined) {
        return null;
      } else {
        return param;
      }
    }
    function nullToUndefined(param) {
      if (param === null) {
        return;
      } else {
        return param;
      }
    }
    function isNamedParam(param) {
      return param !== undefined && param !== null && !Array.isArray(param) && typeof param === "object";
    }
    function computeSingleParam(parameterStructures, param) {
      switch (parameterStructures) {
        case messages_1.ParameterStructures.auto:
          if (isNamedParam(param)) {
            return nullToUndefined(param);
          } else {
            return [undefinedToNull(param)];
          }
        case messages_1.ParameterStructures.byName:
          if (!isNamedParam(param)) {
            throw new Error(`Received parameters by name but param is not an object literal.`);
          }
          return nullToUndefined(param);
        case messages_1.ParameterStructures.byPosition:
          return [undefinedToNull(param)];
        default:
          throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
      }
    }
    function computeMessageParams(type, params) {
      let result;
      const numberOfParams = type.numberOfParams;
      switch (numberOfParams) {
        case 0:
          result = undefined;
          break;
        case 1:
          result = computeSingleParam(type.parameterStructures, params[0]);
          break;
        default:
          result = [];
          for (let i = 0;i < params.length && i < numberOfParams; i++) {
            result.push(undefinedToNull(params[i]));
          }
          if (params.length < numberOfParams) {
            for (let i = params.length;i < numberOfParams; i++) {
              result.push(null);
            }
          }
          break;
      }
      return result;
    }
    const connection = {
      sendNotification: (type, ...args) => {
        throwIfClosedOrDisposed();
        let method;
        let messageParams;
        if (Is.string(type)) {
          method = type;
          const first = args[0];
          let paramStart = 0;
          let parameterStructures = messages_1.ParameterStructures.auto;
          if (messages_1.ParameterStructures.is(first)) {
            paramStart = 1;
            parameterStructures = first;
          }
          let paramEnd = args.length;
          const numberOfParams = paramEnd - paramStart;
          switch (numberOfParams) {
            case 0:
              messageParams = undefined;
              break;
            case 1:
              messageParams = computeSingleParam(parameterStructures, args[paramStart]);
              break;
            default:
              if (parameterStructures === messages_1.ParameterStructures.byName) {
                throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
              }
              messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
              break;
          }
        } else {
          const params = args;
          method = type.method;
          messageParams = computeMessageParams(type, params);
        }
        const notificationMessage = {
          jsonrpc: version,
          method,
          params: messageParams
        };
        traceSendingNotification(notificationMessage);
        return messageWriter.write(notificationMessage).catch((error) => {
          logger.error(`Sending notification failed.`);
          throw error;
        });
      },
      onNotification: (type, handler) => {
        throwIfClosedOrDisposed();
        let method;
        if (Is.func(type)) {
          starNotificationHandler = type;
        } else if (handler) {
          if (Is.string(type)) {
            method = type;
            notificationHandlers.set(type, { type: undefined, handler });
          } else {
            method = type.method;
            notificationHandlers.set(type.method, { type, handler });
          }
        }
        return {
          dispose: () => {
            if (method !== undefined) {
              notificationHandlers.delete(method);
            } else {
              starNotificationHandler = undefined;
            }
          }
        };
      },
      onProgress: (_type, token, handler) => {
        if (progressHandlers.has(token)) {
          throw new Error(`Progress handler for token ${token} already registered`);
        }
        progressHandlers.set(token, handler);
        return {
          dispose: () => {
            progressHandlers.delete(token);
          }
        };
      },
      sendProgress: (_type, token, value) => {
        return connection.sendNotification(ProgressNotification.type, { token, value });
      },
      onUnhandledProgress: unhandledProgressEmitter.event,
      sendRequest: (type, ...args) => {
        throwIfClosedOrDisposed();
        throwIfNotListening();
        let method;
        let messageParams;
        let token = undefined;
        if (Is.string(type)) {
          method = type;
          const first = args[0];
          const last = args[args.length - 1];
          let paramStart = 0;
          let parameterStructures = messages_1.ParameterStructures.auto;
          if (messages_1.ParameterStructures.is(first)) {
            paramStart = 1;
            parameterStructures = first;
          }
          let paramEnd = args.length;
          if (cancellation_1.CancellationToken.is(last)) {
            paramEnd = paramEnd - 1;
            token = last;
          }
          const numberOfParams = paramEnd - paramStart;
          switch (numberOfParams) {
            case 0:
              messageParams = undefined;
              break;
            case 1:
              messageParams = computeSingleParam(parameterStructures, args[paramStart]);
              break;
            default:
              if (parameterStructures === messages_1.ParameterStructures.byName) {
                throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
              }
              messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
              break;
          }
        } else {
          const params = args;
          method = type.method;
          messageParams = computeMessageParams(type, params);
          const numberOfParams = type.numberOfParams;
          token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
        }
        const id = sequenceNumber++;
        let disposable;
        if (token) {
          disposable = token.onCancellationRequested(() => {
            const p = cancellationStrategy.sender.sendCancellation(connection, id);
            if (p === undefined) {
              logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
              return Promise.resolve();
            } else {
              return p.catch(() => {
                logger.log(`Sending cancellation messages for id ${id} failed`);
              });
            }
          });
        }
        const requestMessage = {
          jsonrpc: version,
          id,
          method,
          params: messageParams
        };
        traceSendingRequest(requestMessage);
        if (typeof cancellationStrategy.sender.enableCancellation === "function") {
          cancellationStrategy.sender.enableCancellation(requestMessage);
        }
        return new Promise(async (resolve, reject) => {
          const resolveWithCleanup = (r) => {
            resolve(r);
            cancellationStrategy.sender.cleanup(id);
            disposable?.dispose();
          };
          const rejectWithCleanup = (r) => {
            reject(r);
            cancellationStrategy.sender.cleanup(id);
            disposable?.dispose();
          };
          const responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
          try {
            await messageWriter.write(requestMessage);
            responsePromises.set(id, responsePromise);
          } catch (error) {
            logger.error(`Sending request failed.`);
            responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : "Unknown reason"));
            throw error;
          }
        });
      },
      onRequest: (type, handler) => {
        throwIfClosedOrDisposed();
        let method = null;
        if (StarRequestHandler.is(type)) {
          method = undefined;
          starRequestHandler = type;
        } else if (Is.string(type)) {
          method = null;
          if (handler !== undefined) {
            method = type;
            requestHandlers.set(type, { handler, type: undefined });
          }
        } else {
          if (handler !== undefined) {
            method = type.method;
            requestHandlers.set(type.method, { type, handler });
          }
        }
        return {
          dispose: () => {
            if (method === null) {
              return;
            }
            if (method !== undefined) {
              requestHandlers.delete(method);
            } else {
              starRequestHandler = undefined;
            }
          }
        };
      },
      hasPendingResponse: () => {
        return responsePromises.size > 0;
      },
      trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
        let _sendNotification = false;
        let _traceFormat = TraceFormat.Text;
        if (sendNotificationOrTraceOptions !== undefined) {
          if (Is.boolean(sendNotificationOrTraceOptions)) {
            _sendNotification = sendNotificationOrTraceOptions;
          } else {
            _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
            _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
          }
        }
        trace = _value;
        traceFormat = _traceFormat;
        if (trace === Trace.Off) {
          tracer = undefined;
        } else {
          tracer = _tracer;
        }
        if (_sendNotification && !isClosed() && !isDisposed()) {
          await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
        }
      },
      onError: errorEmitter.event,
      onClose: closeEmitter.event,
      onUnhandledNotification: unhandledNotificationEmitter.event,
      onDispose: disposeEmitter.event,
      end: () => {
        messageWriter.end();
      },
      dispose: () => {
        if (isDisposed()) {
          return;
        }
        state = ConnectionState.Disposed;
        disposeEmitter.fire(undefined);
        const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
        for (const promise of responsePromises.values()) {
          promise.reject(error);
        }
        responsePromises = new Map;
        requestTokens = new Map;
        knownCanceledRequests = new Set;
        messageQueue = new linkedMap_1.LinkedMap;
        if (Is.func(messageWriter.dispose)) {
          messageWriter.dispose();
        }
        if (Is.func(messageReader.dispose)) {
          messageReader.dispose();
        }
      },
      listen: () => {
        throwIfClosedOrDisposed();
        throwIfListening();
        state = ConnectionState.Listening;
        messageReader.listen(callback);
      },
      inspect: () => {
        (0, ral_1.default)().console.log("inspect");
      }
    };
    connection.onNotification(LogTraceNotification.type, (params) => {
      if (trace === Trace.Off || !tracer) {
        return;
      }
      const verbose = trace === Trace.Verbose || trace === Trace.Compact;
      tracer.log(params.message, verbose ? params.verbose : undefined);
    });
    connection.onNotification(ProgressNotification.type, (params) => {
      const handler = progressHandlers.get(params.token);
      if (handler) {
        handler(params.value);
      } else {
        unhandledProgressEmitter.fire(params);
      }
    });
    return connection;
  }
  exports.createMessageConnection = createMessageConnection;
});

// node_modules/vscode-jsonrpc/lib/common/api.js
var require_api = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.AbstractMessageBuffer = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = undefined;
  exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = undefined;
  var messages_1 = require_messages();
  Object.defineProperty(exports, "Message", { enumerable: true, get: function() {
    return messages_1.Message;
  } });
  Object.defineProperty(exports, "RequestType", { enumerable: true, get: function() {
    return messages_1.RequestType;
  } });
  Object.defineProperty(exports, "RequestType0", { enumerable: true, get: function() {
    return messages_1.RequestType0;
  } });
  Object.defineProperty(exports, "RequestType1", { enumerable: true, get: function() {
    return messages_1.RequestType1;
  } });
  Object.defineProperty(exports, "RequestType2", { enumerable: true, get: function() {
    return messages_1.RequestType2;
  } });
  Object.defineProperty(exports, "RequestType3", { enumerable: true, get: function() {
    return messages_1.RequestType3;
  } });
  Object.defineProperty(exports, "RequestType4", { enumerable: true, get: function() {
    return messages_1.RequestType4;
  } });
  Object.defineProperty(exports, "RequestType5", { enumerable: true, get: function() {
    return messages_1.RequestType5;
  } });
  Object.defineProperty(exports, "RequestType6", { enumerable: true, get: function() {
    return messages_1.RequestType6;
  } });
  Object.defineProperty(exports, "RequestType7", { enumerable: true, get: function() {
    return messages_1.RequestType7;
  } });
  Object.defineProperty(exports, "RequestType8", { enumerable: true, get: function() {
    return messages_1.RequestType8;
  } });
  Object.defineProperty(exports, "RequestType9", { enumerable: true, get: function() {
    return messages_1.RequestType9;
  } });
  Object.defineProperty(exports, "ResponseError", { enumerable: true, get: function() {
    return messages_1.ResponseError;
  } });
  Object.defineProperty(exports, "ErrorCodes", { enumerable: true, get: function() {
    return messages_1.ErrorCodes;
  } });
  Object.defineProperty(exports, "NotificationType", { enumerable: true, get: function() {
    return messages_1.NotificationType;
  } });
  Object.defineProperty(exports, "NotificationType0", { enumerable: true, get: function() {
    return messages_1.NotificationType0;
  } });
  Object.defineProperty(exports, "NotificationType1", { enumerable: true, get: function() {
    return messages_1.NotificationType1;
  } });
  Object.defineProperty(exports, "NotificationType2", { enumerable: true, get: function() {
    return messages_1.NotificationType2;
  } });
  Object.defineProperty(exports, "NotificationType3", { enumerable: true, get: function() {
    return messages_1.NotificationType3;
  } });
  Object.defineProperty(exports, "NotificationType4", { enumerable: true, get: function() {
    return messages_1.NotificationType4;
  } });
  Object.defineProperty(exports, "NotificationType5", { enumerable: true, get: function() {
    return messages_1.NotificationType5;
  } });
  Object.defineProperty(exports, "NotificationType6", { enumerable: true, get: function() {
    return messages_1.NotificationType6;
  } });
  Object.defineProperty(exports, "NotificationType7", { enumerable: true, get: function() {
    return messages_1.NotificationType7;
  } });
  Object.defineProperty(exports, "NotificationType8", { enumerable: true, get: function() {
    return messages_1.NotificationType8;
  } });
  Object.defineProperty(exports, "NotificationType9", { enumerable: true, get: function() {
    return messages_1.NotificationType9;
  } });
  Object.defineProperty(exports, "ParameterStructures", { enumerable: true, get: function() {
    return messages_1.ParameterStructures;
  } });
  var linkedMap_1 = require_linkedMap();
  Object.defineProperty(exports, "LinkedMap", { enumerable: true, get: function() {
    return linkedMap_1.LinkedMap;
  } });
  Object.defineProperty(exports, "LRUCache", { enumerable: true, get: function() {
    return linkedMap_1.LRUCache;
  } });
  Object.defineProperty(exports, "Touch", { enumerable: true, get: function() {
    return linkedMap_1.Touch;
  } });
  var disposable_1 = require_disposable();
  Object.defineProperty(exports, "Disposable", { enumerable: true, get: function() {
    return disposable_1.Disposable;
  } });
  var events_1 = require_events();
  Object.defineProperty(exports, "Event", { enumerable: true, get: function() {
    return events_1.Event;
  } });
  Object.defineProperty(exports, "Emitter", { enumerable: true, get: function() {
    return events_1.Emitter;
  } });
  var cancellation_1 = require_cancellation();
  Object.defineProperty(exports, "CancellationTokenSource", { enumerable: true, get: function() {
    return cancellation_1.CancellationTokenSource;
  } });
  Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
    return cancellation_1.CancellationToken;
  } });
  var sharedArrayCancellation_1 = require_sharedArrayCancellation();
  Object.defineProperty(exports, "SharedArraySenderStrategy", { enumerable: true, get: function() {
    return sharedArrayCancellation_1.SharedArraySenderStrategy;
  } });
  Object.defineProperty(exports, "SharedArrayReceiverStrategy", { enumerable: true, get: function() {
    return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
  } });
  var messageReader_1 = require_messageReader();
  Object.defineProperty(exports, "MessageReader", { enumerable: true, get: function() {
    return messageReader_1.MessageReader;
  } });
  Object.defineProperty(exports, "AbstractMessageReader", { enumerable: true, get: function() {
    return messageReader_1.AbstractMessageReader;
  } });
  Object.defineProperty(exports, "ReadableStreamMessageReader", { enumerable: true, get: function() {
    return messageReader_1.ReadableStreamMessageReader;
  } });
  var messageWriter_1 = require_messageWriter();
  Object.defineProperty(exports, "MessageWriter", { enumerable: true, get: function() {
    return messageWriter_1.MessageWriter;
  } });
  Object.defineProperty(exports, "AbstractMessageWriter", { enumerable: true, get: function() {
    return messageWriter_1.AbstractMessageWriter;
  } });
  Object.defineProperty(exports, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
    return messageWriter_1.WriteableStreamMessageWriter;
  } });
  var messageBuffer_1 = require_messageBuffer();
  Object.defineProperty(exports, "AbstractMessageBuffer", { enumerable: true, get: function() {
    return messageBuffer_1.AbstractMessageBuffer;
  } });
  var connection_1 = require_connection();
  Object.defineProperty(exports, "ConnectionStrategy", { enumerable: true, get: function() {
    return connection_1.ConnectionStrategy;
  } });
  Object.defineProperty(exports, "ConnectionOptions", { enumerable: true, get: function() {
    return connection_1.ConnectionOptions;
  } });
  Object.defineProperty(exports, "NullLogger", { enumerable: true, get: function() {
    return connection_1.NullLogger;
  } });
  Object.defineProperty(exports, "createMessageConnection", { enumerable: true, get: function() {
    return connection_1.createMessageConnection;
  } });
  Object.defineProperty(exports, "ProgressToken", { enumerable: true, get: function() {
    return connection_1.ProgressToken;
  } });
  Object.defineProperty(exports, "ProgressType", { enumerable: true, get: function() {
    return connection_1.ProgressType;
  } });
  Object.defineProperty(exports, "Trace", { enumerable: true, get: function() {
    return connection_1.Trace;
  } });
  Object.defineProperty(exports, "TraceValues", { enumerable: true, get: function() {
    return connection_1.TraceValues;
  } });
  Object.defineProperty(exports, "TraceFormat", { enumerable: true, get: function() {
    return connection_1.TraceFormat;
  } });
  Object.defineProperty(exports, "SetTraceNotification", { enumerable: true, get: function() {
    return connection_1.SetTraceNotification;
  } });
  Object.defineProperty(exports, "LogTraceNotification", { enumerable: true, get: function() {
    return connection_1.LogTraceNotification;
  } });
  Object.defineProperty(exports, "ConnectionErrors", { enumerable: true, get: function() {
    return connection_1.ConnectionErrors;
  } });
  Object.defineProperty(exports, "ConnectionError", { enumerable: true, get: function() {
    return connection_1.ConnectionError;
  } });
  Object.defineProperty(exports, "CancellationReceiverStrategy", { enumerable: true, get: function() {
    return connection_1.CancellationReceiverStrategy;
  } });
  Object.defineProperty(exports, "CancellationSenderStrategy", { enumerable: true, get: function() {
    return connection_1.CancellationSenderStrategy;
  } });
  Object.defineProperty(exports, "CancellationStrategy", { enumerable: true, get: function() {
    return connection_1.CancellationStrategy;
  } });
  Object.defineProperty(exports, "MessageStrategy", { enumerable: true, get: function() {
    return connection_1.MessageStrategy;
  } });
  var ral_1 = require_ral();
  exports.RAL = ral_1.default;
});

// node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = __require("util");
  var api_1 = require_api();

  class MessageBuffer extends api_1.AbstractMessageBuffer {
    constructor(encoding = "utf-8") {
      super(encoding);
    }
    emptyBuffer() {
      return MessageBuffer.emptyBuffer;
    }
    fromString(value, encoding) {
      return Buffer.from(value, encoding);
    }
    toString(value, encoding) {
      if (value instanceof Buffer) {
        return value.toString(encoding);
      } else {
        return new util_1.TextDecoder(encoding).decode(value);
      }
    }
    asNative(buffer, length) {
      if (length === undefined) {
        return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
      } else {
        return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
      }
    }
    allocNative(length) {
      return Buffer.allocUnsafe(length);
    }
  }
  MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);

  class ReadableStreamWrapper {
    constructor(stream) {
      this.stream = stream;
    }
    onClose(listener) {
      this.stream.on("close", listener);
      return api_1.Disposable.create(() => this.stream.off("close", listener));
    }
    onError(listener) {
      this.stream.on("error", listener);
      return api_1.Disposable.create(() => this.stream.off("error", listener));
    }
    onEnd(listener) {
      this.stream.on("end", listener);
      return api_1.Disposable.create(() => this.stream.off("end", listener));
    }
    onData(listener) {
      this.stream.on("data", listener);
      return api_1.Disposable.create(() => this.stream.off("data", listener));
    }
  }

  class WritableStreamWrapper {
    constructor(stream) {
      this.stream = stream;
    }
    onClose(listener) {
      this.stream.on("close", listener);
      return api_1.Disposable.create(() => this.stream.off("close", listener));
    }
    onError(listener) {
      this.stream.on("error", listener);
      return api_1.Disposable.create(() => this.stream.off("error", listener));
    }
    onEnd(listener) {
      this.stream.on("end", listener);
      return api_1.Disposable.create(() => this.stream.off("end", listener));
    }
    write(data, encoding) {
      return new Promise((resolve, reject) => {
        const callback = (error) => {
          if (error === undefined || error === null) {
            resolve();
          } else {
            reject(error);
          }
        };
        if (typeof data === "string") {
          this.stream.write(data, encoding, callback);
        } else {
          this.stream.write(data, callback);
        }
      });
    }
    end() {
      this.stream.end();
    }
  }
  var _ril = Object.freeze({
    messageBuffer: Object.freeze({
      create: (encoding) => new MessageBuffer(encoding)
    }),
    applicationJson: Object.freeze({
      encoder: Object.freeze({
        name: "application/json",
        encode: (msg, options) => {
          try {
            return Promise.resolve(Buffer.from(JSON.stringify(msg, undefined, 0), options.charset));
          } catch (err) {
            return Promise.reject(err);
          }
        }
      }),
      decoder: Object.freeze({
        name: "application/json",
        decode: (buffer, options) => {
          try {
            if (buffer instanceof Buffer) {
              return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
            } else {
              return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
            }
          } catch (err) {
            return Promise.reject(err);
          }
        }
      })
    }),
    stream: Object.freeze({
      asReadableStream: (stream) => new ReadableStreamWrapper(stream),
      asWritableStream: (stream) => new WritableStreamWrapper(stream)
    }),
    console,
    timer: Object.freeze({
      setTimeout(callback, ms, ...args) {
        const handle = setTimeout(callback, ms, ...args);
        return { dispose: () => clearTimeout(handle) };
      },
      setImmediate(callback, ...args) {
        const handle = setImmediate(callback, ...args);
        return { dispose: () => clearImmediate(handle) };
      },
      setInterval(callback, ms, ...args) {
        const handle = setInterval(callback, ms, ...args);
        return { dispose: () => clearInterval(handle) };
      }
    })
  });
  function RIL() {
    return _ril;
  }
  (function(RIL2) {
    function install() {
      api_1.RAL.install(_ril);
    }
    RIL2.install = install;
  })(RIL || (RIL = {}));
  exports.default = RIL;
});

// node_modules/vscode-jsonrpc/lib/node/main.js
var require_main = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createMessageConnection = exports.createServerSocketTransport = exports.createClientSocketTransport = exports.createServerPipeTransport = exports.createClientPipeTransport = exports.generateRandomPipeName = exports.StreamMessageWriter = exports.StreamMessageReader = exports.SocketMessageWriter = exports.SocketMessageReader = exports.PortMessageWriter = exports.PortMessageReader = exports.IPCMessageWriter = exports.IPCMessageReader = undefined;
  var ril_1 = require_ril();
  ril_1.default.install();
  var path = __require("path");
  var os = __require("os");
  var crypto_1 = __require("crypto");
  var net_1 = __require("net");
  var api_1 = require_api();
  __exportStar(require_api(), exports);

  class IPCMessageReader extends api_1.AbstractMessageReader {
    constructor(process2) {
      super();
      this.process = process2;
      let eventEmitter = this.process;
      eventEmitter.on("error", (error) => this.fireError(error));
      eventEmitter.on("close", () => this.fireClose());
    }
    listen(callback) {
      this.process.on("message", callback);
      return api_1.Disposable.create(() => this.process.off("message", callback));
    }
  }
  exports.IPCMessageReader = IPCMessageReader;

  class IPCMessageWriter extends api_1.AbstractMessageWriter {
    constructor(process2) {
      super();
      this.process = process2;
      this.errorCount = 0;
      const eventEmitter = this.process;
      eventEmitter.on("error", (error) => this.fireError(error));
      eventEmitter.on("close", () => this.fireClose);
    }
    write(msg) {
      try {
        if (typeof this.process.send === "function") {
          this.process.send(msg, undefined, undefined, (error) => {
            if (error) {
              this.errorCount++;
              this.handleError(error, msg);
            } else {
              this.errorCount = 0;
            }
          });
        }
        return Promise.resolve();
      } catch (error) {
        this.handleError(error, msg);
        return Promise.reject(error);
      }
    }
    handleError(error, msg) {
      this.errorCount++;
      this.fireError(error, msg, this.errorCount);
    }
    end() {
    }
  }
  exports.IPCMessageWriter = IPCMessageWriter;

  class PortMessageReader extends api_1.AbstractMessageReader {
    constructor(port) {
      super();
      this.onData = new api_1.Emitter;
      port.on("close", () => this.fireClose);
      port.on("error", (error) => this.fireError(error));
      port.on("message", (message) => {
        this.onData.fire(message);
      });
    }
    listen(callback) {
      return this.onData.event(callback);
    }
  }
  exports.PortMessageReader = PortMessageReader;

  class PortMessageWriter extends api_1.AbstractMessageWriter {
    constructor(port) {
      super();
      this.port = port;
      this.errorCount = 0;
      port.on("close", () => this.fireClose());
      port.on("error", (error) => this.fireError(error));
    }
    write(msg) {
      try {
        this.port.postMessage(msg);
        return Promise.resolve();
      } catch (error) {
        this.handleError(error, msg);
        return Promise.reject(error);
      }
    }
    handleError(error, msg) {
      this.errorCount++;
      this.fireError(error, msg, this.errorCount);
    }
    end() {
    }
  }
  exports.PortMessageWriter = PortMessageWriter;

  class SocketMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(socket, encoding = "utf-8") {
      super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
    }
  }
  exports.SocketMessageReader = SocketMessageReader;

  class SocketMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(socket, options) {
      super((0, ril_1.default)().stream.asWritableStream(socket), options);
      this.socket = socket;
    }
    dispose() {
      super.dispose();
      this.socket.destroy();
    }
  }
  exports.SocketMessageWriter = SocketMessageWriter;

  class StreamMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(readable, encoding) {
      super((0, ril_1.default)().stream.asReadableStream(readable), encoding);
    }
  }
  exports.StreamMessageReader = StreamMessageReader;

  class StreamMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(writable, options) {
      super((0, ril_1.default)().stream.asWritableStream(writable), options);
    }
  }
  exports.StreamMessageWriter = StreamMessageWriter;
  var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
  var safeIpcPathLengths = new Map([
    ["linux", 107],
    ["darwin", 103]
  ]);
  function generateRandomPipeName() {
    const randomSuffix = (0, crypto_1.randomBytes)(21).toString("hex");
    if (process.platform === "win32") {
      return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
    }
    let result;
    if (XDG_RUNTIME_DIR) {
      result = path.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
    } else {
      result = path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
    }
    const limit = safeIpcPathLengths.get(process.platform);
    if (limit !== undefined && result.length > limit) {
      (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
    }
    return result;
  }
  exports.generateRandomPipeName = generateRandomPipeName;
  function createClientPipeTransport(pipeName, encoding = "utf-8") {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
      connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
      let server = (0, net_1.createServer)((socket) => {
        server.close();
        connectResolve([
          new SocketMessageReader(socket, encoding),
          new SocketMessageWriter(socket, encoding)
        ]);
      });
      server.on("error", reject);
      server.listen(pipeName, () => {
        server.removeListener("error", reject);
        resolve({
          onConnected: () => {
            return connected;
          }
        });
      });
    });
  }
  exports.createClientPipeTransport = createClientPipeTransport;
  function createServerPipeTransport(pipeName, encoding = "utf-8") {
    const socket = (0, net_1.createConnection)(pipeName);
    return [
      new SocketMessageReader(socket, encoding),
      new SocketMessageWriter(socket, encoding)
    ];
  }
  exports.createServerPipeTransport = createServerPipeTransport;
  function createClientSocketTransport(port, encoding = "utf-8") {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
      connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
      const server = (0, net_1.createServer)((socket) => {
        server.close();
        connectResolve([
          new SocketMessageReader(socket, encoding),
          new SocketMessageWriter(socket, encoding)
        ]);
      });
      server.on("error", reject);
      server.listen(port, "127.0.0.1", () => {
        server.removeListener("error", reject);
        resolve({
          onConnected: () => {
            return connected;
          }
        });
      });
    });
  }
  exports.createClientSocketTransport = createClientSocketTransport;
  function createServerSocketTransport(port, encoding = "utf-8") {
    const socket = (0, net_1.createConnection)(port, "127.0.0.1");
    return [
      new SocketMessageReader(socket, encoding),
      new SocketMessageWriter(socket, encoding)
    ];
  }
  exports.createServerSocketTransport = createServerSocketTransport;
  function isReadableStream(value) {
    const candidate = value;
    return candidate.read !== undefined && candidate.addListener !== undefined;
  }
  function isWritableStream(value) {
    const candidate = value;
    return candidate.write !== undefined && candidate.addListener !== undefined;
  }
  function createMessageConnection(input, output, logger, options) {
    if (!logger) {
      logger = api_1.NullLogger;
    }
    const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
    const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
    if (api_1.ConnectionStrategy.is(options)) {
      options = { connectionStrategy: options };
    }
    return (0, api_1.createMessageConnection)(reader, writer, logger, options);
  }
  exports.createMessageConnection = createMessageConnection;
});

// node_modules/vscode-languageserver-types/lib/umd/main.js
var require_main2 = __commonJS((exports, module) => {
  (function(factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
      var v = factory(__require, exports);
      if (v !== undefined)
        module.exports = v;
    } else if (typeof define === "function" && define.amd) {
      define(["require", "exports"], factory);
    }
  })(function(require2, exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TextDocument = exports2.EOL = exports2.WorkspaceFolder = exports2.InlineCompletionContext = exports2.SelectedCompletionInfo = exports2.InlineCompletionTriggerKind = exports2.InlineCompletionList = exports2.InlineCompletionItem = exports2.StringValue = exports2.InlayHint = exports2.InlayHintLabelPart = exports2.InlayHintKind = exports2.InlineValueContext = exports2.InlineValueEvaluatableExpression = exports2.InlineValueVariableLookup = exports2.InlineValueText = exports2.SemanticTokens = exports2.SemanticTokenModifiers = exports2.SemanticTokenTypes = exports2.SelectionRange = exports2.DocumentLink = exports2.FormattingOptions = exports2.CodeLens = exports2.CodeAction = exports2.CodeActionContext = exports2.CodeActionTriggerKind = exports2.CodeActionKind = exports2.DocumentSymbol = exports2.WorkspaceSymbol = exports2.SymbolInformation = exports2.SymbolTag = exports2.SymbolKind = exports2.DocumentHighlight = exports2.DocumentHighlightKind = exports2.SignatureInformation = exports2.ParameterInformation = exports2.Hover = exports2.MarkedString = exports2.CompletionList = exports2.CompletionItem = exports2.CompletionItemLabelDetails = exports2.InsertTextMode = exports2.InsertReplaceEdit = exports2.CompletionItemTag = exports2.InsertTextFormat = exports2.CompletionItemKind = exports2.MarkupContent = exports2.MarkupKind = exports2.TextDocumentItem = exports2.OptionalVersionedTextDocumentIdentifier = exports2.VersionedTextDocumentIdentifier = exports2.TextDocumentIdentifier = exports2.WorkspaceChange = exports2.WorkspaceEdit = exports2.DeleteFile = exports2.RenameFile = exports2.CreateFile = exports2.TextDocumentEdit = exports2.AnnotatedTextEdit = exports2.ChangeAnnotationIdentifier = exports2.ChangeAnnotation = exports2.TextEdit = exports2.Command = exports2.Diagnostic = exports2.CodeDescription = exports2.DiagnosticTag = exports2.DiagnosticSeverity = exports2.DiagnosticRelatedInformation = exports2.FoldingRange = exports2.FoldingRangeKind = exports2.ColorPresentation = exports2.ColorInformation = exports2.Color = exports2.LocationLink = exports2.Location = exports2.Range = exports2.Position = exports2.uinteger = exports2.integer = exports2.URI = exports2.DocumentUri = undefined;
    var DocumentUri;
    (function(DocumentUri2) {
      function is(value) {
        return typeof value === "string";
      }
      DocumentUri2.is = is;
    })(DocumentUri || (exports2.DocumentUri = DocumentUri = {}));
    var URI;
    (function(URI2) {
      function is(value) {
        return typeof value === "string";
      }
      URI2.is = is;
    })(URI || (exports2.URI = URI = {}));
    var integer;
    (function(integer2) {
      integer2.MIN_VALUE = -2147483648;
      integer2.MAX_VALUE = 2147483647;
      function is(value) {
        return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
      }
      integer2.is = is;
    })(integer || (exports2.integer = integer = {}));
    var uinteger;
    (function(uinteger2) {
      uinteger2.MIN_VALUE = 0;
      uinteger2.MAX_VALUE = 2147483647;
      function is(value) {
        return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
      }
      uinteger2.is = is;
    })(uinteger || (exports2.uinteger = uinteger = {}));
    var Position;
    (function(Position2) {
      function create(line, character) {
        if (line === Number.MAX_VALUE) {
          line = uinteger.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
          character = uinteger.MAX_VALUE;
        }
        return { line, character };
      }
      Position2.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
      }
      Position2.is = is;
    })(Position || (exports2.Position = Position = {}));
    var Range;
    (function(Range2) {
      function create(one, two, three, four) {
        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
          return { start: Position.create(one, two), end: Position.create(three, four) };
        } else if (Position.is(one) && Position.is(two)) {
          return { start: one, end: two };
        } else {
          throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
        }
      }
      Range2.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
      }
      Range2.is = is;
    })(Range || (exports2.Range = Range = {}));
    var Location;
    (function(Location2) {
      function create(uri, range) {
        return { uri, range };
      }
      Location2.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
      }
      Location2.is = is;
    })(Location || (exports2.Location = Location = {}));
    var LocationLink;
    (function(LocationLink2) {
      function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
      }
      LocationLink2.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
      }
      LocationLink2.is = is;
    })(LocationLink || (exports2.LocationLink = LocationLink = {}));
    var Color;
    (function(Color2) {
      function create(red, green, blue, alpha) {
        return {
          red,
          green,
          blue,
          alpha
        };
      }
      Color2.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
      }
      Color2.is = is;
    })(Color || (exports2.Color = Color = {}));
    var ColorInformation;
    (function(ColorInformation2) {
      function create(range, color) {
        return {
          range,
          color
        };
      }
      ColorInformation2.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
      }
      ColorInformation2.is = is;
    })(ColorInformation || (exports2.ColorInformation = ColorInformation = {}));
    var ColorPresentation;
    (function(ColorPresentation2) {
      function create(label, textEdit, additionalTextEdits) {
        return {
          label,
          textEdit,
          additionalTextEdits
        };
      }
      ColorPresentation2.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
      }
      ColorPresentation2.is = is;
    })(ColorPresentation || (exports2.ColorPresentation = ColorPresentation = {}));
    var FoldingRangeKind;
    (function(FoldingRangeKind2) {
      FoldingRangeKind2.Comment = "comment";
      FoldingRangeKind2.Imports = "imports";
      FoldingRangeKind2.Region = "region";
    })(FoldingRangeKind || (exports2.FoldingRangeKind = FoldingRangeKind = {}));
    var FoldingRange;
    (function(FoldingRange2) {
      function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
        var result = {
          startLine,
          endLine
        };
        if (Is.defined(startCharacter)) {
          result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
          result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
          result.kind = kind;
        }
        if (Is.defined(collapsedText)) {
          result.collapsedText = collapsedText;
        }
        return result;
      }
      FoldingRange2.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
      }
      FoldingRange2.is = is;
    })(FoldingRange || (exports2.FoldingRange = FoldingRange = {}));
    var DiagnosticRelatedInformation;
    (function(DiagnosticRelatedInformation2) {
      function create(location, message) {
        return {
          location,
          message
        };
      }
      DiagnosticRelatedInformation2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
      }
      DiagnosticRelatedInformation2.is = is;
    })(DiagnosticRelatedInformation || (exports2.DiagnosticRelatedInformation = DiagnosticRelatedInformation = {}));
    var DiagnosticSeverity;
    (function(DiagnosticSeverity2) {
      DiagnosticSeverity2.Error = 1;
      DiagnosticSeverity2.Warning = 2;
      DiagnosticSeverity2.Information = 3;
      DiagnosticSeverity2.Hint = 4;
    })(DiagnosticSeverity || (exports2.DiagnosticSeverity = DiagnosticSeverity = {}));
    var DiagnosticTag;
    (function(DiagnosticTag2) {
      DiagnosticTag2.Unnecessary = 1;
      DiagnosticTag2.Deprecated = 2;
    })(DiagnosticTag || (exports2.DiagnosticTag = DiagnosticTag = {}));
    var CodeDescription;
    (function(CodeDescription2) {
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.href);
      }
      CodeDescription2.is = is;
    })(CodeDescription || (exports2.CodeDescription = CodeDescription = {}));
    var Diagnostic;
    (function(Diagnostic2) {
      function create(range, message, severity, code, source, relatedInformation) {
        var result = { range, message };
        if (Is.defined(severity)) {
          result.severity = severity;
        }
        if (Is.defined(code)) {
          result.code = code;
        }
        if (Is.defined(source)) {
          result.source = source;
        }
        if (Is.defined(relatedInformation)) {
          result.relatedInformation = relatedInformation;
        }
        return result;
      }
      Diagnostic2.create = create;
      function is(value) {
        var _a;
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === undefined ? undefined : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
      }
      Diagnostic2.is = is;
    })(Diagnostic || (exports2.Diagnostic = Diagnostic = {}));
    var Command;
    (function(Command2) {
      function create(title, command) {
        var args = [];
        for (var _i = 2;_i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var result = { title, command };
        if (Is.defined(args) && args.length > 0) {
          result.arguments = args;
        }
        return result;
      }
      Command2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
      }
      Command2.is = is;
    })(Command || (exports2.Command = Command = {}));
    var TextEdit;
    (function(TextEdit2) {
      function replace(range, newText) {
        return { range, newText };
      }
      TextEdit2.replace = replace;
      function insert(position, newText) {
        return { range: { start: position, end: position }, newText };
      }
      TextEdit2.insert = insert;
      function del(range) {
        return { range, newText: "" };
      }
      TextEdit2.del = del;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
      }
      TextEdit2.is = is;
    })(TextEdit || (exports2.TextEdit = TextEdit = {}));
    var ChangeAnnotation;
    (function(ChangeAnnotation2) {
      function create(label, needsConfirmation, description) {
        var result = { label };
        if (needsConfirmation !== undefined) {
          result.needsConfirmation = needsConfirmation;
        }
        if (description !== undefined) {
          result.description = description;
        }
        return result;
      }
      ChangeAnnotation2.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
      }
      ChangeAnnotation2.is = is;
    })(ChangeAnnotation || (exports2.ChangeAnnotation = ChangeAnnotation = {}));
    var ChangeAnnotationIdentifier;
    (function(ChangeAnnotationIdentifier2) {
      function is(value) {
        var candidate = value;
        return Is.string(candidate);
      }
      ChangeAnnotationIdentifier2.is = is;
    })(ChangeAnnotationIdentifier || (exports2.ChangeAnnotationIdentifier = ChangeAnnotationIdentifier = {}));
    var AnnotatedTextEdit;
    (function(AnnotatedTextEdit2) {
      function replace(range, newText, annotation) {
        return { range, newText, annotationId: annotation };
      }
      AnnotatedTextEdit2.replace = replace;
      function insert(position, newText, annotation) {
        return { range: { start: position, end: position }, newText, annotationId: annotation };
      }
      AnnotatedTextEdit2.insert = insert;
      function del(range, annotation) {
        return { range, newText: "", annotationId: annotation };
      }
      AnnotatedTextEdit2.del = del;
      function is(value) {
        var candidate = value;
        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      AnnotatedTextEdit2.is = is;
    })(AnnotatedTextEdit || (exports2.AnnotatedTextEdit = AnnotatedTextEdit = {}));
    var TextDocumentEdit;
    (function(TextDocumentEdit2) {
      function create(textDocument, edits) {
        return { textDocument, edits };
      }
      TextDocumentEdit2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
      }
      TextDocumentEdit2.is = is;
    })(TextDocumentEdit || (exports2.TextDocumentEdit = TextDocumentEdit = {}));
    var CreateFile;
    (function(CreateFile2) {
      function create(uri, options, annotation) {
        var result = {
          kind: "create",
          uri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
          result.options = options;
        }
        if (annotation !== undefined) {
          result.annotationId = annotation;
        }
        return result;
      }
      CreateFile2.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      CreateFile2.is = is;
    })(CreateFile || (exports2.CreateFile = CreateFile = {}));
    var RenameFile;
    (function(RenameFile2) {
      function create(oldUri, newUri, options, annotation) {
        var result = {
          kind: "rename",
          oldUri,
          newUri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
          result.options = options;
        }
        if (annotation !== undefined) {
          result.annotationId = annotation;
        }
        return result;
      }
      RenameFile2.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      RenameFile2.is = is;
    })(RenameFile || (exports2.RenameFile = RenameFile = {}));
    var DeleteFile;
    (function(DeleteFile2) {
      function create(uri, options, annotation) {
        var result = {
          kind: "delete",
          uri
        };
        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
          result.options = options;
        }
        if (annotation !== undefined) {
          result.annotationId = annotation;
        }
        return result;
      }
      DeleteFile2.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      DeleteFile2.is = is;
    })(DeleteFile || (exports2.DeleteFile = DeleteFile = {}));
    var WorkspaceEdit;
    (function(WorkspaceEdit2) {
      function is(value) {
        var candidate = value;
        return candidate && (candidate.changes !== undefined || candidate.documentChanges !== undefined) && (candidate.documentChanges === undefined || candidate.documentChanges.every(function(change) {
          if (Is.string(change.kind)) {
            return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
          } else {
            return TextDocumentEdit.is(change);
          }
        }));
      }
      WorkspaceEdit2.is = is;
    })(WorkspaceEdit || (exports2.WorkspaceEdit = WorkspaceEdit = {}));
    var TextEditChangeImpl = function() {
      function TextEditChangeImpl2(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
      }
      TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
          edit = TextEdit.insert(position, newText);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit = AnnotatedTextEdit.insert(position, newText, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit = AnnotatedTextEdit.insert(position, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
          return id;
        }
      };
      TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
          edit = TextEdit.replace(range, newText);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit = AnnotatedTextEdit.replace(range, newText, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit = AnnotatedTextEdit.replace(range, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
          return id;
        }
      };
      TextEditChangeImpl2.prototype.delete = function(range, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
          edit = TextEdit.del(range);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit = AnnotatedTextEdit.del(range, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit = AnnotatedTextEdit.del(range, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
          return id;
        }
      };
      TextEditChangeImpl2.prototype.add = function(edit) {
        this.edits.push(edit);
      };
      TextEditChangeImpl2.prototype.all = function() {
        return this.edits;
      };
      TextEditChangeImpl2.prototype.clear = function() {
        this.edits.splice(0, this.edits.length);
      };
      TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
        if (value === undefined) {
          throw new Error("Text edit change is not configured to manage change annotations.");
        }
      };
      return TextEditChangeImpl2;
    }();
    var ChangeAnnotations = function() {
      function ChangeAnnotations2(annotations) {
        this._annotations = annotations === undefined ? Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
      }
      ChangeAnnotations2.prototype.all = function() {
        return this._annotations;
      };
      Object.defineProperty(ChangeAnnotations2.prototype, "size", {
        get: function() {
          return this._size;
        },
        enumerable: false,
        configurable: true
      });
      ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
        var id;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
          id = idOrAnnotation;
        } else {
          id = this.nextId();
          annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== undefined) {
          throw new Error("Id ".concat(id, " is already in use."));
        }
        if (annotation === undefined) {
          throw new Error("No annotation provided for id ".concat(id));
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
      };
      ChangeAnnotations2.prototype.nextId = function() {
        this._counter++;
        return this._counter.toString();
      };
      return ChangeAnnotations2;
    }();
    var WorkspaceChange = function() {
      function WorkspaceChange2(workspaceEdit) {
        var _this = this;
        this._textEditChanges = Object.create(null);
        if (workspaceEdit !== undefined) {
          this._workspaceEdit = workspaceEdit;
          if (workspaceEdit.documentChanges) {
            this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
            workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            workspaceEdit.documentChanges.forEach(function(change) {
              if (TextDocumentEdit.is(change)) {
                var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                _this._textEditChanges[change.textDocument.uri] = textEditChange;
              }
            });
          } else if (workspaceEdit.changes) {
            Object.keys(workspaceEdit.changes).forEach(function(key) {
              var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
              _this._textEditChanges[key] = textEditChange;
            });
          }
        } else {
          this._workspaceEdit = {};
        }
      }
      Object.defineProperty(WorkspaceChange2.prototype, "edit", {
        get: function() {
          this.initDocumentChanges();
          if (this._changeAnnotations !== undefined) {
            if (this._changeAnnotations.size === 0) {
              this._workspaceEdit.changeAnnotations = undefined;
            } else {
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          }
          return this._workspaceEdit;
        },
        enumerable: false,
        configurable: true
      });
      WorkspaceChange2.prototype.getTextEditChange = function(key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          var textDocument = { uri: key.uri, version: key.version };
          var result = this._textEditChanges[textDocument.uri];
          if (!result) {
            var edits = [];
            var textDocumentEdit = {
              textDocument,
              edits
            };
            this._workspaceEdit.documentChanges.push(textDocumentEdit);
            result = new TextEditChangeImpl(edits, this._changeAnnotations);
            this._textEditChanges[textDocument.uri] = result;
          }
          return result;
        } else {
          this.initChanges();
          if (this._workspaceEdit.changes === undefined) {
            throw new Error("Workspace edit is not configured for normal text edit changes.");
          }
          var result = this._textEditChanges[key];
          if (!result) {
            var edits = [];
            this._workspaceEdit.changes[key] = edits;
            result = new TextEditChangeImpl(edits);
            this._textEditChanges[key] = result;
          }
          return result;
        }
      };
      WorkspaceChange2.prototype.initDocumentChanges = function() {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
          this._changeAnnotations = new ChangeAnnotations;
          this._workspaceEdit.documentChanges = [];
          this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
      };
      WorkspaceChange2.prototype.initChanges = function() {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
          this._workspaceEdit.changes = Object.create(null);
        }
      };
      WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
          operation = CreateFile.create(uri, options);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = CreateFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
          return id;
        }
      };
      WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
          operation = RenameFile.create(oldUri, newUri, options);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = RenameFile.create(oldUri, newUri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
          return id;
        }
      };
      WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
          operation = DeleteFile.create(uri, options);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = DeleteFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
          return id;
        }
      };
      return WorkspaceChange2;
    }();
    exports2.WorkspaceChange = WorkspaceChange;
    var TextDocumentIdentifier;
    (function(TextDocumentIdentifier2) {
      function create(uri) {
        return { uri };
      }
      TextDocumentIdentifier2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
      }
      TextDocumentIdentifier2.is = is;
    })(TextDocumentIdentifier || (exports2.TextDocumentIdentifier = TextDocumentIdentifier = {}));
    var VersionedTextDocumentIdentifier;
    (function(VersionedTextDocumentIdentifier2) {
      function create(uri, version) {
        return { uri, version };
      }
      VersionedTextDocumentIdentifier2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
      }
      VersionedTextDocumentIdentifier2.is = is;
    })(VersionedTextDocumentIdentifier || (exports2.VersionedTextDocumentIdentifier = VersionedTextDocumentIdentifier = {}));
    var OptionalVersionedTextDocumentIdentifier;
    (function(OptionalVersionedTextDocumentIdentifier2) {
      function create(uri, version) {
        return { uri, version };
      }
      OptionalVersionedTextDocumentIdentifier2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
      }
      OptionalVersionedTextDocumentIdentifier2.is = is;
    })(OptionalVersionedTextDocumentIdentifier || (exports2.OptionalVersionedTextDocumentIdentifier = OptionalVersionedTextDocumentIdentifier = {}));
    var TextDocumentItem;
    (function(TextDocumentItem2) {
      function create(uri, languageId, version, text) {
        return { uri, languageId, version, text };
      }
      TextDocumentItem2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
      }
      TextDocumentItem2.is = is;
    })(TextDocumentItem || (exports2.TextDocumentItem = TextDocumentItem = {}));
    var MarkupKind;
    (function(MarkupKind2) {
      MarkupKind2.PlainText = "plaintext";
      MarkupKind2.Markdown = "markdown";
      function is(value) {
        var candidate = value;
        return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
      }
      MarkupKind2.is = is;
    })(MarkupKind || (exports2.MarkupKind = MarkupKind = {}));
    var MarkupContent;
    (function(MarkupContent2) {
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
      }
      MarkupContent2.is = is;
    })(MarkupContent || (exports2.MarkupContent = MarkupContent = {}));
    var CompletionItemKind;
    (function(CompletionItemKind2) {
      CompletionItemKind2.Text = 1;
      CompletionItemKind2.Method = 2;
      CompletionItemKind2.Function = 3;
      CompletionItemKind2.Constructor = 4;
      CompletionItemKind2.Field = 5;
      CompletionItemKind2.Variable = 6;
      CompletionItemKind2.Class = 7;
      CompletionItemKind2.Interface = 8;
      CompletionItemKind2.Module = 9;
      CompletionItemKind2.Property = 10;
      CompletionItemKind2.Unit = 11;
      CompletionItemKind2.Value = 12;
      CompletionItemKind2.Enum = 13;
      CompletionItemKind2.Keyword = 14;
      CompletionItemKind2.Snippet = 15;
      CompletionItemKind2.Color = 16;
      CompletionItemKind2.File = 17;
      CompletionItemKind2.Reference = 18;
      CompletionItemKind2.Folder = 19;
      CompletionItemKind2.EnumMember = 20;
      CompletionItemKind2.Constant = 21;
      CompletionItemKind2.Struct = 22;
      CompletionItemKind2.Event = 23;
      CompletionItemKind2.Operator = 24;
      CompletionItemKind2.TypeParameter = 25;
    })(CompletionItemKind || (exports2.CompletionItemKind = CompletionItemKind = {}));
    var InsertTextFormat;
    (function(InsertTextFormat2) {
      InsertTextFormat2.PlainText = 1;
      InsertTextFormat2.Snippet = 2;
    })(InsertTextFormat || (exports2.InsertTextFormat = InsertTextFormat = {}));
    var CompletionItemTag;
    (function(CompletionItemTag2) {
      CompletionItemTag2.Deprecated = 1;
    })(CompletionItemTag || (exports2.CompletionItemTag = CompletionItemTag = {}));
    var InsertReplaceEdit;
    (function(InsertReplaceEdit2) {
      function create(newText, insert, replace) {
        return { newText, insert, replace };
      }
      InsertReplaceEdit2.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
      }
      InsertReplaceEdit2.is = is;
    })(InsertReplaceEdit || (exports2.InsertReplaceEdit = InsertReplaceEdit = {}));
    var InsertTextMode;
    (function(InsertTextMode2) {
      InsertTextMode2.asIs = 1;
      InsertTextMode2.adjustIndentation = 2;
    })(InsertTextMode || (exports2.InsertTextMode = InsertTextMode = {}));
    var CompletionItemLabelDetails;
    (function(CompletionItemLabelDetails2) {
      function is(value) {
        var candidate = value;
        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
      }
      CompletionItemLabelDetails2.is = is;
    })(CompletionItemLabelDetails || (exports2.CompletionItemLabelDetails = CompletionItemLabelDetails = {}));
    var CompletionItem;
    (function(CompletionItem2) {
      function create(label) {
        return { label };
      }
      CompletionItem2.create = create;
    })(CompletionItem || (exports2.CompletionItem = CompletionItem = {}));
    var CompletionList;
    (function(CompletionList2) {
      function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
      }
      CompletionList2.create = create;
    })(CompletionList || (exports2.CompletionList = CompletionList = {}));
    var MarkedString;
    (function(MarkedString2) {
      function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
      }
      MarkedString2.fromPlainText = fromPlainText;
      function is(value) {
        var candidate = value;
        return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
      }
      MarkedString2.is = is;
    })(MarkedString || (exports2.MarkedString = MarkedString = {}));
    var Hover;
    (function(Hover2) {
      function is(value) {
        var candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));
      }
      Hover2.is = is;
    })(Hover || (exports2.Hover = Hover = {}));
    var ParameterInformation;
    (function(ParameterInformation2) {
      function create(label, documentation) {
        return documentation ? { label, documentation } : { label };
      }
      ParameterInformation2.create = create;
    })(ParameterInformation || (exports2.ParameterInformation = ParameterInformation = {}));
    var SignatureInformation;
    (function(SignatureInformation2) {
      function create(label, documentation) {
        var parameters = [];
        for (var _i = 2;_i < arguments.length; _i++) {
          parameters[_i - 2] = arguments[_i];
        }
        var result = { label };
        if (Is.defined(documentation)) {
          result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
          result.parameters = parameters;
        } else {
          result.parameters = [];
        }
        return result;
      }
      SignatureInformation2.create = create;
    })(SignatureInformation || (exports2.SignatureInformation = SignatureInformation = {}));
    var DocumentHighlightKind;
    (function(DocumentHighlightKind2) {
      DocumentHighlightKind2.Text = 1;
      DocumentHighlightKind2.Read = 2;
      DocumentHighlightKind2.Write = 3;
    })(DocumentHighlightKind || (exports2.DocumentHighlightKind = DocumentHighlightKind = {}));
    var DocumentHighlight;
    (function(DocumentHighlight2) {
      function create(range, kind) {
        var result = { range };
        if (Is.number(kind)) {
          result.kind = kind;
        }
        return result;
      }
      DocumentHighlight2.create = create;
    })(DocumentHighlight || (exports2.DocumentHighlight = DocumentHighlight = {}));
    var SymbolKind;
    (function(SymbolKind2) {
      SymbolKind2.File = 1;
      SymbolKind2.Module = 2;
      SymbolKind2.Namespace = 3;
      SymbolKind2.Package = 4;
      SymbolKind2.Class = 5;
      SymbolKind2.Method = 6;
      SymbolKind2.Property = 7;
      SymbolKind2.Field = 8;
      SymbolKind2.Constructor = 9;
      SymbolKind2.Enum = 10;
      SymbolKind2.Interface = 11;
      SymbolKind2.Function = 12;
      SymbolKind2.Variable = 13;
      SymbolKind2.Constant = 14;
      SymbolKind2.String = 15;
      SymbolKind2.Number = 16;
      SymbolKind2.Boolean = 17;
      SymbolKind2.Array = 18;
      SymbolKind2.Object = 19;
      SymbolKind2.Key = 20;
      SymbolKind2.Null = 21;
      SymbolKind2.EnumMember = 22;
      SymbolKind2.Struct = 23;
      SymbolKind2.Event = 24;
      SymbolKind2.Operator = 25;
      SymbolKind2.TypeParameter = 26;
    })(SymbolKind || (exports2.SymbolKind = SymbolKind = {}));
    var SymbolTag;
    (function(SymbolTag2) {
      SymbolTag2.Deprecated = 1;
    })(SymbolTag || (exports2.SymbolTag = SymbolTag = {}));
    var SymbolInformation;
    (function(SymbolInformation2) {
      function create(name, kind, range, uri, containerName) {
        var result = {
          name,
          kind,
          location: { uri, range }
        };
        if (containerName) {
          result.containerName = containerName;
        }
        return result;
      }
      SymbolInformation2.create = create;
    })(SymbolInformation || (exports2.SymbolInformation = SymbolInformation = {}));
    var WorkspaceSymbol;
    (function(WorkspaceSymbol2) {
      function create(name, kind, uri, range) {
        return range !== undefined ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
      }
      WorkspaceSymbol2.create = create;
    })(WorkspaceSymbol || (exports2.WorkspaceSymbol = WorkspaceSymbol = {}));
    var DocumentSymbol;
    (function(DocumentSymbol2) {
      function create(name, detail, kind, range, selectionRange, children) {
        var result = {
          name,
          detail,
          kind,
          range,
          selectionRange
        };
        if (children !== undefined) {
          result.children = children;
        }
        return result;
      }
      DocumentSymbol2.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === undefined || Is.string(candidate.detail)) && (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) && (candidate.children === undefined || Array.isArray(candidate.children)) && (candidate.tags === undefined || Array.isArray(candidate.tags));
      }
      DocumentSymbol2.is = is;
    })(DocumentSymbol || (exports2.DocumentSymbol = DocumentSymbol = {}));
    var CodeActionKind;
    (function(CodeActionKind2) {
      CodeActionKind2.Empty = "";
      CodeActionKind2.QuickFix = "quickfix";
      CodeActionKind2.Refactor = "refactor";
      CodeActionKind2.RefactorExtract = "refactor.extract";
      CodeActionKind2.RefactorInline = "refactor.inline";
      CodeActionKind2.RefactorRewrite = "refactor.rewrite";
      CodeActionKind2.Source = "source";
      CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
      CodeActionKind2.SourceFixAll = "source.fixAll";
    })(CodeActionKind || (exports2.CodeActionKind = CodeActionKind = {}));
    var CodeActionTriggerKind;
    (function(CodeActionTriggerKind2) {
      CodeActionTriggerKind2.Invoked = 1;
      CodeActionTriggerKind2.Automatic = 2;
    })(CodeActionTriggerKind || (exports2.CodeActionTriggerKind = CodeActionTriggerKind = {}));
    var CodeActionContext;
    (function(CodeActionContext2) {
      function create(diagnostics, only, triggerKind) {
        var result = { diagnostics };
        if (only !== undefined && only !== null) {
          result.only = only;
        }
        if (triggerKind !== undefined && triggerKind !== null) {
          result.triggerKind = triggerKind;
        }
        return result;
      }
      CodeActionContext2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
      }
      CodeActionContext2.is = is;
    })(CodeActionContext || (exports2.CodeActionContext = CodeActionContext = {}));
    var CodeAction;
    (function(CodeAction2) {
      function create(title, kindOrCommandOrEdit, kind) {
        var result = { title };
        var checkKind = true;
        if (typeof kindOrCommandOrEdit === "string") {
          checkKind = false;
          result.kind = kindOrCommandOrEdit;
        } else if (Command.is(kindOrCommandOrEdit)) {
          result.command = kindOrCommandOrEdit;
        } else {
          result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== undefined) {
          result.kind = kind;
        }
        return result;
      }
      CodeAction2.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.title) && (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === undefined || Is.string(candidate.kind)) && (candidate.edit !== undefined || candidate.command !== undefined) && (candidate.command === undefined || Command.is(candidate.command)) && (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) && (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
      }
      CodeAction2.is = is;
    })(CodeAction || (exports2.CodeAction = CodeAction = {}));
    var CodeLens;
    (function(CodeLens2) {
      function create(range, data) {
        var result = { range };
        if (Is.defined(data)) {
          result.data = data;
        }
        return result;
      }
      CodeLens2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
      }
      CodeLens2.is = is;
    })(CodeLens || (exports2.CodeLens = CodeLens = {}));
    var FormattingOptions;
    (function(FormattingOptions2) {
      function create(tabSize, insertSpaces) {
        return { tabSize, insertSpaces };
      }
      FormattingOptions2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
      }
      FormattingOptions2.is = is;
    })(FormattingOptions || (exports2.FormattingOptions = FormattingOptions = {}));
    var DocumentLink;
    (function(DocumentLink2) {
      function create(range, target, data) {
        return { range, target, data };
      }
      DocumentLink2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
      }
      DocumentLink2.is = is;
    })(DocumentLink || (exports2.DocumentLink = DocumentLink = {}));
    var SelectionRange;
    (function(SelectionRange2) {
      function create(range, parent) {
        return { range, parent };
      }
      SelectionRange2.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange2.is(candidate.parent));
      }
      SelectionRange2.is = is;
    })(SelectionRange || (exports2.SelectionRange = SelectionRange = {}));
    var SemanticTokenTypes;
    (function(SemanticTokenTypes2) {
      SemanticTokenTypes2["namespace"] = "namespace";
      SemanticTokenTypes2["type"] = "type";
      SemanticTokenTypes2["class"] = "class";
      SemanticTokenTypes2["enum"] = "enum";
      SemanticTokenTypes2["interface"] = "interface";
      SemanticTokenTypes2["struct"] = "struct";
      SemanticTokenTypes2["typeParameter"] = "typeParameter";
      SemanticTokenTypes2["parameter"] = "parameter";
      SemanticTokenTypes2["variable"] = "variable";
      SemanticTokenTypes2["property"] = "property";
      SemanticTokenTypes2["enumMember"] = "enumMember";
      SemanticTokenTypes2["event"] = "event";
      SemanticTokenTypes2["function"] = "function";
      SemanticTokenTypes2["method"] = "method";
      SemanticTokenTypes2["macro"] = "macro";
      SemanticTokenTypes2["keyword"] = "keyword";
      SemanticTokenTypes2["modifier"] = "modifier";
      SemanticTokenTypes2["comment"] = "comment";
      SemanticTokenTypes2["string"] = "string";
      SemanticTokenTypes2["number"] = "number";
      SemanticTokenTypes2["regexp"] = "regexp";
      SemanticTokenTypes2["operator"] = "operator";
      SemanticTokenTypes2["decorator"] = "decorator";
    })(SemanticTokenTypes || (exports2.SemanticTokenTypes = SemanticTokenTypes = {}));
    var SemanticTokenModifiers;
    (function(SemanticTokenModifiers2) {
      SemanticTokenModifiers2["declaration"] = "declaration";
      SemanticTokenModifiers2["definition"] = "definition";
      SemanticTokenModifiers2["readonly"] = "readonly";
      SemanticTokenModifiers2["static"] = "static";
      SemanticTokenModifiers2["deprecated"] = "deprecated";
      SemanticTokenModifiers2["abstract"] = "abstract";
      SemanticTokenModifiers2["async"] = "async";
      SemanticTokenModifiers2["modification"] = "modification";
      SemanticTokenModifiers2["documentation"] = "documentation";
      SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
    })(SemanticTokenModifiers || (exports2.SemanticTokenModifiers = SemanticTokenModifiers = {}));
    var SemanticTokens;
    (function(SemanticTokens2) {
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
      }
      SemanticTokens2.is = is;
    })(SemanticTokens || (exports2.SemanticTokens = SemanticTokens = {}));
    var InlineValueText;
    (function(InlineValueText2) {
      function create(range, text) {
        return { range, text };
      }
      InlineValueText2.create = create;
      function is(value) {
        var candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
      }
      InlineValueText2.is = is;
    })(InlineValueText || (exports2.InlineValueText = InlineValueText = {}));
    var InlineValueVariableLookup;
    (function(InlineValueVariableLookup2) {
      function create(range, variableName, caseSensitiveLookup) {
        return { range, variableName, caseSensitiveLookup };
      }
      InlineValueVariableLookup2.create = create;
      function is(value) {
        var candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === undefined);
      }
      InlineValueVariableLookup2.is = is;
    })(InlineValueVariableLookup || (exports2.InlineValueVariableLookup = InlineValueVariableLookup = {}));
    var InlineValueEvaluatableExpression;
    (function(InlineValueEvaluatableExpression2) {
      function create(range, expression) {
        return { range, expression };
      }
      InlineValueEvaluatableExpression2.create = create;
      function is(value) {
        var candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === undefined);
      }
      InlineValueEvaluatableExpression2.is = is;
    })(InlineValueEvaluatableExpression || (exports2.InlineValueEvaluatableExpression = InlineValueEvaluatableExpression = {}));
    var InlineValueContext;
    (function(InlineValueContext2) {
      function create(frameId, stoppedLocation) {
        return { frameId, stoppedLocation };
      }
      InlineValueContext2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(value.stoppedLocation);
      }
      InlineValueContext2.is = is;
    })(InlineValueContext || (exports2.InlineValueContext = InlineValueContext = {}));
    var InlayHintKind;
    (function(InlayHintKind2) {
      InlayHintKind2.Type = 1;
      InlayHintKind2.Parameter = 2;
      function is(value) {
        return value === 1 || value === 2;
      }
      InlayHintKind2.is = is;
    })(InlayHintKind || (exports2.InlayHintKind = InlayHintKind = {}));
    var InlayHintLabelPart;
    (function(InlayHintLabelPart2) {
      function create(value) {
        return { value };
      }
      InlayHintLabelPart2.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === undefined || Location.is(candidate.location)) && (candidate.command === undefined || Command.is(candidate.command));
      }
      InlayHintLabelPart2.is = is;
    })(InlayHintLabelPart || (exports2.InlayHintLabelPart = InlayHintLabelPart = {}));
    var InlayHint;
    (function(InlayHint2) {
      function create(position, label, kind) {
        var result = { position, label };
        if (kind !== undefined) {
          result.kind = kind;
        }
        return result;
      }
      InlayHint2.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === undefined || InlayHintKind.is(candidate.kind)) && candidate.textEdits === undefined || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));
      }
      InlayHint2.is = is;
    })(InlayHint || (exports2.InlayHint = InlayHint = {}));
    var StringValue;
    (function(StringValue2) {
      function createSnippet(value) {
        return { kind: "snippet", value };
      }
      StringValue2.createSnippet = createSnippet;
    })(StringValue || (exports2.StringValue = StringValue = {}));
    var InlineCompletionItem;
    (function(InlineCompletionItem2) {
      function create(insertText, filterText, range, command) {
        return { insertText, filterText, range, command };
      }
      InlineCompletionItem2.create = create;
    })(InlineCompletionItem || (exports2.InlineCompletionItem = InlineCompletionItem = {}));
    var InlineCompletionList;
    (function(InlineCompletionList2) {
      function create(items) {
        return { items };
      }
      InlineCompletionList2.create = create;
    })(InlineCompletionList || (exports2.InlineCompletionList = InlineCompletionList = {}));
    var InlineCompletionTriggerKind;
    (function(InlineCompletionTriggerKind2) {
      InlineCompletionTriggerKind2.Invoked = 0;
      InlineCompletionTriggerKind2.Automatic = 1;
    })(InlineCompletionTriggerKind || (exports2.InlineCompletionTriggerKind = InlineCompletionTriggerKind = {}));
    var SelectedCompletionInfo;
    (function(SelectedCompletionInfo2) {
      function create(range, text) {
        return { range, text };
      }
      SelectedCompletionInfo2.create = create;
    })(SelectedCompletionInfo || (exports2.SelectedCompletionInfo = SelectedCompletionInfo = {}));
    var InlineCompletionContext;
    (function(InlineCompletionContext2) {
      function create(triggerKind, selectedCompletionInfo) {
        return { triggerKind, selectedCompletionInfo };
      }
      InlineCompletionContext2.create = create;
    })(InlineCompletionContext || (exports2.InlineCompletionContext = InlineCompletionContext = {}));
    var WorkspaceFolder;
    (function(WorkspaceFolder2) {
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
      }
      WorkspaceFolder2.is = is;
    })(WorkspaceFolder || (exports2.WorkspaceFolder = WorkspaceFolder = {}));
    exports2.EOL = [`
`, `\r
`, "\r"];
    var TextDocument;
    (function(TextDocument2) {
      function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
      }
      TextDocument2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
      }
      TextDocument2.is = is;
      function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort(edits, function(a, b) {
          var diff = a.range.start.line - b.range.start.line;
          if (diff === 0) {
            return a.range.start.character - b.range.start.character;
          }
          return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1;i >= 0; i--) {
          var e = sortedEdits[i];
          var startOffset = document.offsetAt(e.range.start);
          var endOffset = document.offsetAt(e.range.end);
          if (endOffset <= lastModifiedOffset) {
            text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
          } else {
            throw new Error("Overlapping edit");
          }
          lastModifiedOffset = startOffset;
        }
        return text;
      }
      TextDocument2.applyEdits = applyEdits;
      function mergeSort(data, compare) {
        if (data.length <= 1) {
          return data;
        }
        var p = data.length / 2 | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
          var ret = compare(left[leftIdx], right[rightIdx]);
          if (ret <= 0) {
            data[i++] = left[leftIdx++];
          } else {
            data[i++] = right[rightIdx++];
          }
        }
        while (leftIdx < left.length) {
          data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
          data[i++] = right[rightIdx++];
        }
        return data;
      }
    })(TextDocument || (exports2.TextDocument = TextDocument = {}));
    var FullTextDocument = function() {
      function FullTextDocument2(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
      }
      Object.defineProperty(FullTextDocument2.prototype, "uri", {
        get: function() {
          return this._uri;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FullTextDocument2.prototype, "languageId", {
        get: function() {
          return this._languageId;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FullTextDocument2.prototype, "version", {
        get: function() {
          return this._version;
        },
        enumerable: false,
        configurable: true
      });
      FullTextDocument2.prototype.getText = function(range) {
        if (range) {
          var start = this.offsetAt(range.start);
          var end = this.offsetAt(range.end);
          return this._content.substring(start, end);
        }
        return this._content;
      };
      FullTextDocument2.prototype.update = function(event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = undefined;
      };
      FullTextDocument2.prototype.getLineOffsets = function() {
        if (this._lineOffsets === undefined) {
          var lineOffsets = [];
          var text = this._content;
          var isLineStart = true;
          for (var i = 0;i < text.length; i++) {
            if (isLineStart) {
              lineOffsets.push(i);
              isLineStart = false;
            }
            var ch = text.charAt(i);
            isLineStart = ch === "\r" || ch === `
`;
            if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === `
`) {
              i++;
            }
          }
          if (isLineStart && text.length > 0) {
            lineOffsets.push(text.length);
          }
          this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
      };
      FullTextDocument2.prototype.positionAt = function(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
          return Position.create(0, offset);
        }
        while (low < high) {
          var mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        var line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
      };
      FullTextDocument2.prototype.offsetAt = function(position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
      };
      Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
        get: function() {
          return this.getLineOffsets().length;
        },
        enumerable: false,
        configurable: true
      });
      return FullTextDocument2;
    }();
    var Is;
    (function(Is2) {
      var toString = Object.prototype.toString;
      function defined(value) {
        return typeof value !== "undefined";
      }
      Is2.defined = defined;
      function undefined2(value) {
        return typeof value === "undefined";
      }
      Is2.undefined = undefined2;
      function boolean(value) {
        return value === true || value === false;
      }
      Is2.boolean = boolean;
      function string(value) {
        return toString.call(value) === "[object String]";
      }
      Is2.string = string;
      function number(value) {
        return toString.call(value) === "[object Number]";
      }
      Is2.number = number;
      function numberRange(value, min, max) {
        return toString.call(value) === "[object Number]" && min <= value && value <= max;
      }
      Is2.numberRange = numberRange;
      function integer2(value) {
        return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
      }
      Is2.integer = integer2;
      function uinteger2(value) {
        return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
      }
      Is2.uinteger = uinteger2;
      function func(value) {
        return toString.call(value) === "[object Function]";
      }
      Is2.func = func;
      function objectLiteral(value) {
        return value !== null && typeof value === "object";
      }
      Is2.objectLiteral = objectLiteral;
      function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
      }
      Is2.typedArray = typedArray;
    })(Is || (Is = {}));
  });
});

// node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = exports.MessageDirection = undefined;
  var vscode_jsonrpc_1 = require_main();
  var MessageDirection;
  (function(MessageDirection2) {
    MessageDirection2["clientToServer"] = "clientToServer";
    MessageDirection2["serverToClient"] = "serverToClient";
    MessageDirection2["both"] = "both";
  })(MessageDirection || (exports.MessageDirection = MessageDirection = {}));

  class RegistrationType {
    constructor(method) {
      this.method = method;
    }
  }
  exports.RegistrationType = RegistrationType;

  class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
    constructor(method) {
      super(method);
    }
  }
  exports.ProtocolRequestType0 = ProtocolRequestType0;

  class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
    constructor(method) {
      super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
  }
  exports.ProtocolRequestType = ProtocolRequestType;

  class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
    constructor(method) {
      super(method);
    }
  }
  exports.ProtocolNotificationType0 = ProtocolNotificationType0;

  class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
    constructor(method) {
      super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
  }
  exports.ProtocolNotificationType = ProtocolNotificationType;
});

// node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.objectLiteral = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = undefined;
  function boolean(value) {
    return value === true || value === false;
  }
  exports.boolean = boolean;
  function string(value) {
    return typeof value === "string" || value instanceof String;
  }
  exports.string = string;
  function number(value) {
    return typeof value === "number" || value instanceof Number;
  }
  exports.number = number;
  function error(value) {
    return value instanceof Error;
  }
  exports.error = error;
  function func(value) {
    return typeof value === "function";
  }
  exports.func = func;
  function array(value) {
    return Array.isArray(value);
  }
  exports.array = array;
  function stringArray(value) {
    return array(value) && value.every((elem) => string(elem));
  }
  exports.stringArray = stringArray;
  function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
  }
  exports.typedArray = typedArray;
  function objectLiteral(value) {
    return value !== null && typeof value === "object";
  }
  exports.objectLiteral = objectLiteral;
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ImplementationRequest = undefined;
  var messages_1 = require_messages2();
  var ImplementationRequest;
  (function(ImplementationRequest2) {
    ImplementationRequest2.method = "textDocument/implementation";
    ImplementationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
  })(ImplementationRequest || (exports.ImplementationRequest = ImplementationRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeDefinitionRequest = undefined;
  var messages_1 = require_messages2();
  var TypeDefinitionRequest;
  (function(TypeDefinitionRequest2) {
    TypeDefinitionRequest2.method = "textDocument/typeDefinition";
    TypeDefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
  })(TypeDefinitionRequest || (exports.TypeDefinitionRequest = TypeDefinitionRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js
var require_protocol_workspaceFolder = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = undefined;
  var messages_1 = require_messages2();
  var WorkspaceFoldersRequest;
  (function(WorkspaceFoldersRequest2) {
    WorkspaceFoldersRequest2.method = "workspace/workspaceFolders";
    WorkspaceFoldersRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
    WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest2.method);
  })(WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));
  var DidChangeWorkspaceFoldersNotification;
  (function(DidChangeWorkspaceFoldersNotification2) {
    DidChangeWorkspaceFoldersNotification2.method = "workspace/didChangeWorkspaceFolders";
    DidChangeWorkspaceFoldersNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification2.method);
  })(DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConfigurationRequest = undefined;
  var messages_1 = require_messages2();
  var ConfigurationRequest;
  (function(ConfigurationRequest2) {
    ConfigurationRequest2.method = "workspace/configuration";
    ConfigurationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
    ConfigurationRequest2.type = new messages_1.ProtocolRequestType(ConfigurationRequest2.method);
  })(ConfigurationRequest || (exports.ConfigurationRequest = ConfigurationRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ColorPresentationRequest = exports.DocumentColorRequest = undefined;
  var messages_1 = require_messages2();
  var DocumentColorRequest;
  (function(DocumentColorRequest2) {
    DocumentColorRequest2.method = "textDocument/documentColor";
    DocumentColorRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
  })(DocumentColorRequest || (exports.DocumentColorRequest = DocumentColorRequest = {}));
  var ColorPresentationRequest;
  (function(ColorPresentationRequest2) {
    ColorPresentationRequest2.method = "textDocument/colorPresentation";
    ColorPresentationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    ColorPresentationRequest2.type = new messages_1.ProtocolRequestType(ColorPresentationRequest2.method);
  })(ColorPresentationRequest || (exports.ColorPresentationRequest = ColorPresentationRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FoldingRangeRefreshRequest = exports.FoldingRangeRequest = undefined;
  var messages_1 = require_messages2();
  var FoldingRangeRequest;
  (function(FoldingRangeRequest2) {
    FoldingRangeRequest2.method = "textDocument/foldingRange";
    FoldingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
  })(FoldingRangeRequest || (exports.FoldingRangeRequest = FoldingRangeRequest = {}));
  var FoldingRangeRefreshRequest;
  (function(FoldingRangeRefreshRequest2) {
    FoldingRangeRefreshRequest2.method = `workspace/foldingRange/refresh`;
    FoldingRangeRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
    FoldingRangeRefreshRequest2.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest2.method);
  })(FoldingRangeRefreshRequest || (exports.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DeclarationRequest = undefined;
  var messages_1 = require_messages2();
  var DeclarationRequest;
  (function(DeclarationRequest2) {
    DeclarationRequest2.method = "textDocument/declaration";
    DeclarationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
  })(DeclarationRequest || (exports.DeclarationRequest = DeclarationRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SelectionRangeRequest = undefined;
  var messages_1 = require_messages2();
  var SelectionRangeRequest;
  (function(SelectionRangeRequest2) {
    SelectionRangeRequest2.method = "textDocument/selectionRange";
    SelectionRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
  })(SelectionRangeRequest || (exports.SelectionRangeRequest = SelectionRangeRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = undefined;
  var vscode_jsonrpc_1 = require_main();
  var messages_1 = require_messages2();
  var WorkDoneProgress;
  (function(WorkDoneProgress2) {
    WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType;
    function is(value) {
      return value === WorkDoneProgress2.type;
    }
    WorkDoneProgress2.is = is;
  })(WorkDoneProgress || (exports.WorkDoneProgress = WorkDoneProgress = {}));
  var WorkDoneProgressCreateRequest;
  (function(WorkDoneProgressCreateRequest2) {
    WorkDoneProgressCreateRequest2.method = "window/workDoneProgress/create";
    WorkDoneProgressCreateRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
    WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest2.method);
  })(WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));
  var WorkDoneProgressCancelNotification;
  (function(WorkDoneProgressCancelNotification2) {
    WorkDoneProgressCancelNotification2.method = "window/workDoneProgress/cancel";
    WorkDoneProgressCancelNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
    WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification2.method);
  })(WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = undefined;
  var messages_1 = require_messages2();
  var CallHierarchyPrepareRequest;
  (function(CallHierarchyPrepareRequest2) {
    CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
    CallHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
  })(CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));
  var CallHierarchyIncomingCallsRequest;
  (function(CallHierarchyIncomingCallsRequest2) {
    CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
    CallHierarchyIncomingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
  })(CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));
  var CallHierarchyOutgoingCallsRequest;
  (function(CallHierarchyOutgoingCallsRequest2) {
    CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
    CallHierarchyOutgoingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
  })(CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = undefined;
  var messages_1 = require_messages2();
  var TokenFormat;
  (function(TokenFormat2) {
    TokenFormat2.Relative = "relative";
  })(TokenFormat || (exports.TokenFormat = TokenFormat = {}));
  var SemanticTokensRegistrationType;
  (function(SemanticTokensRegistrationType2) {
    SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
    SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
  })(SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));
  var SemanticTokensRequest;
  (function(SemanticTokensRequest2) {
    SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
    SemanticTokensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
    SemanticTokensRequest2.registrationMethod = SemanticTokensRegistrationType.method;
  })(SemanticTokensRequest || (exports.SemanticTokensRequest = SemanticTokensRequest = {}));
  var SemanticTokensDeltaRequest;
  (function(SemanticTokensDeltaRequest2) {
    SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
    SemanticTokensDeltaRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
    SemanticTokensDeltaRequest2.registrationMethod = SemanticTokensRegistrationType.method;
  })(SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));
  var SemanticTokensRangeRequest;
  (function(SemanticTokensRangeRequest2) {
    SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
    SemanticTokensRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
    SemanticTokensRangeRequest2.registrationMethod = SemanticTokensRegistrationType.method;
  })(SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));
  var SemanticTokensRefreshRequest;
  (function(SemanticTokensRefreshRequest2) {
    SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
    SemanticTokensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
    SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
  })(SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ShowDocumentRequest = undefined;
  var messages_1 = require_messages2();
  var ShowDocumentRequest;
  (function(ShowDocumentRequest2) {
    ShowDocumentRequest2.method = "window/showDocument";
    ShowDocumentRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
    ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
  })(ShowDocumentRequest || (exports.ShowDocumentRequest = ShowDocumentRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LinkedEditingRangeRequest = undefined;
  var messages_1 = require_messages2();
  var LinkedEditingRangeRequest;
  (function(LinkedEditingRangeRequest2) {
    LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
    LinkedEditingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
  })(LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = undefined;
  var messages_1 = require_messages2();
  var FileOperationPatternKind;
  (function(FileOperationPatternKind2) {
    FileOperationPatternKind2.file = "file";
    FileOperationPatternKind2.folder = "folder";
  })(FileOperationPatternKind || (exports.FileOperationPatternKind = FileOperationPatternKind = {}));
  var WillCreateFilesRequest;
  (function(WillCreateFilesRequest2) {
    WillCreateFilesRequest2.method = "workspace/willCreateFiles";
    WillCreateFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
  })(WillCreateFilesRequest || (exports.WillCreateFilesRequest = WillCreateFilesRequest = {}));
  var DidCreateFilesNotification;
  (function(DidCreateFilesNotification2) {
    DidCreateFilesNotification2.method = "workspace/didCreateFiles";
    DidCreateFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
    DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
  })(DidCreateFilesNotification || (exports.DidCreateFilesNotification = DidCreateFilesNotification = {}));
  var WillRenameFilesRequest;
  (function(WillRenameFilesRequest2) {
    WillRenameFilesRequest2.method = "workspace/willRenameFiles";
    WillRenameFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
  })(WillRenameFilesRequest || (exports.WillRenameFilesRequest = WillRenameFilesRequest = {}));
  var DidRenameFilesNotification;
  (function(DidRenameFilesNotification2) {
    DidRenameFilesNotification2.method = "workspace/didRenameFiles";
    DidRenameFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
    DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
  })(DidRenameFilesNotification || (exports.DidRenameFilesNotification = DidRenameFilesNotification = {}));
  var DidDeleteFilesNotification;
  (function(DidDeleteFilesNotification2) {
    DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
    DidDeleteFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
    DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
  })(DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));
  var WillDeleteFilesRequest;
  (function(WillDeleteFilesRequest2) {
    WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
    WillDeleteFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
  })(WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = undefined;
  var messages_1 = require_messages2();
  var UniquenessLevel;
  (function(UniquenessLevel2) {
    UniquenessLevel2.document = "document";
    UniquenessLevel2.project = "project";
    UniquenessLevel2.group = "group";
    UniquenessLevel2.scheme = "scheme";
    UniquenessLevel2.global = "global";
  })(UniquenessLevel || (exports.UniquenessLevel = UniquenessLevel = {}));
  var MonikerKind;
  (function(MonikerKind2) {
    MonikerKind2.$import = "import";
    MonikerKind2.$export = "export";
    MonikerKind2.local = "local";
  })(MonikerKind || (exports.MonikerKind = MonikerKind = {}));
  var MonikerRequest;
  (function(MonikerRequest2) {
    MonikerRequest2.method = "textDocument/moniker";
    MonikerRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
  })(MonikerRequest || (exports.MonikerRequest = MonikerRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js
var require_protocol_typeHierarchy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeHierarchySubtypesRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchyPrepareRequest = undefined;
  var messages_1 = require_messages2();
  var TypeHierarchyPrepareRequest;
  (function(TypeHierarchyPrepareRequest2) {
    TypeHierarchyPrepareRequest2.method = "textDocument/prepareTypeHierarchy";
    TypeHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    TypeHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest2.method);
  })(TypeHierarchyPrepareRequest || (exports.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));
  var TypeHierarchySupertypesRequest;
  (function(TypeHierarchySupertypesRequest2) {
    TypeHierarchySupertypesRequest2.method = "typeHierarchy/supertypes";
    TypeHierarchySupertypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    TypeHierarchySupertypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest2.method);
  })(TypeHierarchySupertypesRequest || (exports.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));
  var TypeHierarchySubtypesRequest;
  (function(TypeHierarchySubtypesRequest2) {
    TypeHierarchySubtypesRequest2.method = "typeHierarchy/subtypes";
    TypeHierarchySubtypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    TypeHierarchySubtypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest2.method);
  })(TypeHierarchySubtypesRequest || (exports.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js
var require_protocol_inlineValue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InlineValueRefreshRequest = exports.InlineValueRequest = undefined;
  var messages_1 = require_messages2();
  var InlineValueRequest;
  (function(InlineValueRequest2) {
    InlineValueRequest2.method = "textDocument/inlineValue";
    InlineValueRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    InlineValueRequest2.type = new messages_1.ProtocolRequestType(InlineValueRequest2.method);
  })(InlineValueRequest || (exports.InlineValueRequest = InlineValueRequest = {}));
  var InlineValueRefreshRequest;
  (function(InlineValueRefreshRequest2) {
    InlineValueRefreshRequest2.method = `workspace/inlineValue/refresh`;
    InlineValueRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
    InlineValueRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest2.method);
  })(InlineValueRefreshRequest || (exports.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js
var require_protocol_inlayHint = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = undefined;
  var messages_1 = require_messages2();
  var InlayHintRequest;
  (function(InlayHintRequest2) {
    InlayHintRequest2.method = "textDocument/inlayHint";
    InlayHintRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    InlayHintRequest2.type = new messages_1.ProtocolRequestType(InlayHintRequest2.method);
  })(InlayHintRequest || (exports.InlayHintRequest = InlayHintRequest = {}));
  var InlayHintResolveRequest;
  (function(InlayHintResolveRequest2) {
    InlayHintResolveRequest2.method = "inlayHint/resolve";
    InlayHintResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    InlayHintResolveRequest2.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest2.method);
  })(InlayHintResolveRequest || (exports.InlayHintResolveRequest = InlayHintResolveRequest = {}));
  var InlayHintRefreshRequest;
  (function(InlayHintRefreshRequest2) {
    InlayHintRefreshRequest2.method = `workspace/inlayHint/refresh`;
    InlayHintRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
    InlayHintRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest2.method);
  })(InlayHintRefreshRequest || (exports.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js
var require_protocol_diagnostic = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = undefined;
  var vscode_jsonrpc_1 = require_main();
  var Is = require_is3();
  var messages_1 = require_messages2();
  var DiagnosticServerCancellationData;
  (function(DiagnosticServerCancellationData2) {
    function is(value) {
      const candidate = value;
      return candidate && Is.boolean(candidate.retriggerRequest);
    }
    DiagnosticServerCancellationData2.is = is;
  })(DiagnosticServerCancellationData || (exports.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));
  var DocumentDiagnosticReportKind;
  (function(DocumentDiagnosticReportKind2) {
    DocumentDiagnosticReportKind2.Full = "full";
    DocumentDiagnosticReportKind2.Unchanged = "unchanged";
  })(DocumentDiagnosticReportKind || (exports.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind = {}));
  var DocumentDiagnosticRequest;
  (function(DocumentDiagnosticRequest2) {
    DocumentDiagnosticRequest2.method = "textDocument/diagnostic";
    DocumentDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentDiagnosticRequest2.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest2.method);
    DocumentDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType;
  })(DocumentDiagnosticRequest || (exports.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));
  var WorkspaceDiagnosticRequest;
  (function(WorkspaceDiagnosticRequest2) {
    WorkspaceDiagnosticRequest2.method = "workspace/diagnostic";
    WorkspaceDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    WorkspaceDiagnosticRequest2.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest2.method);
    WorkspaceDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType;
  })(WorkspaceDiagnosticRequest || (exports.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));
  var DiagnosticRefreshRequest;
  (function(DiagnosticRefreshRequest2) {
    DiagnosticRefreshRequest2.method = `workspace/diagnostic/refresh`;
    DiagnosticRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
    DiagnosticRefreshRequest2.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest2.method);
  })(DiagnosticRefreshRequest || (exports.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js
var require_protocol_notebook = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = undefined;
  var vscode_languageserver_types_1 = require_main2();
  var Is = require_is3();
  var messages_1 = require_messages2();
  var NotebookCellKind;
  (function(NotebookCellKind2) {
    NotebookCellKind2.Markup = 1;
    NotebookCellKind2.Code = 2;
    function is(value) {
      return value === 1 || value === 2;
    }
    NotebookCellKind2.is = is;
  })(NotebookCellKind || (exports.NotebookCellKind = NotebookCellKind = {}));
  var ExecutionSummary;
  (function(ExecutionSummary2) {
    function create(executionOrder, success) {
      const result = { executionOrder };
      if (success === true || success === false) {
        result.success = success;
      }
      return result;
    }
    ExecutionSummary2.create = create;
    function is(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === undefined || Is.boolean(candidate.success));
    }
    ExecutionSummary2.is = is;
    function equals(one, other) {
      if (one === other) {
        return true;
      }
      if (one === null || one === undefined || other === null || other === undefined) {
        return false;
      }
      return one.executionOrder === other.executionOrder && one.success === other.success;
    }
    ExecutionSummary2.equals = equals;
  })(ExecutionSummary || (exports.ExecutionSummary = ExecutionSummary = {}));
  var NotebookCell;
  (function(NotebookCell2) {
    function create(kind, document) {
      return { kind, document };
    }
    NotebookCell2.create = create;
    function is(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === undefined || Is.objectLiteral(candidate.metadata));
    }
    NotebookCell2.is = is;
    function diff(one, two) {
      const result = new Set;
      if (one.document !== two.document) {
        result.add("document");
      }
      if (one.kind !== two.kind) {
        result.add("kind");
      }
      if (one.executionSummary !== two.executionSummary) {
        result.add("executionSummary");
      }
      if ((one.metadata !== undefined || two.metadata !== undefined) && !equalsMetadata(one.metadata, two.metadata)) {
        result.add("metadata");
      }
      if ((one.executionSummary !== undefined || two.executionSummary !== undefined) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
        result.add("executionSummary");
      }
      return result;
    }
    NotebookCell2.diff = diff;
    function equalsMetadata(one, other) {
      if (one === other) {
        return true;
      }
      if (one === null || one === undefined || other === null || other === undefined) {
        return false;
      }
      if (typeof one !== typeof other) {
        return false;
      }
      if (typeof one !== "object") {
        return false;
      }
      const oneArray = Array.isArray(one);
      const otherArray = Array.isArray(other);
      if (oneArray !== otherArray) {
        return false;
      }
      if (oneArray && otherArray) {
        if (one.length !== other.length) {
          return false;
        }
        for (let i = 0;i < one.length; i++) {
          if (!equalsMetadata(one[i], other[i])) {
            return false;
          }
        }
      }
      if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
        const oneKeys = Object.keys(one);
        const otherKeys = Object.keys(other);
        if (oneKeys.length !== otherKeys.length) {
          return false;
        }
        oneKeys.sort();
        otherKeys.sort();
        if (!equalsMetadata(oneKeys, otherKeys)) {
          return false;
        }
        for (let i = 0;i < oneKeys.length; i++) {
          const prop = oneKeys[i];
          if (!equalsMetadata(one[prop], other[prop])) {
            return false;
          }
        }
      }
      return true;
    }
  })(NotebookCell || (exports.NotebookCell = NotebookCell = {}));
  var NotebookDocument;
  (function(NotebookDocument2) {
    function create(uri, notebookType, version, cells) {
      return { uri, notebookType, version, cells };
    }
    NotebookDocument2.create = create;
    function is(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
    }
    NotebookDocument2.is = is;
  })(NotebookDocument || (exports.NotebookDocument = NotebookDocument = {}));
  var NotebookDocumentSyncRegistrationType;
  (function(NotebookDocumentSyncRegistrationType2) {
    NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
    NotebookDocumentSyncRegistrationType2.messageDirection = messages_1.MessageDirection.clientToServer;
    NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
  })(NotebookDocumentSyncRegistrationType || (exports.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));
  var DidOpenNotebookDocumentNotification;
  (function(DidOpenNotebookDocumentNotification2) {
    DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
    DidOpenNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
    DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
    DidOpenNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
  })(DidOpenNotebookDocumentNotification || (exports.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));
  var NotebookCellArrayChange;
  (function(NotebookCellArrayChange2) {
    function is(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === undefined || Is.typedArray(candidate.cells, NotebookCell.is));
    }
    NotebookCellArrayChange2.is = is;
    function create(start, deleteCount, cells) {
      const result = { start, deleteCount };
      if (cells !== undefined) {
        result.cells = cells;
      }
      return result;
    }
    NotebookCellArrayChange2.create = create;
  })(NotebookCellArrayChange || (exports.NotebookCellArrayChange = NotebookCellArrayChange = {}));
  var DidChangeNotebookDocumentNotification;
  (function(DidChangeNotebookDocumentNotification2) {
    DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
    DidChangeNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
    DidChangeNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
  })(DidChangeNotebookDocumentNotification || (exports.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));
  var DidSaveNotebookDocumentNotification;
  (function(DidSaveNotebookDocumentNotification2) {
    DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
    DidSaveNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
    DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
    DidSaveNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
  })(DidSaveNotebookDocumentNotification || (exports.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));
  var DidCloseNotebookDocumentNotification;
  (function(DidCloseNotebookDocumentNotification2) {
    DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
    DidCloseNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
    DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
    DidCloseNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
  })(DidCloseNotebookDocumentNotification || (exports.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js
var require_protocol_inlineCompletion = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InlineCompletionRequest = undefined;
  var messages_1 = require_messages2();
  var InlineCompletionRequest;
  (function(InlineCompletionRequest2) {
    InlineCompletionRequest2.method = "textDocument/inlineCompletion";
    InlineCompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    InlineCompletionRequest2.type = new messages_1.ProtocolRequestType(InlineCompletionRequest2.method);
  })(InlineCompletionRequest || (exports.InlineCompletionRequest = InlineCompletionRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.RelativePattern = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeErrorCodes = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.PositionEncodingKind = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.NotebookCellTextDocumentFilter = exports.NotebookDocumentFilter = exports.TextDocumentFilter = undefined;
  exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRefreshRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangesFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolResolveRequest = undefined;
  exports.InlineCompletionRequest = exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = exports.InlineValueRefreshRequest = exports.InlineValueRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchySubtypesRequest = exports.TypeHierarchyPrepareRequest = undefined;
  var messages_1 = require_messages2();
  var vscode_languageserver_types_1 = require_main2();
  var Is = require_is3();
  var protocol_implementation_1 = require_protocol_implementation();
  Object.defineProperty(exports, "ImplementationRequest", { enumerable: true, get: function() {
    return protocol_implementation_1.ImplementationRequest;
  } });
  var protocol_typeDefinition_1 = require_protocol_typeDefinition();
  Object.defineProperty(exports, "TypeDefinitionRequest", { enumerable: true, get: function() {
    return protocol_typeDefinition_1.TypeDefinitionRequest;
  } });
  var protocol_workspaceFolder_1 = require_protocol_workspaceFolder();
  Object.defineProperty(exports, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
    return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
  } });
  Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
    return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
  } });
  var protocol_configuration_1 = require_protocol_configuration();
  Object.defineProperty(exports, "ConfigurationRequest", { enumerable: true, get: function() {
    return protocol_configuration_1.ConfigurationRequest;
  } });
  var protocol_colorProvider_1 = require_protocol_colorProvider();
  Object.defineProperty(exports, "DocumentColorRequest", { enumerable: true, get: function() {
    return protocol_colorProvider_1.DocumentColorRequest;
  } });
  Object.defineProperty(exports, "ColorPresentationRequest", { enumerable: true, get: function() {
    return protocol_colorProvider_1.ColorPresentationRequest;
  } });
  var protocol_foldingRange_1 = require_protocol_foldingRange();
  Object.defineProperty(exports, "FoldingRangeRequest", { enumerable: true, get: function() {
    return protocol_foldingRange_1.FoldingRangeRequest;
  } });
  Object.defineProperty(exports, "FoldingRangeRefreshRequest", { enumerable: true, get: function() {
    return protocol_foldingRange_1.FoldingRangeRefreshRequest;
  } });
  var protocol_declaration_1 = require_protocol_declaration();
  Object.defineProperty(exports, "DeclarationRequest", { enumerable: true, get: function() {
    return protocol_declaration_1.DeclarationRequest;
  } });
  var protocol_selectionRange_1 = require_protocol_selectionRange();
  Object.defineProperty(exports, "SelectionRangeRequest", { enumerable: true, get: function() {
    return protocol_selectionRange_1.SelectionRangeRequest;
  } });
  var protocol_progress_1 = require_protocol_progress();
  Object.defineProperty(exports, "WorkDoneProgress", { enumerable: true, get: function() {
    return protocol_progress_1.WorkDoneProgress;
  } });
  Object.defineProperty(exports, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
    return protocol_progress_1.WorkDoneProgressCreateRequest;
  } });
  Object.defineProperty(exports, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
    return protocol_progress_1.WorkDoneProgressCancelNotification;
  } });
  var protocol_callHierarchy_1 = require_protocol_callHierarchy();
  Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
    return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
  } });
  Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
    return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
  } });
  Object.defineProperty(exports, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
    return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
  } });
  var protocol_semanticTokens_1 = require_protocol_semanticTokens();
  Object.defineProperty(exports, "TokenFormat", { enumerable: true, get: function() {
    return protocol_semanticTokens_1.TokenFormat;
  } });
  Object.defineProperty(exports, "SemanticTokensRequest", { enumerable: true, get: function() {
    return protocol_semanticTokens_1.SemanticTokensRequest;
  } });
  Object.defineProperty(exports, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
    return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
  } });
  Object.defineProperty(exports, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
    return protocol_semanticTokens_1.SemanticTokensRangeRequest;
  } });
  Object.defineProperty(exports, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
    return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
  } });
  Object.defineProperty(exports, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
    return protocol_semanticTokens_1.SemanticTokensRegistrationType;
  } });
  var protocol_showDocument_1 = require_protocol_showDocument();
  Object.defineProperty(exports, "ShowDocumentRequest", { enumerable: true, get: function() {
    return protocol_showDocument_1.ShowDocumentRequest;
  } });
  var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
  Object.defineProperty(exports, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
    return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
  } });
  var protocol_fileOperations_1 = require_protocol_fileOperations();
  Object.defineProperty(exports, "FileOperationPatternKind", { enumerable: true, get: function() {
    return protocol_fileOperations_1.FileOperationPatternKind;
  } });
  Object.defineProperty(exports, "DidCreateFilesNotification", { enumerable: true, get: function() {
    return protocol_fileOperations_1.DidCreateFilesNotification;
  } });
  Object.defineProperty(exports, "WillCreateFilesRequest", { enumerable: true, get: function() {
    return protocol_fileOperations_1.WillCreateFilesRequest;
  } });
  Object.defineProperty(exports, "DidRenameFilesNotification", { enumerable: true, get: function() {
    return protocol_fileOperations_1.DidRenameFilesNotification;
  } });
  Object.defineProperty(exports, "WillRenameFilesRequest", { enumerable: true, get: function() {
    return protocol_fileOperations_1.WillRenameFilesRequest;
  } });
  Object.defineProperty(exports, "DidDeleteFilesNotification", { enumerable: true, get: function() {
    return protocol_fileOperations_1.DidDeleteFilesNotification;
  } });
  Object.defineProperty(exports, "WillDeleteFilesRequest", { enumerable: true, get: function() {
    return protocol_fileOperations_1.WillDeleteFilesRequest;
  } });
  var protocol_moniker_1 = require_protocol_moniker();
  Object.defineProperty(exports, "UniquenessLevel", { enumerable: true, get: function() {
    return protocol_moniker_1.UniquenessLevel;
  } });
  Object.defineProperty(exports, "MonikerKind", { enumerable: true, get: function() {
    return protocol_moniker_1.MonikerKind;
  } });
  Object.defineProperty(exports, "MonikerRequest", { enumerable: true, get: function() {
    return protocol_moniker_1.MonikerRequest;
  } });
  var protocol_typeHierarchy_1 = require_protocol_typeHierarchy();
  Object.defineProperty(exports, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
    return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
  } });
  Object.defineProperty(exports, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
    return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
  } });
  Object.defineProperty(exports, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
    return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
  } });
  var protocol_inlineValue_1 = require_protocol_inlineValue();
  Object.defineProperty(exports, "InlineValueRequest", { enumerable: true, get: function() {
    return protocol_inlineValue_1.InlineValueRequest;
  } });
  Object.defineProperty(exports, "InlineValueRefreshRequest", { enumerable: true, get: function() {
    return protocol_inlineValue_1.InlineValueRefreshRequest;
  } });
  var protocol_inlayHint_1 = require_protocol_inlayHint();
  Object.defineProperty(exports, "InlayHintRequest", { enumerable: true, get: function() {
    return protocol_inlayHint_1.InlayHintRequest;
  } });
  Object.defineProperty(exports, "InlayHintResolveRequest", { enumerable: true, get: function() {
    return protocol_inlayHint_1.InlayHintResolveRequest;
  } });
  Object.defineProperty(exports, "InlayHintRefreshRequest", { enumerable: true, get: function() {
    return protocol_inlayHint_1.InlayHintRefreshRequest;
  } });
  var protocol_diagnostic_1 = require_protocol_diagnostic();
  Object.defineProperty(exports, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
    return protocol_diagnostic_1.DiagnosticServerCancellationData;
  } });
  Object.defineProperty(exports, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
    return protocol_diagnostic_1.DocumentDiagnosticReportKind;
  } });
  Object.defineProperty(exports, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
    return protocol_diagnostic_1.DocumentDiagnosticRequest;
  } });
  Object.defineProperty(exports, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
    return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
  } });
  Object.defineProperty(exports, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
    return protocol_diagnostic_1.DiagnosticRefreshRequest;
  } });
  var protocol_notebook_1 = require_protocol_notebook();
  Object.defineProperty(exports, "NotebookCellKind", { enumerable: true, get: function() {
    return protocol_notebook_1.NotebookCellKind;
  } });
  Object.defineProperty(exports, "ExecutionSummary", { enumerable: true, get: function() {
    return protocol_notebook_1.ExecutionSummary;
  } });
  Object.defineProperty(exports, "NotebookCell", { enumerable: true, get: function() {
    return protocol_notebook_1.NotebookCell;
  } });
  Object.defineProperty(exports, "NotebookDocument", { enumerable: true, get: function() {
    return protocol_notebook_1.NotebookDocument;
  } });
  Object.defineProperty(exports, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
    return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
  } });
  Object.defineProperty(exports, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
    return protocol_notebook_1.DidOpenNotebookDocumentNotification;
  } });
  Object.defineProperty(exports, "NotebookCellArrayChange", { enumerable: true, get: function() {
    return protocol_notebook_1.NotebookCellArrayChange;
  } });
  Object.defineProperty(exports, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
    return protocol_notebook_1.DidChangeNotebookDocumentNotification;
  } });
  Object.defineProperty(exports, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
    return protocol_notebook_1.DidSaveNotebookDocumentNotification;
  } });
  Object.defineProperty(exports, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
    return protocol_notebook_1.DidCloseNotebookDocumentNotification;
  } });
  var protocol_inlineCompletion_1 = require_protocol_inlineCompletion();
  Object.defineProperty(exports, "InlineCompletionRequest", { enumerable: true, get: function() {
    return protocol_inlineCompletion_1.InlineCompletionRequest;
  } });
  var TextDocumentFilter;
  (function(TextDocumentFilter2) {
    function is(value) {
      const candidate = value;
      return Is.string(candidate) || (Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
    }
    TextDocumentFilter2.is = is;
  })(TextDocumentFilter || (exports.TextDocumentFilter = TextDocumentFilter = {}));
  var NotebookDocumentFilter;
  (function(NotebookDocumentFilter2) {
    function is(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
    }
    NotebookDocumentFilter2.is = is;
  })(NotebookDocumentFilter || (exports.NotebookDocumentFilter = NotebookDocumentFilter = {}));
  var NotebookCellTextDocumentFilter;
  (function(NotebookCellTextDocumentFilter2) {
    function is(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === undefined || Is.string(candidate.language));
    }
    NotebookCellTextDocumentFilter2.is = is;
  })(NotebookCellTextDocumentFilter || (exports.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));
  var DocumentSelector;
  (function(DocumentSelector2) {
    function is(value) {
      if (!Array.isArray(value)) {
        return false;
      }
      for (let elem of value) {
        if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
          return false;
        }
      }
      return true;
    }
    DocumentSelector2.is = is;
  })(DocumentSelector || (exports.DocumentSelector = DocumentSelector = {}));
  var RegistrationRequest;
  (function(RegistrationRequest2) {
    RegistrationRequest2.method = "client/registerCapability";
    RegistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
    RegistrationRequest2.type = new messages_1.ProtocolRequestType(RegistrationRequest2.method);
  })(RegistrationRequest || (exports.RegistrationRequest = RegistrationRequest = {}));
  var UnregistrationRequest;
  (function(UnregistrationRequest2) {
    UnregistrationRequest2.method = "client/unregisterCapability";
    UnregistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
    UnregistrationRequest2.type = new messages_1.ProtocolRequestType(UnregistrationRequest2.method);
  })(UnregistrationRequest || (exports.UnregistrationRequest = UnregistrationRequest = {}));
  var ResourceOperationKind;
  (function(ResourceOperationKind2) {
    ResourceOperationKind2.Create = "create";
    ResourceOperationKind2.Rename = "rename";
    ResourceOperationKind2.Delete = "delete";
  })(ResourceOperationKind || (exports.ResourceOperationKind = ResourceOperationKind = {}));
  var FailureHandlingKind;
  (function(FailureHandlingKind2) {
    FailureHandlingKind2.Abort = "abort";
    FailureHandlingKind2.Transactional = "transactional";
    FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
    FailureHandlingKind2.Undo = "undo";
  })(FailureHandlingKind || (exports.FailureHandlingKind = FailureHandlingKind = {}));
  var PositionEncodingKind;
  (function(PositionEncodingKind2) {
    PositionEncodingKind2.UTF8 = "utf-8";
    PositionEncodingKind2.UTF16 = "utf-16";
    PositionEncodingKind2.UTF32 = "utf-32";
  })(PositionEncodingKind || (exports.PositionEncodingKind = PositionEncodingKind = {}));
  var StaticRegistrationOptions;
  (function(StaticRegistrationOptions2) {
    function hasId(value) {
      const candidate = value;
      return candidate && Is.string(candidate.id) && candidate.id.length > 0;
    }
    StaticRegistrationOptions2.hasId = hasId;
  })(StaticRegistrationOptions || (exports.StaticRegistrationOptions = StaticRegistrationOptions = {}));
  var TextDocumentRegistrationOptions;
  (function(TextDocumentRegistrationOptions2) {
    function is(value) {
      const candidate = value;
      return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
    }
    TextDocumentRegistrationOptions2.is = is;
  })(TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));
  var WorkDoneProgressOptions;
  (function(WorkDoneProgressOptions2) {
    function is(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
    }
    WorkDoneProgressOptions2.is = is;
    function hasWorkDoneProgress(value) {
      const candidate = value;
      return candidate && Is.boolean(candidate.workDoneProgress);
    }
    WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
  })(WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));
  var InitializeRequest;
  (function(InitializeRequest2) {
    InitializeRequest2.method = "initialize";
    InitializeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    InitializeRequest2.type = new messages_1.ProtocolRequestType(InitializeRequest2.method);
  })(InitializeRequest || (exports.InitializeRequest = InitializeRequest = {}));
  var InitializeErrorCodes;
  (function(InitializeErrorCodes2) {
    InitializeErrorCodes2.unknownProtocolVersion = 1;
  })(InitializeErrorCodes || (exports.InitializeErrorCodes = InitializeErrorCodes = {}));
  var InitializedNotification;
  (function(InitializedNotification2) {
    InitializedNotification2.method = "initialized";
    InitializedNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
    InitializedNotification2.type = new messages_1.ProtocolNotificationType(InitializedNotification2.method);
  })(InitializedNotification || (exports.InitializedNotification = InitializedNotification = {}));
  var ShutdownRequest;
  (function(ShutdownRequest2) {
    ShutdownRequest2.method = "shutdown";
    ShutdownRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    ShutdownRequest2.type = new messages_1.ProtocolRequestType0(ShutdownRequest2.method);
  })(ShutdownRequest || (exports.ShutdownRequest = ShutdownRequest = {}));
  var ExitNotification;
  (function(ExitNotification2) {
    ExitNotification2.method = "exit";
    ExitNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
    ExitNotification2.type = new messages_1.ProtocolNotificationType0(ExitNotification2.method);
  })(ExitNotification || (exports.ExitNotification = ExitNotification = {}));
  var DidChangeConfigurationNotification;
  (function(DidChangeConfigurationNotification2) {
    DidChangeConfigurationNotification2.method = "workspace/didChangeConfiguration";
    DidChangeConfigurationNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification2.method);
  })(DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = DidChangeConfigurationNotification = {}));
  var MessageType;
  (function(MessageType2) {
    MessageType2.Error = 1;
    MessageType2.Warning = 2;
    MessageType2.Info = 3;
    MessageType2.Log = 4;
    MessageType2.Debug = 5;
  })(MessageType || (exports.MessageType = MessageType = {}));
  var ShowMessageNotification;
  (function(ShowMessageNotification2) {
    ShowMessageNotification2.method = "window/showMessage";
    ShowMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
    ShowMessageNotification2.type = new messages_1.ProtocolNotificationType(ShowMessageNotification2.method);
  })(ShowMessageNotification || (exports.ShowMessageNotification = ShowMessageNotification = {}));
  var ShowMessageRequest;
  (function(ShowMessageRequest2) {
    ShowMessageRequest2.method = "window/showMessageRequest";
    ShowMessageRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
    ShowMessageRequest2.type = new messages_1.ProtocolRequestType(ShowMessageRequest2.method);
  })(ShowMessageRequest || (exports.ShowMessageRequest = ShowMessageRequest = {}));
  var LogMessageNotification;
  (function(LogMessageNotification2) {
    LogMessageNotification2.method = "window/logMessage";
    LogMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
    LogMessageNotification2.type = new messages_1.ProtocolNotificationType(LogMessageNotification2.method);
  })(LogMessageNotification || (exports.LogMessageNotification = LogMessageNotification = {}));
  var TelemetryEventNotification;
  (function(TelemetryEventNotification2) {
    TelemetryEventNotification2.method = "telemetry/event";
    TelemetryEventNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
    TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification2.method);
  })(TelemetryEventNotification || (exports.TelemetryEventNotification = TelemetryEventNotification = {}));
  var TextDocumentSyncKind;
  (function(TextDocumentSyncKind2) {
    TextDocumentSyncKind2.None = 0;
    TextDocumentSyncKind2.Full = 1;
    TextDocumentSyncKind2.Incremental = 2;
  })(TextDocumentSyncKind || (exports.TextDocumentSyncKind = TextDocumentSyncKind = {}));
  var DidOpenTextDocumentNotification;
  (function(DidOpenTextDocumentNotification2) {
    DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
    DidOpenTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
    DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
  })(DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));
  var TextDocumentContentChangeEvent;
  (function(TextDocumentContentChangeEvent2) {
    function isIncremental(event) {
      let candidate = event;
      return candidate !== undefined && candidate !== null && typeof candidate.text === "string" && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === "number");
    }
    TextDocumentContentChangeEvent2.isIncremental = isIncremental;
    function isFull(event) {
      let candidate = event;
      return candidate !== undefined && candidate !== null && typeof candidate.text === "string" && candidate.range === undefined && candidate.rangeLength === undefined;
    }
    TextDocumentContentChangeEvent2.isFull = isFull;
  })(TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));
  var DidChangeTextDocumentNotification;
  (function(DidChangeTextDocumentNotification2) {
    DidChangeTextDocumentNotification2.method = "textDocument/didChange";
    DidChangeTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
  })(DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));
  var DidCloseTextDocumentNotification;
  (function(DidCloseTextDocumentNotification2) {
    DidCloseTextDocumentNotification2.method = "textDocument/didClose";
    DidCloseTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
    DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
  })(DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));
  var DidSaveTextDocumentNotification;
  (function(DidSaveTextDocumentNotification2) {
    DidSaveTextDocumentNotification2.method = "textDocument/didSave";
    DidSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
    DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
  })(DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));
  var TextDocumentSaveReason;
  (function(TextDocumentSaveReason2) {
    TextDocumentSaveReason2.Manual = 1;
    TextDocumentSaveReason2.AfterDelay = 2;
    TextDocumentSaveReason2.FocusOut = 3;
  })(TextDocumentSaveReason || (exports.TextDocumentSaveReason = TextDocumentSaveReason = {}));
  var WillSaveTextDocumentNotification;
  (function(WillSaveTextDocumentNotification2) {
    WillSaveTextDocumentNotification2.method = "textDocument/willSave";
    WillSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
    WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
  })(WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));
  var WillSaveTextDocumentWaitUntilRequest;
  (function(WillSaveTextDocumentWaitUntilRequest2) {
    WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
    WillSaveTextDocumentWaitUntilRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
  })(WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));
  var DidChangeWatchedFilesNotification;
  (function(DidChangeWatchedFilesNotification2) {
    DidChangeWatchedFilesNotification2.method = "workspace/didChangeWatchedFiles";
    DidChangeWatchedFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification2.method);
  })(DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification = {}));
  var FileChangeType;
  (function(FileChangeType2) {
    FileChangeType2.Created = 1;
    FileChangeType2.Changed = 2;
    FileChangeType2.Deleted = 3;
  })(FileChangeType || (exports.FileChangeType = FileChangeType = {}));
  var RelativePattern;
  (function(RelativePattern2) {
    function is(value) {
      const candidate = value;
      return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
    }
    RelativePattern2.is = is;
  })(RelativePattern || (exports.RelativePattern = RelativePattern = {}));
  var WatchKind;
  (function(WatchKind2) {
    WatchKind2.Create = 1;
    WatchKind2.Change = 2;
    WatchKind2.Delete = 4;
  })(WatchKind || (exports.WatchKind = WatchKind = {}));
  var PublishDiagnosticsNotification;
  (function(PublishDiagnosticsNotification2) {
    PublishDiagnosticsNotification2.method = "textDocument/publishDiagnostics";
    PublishDiagnosticsNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
    PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification2.method);
  })(PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));
  var CompletionTriggerKind;
  (function(CompletionTriggerKind2) {
    CompletionTriggerKind2.Invoked = 1;
    CompletionTriggerKind2.TriggerCharacter = 2;
    CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
  })(CompletionTriggerKind || (exports.CompletionTriggerKind = CompletionTriggerKind = {}));
  var CompletionRequest;
  (function(CompletionRequest2) {
    CompletionRequest2.method = "textDocument/completion";
    CompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
  })(CompletionRequest || (exports.CompletionRequest = CompletionRequest = {}));
  var CompletionResolveRequest;
  (function(CompletionResolveRequest2) {
    CompletionResolveRequest2.method = "completionItem/resolve";
    CompletionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
  })(CompletionResolveRequest || (exports.CompletionResolveRequest = CompletionResolveRequest = {}));
  var HoverRequest;
  (function(HoverRequest2) {
    HoverRequest2.method = "textDocument/hover";
    HoverRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
  })(HoverRequest || (exports.HoverRequest = HoverRequest = {}));
  var SignatureHelpTriggerKind;
  (function(SignatureHelpTriggerKind2) {
    SignatureHelpTriggerKind2.Invoked = 1;
    SignatureHelpTriggerKind2.TriggerCharacter = 2;
    SignatureHelpTriggerKind2.ContentChange = 3;
  })(SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
  var SignatureHelpRequest;
  (function(SignatureHelpRequest2) {
    SignatureHelpRequest2.method = "textDocument/signatureHelp";
    SignatureHelpRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
  })(SignatureHelpRequest || (exports.SignatureHelpRequest = SignatureHelpRequest = {}));
  var DefinitionRequest;
  (function(DefinitionRequest2) {
    DefinitionRequest2.method = "textDocument/definition";
    DefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
  })(DefinitionRequest || (exports.DefinitionRequest = DefinitionRequest = {}));
  var ReferencesRequest;
  (function(ReferencesRequest2) {
    ReferencesRequest2.method = "textDocument/references";
    ReferencesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
  })(ReferencesRequest || (exports.ReferencesRequest = ReferencesRequest = {}));
  var DocumentHighlightRequest;
  (function(DocumentHighlightRequest2) {
    DocumentHighlightRequest2.method = "textDocument/documentHighlight";
    DocumentHighlightRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
  })(DocumentHighlightRequest || (exports.DocumentHighlightRequest = DocumentHighlightRequest = {}));
  var DocumentSymbolRequest;
  (function(DocumentSymbolRequest2) {
    DocumentSymbolRequest2.method = "textDocument/documentSymbol";
    DocumentSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
  })(DocumentSymbolRequest || (exports.DocumentSymbolRequest = DocumentSymbolRequest = {}));
  var CodeActionRequest;
  (function(CodeActionRequest2) {
    CodeActionRequest2.method = "textDocument/codeAction";
    CodeActionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
  })(CodeActionRequest || (exports.CodeActionRequest = CodeActionRequest = {}));
  var CodeActionResolveRequest;
  (function(CodeActionResolveRequest2) {
    CodeActionResolveRequest2.method = "codeAction/resolve";
    CodeActionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
  })(CodeActionResolveRequest || (exports.CodeActionResolveRequest = CodeActionResolveRequest = {}));
  var WorkspaceSymbolRequest;
  (function(WorkspaceSymbolRequest2) {
    WorkspaceSymbolRequest2.method = "workspace/symbol";
    WorkspaceSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
  })(WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));
  var WorkspaceSymbolResolveRequest;
  (function(WorkspaceSymbolResolveRequest2) {
    WorkspaceSymbolResolveRequest2.method = "workspaceSymbol/resolve";
    WorkspaceSymbolResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    WorkspaceSymbolResolveRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest2.method);
  })(WorkspaceSymbolResolveRequest || (exports.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));
  var CodeLensRequest;
  (function(CodeLensRequest2) {
    CodeLensRequest2.method = "textDocument/codeLens";
    CodeLensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
  })(CodeLensRequest || (exports.CodeLensRequest = CodeLensRequest = {}));
  var CodeLensResolveRequest;
  (function(CodeLensResolveRequest2) {
    CodeLensResolveRequest2.method = "codeLens/resolve";
    CodeLensResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
  })(CodeLensResolveRequest || (exports.CodeLensResolveRequest = CodeLensResolveRequest = {}));
  var CodeLensRefreshRequest;
  (function(CodeLensRefreshRequest2) {
    CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
    CodeLensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
    CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
  })(CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));
  var DocumentLinkRequest;
  (function(DocumentLinkRequest2) {
    DocumentLinkRequest2.method = "textDocument/documentLink";
    DocumentLinkRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
  })(DocumentLinkRequest || (exports.DocumentLinkRequest = DocumentLinkRequest = {}));
  var DocumentLinkResolveRequest;
  (function(DocumentLinkResolveRequest2) {
    DocumentLinkResolveRequest2.method = "documentLink/resolve";
    DocumentLinkResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
  })(DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));
  var DocumentFormattingRequest;
  (function(DocumentFormattingRequest2) {
    DocumentFormattingRequest2.method = "textDocument/formatting";
    DocumentFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
  })(DocumentFormattingRequest || (exports.DocumentFormattingRequest = DocumentFormattingRequest = {}));
  var DocumentRangeFormattingRequest;
  (function(DocumentRangeFormattingRequest2) {
    DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
    DocumentRangeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
  })(DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));
  var DocumentRangesFormattingRequest;
  (function(DocumentRangesFormattingRequest2) {
    DocumentRangesFormattingRequest2.method = "textDocument/rangesFormatting";
    DocumentRangesFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentRangesFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest2.method);
  })(DocumentRangesFormattingRequest || (exports.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));
  var DocumentOnTypeFormattingRequest;
  (function(DocumentOnTypeFormattingRequest2) {
    DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
    DocumentOnTypeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
  })(DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));
  var PrepareSupportDefaultBehavior;
  (function(PrepareSupportDefaultBehavior2) {
    PrepareSupportDefaultBehavior2.Identifier = 1;
  })(PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));
  var RenameRequest;
  (function(RenameRequest2) {
    RenameRequest2.method = "textDocument/rename";
    RenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
  })(RenameRequest || (exports.RenameRequest = RenameRequest = {}));
  var PrepareRenameRequest;
  (function(PrepareRenameRequest2) {
    PrepareRenameRequest2.method = "textDocument/prepareRename";
    PrepareRenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
  })(PrepareRenameRequest || (exports.PrepareRenameRequest = PrepareRenameRequest = {}));
  var ExecuteCommandRequest;
  (function(ExecuteCommandRequest2) {
    ExecuteCommandRequest2.method = "workspace/executeCommand";
    ExecuteCommandRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
    ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest2.method);
  })(ExecuteCommandRequest || (exports.ExecuteCommandRequest = ExecuteCommandRequest = {}));
  var ApplyWorkspaceEditRequest;
  (function(ApplyWorkspaceEditRequest2) {
    ApplyWorkspaceEditRequest2.method = "workspace/applyEdit";
    ApplyWorkspaceEditRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
    ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
  })(ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {}));
});

// node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createProtocolConnection = undefined;
  var vscode_jsonrpc_1 = require_main();
  function createProtocolConnection(input, output, logger, options) {
    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
      options = { connectionStrategy: options };
    }
    return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
  }
  exports.createProtocolConnection = createProtocolConnection;
});

// node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LSPErrorCodes = exports.createProtocolConnection = undefined;
  __exportStar(require_main(), exports);
  __exportStar(require_main2(), exports);
  __exportStar(require_messages2(), exports);
  __exportStar(require_protocol(), exports);
  var connection_1 = require_connection2();
  Object.defineProperty(exports, "createProtocolConnection", { enumerable: true, get: function() {
    return connection_1.createProtocolConnection;
  } });
  var LSPErrorCodes;
  (function(LSPErrorCodes2) {
    LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
    LSPErrorCodes2.RequestFailed = -32803;
    LSPErrorCodes2.ServerCancelled = -32802;
    LSPErrorCodes2.ContentModified = -32801;
    LSPErrorCodes2.RequestCancelled = -32800;
    LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
  })(LSPErrorCodes || (exports.LSPErrorCodes = LSPErrorCodes = {}));
});

// node_modules/vscode-languageserver-protocol/lib/node/main.js
var require_main3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createProtocolConnection = undefined;
  var node_1 = require_main();
  __exportStar(require_main(), exports);
  __exportStar(require_api2(), exports);
  function createProtocolConnection(input, output, logger, options) {
    return (0, node_1.createMessageConnection)(input, output, logger, options);
  }
  exports.createProtocolConnection = createProtocolConnection;
});

// node_modules/vscode-languageserver/lib/common/utils/uuid.js
var require_uuid = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.generateUuid = exports.parse = exports.isUUID = exports.v4 = exports.empty = undefined;

  class ValueUUID {
    constructor(_value) {
      this._value = _value;
    }
    asHex() {
      return this._value;
    }
    equals(other) {
      return this.asHex() === other.asHex();
    }
  }

  class V4UUID extends ValueUUID {
    static _oneOf(array) {
      return array[Math.floor(array.length * Math.random())];
    }
    static _randomHex() {
      return V4UUID._oneOf(V4UUID._chars);
    }
    constructor() {
      super([
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        "-",
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        "-",
        "4",
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        "-",
        V4UUID._oneOf(V4UUID._timeHighBits),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        "-",
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex(),
        V4UUID._randomHex()
      ].join(""));
    }
  }
  V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
  V4UUID._timeHighBits = ["8", "9", "a", "b"];
  exports.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
  function v4() {
    return new V4UUID;
  }
  exports.v4 = v4;
  var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  function isUUID(value) {
    return _UUIDPattern.test(value);
  }
  exports.isUUID = isUUID;
  function parse(value) {
    if (!isUUID(value)) {
      throw new Error("invalid uuid");
    }
    return new ValueUUID(value);
  }
  exports.parse = parse;
  function generateUuid() {
    return v4().asHex();
  }
  exports.generateUuid = generateUuid;
});

// node_modules/vscode-languageserver/lib/common/progress.js
var require_progress = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.attachPartialResult = exports.ProgressFeature = exports.attachWorkDone = undefined;
  var vscode_languageserver_protocol_1 = require_main3();
  var uuid_1 = require_uuid();

  class WorkDoneProgressReporterImpl {
    constructor(_connection, _token) {
      this._connection = _connection;
      this._token = _token;
      WorkDoneProgressReporterImpl.Instances.set(this._token, this);
    }
    begin(title, percentage, message, cancellable) {
      let param = {
        kind: "begin",
        title,
        percentage,
        message,
        cancellable
      };
      this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
    }
    report(arg0, arg1) {
      let param = {
        kind: "report"
      };
      if (typeof arg0 === "number") {
        param.percentage = arg0;
        if (arg1 !== undefined) {
          param.message = arg1;
        }
      } else {
        param.message = arg0;
      }
      this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
    }
    done() {
      WorkDoneProgressReporterImpl.Instances.delete(this._token);
      this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: "end" });
    }
  }
  WorkDoneProgressReporterImpl.Instances = new Map;

  class WorkDoneProgressServerReporterImpl extends WorkDoneProgressReporterImpl {
    constructor(connection, token) {
      super(connection, token);
      this._source = new vscode_languageserver_protocol_1.CancellationTokenSource;
    }
    get token() {
      return this._source.token;
    }
    done() {
      this._source.dispose();
      super.done();
    }
    cancel() {
      this._source.cancel();
    }
  }

  class NullProgressReporter {
    constructor() {
    }
    begin() {
    }
    report() {
    }
    done() {
    }
  }

  class NullProgressServerReporter extends NullProgressReporter {
    constructor() {
      super();
      this._source = new vscode_languageserver_protocol_1.CancellationTokenSource;
    }
    get token() {
      return this._source.token;
    }
    done() {
      this._source.dispose();
    }
    cancel() {
      this._source.cancel();
    }
  }
  function attachWorkDone(connection, params) {
    if (params === undefined || params.workDoneToken === undefined) {
      return new NullProgressReporter;
    }
    const token = params.workDoneToken;
    delete params.workDoneToken;
    return new WorkDoneProgressReporterImpl(connection, token);
  }
  exports.attachWorkDone = attachWorkDone;
  var ProgressFeature = (Base) => {
    return class extends Base {
      constructor() {
        super();
        this._progressSupported = false;
      }
      initialize(capabilities) {
        super.initialize(capabilities);
        if (capabilities?.window?.workDoneProgress === true) {
          this._progressSupported = true;
          this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
            let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
            if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
              progress.cancel();
            }
          });
        }
      }
      attachWorkDoneProgress(token) {
        if (token === undefined) {
          return new NullProgressReporter;
        } else {
          return new WorkDoneProgressReporterImpl(this.connection, token);
        }
      }
      createWorkDoneProgress() {
        if (this._progressSupported) {
          const token = (0, uuid_1.generateUuid)();
          return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
            const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
            return result;
          });
        } else {
          return Promise.resolve(new NullProgressServerReporter);
        }
      }
    };
  };
  exports.ProgressFeature = ProgressFeature;
  var ResultProgress;
  (function(ResultProgress2) {
    ResultProgress2.type = new vscode_languageserver_protocol_1.ProgressType;
  })(ResultProgress || (ResultProgress = {}));

  class ResultProgressReporterImpl {
    constructor(_connection, _token) {
      this._connection = _connection;
      this._token = _token;
    }
    report(data) {
      this._connection.sendProgress(ResultProgress.type, this._token, data);
    }
  }
  function attachPartialResult(connection, params) {
    if (params === undefined || params.partialResultToken === undefined) {
      return;
    }
    const token = params.partialResultToken;
    delete params.partialResultToken;
    return new ResultProgressReporterImpl(connection, token);
  }
  exports.attachPartialResult = attachPartialResult;
});

// node_modules/vscode-languageserver/lib/common/configuration.js
var require_configuration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConfigurationFeature = undefined;
  var vscode_languageserver_protocol_1 = require_main3();
  var Is = require_is();
  var ConfigurationFeature = (Base) => {
    return class extends Base {
      getConfiguration(arg) {
        if (!arg) {
          return this._getConfiguration({});
        } else if (Is.string(arg)) {
          return this._getConfiguration({ section: arg });
        } else {
          return this._getConfiguration(arg);
        }
      }
      _getConfiguration(arg) {
        let params = {
          items: Array.isArray(arg) ? arg : [arg]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
          if (Array.isArray(result)) {
            return Array.isArray(arg) ? result : result[0];
          } else {
            return Array.isArray(arg) ? [] : null;
          }
        });
      }
    };
  };
  exports.ConfigurationFeature = ConfigurationFeature;
});

// node_modules/vscode-languageserver/lib/common/workspaceFolder.js
var require_workspaceFolder = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WorkspaceFoldersFeature = undefined;
  var vscode_languageserver_protocol_1 = require_main3();
  var WorkspaceFoldersFeature = (Base) => {
    return class extends Base {
      constructor() {
        super();
        this._notificationIsAutoRegistered = false;
      }
      initialize(capabilities) {
        super.initialize(capabilities);
        let workspaceCapabilities = capabilities.workspace;
        if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
          this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter;
          this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
            this._onDidChangeWorkspaceFolders.fire(params.event);
          });
        }
      }
      fillServerCapabilities(capabilities) {
        super.fillServerCapabilities(capabilities);
        const changeNotifications = capabilities.workspace?.workspaceFolders?.changeNotifications;
        this._notificationIsAutoRegistered = changeNotifications === true || typeof changeNotifications === "string";
      }
      getWorkspaceFolders() {
        return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
      }
      get onDidChangeWorkspaceFolders() {
        if (!this._onDidChangeWorkspaceFolders) {
          throw new Error("Client doesn't support sending workspace folder change events.");
        }
        if (!this._notificationIsAutoRegistered && !this._unregistration) {
          this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
        }
        return this._onDidChangeWorkspaceFolders.event;
      }
    };
  };
  exports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
});

// node_modules/vscode-languageserver/lib/common/callHierarchy.js
var require_callHierarchy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CallHierarchyFeature = undefined;
  var vscode_languageserver_protocol_1 = require_main3();
  var CallHierarchyFeature = (Base) => {
    return class extends Base {
      get callHierarchy() {
        return {
          onPrepare: (handler) => {
            return this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {
              return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);
            });
          },
          onIncomingCalls: (handler) => {
            const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;
            return this.connection.onRequest(type, (params, cancel) => {
              return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
            });
          },
          onOutgoingCalls: (handler) => {
            const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;
            return this.connection.onRequest(type, (params, cancel) => {
              return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
            });
          }
        };
      }
    };
  };
  exports.CallHierarchyFeature = CallHierarchyFeature;
});

// node_modules/vscode-languageserver/lib/common/semanticTokens.js
var require_semanticTokens = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SemanticTokensBuilder = exports.SemanticTokensDiff = exports.SemanticTokensFeature = undefined;
  var vscode_languageserver_protocol_1 = require_main3();
  var SemanticTokensFeature = (Base) => {
    return class extends Base {
      get semanticTokens() {
        return {
          refresh: () => {
            return this.connection.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type);
          },
          on: (handler) => {
            const type = vscode_languageserver_protocol_1.SemanticTokensRequest.type;
            return this.connection.onRequest(type, (params, cancel) => {
              return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
            });
          },
          onDelta: (handler) => {
            const type = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;
            return this.connection.onRequest(type, (params, cancel) => {
              return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
            });
          },
          onRange: (handler) => {
            const type = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;
            return this.connection.onRequest(type, (params, cancel) => {
              return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
            });
          }
        };
      }
    };
  };
  exports.SemanticTokensFeature = SemanticTokensFeature;

  class SemanticTokensDiff {
    constructor(originalSequence, modifiedSequence) {
      this.originalSequence = originalSequence;
      this.modifiedSequence = modifiedSequence;
    }
    computeDiff() {
      const originalLength = this.originalSequence.length;
      const modifiedLength = this.modifiedSequence.length;
      let startIndex = 0;
      while (startIndex < modifiedLength && startIndex < originalLength && this.originalSequence[startIndex] === this.modifiedSequence[startIndex]) {
        startIndex++;
      }
      if (startIndex < modifiedLength && startIndex < originalLength) {
        let originalEndIndex = originalLength - 1;
        let modifiedEndIndex = modifiedLength - 1;
        while (originalEndIndex >= startIndex && modifiedEndIndex >= startIndex && this.originalSequence[originalEndIndex] === this.modifiedSequence[modifiedEndIndex]) {
          originalEndIndex--;
          modifiedEndIndex--;
        }
        if (originalEndIndex < startIndex || modifiedEndIndex < startIndex) {
          originalEndIndex++;
          modifiedEndIndex++;
        }
        const deleteCount = originalEndIndex - startIndex + 1;
        const newData = this.modifiedSequence.slice(startIndex, modifiedEndIndex + 1);
        if (newData.length === 1 && newData[0] === this.originalSequence[originalEndIndex]) {
          return [
            { start: startIndex, deleteCount: deleteCount - 1 }
          ];
        } else {
          return [
            { start: startIndex, deleteCount, data: newData }
          ];
        }
      } else if (startIndex < modifiedLength) {
        return [
          { start: startIndex, deleteCount: 0, data: this.modifiedSequence.slice(startIndex) }
        ];
      } else if (startIndex < originalLength) {
        return [
          { start: startIndex, deleteCount: originalLength - startIndex }
        ];
      } else {
        return [];
      }
    }
  }
  exports.SemanticTokensDiff = SemanticTokensDiff;

  class SemanticTokensBuilder {
    constructor() {
      this._prevData = undefined;
      this.initialize();
    }
    initialize() {
      this._id = Date.now();
      this._prevLine = 0;
      this._prevChar = 0;
      this._data = [];
      this._dataLen = 0;
    }
    push(line, char, length, tokenType, tokenModifiers) {
      let pushLine = line;
      let pushChar = char;
      if (this._dataLen > 0) {
        pushLine -= this._prevLine;
        if (pushLine === 0) {
          pushChar -= this._prevChar;
        }
      }
      this._data[this._dataLen++] = pushLine;
      this._data[this._dataLen++] = pushChar;
      this._data[this._dataLen++] = length;
      this._data[this._dataLen++] = tokenType;
      this._data[this._dataLen++] = tokenModifiers;
      this._prevLine = line;
      this._prevChar = char;
    }
    get id() {
      return this._id.toString();
    }
    previousResult(id) {
      if (this.id === id) {
        this._prevData = this._data;
      }
      this.initialize();
    }
    build() {
      this._prevData = undefined;
      return {
        resultId: this.id,
        data: this._data
      };
    }
    canBuildEdits() {
      return this._prevData !== undefined;
    }
    buildEdits() {
      if (this._prevData !== undefined) {
        return {
          resultId: this.id,
          edits: new SemanticTokensDiff(this._prevData, this._data).computeDiff()
        };
      } else {
        return this.build();
      }
    }
  }
  exports.SemanticTokensBuilder = SemanticTokensBuilder;
});

// node_modules/vscode-languageserver/lib/common/showDocument.js
var require_showDocument = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ShowDocumentFeature = undefined;
  var vscode_languageserver_protocol_1 = require_main3();
  var ShowDocumentFeature = (Base) => {
    return class extends Base {
      showDocument(params) {
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);
      }
    };
  };
  exports.ShowDocumentFeature = ShowDocumentFeature;
});

// node_modules/vscode-languageserver/lib/common/fileOperations.js
var require_fileOperations = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FileOperationsFeature = undefined;
  var vscode_languageserver_protocol_1 = require_main3();
  var FileOperationsFeature = (Base) => {
    return class extends Base {
      onDidCreateFiles(handler) {
        return this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {
          handler(params);
        });
      }
      onDidRenameFiles(handler) {
        return this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {
          handler(params);
        });
      }
      onDidDeleteFiles(handler) {
        return this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {
          handler(params);
        });
      }
      onWillCreateFiles(handler) {
        return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {
          return handler(params, cancel);
        });
      }
      onWillRenameFiles(handler) {
        return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {
          return handler(params, cancel);
        });
      }
      onWillDeleteFiles(handler) {
        return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {
          return handler(params, cancel);
        });
      }
    };
  };
  exports.FileOperationsFeature = FileOperationsFeature;
});

// node_modules/vscode-languageserver/lib/common/linkedEditingRange.js
var require_linkedEditingRange = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LinkedEditingRangeFeature = undefined;
  var vscode_languageserver_protocol_1 = require_main3();
  var LinkedEditingRangeFeature = (Base) => {
    return class extends Base {
      onLinkedEditingRange(handler) {
        return this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);
        });
      }
    };
  };
  exports.LinkedEditingRangeFeature = LinkedEditingRangeFeature;
});

// node_modules/vscode-languageserver/lib/common/typeHierarchy.js
var require_typeHierarchy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeHierarchyFeature = undefined;
  var vscode_languageserver_protocol_1 = require_main3();
  var TypeHierarchyFeature = (Base) => {
    return class extends Base {
      get typeHierarchy() {
        return {
          onPrepare: (handler) => {
            return this.connection.onRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, (params, cancel) => {
              return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);
            });
          },
          onSupertypes: (handler) => {
            const type = vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type;
            return this.connection.onRequest(type, (params, cancel) => {
              return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
            });
          },
          onSubtypes: (handler) => {
            const type = vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type;
            return this.connection.onRequest(type, (params, cancel) => {
              return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
            });
          }
        };
      }
    };
  };
  exports.TypeHierarchyFeature = TypeHierarchyFeature;
});

// node_modules/vscode-languageserver/lib/common/inlineValue.js
var require_inlineValue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InlineValueFeature = undefined;
  var vscode_languageserver_protocol_1 = require_main3();
  var InlineValueFeature = (Base) => {
    return class extends Base {
      get inlineValue() {
        return {
          refresh: () => {
            return this.connection.sendRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type);
          },
          on: (handler) => {
            return this.connection.onRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, (params, cancel) => {
              return handler(params, cancel, this.attachWorkDoneProgress(params));
            });
          }
        };
      }
    };
  };
  exports.InlineValueFeature = InlineValueFeature;
});

// node_modules/vscode-languageserver/lib/common/foldingRange.js
var require_foldingRange = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FoldingRangeFeature = undefined;
  var vscode_languageserver_protocol_1 = require_main3();
  var FoldingRangeFeature = (Base) => {
    return class extends Base {
      get foldingRange() {
        return {
          refresh: () => {
            return this.connection.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRefreshRequest.type);
          },
          on: (handler) => {
            const type = vscode_languageserver_protocol_1.FoldingRangeRequest.type;
            return this.connection.onRequest(type, (params, cancel) => {
              return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
            });
          }
        };
      }
    };
  };
  exports.FoldingRangeFeature = FoldingRangeFeature;
});

// node_modules/vscode-languageserver/lib/common/inlayHint.js
var require_inlayHint = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InlayHintFeature = undefined;
  var vscode_languageserver_protocol_1 = require_main3();
  var InlayHintFeature = (Base) => {
    return class extends Base {
      get inlayHint() {
        return {
          refresh: () => {
            return this.connection.sendRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type);
          },
          on: (handler) => {
            return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, (params, cancel) => {
              return handler(params, cancel, this.attachWorkDoneProgress(params));
            });
          },
          resolve: (handler) => {
            return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, (params, cancel) => {
              return handler(params, cancel);
            });
          }
        };
      }
    };
  };
  exports.InlayHintFeature = InlayHintFeature;
});

// node_modules/vscode-languageserver/lib/common/diagnostic.js
var require_diagnostic = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiagnosticFeature = undefined;
  var vscode_languageserver_protocol_1 = require_main3();
  var DiagnosticFeature = (Base) => {
    return class extends Base {
      get diagnostics() {
        return {
          refresh: () => {
            return this.connection.sendRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type);
          },
          on: (handler) => {
            return this.connection.onRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, (params, cancel) => {
              return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.partialResult, params));
            });
          },
          onWorkspace: (handler) => {
            return this.connection.onRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, (params, cancel) => {
              return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, params));
            });
          }
        };
      }
    };
  };
  exports.DiagnosticFeature = DiagnosticFeature;
});

// node_modules/vscode-languageserver/lib/common/textDocuments.js
var require_textDocuments = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TextDocuments = undefined;
  var vscode_languageserver_protocol_1 = require_main3();

  class TextDocuments {
    constructor(configuration) {
      this._configuration = configuration;
      this._syncedDocuments = new Map;
      this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter;
      this._onDidOpen = new vscode_languageserver_protocol_1.Emitter;
      this._onDidClose = new vscode_languageserver_protocol_1.Emitter;
      this._onDidSave = new vscode_languageserver_protocol_1.Emitter;
      this._onWillSave = new vscode_languageserver_protocol_1.Emitter;
    }
    get onDidOpen() {
      return this._onDidOpen.event;
    }
    get onDidChangeContent() {
      return this._onDidChangeContent.event;
    }
    get onWillSave() {
      return this._onWillSave.event;
    }
    onWillSaveWaitUntil(handler) {
      this._willSaveWaitUntil = handler;
    }
    get onDidSave() {
      return this._onDidSave.event;
    }
    get onDidClose() {
      return this._onDidClose.event;
    }
    get(uri) {
      return this._syncedDocuments.get(uri);
    }
    all() {
      return Array.from(this._syncedDocuments.values());
    }
    keys() {
      return Array.from(this._syncedDocuments.keys());
    }
    listen(connection) {
      connection.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;
      const disposables = [];
      disposables.push(connection.onDidOpenTextDocument((event) => {
        const td = event.textDocument;
        const document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
        this._syncedDocuments.set(td.uri, document);
        const toFire = Object.freeze({ document });
        this._onDidOpen.fire(toFire);
        this._onDidChangeContent.fire(toFire);
      }));
      disposables.push(connection.onDidChangeTextDocument((event) => {
        const td = event.textDocument;
        const changes = event.contentChanges;
        if (changes.length === 0) {
          return;
        }
        const { version } = td;
        if (version === null || version === undefined) {
          throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
        }
        let syncedDocument = this._syncedDocuments.get(td.uri);
        if (syncedDocument !== undefined) {
          syncedDocument = this._configuration.update(syncedDocument, changes, version);
          this._syncedDocuments.set(td.uri, syncedDocument);
          this._onDidChangeContent.fire(Object.freeze({ document: syncedDocument }));
        }
      }));
      disposables.push(connection.onDidCloseTextDocument((event) => {
        let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
        if (syncedDocument !== undefined) {
          this._syncedDocuments.delete(event.textDocument.uri);
          this._onDidClose.fire(Object.freeze({ document: syncedDocument }));
        }
      }));
      disposables.push(connection.onWillSaveTextDocument((event) => {
        let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
        if (syncedDocument !== undefined) {
          this._onWillSave.fire(Object.freeze({ document: syncedDocument, reason: event.reason }));
        }
      }));
      disposables.push(connection.onWillSaveTextDocumentWaitUntil((event, token) => {
        let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
        if (syncedDocument !== undefined && this._willSaveWaitUntil) {
          return this._willSaveWaitUntil(Object.freeze({ document: syncedDocument, reason: event.reason }), token);
        } else {
          return [];
        }
      }));
      disposables.push(connection.onDidSaveTextDocument((event) => {
        let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
        if (syncedDocument !== undefined) {
          this._onDidSave.fire(Object.freeze({ document: syncedDocument }));
        }
      }));
      return vscode_languageserver_protocol_1.Disposable.create(() => {
        disposables.forEach((disposable) => disposable.dispose());
      });
    }
  }
  exports.TextDocuments = TextDocuments;
});

// node_modules/vscode-languageserver/lib/common/notebook.js
var require_notebook = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NotebookDocuments = exports.NotebookSyncFeature = undefined;
  var vscode_languageserver_protocol_1 = require_main3();
  var textDocuments_1 = require_textDocuments();
  var NotebookSyncFeature = (Base) => {
    return class extends Base {
      get synchronization() {
        return {
          onDidOpenNotebookDocument: (handler) => {
            return this.connection.onNotification(vscode_languageserver_protocol_1.DidOpenNotebookDocumentNotification.type, (params) => {
              handler(params);
            });
          },
          onDidChangeNotebookDocument: (handler) => {
            return this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeNotebookDocumentNotification.type, (params) => {
              handler(params);
            });
          },
          onDidSaveNotebookDocument: (handler) => {
            return this.connection.onNotification(vscode_languageserver_protocol_1.DidSaveNotebookDocumentNotification.type, (params) => {
              handler(params);
            });
          },
          onDidCloseNotebookDocument: (handler) => {
            return this.connection.onNotification(vscode_languageserver_protocol_1.DidCloseNotebookDocumentNotification.type, (params) => {
              handler(params);
            });
          }
        };
      }
    };
  };
  exports.NotebookSyncFeature = NotebookSyncFeature;

  class CellTextDocumentConnection {
    onDidOpenTextDocument(handler) {
      this.openHandler = handler;
      return vscode_languageserver_protocol_1.Disposable.create(() => {
        this.openHandler = undefined;
      });
    }
    openTextDocument(params) {
      this.openHandler && this.openHandler(params);
    }
    onDidChangeTextDocument(handler) {
      this.changeHandler = handler;
      return vscode_languageserver_protocol_1.Disposable.create(() => {
        this.changeHandler = handler;
      });
    }
    changeTextDocument(params) {
      this.changeHandler && this.changeHandler(params);
    }
    onDidCloseTextDocument(handler) {
      this.closeHandler = handler;
      return vscode_languageserver_protocol_1.Disposable.create(() => {
        this.closeHandler = undefined;
      });
    }
    closeTextDocument(params) {
      this.closeHandler && this.closeHandler(params);
    }
    onWillSaveTextDocument() {
      return CellTextDocumentConnection.NULL_DISPOSE;
    }
    onWillSaveTextDocumentWaitUntil() {
      return CellTextDocumentConnection.NULL_DISPOSE;
    }
    onDidSaveTextDocument() {
      return CellTextDocumentConnection.NULL_DISPOSE;
    }
  }
  CellTextDocumentConnection.NULL_DISPOSE = Object.freeze({ dispose: () => {
  } });

  class NotebookDocuments {
    constructor(configurationOrTextDocuments) {
      if (configurationOrTextDocuments instanceof textDocuments_1.TextDocuments) {
        this._cellTextDocuments = configurationOrTextDocuments;
      } else {
        this._cellTextDocuments = new textDocuments_1.TextDocuments(configurationOrTextDocuments);
      }
      this.notebookDocuments = new Map;
      this.notebookCellMap = new Map;
      this._onDidOpen = new vscode_languageserver_protocol_1.Emitter;
      this._onDidChange = new vscode_languageserver_protocol_1.Emitter;
      this._onDidSave = new vscode_languageserver_protocol_1.Emitter;
      this._onDidClose = new vscode_languageserver_protocol_1.Emitter;
    }
    get cellTextDocuments() {
      return this._cellTextDocuments;
    }
    getCellTextDocument(cell) {
      return this._cellTextDocuments.get(cell.document);
    }
    getNotebookDocument(uri) {
      return this.notebookDocuments.get(uri);
    }
    getNotebookCell(uri) {
      const value = this.notebookCellMap.get(uri);
      return value && value[0];
    }
    findNotebookDocumentForCell(cell) {
      const key = typeof cell === "string" ? cell : cell.document;
      const value = this.notebookCellMap.get(key);
      return value && value[1];
    }
    get onDidOpen() {
      return this._onDidOpen.event;
    }
    get onDidSave() {
      return this._onDidSave.event;
    }
    get onDidChange() {
      return this._onDidChange.event;
    }
    get onDidClose() {
      return this._onDidClose.event;
    }
    listen(connection) {
      const cellTextDocumentConnection = new CellTextDocumentConnection;
      const disposables = [];
      disposables.push(this.cellTextDocuments.listen(cellTextDocumentConnection));
      disposables.push(connection.notebooks.synchronization.onDidOpenNotebookDocument((params) => {
        this.notebookDocuments.set(params.notebookDocument.uri, params.notebookDocument);
        for (const cellTextDocument of params.cellTextDocuments) {
          cellTextDocumentConnection.openTextDocument({ textDocument: cellTextDocument });
        }
        this.updateCellMap(params.notebookDocument);
        this._onDidOpen.fire(params.notebookDocument);
      }));
      disposables.push(connection.notebooks.synchronization.onDidChangeNotebookDocument((params) => {
        const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
        if (notebookDocument === undefined) {
          return;
        }
        notebookDocument.version = params.notebookDocument.version;
        const oldMetadata = notebookDocument.metadata;
        let metadataChanged = false;
        const change = params.change;
        if (change.metadata !== undefined) {
          metadataChanged = true;
          notebookDocument.metadata = change.metadata;
        }
        const opened = [];
        const closed = [];
        const data = [];
        const text = [];
        if (change.cells !== undefined) {
          const changedCells = change.cells;
          if (changedCells.structure !== undefined) {
            const array = changedCells.structure.array;
            notebookDocument.cells.splice(array.start, array.deleteCount, ...array.cells !== undefined ? array.cells : []);
            if (changedCells.structure.didOpen !== undefined) {
              for (const open of changedCells.structure.didOpen) {
                cellTextDocumentConnection.openTextDocument({ textDocument: open });
                opened.push(open.uri);
              }
            }
            if (changedCells.structure.didClose) {
              for (const close of changedCells.structure.didClose) {
                cellTextDocumentConnection.closeTextDocument({ textDocument: close });
                closed.push(close.uri);
              }
            }
          }
          if (changedCells.data !== undefined) {
            const cellUpdates = new Map(changedCells.data.map((cell) => [cell.document, cell]));
            for (let i = 0;i <= notebookDocument.cells.length; i++) {
              const change2 = cellUpdates.get(notebookDocument.cells[i].document);
              if (change2 !== undefined) {
                const old = notebookDocument.cells.splice(i, 1, change2);
                data.push({ old: old[0], new: change2 });
                cellUpdates.delete(change2.document);
                if (cellUpdates.size === 0) {
                  break;
                }
              }
            }
          }
          if (changedCells.textContent !== undefined) {
            for (const cellTextDocument of changedCells.textContent) {
              cellTextDocumentConnection.changeTextDocument({ textDocument: cellTextDocument.document, contentChanges: cellTextDocument.changes });
              text.push(cellTextDocument.document.uri);
            }
          }
        }
        this.updateCellMap(notebookDocument);
        const changeEvent = { notebookDocument };
        if (metadataChanged) {
          changeEvent.metadata = { old: oldMetadata, new: notebookDocument.metadata };
        }
        const added = [];
        for (const open of opened) {
          added.push(this.getNotebookCell(open));
        }
        const removed = [];
        for (const close of closed) {
          removed.push(this.getNotebookCell(close));
        }
        const textContent = [];
        for (const change2 of text) {
          textContent.push(this.getNotebookCell(change2));
        }
        if (added.length > 0 || removed.length > 0 || data.length > 0 || textContent.length > 0) {
          changeEvent.cells = { added, removed, changed: { data, textContent } };
        }
        if (changeEvent.metadata !== undefined || changeEvent.cells !== undefined) {
          this._onDidChange.fire(changeEvent);
        }
      }));
      disposables.push(connection.notebooks.synchronization.onDidSaveNotebookDocument((params) => {
        const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
        if (notebookDocument === undefined) {
          return;
        }
        this._onDidSave.fire(notebookDocument);
      }));
      disposables.push(connection.notebooks.synchronization.onDidCloseNotebookDocument((params) => {
        const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
        if (notebookDocument === undefined) {
          return;
        }
        this._onDidClose.fire(notebookDocument);
        for (const cellTextDocument of params.cellTextDocuments) {
          cellTextDocumentConnection.closeTextDocument({ textDocument: cellTextDocument });
        }
        this.notebookDocuments.delete(params.notebookDocument.uri);
        for (const cell of notebookDocument.cells) {
          this.notebookCellMap.delete(cell.document);
        }
      }));
      return vscode_languageserver_protocol_1.Disposable.create(() => {
        disposables.forEach((disposable) => disposable.dispose());
      });
    }
    updateCellMap(notebookDocument) {
      for (const cell of notebookDocument.cells) {
        this.notebookCellMap.set(cell.document, [cell, notebookDocument]);
      }
    }
  }
  exports.NotebookDocuments = NotebookDocuments;
});

// node_modules/vscode-languageserver/lib/common/moniker.js
var require_moniker = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MonikerFeature = undefined;
  var vscode_languageserver_protocol_1 = require_main3();
  var MonikerFeature = (Base) => {
    return class extends Base {
      get moniker() {
        return {
          on: (handler) => {
            const type = vscode_languageserver_protocol_1.MonikerRequest.type;
            return this.connection.onRequest(type, (params, cancel) => {
              return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
            });
          }
        };
      }
    };
  };
  exports.MonikerFeature = MonikerFeature;
});

// node_modules/vscode-languageserver/lib/common/server.js
var require_server = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createConnection = exports.combineFeatures = exports.combineNotebooksFeatures = exports.combineLanguagesFeatures = exports.combineWorkspaceFeatures = exports.combineWindowFeatures = exports.combineClientFeatures = exports.combineTracerFeatures = exports.combineTelemetryFeatures = exports.combineConsoleFeatures = exports._NotebooksImpl = exports._LanguagesImpl = exports.BulkUnregistration = exports.BulkRegistration = exports.ErrorMessageTracker = undefined;
  var vscode_languageserver_protocol_1 = require_main3();
  var Is = require_is();
  var UUID = require_uuid();
  var progress_1 = require_progress();
  var configuration_1 = require_configuration();
  var workspaceFolder_1 = require_workspaceFolder();
  var callHierarchy_1 = require_callHierarchy();
  var semanticTokens_1 = require_semanticTokens();
  var showDocument_1 = require_showDocument();
  var fileOperations_1 = require_fileOperations();
  var linkedEditingRange_1 = require_linkedEditingRange();
  var typeHierarchy_1 = require_typeHierarchy();
  var inlineValue_1 = require_inlineValue();
  var foldingRange_1 = require_foldingRange();
  var inlayHint_1 = require_inlayHint();
  var diagnostic_1 = require_diagnostic();
  var notebook_1 = require_notebook();
  var moniker_1 = require_moniker();
  function null2Undefined(value) {
    if (value === null) {
      return;
    }
    return value;
  }

  class ErrorMessageTracker {
    constructor() {
      this._messages = Object.create(null);
    }
    add(message) {
      let count = this._messages[message];
      if (!count) {
        count = 0;
      }
      count++;
      this._messages[message] = count;
    }
    sendErrors(connection) {
      Object.keys(this._messages).forEach((message) => {
        connection.window.showErrorMessage(message);
      });
    }
  }
  exports.ErrorMessageTracker = ErrorMessageTracker;

  class RemoteConsoleImpl {
    constructor() {
    }
    rawAttach(connection) {
      this._rawConnection = connection;
    }
    attach(connection) {
      this._connection = connection;
    }
    get connection() {
      if (!this._connection) {
        throw new Error("Remote is not attached to a connection yet.");
      }
      return this._connection;
    }
    fillServerCapabilities(_capabilities) {
    }
    initialize(_capabilities) {
    }
    error(message) {
      this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
    }
    warn(message) {
      this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
    }
    info(message) {
      this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
    }
    log(message) {
      this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
    }
    debug(message) {
      this.send(vscode_languageserver_protocol_1.MessageType.Debug, message);
    }
    send(type, message) {
      if (this._rawConnection) {
        this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message }).catch(() => {
          (0, vscode_languageserver_protocol_1.RAL)().console.error(`Sending log message failed`);
        });
      }
    }
  }

  class _RemoteWindowImpl {
    constructor() {
    }
    attach(connection) {
      this._connection = connection;
    }
    get connection() {
      if (!this._connection) {
        throw new Error("Remote is not attached to a connection yet.");
      }
      return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    showErrorMessage(message, ...actions) {
      let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
      return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
    showWarningMessage(message, ...actions) {
      let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
      return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
    showInformationMessage(message, ...actions) {
      let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
      return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
  }
  var RemoteWindowImpl = (0, showDocument_1.ShowDocumentFeature)((0, progress_1.ProgressFeature)(_RemoteWindowImpl));
  var BulkRegistration;
  (function(BulkRegistration2) {
    function create() {
      return new BulkRegistrationImpl;
    }
    BulkRegistration2.create = create;
  })(BulkRegistration || (exports.BulkRegistration = BulkRegistration = {}));

  class BulkRegistrationImpl {
    constructor() {
      this._registrations = [];
      this._registered = new Set;
    }
    add(type, registerOptions) {
      const method = Is.string(type) ? type : type.method;
      if (this._registered.has(method)) {
        throw new Error(`${method} is already added to this registration`);
      }
      const id = UUID.generateUuid();
      this._registrations.push({
        id,
        method,
        registerOptions: registerOptions || {}
      });
      this._registered.add(method);
    }
    asRegistrationParams() {
      return {
        registrations: this._registrations
      };
    }
  }
  var BulkUnregistration;
  (function(BulkUnregistration2) {
    function create() {
      return new BulkUnregistrationImpl(undefined, []);
    }
    BulkUnregistration2.create = create;
  })(BulkUnregistration || (exports.BulkUnregistration = BulkUnregistration = {}));

  class BulkUnregistrationImpl {
    constructor(_connection, unregistrations) {
      this._connection = _connection;
      this._unregistrations = new Map;
      unregistrations.forEach((unregistration) => {
        this._unregistrations.set(unregistration.method, unregistration);
      });
    }
    get isAttached() {
      return !!this._connection;
    }
    attach(connection) {
      this._connection = connection;
    }
    add(unregistration) {
      this._unregistrations.set(unregistration.method, unregistration);
    }
    dispose() {
      let unregistrations = [];
      for (let unregistration of this._unregistrations.values()) {
        unregistrations.push(unregistration);
      }
      let params = {
        unregisterations: unregistrations
      };
      this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
        this._connection.console.info(`Bulk unregistration failed.`);
      });
    }
    disposeSingle(arg) {
      const method = Is.string(arg) ? arg : arg.method;
      const unregistration = this._unregistrations.get(method);
      if (!unregistration) {
        return false;
      }
      let params = {
        unregisterations: [unregistration]
      };
      this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
        this._unregistrations.delete(method);
      }, (_error) => {
        this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
      });
      return true;
    }
  }

  class RemoteClientImpl {
    attach(connection) {
      this._connection = connection;
    }
    get connection() {
      if (!this._connection) {
        throw new Error("Remote is not attached to a connection yet.");
      }
      return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
      if (typeOrRegistrations instanceof BulkRegistrationImpl) {
        return this.registerMany(typeOrRegistrations);
      } else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
        return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
      } else {
        return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
      }
    }
    registerSingle1(unregistration, type, registerOptions) {
      const method = Is.string(type) ? type : type.method;
      const id = UUID.generateUuid();
      let params = {
        registrations: [{ id, method, registerOptions: registerOptions || {} }]
      };
      if (!unregistration.isAttached) {
        unregistration.attach(this.connection);
      }
      return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
        unregistration.add({ id, method });
        return unregistration;
      }, (_error) => {
        this.connection.console.info(`Registering request handler for ${method} failed.`);
        return Promise.reject(_error);
      });
    }
    registerSingle2(type, registerOptions) {
      const method = Is.string(type) ? type : type.method;
      const id = UUID.generateUuid();
      let params = {
        registrations: [{ id, method, registerOptions: registerOptions || {} }]
      };
      return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.unregisterSingle(id, method).catch(() => {
            this.connection.console.info(`Un-registering capability with id ${id} failed.`);
          });
        });
      }, (_error) => {
        this.connection.console.info(`Registering request handler for ${method} failed.`);
        return Promise.reject(_error);
      });
    }
    unregisterSingle(id, method) {
      let params = {
        unregisterations: [{ id, method }]
      };
      return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
        this.connection.console.info(`Un-registering request handler for ${id} failed.`);
      });
    }
    registerMany(registrations) {
      let params = registrations.asRegistrationParams();
      return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
        return new BulkUnregistrationImpl(this._connection, params.registrations.map((registration) => {
          return { id: registration.id, method: registration.method };
        }));
      }, (_error) => {
        this.connection.console.info(`Bulk registration failed.`);
        return Promise.reject(_error);
      });
    }
  }

  class _RemoteWorkspaceImpl {
    constructor() {
    }
    attach(connection) {
      this._connection = connection;
    }
    get connection() {
      if (!this._connection) {
        throw new Error("Remote is not attached to a connection yet.");
      }
      return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    applyEdit(paramOrEdit) {
      function isApplyWorkspaceEditParams(value) {
        return value && !!value.edit;
      }
      let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
      return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
    }
  }
  var RemoteWorkspaceImpl = (0, fileOperations_1.FileOperationsFeature)((0, workspaceFolder_1.WorkspaceFoldersFeature)((0, configuration_1.ConfigurationFeature)(_RemoteWorkspaceImpl)));

  class TracerImpl {
    constructor() {
      this._trace = vscode_languageserver_protocol_1.Trace.Off;
    }
    attach(connection) {
      this._connection = connection;
    }
    get connection() {
      if (!this._connection) {
        throw new Error("Remote is not attached to a connection yet.");
      }
      return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    set trace(value) {
      this._trace = value;
    }
    log(message, verbose) {
      if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
        return;
      }
      this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
        message,
        verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : undefined
      }).catch(() => {
      });
    }
  }

  class TelemetryImpl {
    constructor() {
    }
    attach(connection) {
      this._connection = connection;
    }
    get connection() {
      if (!this._connection) {
        throw new Error("Remote is not attached to a connection yet.");
      }
      return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    logEvent(data) {
      this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data).catch(() => {
        this.connection.console.log(`Sending TelemetryEventNotification failed`);
      });
    }
  }

  class _LanguagesImpl {
    constructor() {
    }
    attach(connection) {
      this._connection = connection;
    }
    get connection() {
      if (!this._connection) {
        throw new Error("Remote is not attached to a connection yet.");
      }
      return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    attachWorkDoneProgress(params) {
      return (0, progress_1.attachWorkDone)(this.connection, params);
    }
    attachPartialResultProgress(_type, params) {
      return (0, progress_1.attachPartialResult)(this.connection, params);
    }
  }
  exports._LanguagesImpl = _LanguagesImpl;
  var LanguagesImpl = (0, foldingRange_1.FoldingRangeFeature)((0, moniker_1.MonikerFeature)((0, diagnostic_1.DiagnosticFeature)((0, inlayHint_1.InlayHintFeature)((0, inlineValue_1.InlineValueFeature)((0, typeHierarchy_1.TypeHierarchyFeature)((0, linkedEditingRange_1.LinkedEditingRangeFeature)((0, semanticTokens_1.SemanticTokensFeature)((0, callHierarchy_1.CallHierarchyFeature)(_LanguagesImpl)))))))));

  class _NotebooksImpl {
    constructor() {
    }
    attach(connection) {
      this._connection = connection;
    }
    get connection() {
      if (!this._connection) {
        throw new Error("Remote is not attached to a connection yet.");
      }
      return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    attachWorkDoneProgress(params) {
      return (0, progress_1.attachWorkDone)(this.connection, params);
    }
    attachPartialResultProgress(_type, params) {
      return (0, progress_1.attachPartialResult)(this.connection, params);
    }
  }
  exports._NotebooksImpl = _NotebooksImpl;
  var NotebooksImpl = (0, notebook_1.NotebookSyncFeature)(_NotebooksImpl);
  function combineConsoleFeatures(one, two) {
    return function(Base) {
      return two(one(Base));
    };
  }
  exports.combineConsoleFeatures = combineConsoleFeatures;
  function combineTelemetryFeatures(one, two) {
    return function(Base) {
      return two(one(Base));
    };
  }
  exports.combineTelemetryFeatures = combineTelemetryFeatures;
  function combineTracerFeatures(one, two) {
    return function(Base) {
      return two(one(Base));
    };
  }
  exports.combineTracerFeatures = combineTracerFeatures;
  function combineClientFeatures(one, two) {
    return function(Base) {
      return two(one(Base));
    };
  }
  exports.combineClientFeatures = combineClientFeatures;
  function combineWindowFeatures(one, two) {
    return function(Base) {
      return two(one(Base));
    };
  }
  exports.combineWindowFeatures = combineWindowFeatures;
  function combineWorkspaceFeatures(one, two) {
    return function(Base) {
      return two(one(Base));
    };
  }
  exports.combineWorkspaceFeatures = combineWorkspaceFeatures;
  function combineLanguagesFeatures(one, two) {
    return function(Base) {
      return two(one(Base));
    };
  }
  exports.combineLanguagesFeatures = combineLanguagesFeatures;
  function combineNotebooksFeatures(one, two) {
    return function(Base) {
      return two(one(Base));
    };
  }
  exports.combineNotebooksFeatures = combineNotebooksFeatures;
  function combineFeatures(one, two) {
    function combine(one2, two2, func) {
      if (one2 && two2) {
        return func(one2, two2);
      } else if (one2) {
        return one2;
      } else {
        return two2;
      }
    }
    let result = {
      __brand: "features",
      console: combine(one.console, two.console, combineConsoleFeatures),
      tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
      telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
      client: combine(one.client, two.client, combineClientFeatures),
      window: combine(one.window, two.window, combineWindowFeatures),
      workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures),
      languages: combine(one.languages, two.languages, combineLanguagesFeatures),
      notebooks: combine(one.notebooks, two.notebooks, combineNotebooksFeatures)
    };
    return result;
  }
  exports.combineFeatures = combineFeatures;
  function createConnection(connectionFactory, watchDog, factories) {
    const logger = factories && factories.console ? new (factories.console(RemoteConsoleImpl)) : new RemoteConsoleImpl;
    const connection = connectionFactory(logger);
    logger.rawAttach(connection);
    const tracer = factories && factories.tracer ? new (factories.tracer(TracerImpl)) : new TracerImpl;
    const telemetry = factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl)) : new TelemetryImpl;
    const client = factories && factories.client ? new (factories.client(RemoteClientImpl)) : new RemoteClientImpl;
    const remoteWindow = factories && factories.window ? new (factories.window(RemoteWindowImpl)) : new RemoteWindowImpl;
    const workspace = factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl)) : new RemoteWorkspaceImpl;
    const languages = factories && factories.languages ? new (factories.languages(LanguagesImpl)) : new LanguagesImpl;
    const notebooks = factories && factories.notebooks ? new (factories.notebooks(NotebooksImpl)) : new NotebooksImpl;
    const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages, notebooks];
    function asPromise(value) {
      if (value instanceof Promise) {
        return value;
      } else if (Is.thenable(value)) {
        return new Promise((resolve, reject) => {
          value.then((resolved) => resolve(resolved), (error) => reject(error));
        });
      } else {
        return Promise.resolve(value);
      }
    }
    let shutdownHandler = undefined;
    let initializeHandler = undefined;
    let exitHandler = undefined;
    let protocolConnection = {
      listen: () => connection.listen(),
      sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),
      onRequest: (type, handler) => connection.onRequest(type, handler),
      sendNotification: (type, param) => {
        const method = Is.string(type) ? type : type.method;
        return connection.sendNotification(method, param);
      },
      onNotification: (type, handler) => connection.onNotification(type, handler),
      onProgress: connection.onProgress,
      sendProgress: connection.sendProgress,
      onInitialize: (handler) => {
        initializeHandler = handler;
        return {
          dispose: () => {
            initializeHandler = undefined;
          }
        };
      },
      onInitialized: (handler) => connection.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
      onShutdown: (handler) => {
        shutdownHandler = handler;
        return {
          dispose: () => {
            shutdownHandler = undefined;
          }
        };
      },
      onExit: (handler) => {
        exitHandler = handler;
        return {
          dispose: () => {
            exitHandler = undefined;
          }
        };
      },
      get console() {
        return logger;
      },
      get telemetry() {
        return telemetry;
      },
      get tracer() {
        return tracer;
      },
      get client() {
        return client;
      },
      get window() {
        return remoteWindow;
      },
      get workspace() {
        return workspace;
      },
      get languages() {
        return languages;
      },
      get notebooks() {
        return notebooks;
      },
      onDidChangeConfiguration: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
      onDidChangeWatchedFiles: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
      __textDocumentSync: undefined,
      onDidOpenTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
      onDidChangeTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
      onDidCloseTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
      onWillSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
      onWillSaveTextDocumentWaitUntil: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
      onDidSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
      sendDiagnostics: (params) => connection.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
      onHover: (handler) => connection.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
        return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
      }),
      onCompletion: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
        return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
      }),
      onCompletionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
      onSignatureHelp: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
        return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
      }),
      onDeclaration: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
        return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
      }),
      onDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
        return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
      }),
      onTypeDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
        return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
      }),
      onImplementation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
        return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
      }),
      onReferences: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
        return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
      }),
      onDocumentHighlight: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
        return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
      }),
      onDocumentSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
        return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
      }),
      onWorkspaceSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
        return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
      }),
      onWorkspaceSymbolResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, handler),
      onCodeAction: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
        return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
      }),
      onCodeActionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
        return handler(params, cancel);
      }),
      onCodeLens: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
        return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
      }),
      onCodeLensResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
        return handler(params, cancel);
      }),
      onDocumentFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
        return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
      }),
      onDocumentRangeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
        return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
      }),
      onDocumentOnTypeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
        return handler(params, cancel);
      }),
      onRenameRequest: (handler) => connection.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
        return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
      }),
      onPrepareRename: (handler) => connection.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
        return handler(params, cancel);
      }),
      onDocumentLinks: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
        return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
      }),
      onDocumentLinkResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
        return handler(params, cancel);
      }),
      onDocumentColor: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
        return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
      }),
      onColorPresentation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
        return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
      }),
      onFoldingRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
        return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
      }),
      onSelectionRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
        return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
      }),
      onExecuteCommand: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
        return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);
      }),
      dispose: () => connection.dispose()
    };
    for (let remote of allRemotes) {
      remote.attach(protocolConnection);
    }
    connection.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
      watchDog.initialize(params);
      if (Is.string(params.trace)) {
        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
      }
      for (let remote of allRemotes) {
        remote.initialize(params.capabilities);
      }
      if (initializeHandler) {
        let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, (0, progress_1.attachWorkDone)(connection, params), undefined);
        return asPromise(result).then((value) => {
          if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
            return value;
          }
          let result2 = value;
          if (!result2) {
            result2 = { capabilities: {} };
          }
          let capabilities = result2.capabilities;
          if (!capabilities) {
            capabilities = {};
            result2.capabilities = capabilities;
          }
          if (capabilities.textDocumentSync === undefined || capabilities.textDocumentSync === null) {
            capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
          } else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {
            capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
          }
          for (let remote of allRemotes) {
            remote.fillServerCapabilities(capabilities);
          }
          return result2;
        });
      } else {
        let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
        for (let remote of allRemotes) {
          remote.fillServerCapabilities(result.capabilities);
        }
        return result;
      }
    });
    connection.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
      watchDog.shutdownReceived = true;
      if (shutdownHandler) {
        return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
      } else {
        return;
      }
    });
    connection.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
      try {
        if (exitHandler) {
          exitHandler();
        }
      } finally {
        if (watchDog.shutdownReceived) {
          watchDog.exit(0);
        } else {
          watchDog.exit(1);
        }
      }
    });
    connection.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
      tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
    });
    return protocolConnection;
  }
  exports.createConnection = createConnection;
});

// node_modules/vscode-languageserver/lib/node/files.js
var require_files = __commonJS((exports) => {
  var __filename = "D:\\cspell-lsp\\node_modules\\vscode-languageserver\\lib\\node\\files.js";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveModulePath = exports.FileSystem = exports.resolveGlobalYarnPath = exports.resolveGlobalNodePath = exports.resolve = exports.uriToFilePath = undefined;
  var url = __require("url");
  var path = __require("path");
  var fs = __require("fs");
  var child_process_1 = __require("child_process");
  function uriToFilePath(uri) {
    let parsed = url.parse(uri);
    if (parsed.protocol !== "file:" || !parsed.path) {
      return;
    }
    let segments = parsed.path.split("/");
    for (var i = 0, len = segments.length;i < len; i++) {
      segments[i] = decodeURIComponent(segments[i]);
    }
    if (process.platform === "win32" && segments.length > 1) {
      let first = segments[0];
      let second = segments[1];
      if (first.length === 0 && second.length > 1 && second[1] === ":") {
        segments.shift();
      }
    }
    return path.normalize(segments.join("/"));
  }
  exports.uriToFilePath = uriToFilePath;
  function isWindows() {
    return process.platform === "win32";
  }
  function resolve(moduleName, nodePath, cwd, tracer) {
    const nodePathKey = "NODE_PATH";
    const app = [
      "var p = process;",
      "p.on('message',function(m){",
      "if(m.c==='e'){",
      "p.exit(0);",
      "}",
      "else if(m.c==='rs'){",
      "try{",
      "var r=require.resolve(m.a);",
      "p.send({c:'r',s:true,r:r});",
      "}",
      "catch(err){",
      "p.send({c:'r',s:false});",
      "}",
      "}",
      "});"
    ].join("");
    return new Promise((resolve2, reject) => {
      let env = process.env;
      let newEnv = Object.create(null);
      Object.keys(env).forEach((key) => newEnv[key] = env[key]);
      if (nodePath && fs.existsSync(nodePath)) {
        if (newEnv[nodePathKey]) {
          newEnv[nodePathKey] = nodePath + path.delimiter + newEnv[nodePathKey];
        } else {
          newEnv[nodePathKey] = nodePath;
        }
        if (tracer) {
          tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);
        }
      }
      newEnv["ELECTRON_RUN_AS_NODE"] = "1";
      try {
        let cp = (0, child_process_1.fork)("", [], {
          cwd,
          env: newEnv,
          execArgv: ["-e", app]
        });
        if (cp.pid === undefined) {
          reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));
          return;
        }
        cp.on("error", (error) => {
          reject(error);
        });
        cp.on("message", (message2) => {
          if (message2.c === "r") {
            cp.send({ c: "e" });
            if (message2.s) {
              resolve2(message2.r);
            } else {
              reject(new Error(`Failed to resolve module: ${moduleName}`));
            }
          }
        });
        let message = {
          c: "rs",
          a: moduleName
        };
        cp.send(message);
      } catch (error) {
        reject(error);
      }
    });
  }
  exports.resolve = resolve;
  function resolveGlobalNodePath(tracer) {
    let npmCommand = "npm";
    const env = Object.create(null);
    Object.keys(process.env).forEach((key) => env[key] = process.env[key]);
    env["NO_UPDATE_NOTIFIER"] = "true";
    const options = {
      encoding: "utf8",
      env
    };
    if (isWindows()) {
      npmCommand = "npm.cmd";
      options.shell = true;
    }
    let handler = () => {
    };
    try {
      process.on("SIGPIPE", handler);
      let stdout = (0, child_process_1.spawnSync)(npmCommand, ["config", "get", "prefix"], options).stdout;
      if (!stdout) {
        if (tracer) {
          tracer(`'npm config get prefix' didn't return a value.`);
        }
        return;
      }
      let prefix = stdout.trim();
      if (tracer) {
        tracer(`'npm config get prefix' value is: ${prefix}`);
      }
      if (prefix.length > 0) {
        if (isWindows()) {
          return path.join(prefix, "node_modules");
        } else {
          return path.join(prefix, "lib", "node_modules");
        }
      }
      return;
    } catch (err) {
      return;
    } finally {
      process.removeListener("SIGPIPE", handler);
    }
  }
  exports.resolveGlobalNodePath = resolveGlobalNodePath;
  function resolveGlobalYarnPath(tracer) {
    let yarnCommand = "yarn";
    let options = {
      encoding: "utf8"
    };
    if (isWindows()) {
      yarnCommand = "yarn.cmd";
      options.shell = true;
    }
    let handler = () => {
    };
    try {
      process.on("SIGPIPE", handler);
      let results = (0, child_process_1.spawnSync)(yarnCommand, ["global", "dir", "--json"], options);
      let stdout = results.stdout;
      if (!stdout) {
        if (tracer) {
          tracer(`'yarn global dir' didn't return a value.`);
          if (results.stderr) {
            tracer(results.stderr);
          }
        }
        return;
      }
      let lines = stdout.trim().split(/\r?\n/);
      for (let line of lines) {
        try {
          let yarn = JSON.parse(line);
          if (yarn.type === "log") {
            return path.join(yarn.data, "node_modules");
          }
        } catch (e) {
        }
      }
      return;
    } catch (err) {
      return;
    } finally {
      process.removeListener("SIGPIPE", handler);
    }
  }
  exports.resolveGlobalYarnPath = resolveGlobalYarnPath;
  var FileSystem;
  (function(FileSystem2) {
    let _isCaseSensitive = undefined;
    function isCaseSensitive() {
      if (_isCaseSensitive !== undefined) {
        return _isCaseSensitive;
      }
      if (process.platform === "win32") {
        _isCaseSensitive = false;
      } else {
        _isCaseSensitive = !fs.existsSync(__filename.toUpperCase()) || !fs.existsSync(__filename.toLowerCase());
      }
      return _isCaseSensitive;
    }
    FileSystem2.isCaseSensitive = isCaseSensitive;
    function isParent(parent, child) {
      if (isCaseSensitive()) {
        return path.normalize(child).indexOf(path.normalize(parent)) === 0;
      } else {
        return path.normalize(child).toLowerCase().indexOf(path.normalize(parent).toLowerCase()) === 0;
      }
    }
    FileSystem2.isParent = isParent;
  })(FileSystem || (exports.FileSystem = FileSystem = {}));
  function resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {
    if (nodePath) {
      if (!path.isAbsolute(nodePath)) {
        nodePath = path.join(workspaceRoot, nodePath);
      }
      return resolve(moduleName, nodePath, nodePath, tracer).then((value) => {
        if (FileSystem.isParent(nodePath, value)) {
          return value;
        } else {
          return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));
        }
      }).then(undefined, (_error) => {
        return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
      });
    } else {
      return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
    }
  }
  exports.resolveModulePath = resolveModulePath;
});

// node_modules/vscode-languageserver/lib/common/inlineCompletion.proposed.js
var require_inlineCompletion_proposed = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InlineCompletionFeature = undefined;
  var vscode_languageserver_protocol_1 = require_main3();
  var InlineCompletionFeature = (Base) => {
    return class extends Base {
      get inlineCompletion() {
        return {
          on: (handler) => {
            return this.connection.onRequest(vscode_languageserver_protocol_1.InlineCompletionRequest.type, (params, cancel) => {
              return handler(params, cancel, this.attachWorkDoneProgress(params));
            });
          }
        };
      }
    };
  };
  exports.InlineCompletionFeature = InlineCompletionFeature;
});

// node_modules/vscode-languageserver/lib/common/api.js
var require_api3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProposedFeatures = exports.NotebookDocuments = exports.TextDocuments = exports.SemanticTokensBuilder = undefined;
  var semanticTokens_1 = require_semanticTokens();
  Object.defineProperty(exports, "SemanticTokensBuilder", { enumerable: true, get: function() {
    return semanticTokens_1.SemanticTokensBuilder;
  } });
  var ic = require_inlineCompletion_proposed();
  __exportStar(require_main3(), exports);
  var textDocuments_1 = require_textDocuments();
  Object.defineProperty(exports, "TextDocuments", { enumerable: true, get: function() {
    return textDocuments_1.TextDocuments;
  } });
  var notebook_1 = require_notebook();
  Object.defineProperty(exports, "NotebookDocuments", { enumerable: true, get: function() {
    return notebook_1.NotebookDocuments;
  } });
  __exportStar(require_server(), exports);
  var ProposedFeatures;
  (function(ProposedFeatures2) {
    ProposedFeatures2.all = {
      __brand: "features",
      languages: ic.InlineCompletionFeature
    };
  })(ProposedFeatures || (exports.ProposedFeatures = ProposedFeatures = {}));
});

// node_modules/vscode-languageserver/lib/node/main.js
var require_main4 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createConnection = exports.Files = undefined;
  var node_util_1 = __require("node:util");
  var Is = require_is();
  var server_1 = require_server();
  var fm = require_files();
  var node_1 = require_main3();
  __exportStar(require_main3(), exports);
  __exportStar(require_api3(), exports);
  var Files;
  (function(Files2) {
    Files2.uriToFilePath = fm.uriToFilePath;
    Files2.resolveGlobalNodePath = fm.resolveGlobalNodePath;
    Files2.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;
    Files2.resolve = fm.resolve;
    Files2.resolveModulePath = fm.resolveModulePath;
  })(Files || (exports.Files = Files = {}));
  var _protocolConnection;
  function endProtocolConnection() {
    if (_protocolConnection === undefined) {
      return;
    }
    try {
      _protocolConnection.end();
    } catch (_err) {
    }
  }
  var _shutdownReceived = false;
  var exitTimer = undefined;
  function setupExitTimer() {
    const argName = "--clientProcessId";
    function runTimer(value) {
      try {
        let processId = parseInt(value);
        if (!isNaN(processId)) {
          exitTimer = setInterval(() => {
            try {
              process.kill(processId, 0);
            } catch (ex) {
              endProtocolConnection();
              process.exit(_shutdownReceived ? 0 : 1);
            }
          }, 3000);
        }
      } catch (e) {
      }
    }
    for (let i = 2;i < process.argv.length; i++) {
      let arg = process.argv[i];
      if (arg === argName && i + 1 < process.argv.length) {
        runTimer(process.argv[i + 1]);
        return;
      } else {
        let args = arg.split("=");
        if (args[0] === argName) {
          runTimer(args[1]);
        }
      }
    }
  }
  setupExitTimer();
  var watchDog = {
    initialize: (params) => {
      const processId = params.processId;
      if (Is.number(processId) && exitTimer === undefined) {
        setInterval(() => {
          try {
            process.kill(processId, 0);
          } catch (ex) {
            process.exit(_shutdownReceived ? 0 : 1);
          }
        }, 3000);
      }
    },
    get shutdownReceived() {
      return _shutdownReceived;
    },
    set shutdownReceived(value) {
      _shutdownReceived = value;
    },
    exit: (code) => {
      endProtocolConnection();
      process.exit(code);
    }
  };
  function createConnection(arg1, arg2, arg3, arg4) {
    let factories;
    let input;
    let output;
    let options;
    if (arg1 !== undefined && arg1.__brand === "features") {
      factories = arg1;
      arg1 = arg2;
      arg2 = arg3;
      arg3 = arg4;
    }
    if (node_1.ConnectionStrategy.is(arg1) || node_1.ConnectionOptions.is(arg1)) {
      options = arg1;
    } else {
      input = arg1;
      output = arg2;
      options = arg3;
    }
    return _createConnection(input, output, options, factories);
  }
  exports.createConnection = createConnection;
  function _createConnection(input, output, options, factories) {
    let stdio = false;
    if (!input && !output && process.argv.length > 2) {
      let port = undefined;
      let pipeName = undefined;
      let argv = process.argv.slice(2);
      for (let i = 0;i < argv.length; i++) {
        let arg = argv[i];
        if (arg === "--node-ipc") {
          input = new node_1.IPCMessageReader(process);
          output = new node_1.IPCMessageWriter(process);
          break;
        } else if (arg === "--stdio") {
          stdio = true;
          input = process.stdin;
          output = process.stdout;
          break;
        } else if (arg === "--socket") {
          port = parseInt(argv[i + 1]);
          break;
        } else if (arg === "--pipe") {
          pipeName = argv[i + 1];
          break;
        } else {
          var args = arg.split("=");
          if (args[0] === "--socket") {
            port = parseInt(args[1]);
            break;
          } else if (args[0] === "--pipe") {
            pipeName = args[1];
            break;
          }
        }
      }
      if (port) {
        let transport = (0, node_1.createServerSocketTransport)(port);
        input = transport[0];
        output = transport[1];
      } else if (pipeName) {
        let transport = (0, node_1.createServerPipeTransport)(pipeName);
        input = transport[0];
        output = transport[1];
      }
    }
    var commandLineMessage = "Use arguments of createConnection or set command line parameters: '--node-ipc', '--stdio' or '--socket={number}'";
    if (!input) {
      throw new Error("Connection input stream is not set. " + commandLineMessage);
    }
    if (!output) {
      throw new Error("Connection output stream is not set. " + commandLineMessage);
    }
    if (Is.func(input.read) && Is.func(input.on)) {
      let inputStream = input;
      inputStream.on("end", () => {
        endProtocolConnection();
        process.exit(_shutdownReceived ? 0 : 1);
      });
      inputStream.on("close", () => {
        endProtocolConnection();
        process.exit(_shutdownReceived ? 0 : 1);
      });
    }
    const connectionFactory = (logger) => {
      const result = (0, node_1.createProtocolConnection)(input, output, logger, options);
      if (stdio) {
        patchConsole(logger);
      }
      return result;
    };
    return (0, server_1.createConnection)(connectionFactory, watchDog, factories);
  }
  function patchConsole(logger) {
    function serialize(args) {
      return args.map((arg) => typeof arg === "string" ? arg : (0, node_util_1.inspect)(arg)).join(" ");
    }
    const counters = new Map;
    console.assert = function assert(assertion, ...args) {
      if (assertion) {
        return;
      }
      if (args.length === 0) {
        logger.error("Assertion failed");
      } else {
        const [message, ...rest] = args;
        logger.error(`Assertion failed: ${message} ${serialize(rest)}`);
      }
    };
    console.count = function count(label = "default") {
      const message = String(label);
      let counter = counters.get(message) ?? 0;
      counter += 1;
      counters.set(message, counter);
      logger.log(`${message}: ${message}`);
    };
    console.countReset = function countReset(label) {
      if (label === undefined) {
        counters.clear();
      } else {
        counters.delete(String(label));
      }
    };
    console.debug = function debug(...args) {
      logger.log(serialize(args));
    };
    console.dir = function dir(arg, options) {
      logger.log((0, node_util_1.inspect)(arg, options));
    };
    console.log = function log(...args) {
      logger.log(serialize(args));
    };
    console.error = function error(...args) {
      logger.error(serialize(args));
    };
    console.trace = function trace(...args) {
      const stack = new Error().stack.replace(/(.+\n){2}/, "");
      let message = "Trace";
      if (args.length !== 0) {
        message += `: ${serialize(args)}`;
      }
      logger.log(`${message}
${stack}`);
    };
    console.warn = function warn(...args) {
      logger.warn(serialize(args));
    };
  }
});

// node_modules/@cspell/cspell-resolver/dist/requireResolve.js
var require_requireResolve = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.requireResolve = requireResolve;
  function requireResolve(filename, paths) {
    try {
      return __require.resolve(filename, paths ? { paths } : undefined);
    } catch {
      return;
    }
  }
});

// node_modules/ini/lib/ini.js
var require_ini = __commonJS((exports, module) => {
  var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
  var encode = (obj, opt = {}) => {
    if (typeof opt === "string") {
      opt = { section: opt };
    }
    opt.align = opt.align === true;
    opt.newline = opt.newline === true;
    opt.sort = opt.sort === true;
    opt.whitespace = opt.whitespace === true || opt.align === true;
    opt.platform = opt.platform || typeof process !== "undefined" && process.platform;
    opt.bracketedArray = opt.bracketedArray !== false;
    const eol = opt.platform === "win32" ? `\r
` : `
`;
    const separator = opt.whitespace ? " = " : "=";
    const children = [];
    const keys2 = opt.sort ? Object.keys(obj).sort() : Object.keys(obj);
    let padToChars = 0;
    if (opt.align) {
      padToChars = safe(keys2.filter((k) => obj[k] === null || Array.isArray(obj[k]) || typeof obj[k] !== "object").map((k) => Array.isArray(obj[k]) ? `${k}[]` : k).concat([""]).reduce((a, b) => safe(a).length >= safe(b).length ? a : b)).length;
    }
    let out = "";
    const arraySuffix = opt.bracketedArray ? "[]" : "";
    for (const k of keys2) {
      const val = obj[k];
      if (val && Array.isArray(val)) {
        for (const item of val) {
          out += safe(`${k}${arraySuffix}`).padEnd(padToChars, " ") + separator + safe(item) + eol;
        }
      } else if (val && typeof val === "object") {
        children.push(k);
      } else {
        out += safe(k).padEnd(padToChars, " ") + separator + safe(val) + eol;
      }
    }
    if (opt.section && out.length) {
      out = "[" + safe(opt.section) + "]" + (opt.newline ? eol + eol : eol) + out;
    }
    for (const k of children) {
      const nk = splitSections(k, ".").join("\\.");
      const section = (opt.section ? opt.section + "." : "") + nk;
      const child = encode(obj[k], {
        ...opt,
        section
      });
      if (out.length && child.length) {
        out += eol;
      }
      out += child;
    }
    return out;
  };
  function splitSections(str, separator) {
    var lastMatchIndex = 0;
    var lastSeparatorIndex = 0;
    var nextIndex = 0;
    var sections = [];
    do {
      nextIndex = str.indexOf(separator, lastMatchIndex);
      if (nextIndex !== -1) {
        lastMatchIndex = nextIndex + separator.length;
        if (nextIndex > 0 && str[nextIndex - 1] === "\\") {
          continue;
        }
        sections.push(str.slice(lastSeparatorIndex, nextIndex));
        lastSeparatorIndex = nextIndex + separator.length;
      }
    } while (nextIndex !== -1);
    sections.push(str.slice(lastSeparatorIndex));
    return sections;
  }
  var decode = (str, opt = {}) => {
    opt.bracketedArray = opt.bracketedArray !== false;
    const out = Object.create(null);
    let p = out;
    let section = null;
    const re = /^\[([^\]]*)\]\s*$|^([^=]+)(=(.*))?$/i;
    const lines = str.split(/[\r\n]+/g);
    const duplicates = {};
    for (const line of lines) {
      if (!line || line.match(/^\s*[;#]/) || line.match(/^\s*$/)) {
        continue;
      }
      const match = line.match(re);
      if (!match) {
        continue;
      }
      if (match[1] !== undefined) {
        section = unsafe(match[1]);
        if (section === "__proto__") {
          p = Object.create(null);
          continue;
        }
        p = out[section] = out[section] || Object.create(null);
        continue;
      }
      const keyRaw = unsafe(match[2]);
      let isArray3;
      if (opt.bracketedArray) {
        isArray3 = keyRaw.length > 2 && keyRaw.slice(-2) === "[]";
      } else {
        duplicates[keyRaw] = (duplicates?.[keyRaw] || 0) + 1;
        isArray3 = duplicates[keyRaw] > 1;
      }
      const key = isArray3 ? keyRaw.slice(0, -2) : keyRaw;
      if (key === "__proto__") {
        continue;
      }
      const valueRaw = match[3] ? unsafe(match[4]) : true;
      const value = valueRaw === "true" || valueRaw === "false" || valueRaw === "null" ? JSON.parse(valueRaw) : valueRaw;
      if (isArray3) {
        if (!hasOwnProperty2.call(p, key)) {
          p[key] = [];
        } else if (!Array.isArray(p[key])) {
          p[key] = [p[key]];
        }
      }
      if (Array.isArray(p[key])) {
        p[key].push(value);
      } else {
        p[key] = value;
      }
    }
    const remove = [];
    for (const k of Object.keys(out)) {
      if (!hasOwnProperty2.call(out, k) || typeof out[k] !== "object" || Array.isArray(out[k])) {
        continue;
      }
      const parts = splitSections(k, ".");
      p = out;
      const l = parts.pop();
      const nl = l.replace(/\\\./g, ".");
      for (const part of parts) {
        if (part === "__proto__") {
          continue;
        }
        if (!hasOwnProperty2.call(p, part) || typeof p[part] !== "object") {
          p[part] = Object.create(null);
        }
        p = p[part];
      }
      if (p === out && nl === l) {
        continue;
      }
      p[nl] = out[k];
      remove.push(k);
    }
    for (const del of remove) {
      delete out[del];
    }
    return out;
  };
  var isQuoted = (val) => {
    return val.startsWith('"') && val.endsWith('"') || val.startsWith("'") && val.endsWith("'");
  };
  var safe = (val) => {
    if (typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim()) {
      return JSON.stringify(val);
    }
    return val.split(";").join("\\;").split("#").join("\\#");
  };
  var unsafe = (val, doUnesc) => {
    val = (val || "").trim();
    if (isQuoted(val)) {
      if (val.charAt(0) === "'") {
        val = val.slice(1, -1);
      }
      try {
        val = JSON.parse(val);
      } catch {
      }
    } else {
      let esc = false;
      let unesc = "";
      for (let i = 0, l = val.length;i < l; i++) {
        const c = val.charAt(i);
        if (esc) {
          if ("\\;#".indexOf(c) !== -1) {
            unesc += c;
          } else {
            unesc += "\\" + c;
          }
          esc = false;
        } else if (";#".indexOf(c) !== -1) {
          break;
        } else if (c === "\\") {
          esc = true;
        } else {
          unesc += c;
        }
      }
      if (esc) {
        unesc += "\\";
      }
      return unesc.trim();
    }
    return val;
  };
  module.exports = {
    parse: decode,
    decode,
    stringify: encode,
    encode,
    safe,
    unsafe
  };
});

// node_modules/resolve-from/index.js
var require_resolve_from = __commonJS((exports, module) => {
  var path4 = __require("path");
  var Module = __require("module");
  var fs3 = __require("fs");
  var resolveFrom = (fromDirectory, moduleId, silent) => {
    if (typeof fromDirectory !== "string") {
      throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDirectory}\``);
    }
    if (typeof moduleId !== "string") {
      throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
    }
    try {
      fromDirectory = fs3.realpathSync(fromDirectory);
    } catch (error) {
      if (error.code === "ENOENT") {
        fromDirectory = path4.resolve(fromDirectory);
      } else if (silent) {
        return;
      } else {
        throw error;
      }
    }
    const fromFile = path4.join(fromDirectory, "noop.js");
    const resolveFileName = () => Module._resolveFilename(moduleId, {
      id: fromFile,
      filename: fromFile,
      paths: Module._nodeModulePaths(fromDirectory)
    });
    if (silent) {
      try {
        return resolveFileName();
      } catch (error) {
        return;
      }
    }
    return resolveFileName();
  };
  module.exports = (fromDirectory, moduleId) => resolveFrom(fromDirectory, moduleId);
  module.exports.silent = (fromDirectory, moduleId) => resolveFrom(fromDirectory, moduleId, true);
});

// node_modules/braces/lib/utils.js
var require_utils = __commonJS((exports) => {
  exports.isInteger = (num) => {
    if (typeof num === "number") {
      return Number.isInteger(num);
    }
    if (typeof num === "string" && num.trim() !== "") {
      return Number.isInteger(Number(num));
    }
    return false;
  };
  exports.find = (node, type) => node.nodes.find((node2) => node2.type === type);
  exports.exceedsLimit = (min3, max3, step = 1, limit) => {
    if (limit === false)
      return false;
    if (!exports.isInteger(min3) || !exports.isInteger(max3))
      return false;
    return (Number(max3) - Number(min3)) / Number(step) >= limit;
  };
  exports.escapeNode = (block, n = 0, type) => {
    const node = block.nodes[n];
    if (!node)
      return;
    if (type && node.type === type || node.type === "open" || node.type === "close") {
      if (node.escaped !== true) {
        node.value = "\\" + node.value;
        node.escaped = true;
      }
    }
  };
  exports.encloseBrace = (node) => {
    if (node.type !== "brace")
      return false;
    if (node.commas >> 0 + node.ranges >> 0 === 0) {
      node.invalid = true;
      return true;
    }
    return false;
  };
  exports.isInvalidBrace = (block) => {
    if (block.type !== "brace")
      return false;
    if (block.invalid === true || block.dollar)
      return true;
    if (block.commas >> 0 + block.ranges >> 0 === 0) {
      block.invalid = true;
      return true;
    }
    if (block.open !== true || block.close !== true) {
      block.invalid = true;
      return true;
    }
    return false;
  };
  exports.isOpenOrClose = (node) => {
    if (node.type === "open" || node.type === "close") {
      return true;
    }
    return node.open === true || node.close === true;
  };
  exports.reduce = (nodes) => nodes.reduce((acc, node) => {
    if (node.type === "text")
      acc.push(node.value);
    if (node.type === "range")
      node.type = "text";
    return acc;
  }, []);
  exports.flatten = (...args) => {
    const result = [];
    const flat = (arr) => {
      for (let i = 0;i < arr.length; i++) {
        const ele = arr[i];
        if (Array.isArray(ele)) {
          flat(ele);
          continue;
        }
        if (ele !== undefined) {
          result.push(ele);
        }
      }
      return result;
    };
    flat(args);
    return result;
  };
});

// node_modules/braces/lib/stringify.js
var require_stringify = __commonJS((exports, module) => {
  var utils = require_utils();
  module.exports = (ast, options = {}) => {
    const stringify = (node, parent = {}) => {
      const invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
      const invalidNode = node.invalid === true && options.escapeInvalid === true;
      let output = "";
      if (node.value) {
        if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
          return "\\" + node.value;
        }
        return node.value;
      }
      if (node.value) {
        return node.value;
      }
      if (node.nodes) {
        for (const child of node.nodes) {
          output += stringify(child);
        }
      }
      return output;
    };
    return stringify(ast);
  };
});

// node_modules/is-number/index.js
var require_is_number = __commonJS((exports, module) => {
  /*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   */
  module.exports = function(num) {
    if (typeof num === "number") {
      return num - num === 0;
    }
    if (typeof num === "string" && num.trim() !== "") {
      return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
    }
    return false;
  };
});

// node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS((exports, module) => {
  /*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   */
  var isNumber = require_is_number();
  var toRegexRange = (min3, max3, options) => {
    if (isNumber(min3) === false) {
      throw new TypeError("toRegexRange: expected the first argument to be a number");
    }
    if (max3 === undefined || min3 === max3) {
      return String(min3);
    }
    if (isNumber(max3) === false) {
      throw new TypeError("toRegexRange: expected the second argument to be a number.");
    }
    let opts = { relaxZeros: true, ...options };
    if (typeof opts.strictZeros === "boolean") {
      opts.relaxZeros = opts.strictZeros === false;
    }
    let relax = String(opts.relaxZeros);
    let shorthand = String(opts.shorthand);
    let capture = String(opts.capture);
    let wrap = String(opts.wrap);
    let cacheKey = min3 + ":" + max3 + "=" + relax + shorthand + capture + wrap;
    if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
      return toRegexRange.cache[cacheKey].result;
    }
    let a = Math.min(min3, max3);
    let b = Math.max(min3, max3);
    if (Math.abs(a - b) === 1) {
      let result = min3 + "|" + max3;
      if (opts.capture) {
        return `(${result})`;
      }
      if (opts.wrap === false) {
        return result;
      }
      return `(?:${result})`;
    }
    let isPadded = hasPadding(min3) || hasPadding(max3);
    let state = { min: min3, max: max3, a, b };
    let positives = [];
    let negatives = [];
    if (isPadded) {
      state.isPadded = isPadded;
      state.maxLen = String(state.max).length;
    }
    if (a < 0) {
      let newMin = b < 0 ? Math.abs(b) : 1;
      negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
      a = state.a = 0;
    }
    if (b >= 0) {
      positives = splitToPatterns(a, b, state, opts);
    }
    state.negatives = negatives;
    state.positives = positives;
    state.result = collatePatterns(negatives, positives, opts);
    if (opts.capture === true) {
      state.result = `(${state.result})`;
    } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
      state.result = `(?:${state.result})`;
    }
    toRegexRange.cache[cacheKey] = state;
    return state.result;
  };
  function collatePatterns(neg, pos, options) {
    let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
    let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
    let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
    let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
    return subpatterns.join("|");
  }
  function splitToRanges(min3, max3) {
    let nines = 1;
    let zeros = 1;
    let stop = countNines(min3, nines);
    let stops = new Set([max3]);
    while (min3 <= stop && stop <= max3) {
      stops.add(stop);
      nines += 1;
      stop = countNines(min3, nines);
    }
    stop = countZeros(max3 + 1, zeros) - 1;
    while (min3 < stop && stop <= max3) {
      stops.add(stop);
      zeros += 1;
      stop = countZeros(max3 + 1, zeros) - 1;
    }
    stops = [...stops];
    stops.sort(compare4);
    return stops;
  }
  function rangeToPattern(start, stop, options) {
    if (start === stop) {
      return { pattern: start, count: [], digits: 0 };
    }
    let zipped = zip(start, stop);
    let digits = zipped.length;
    let pattern = "";
    let count3 = 0;
    for (let i = 0;i < digits; i++) {
      let [startDigit, stopDigit] = zipped[i];
      if (startDigit === stopDigit) {
        pattern += startDigit;
      } else if (startDigit !== "0" || stopDigit !== "9") {
        pattern += toCharacterClass(startDigit, stopDigit, options);
      } else {
        count3++;
      }
    }
    if (count3) {
      pattern += options.shorthand === true ? "\\d" : "[0-9]";
    }
    return { pattern, count: [count3], digits };
  }
  function splitToPatterns(min3, max3, tok, options) {
    let ranges = splitToRanges(min3, max3);
    let tokens = [];
    let start = min3;
    let prev;
    for (let i = 0;i < ranges.length; i++) {
      let max4 = ranges[i];
      let obj = rangeToPattern(String(start), String(max4), options);
      let zeros = "";
      if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
        if (prev.count.length > 1) {
          prev.count.pop();
        }
        prev.count.push(obj.count[0]);
        prev.string = prev.pattern + toQuantifier(prev.count);
        start = max4 + 1;
        continue;
      }
      if (tok.isPadded) {
        zeros = padZeros(max4, tok, options);
      }
      obj.string = zeros + obj.pattern + toQuantifier(obj.count);
      tokens.push(obj);
      start = max4 + 1;
      prev = obj;
    }
    return tokens;
  }
  function filterPatterns(arr, comparison, prefix, intersection, options) {
    let result = [];
    for (let ele of arr) {
      let { string } = ele;
      if (!intersection && !contains(comparison, "string", string)) {
        result.push(prefix + string);
      }
      if (intersection && contains(comparison, "string", string)) {
        result.push(prefix + string);
      }
    }
    return result;
  }
  function zip(a, b) {
    let arr = [];
    for (let i = 0;i < a.length; i++)
      arr.push([a[i], b[i]]);
    return arr;
  }
  function compare4(a, b) {
    return a > b ? 1 : b > a ? -1 : 0;
  }
  function contains(arr, key, val) {
    return arr.some((ele) => ele[key] === val);
  }
  function countNines(min3, len) {
    return Number(String(min3).slice(0, -len) + "9".repeat(len));
  }
  function countZeros(integer, zeros) {
    return integer - integer % Math.pow(10, zeros);
  }
  function toQuantifier(digits) {
    let [start = 0, stop = ""] = digits;
    if (stop || start > 1) {
      return `{${start + (stop ? "," + stop : "")}}`;
    }
    return "";
  }
  function toCharacterClass(a, b, options) {
    return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
  }
  function hasPadding(str) {
    return /^-?(0+)\d/.test(str);
  }
  function padZeros(value, tok, options) {
    if (!tok.isPadded) {
      return value;
    }
    let diff = Math.abs(tok.maxLen - String(value).length);
    let relax = options.relaxZeros !== false;
    switch (diff) {
      case 0:
        return "";
      case 1:
        return relax ? "0?" : "0";
      case 2:
        return relax ? "0{0,2}" : "00";
      default: {
        return relax ? `0{0,${diff}}` : `0{${diff}}`;
      }
    }
  }
  toRegexRange.cache = {};
  toRegexRange.clearCache = () => toRegexRange.cache = {};
  module.exports = toRegexRange;
});

// node_modules/fill-range/index.js
var require_fill_range = __commonJS((exports, module) => {
  /*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  var util = __require("util");
  var toRegexRange = require_to_regex_range();
  var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  var transform = (toNumber) => {
    return (value) => toNumber === true ? Number(value) : String(value);
  };
  var isValidValue = (value) => {
    return typeof value === "number" || typeof value === "string" && value !== "";
  };
  var isNumber = (num) => Number.isInteger(+num);
  var zeros = (input) => {
    let value = `${input}`;
    let index = -1;
    if (value[0] === "-")
      value = value.slice(1);
    if (value === "0")
      return false;
    while (value[++index] === "0")
      ;
    return index > 0;
  };
  var stringify = (start, end, options) => {
    if (typeof start === "string" || typeof end === "string") {
      return true;
    }
    return options.stringify === true;
  };
  var pad = (input, maxLength, toNumber) => {
    if (maxLength > 0) {
      let dash = input[0] === "-" ? "-" : "";
      if (dash)
        input = input.slice(1);
      input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
    }
    if (toNumber === false) {
      return String(input);
    }
    return input;
  };
  var toMaxLen = (input, maxLength) => {
    let negative = input[0] === "-" ? "-" : "";
    if (negative) {
      input = input.slice(1);
      maxLength--;
    }
    while (input.length < maxLength)
      input = "0" + input;
    return negative ? "-" + input : input;
  };
  var toSequence = (parts, options, maxLen) => {
    parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    let prefix = options.capture ? "" : "?:";
    let positives = "";
    let negatives = "";
    let result;
    if (parts.positives.length) {
      positives = parts.positives.map((v) => toMaxLen(String(v), maxLen)).join("|");
    }
    if (parts.negatives.length) {
      negatives = `-(${prefix}${parts.negatives.map((v) => toMaxLen(String(v), maxLen)).join("|")})`;
    }
    if (positives && negatives) {
      result = `${positives}|${negatives}`;
    } else {
      result = positives || negatives;
    }
    if (options.wrap) {
      return `(${prefix}${result})`;
    }
    return result;
  };
  var toRange = (a, b, isNumbers, options) => {
    if (isNumbers) {
      return toRegexRange(a, b, { wrap: false, ...options });
    }
    let start = String.fromCharCode(a);
    if (a === b)
      return start;
    let stop = String.fromCharCode(b);
    return `[${start}-${stop}]`;
  };
  var toRegex = (start, end, options) => {
    if (Array.isArray(start)) {
      let wrap = options.wrap === true;
      let prefix = options.capture ? "" : "?:";
      return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
    }
    return toRegexRange(start, end, options);
  };
  var rangeError = (...args) => {
    return new RangeError("Invalid range arguments: " + util.inspect(...args));
  };
  var invalidRange = (start, end, options) => {
    if (options.strictRanges === true)
      throw rangeError([start, end]);
    return [];
  };
  var invalidStep = (step, options) => {
    if (options.strictRanges === true) {
      throw new TypeError(`Expected step "${step}" to be a number`);
    }
    return [];
  };
  var fillNumbers = (start, end, step = 1, options = {}) => {
    let a = Number(start);
    let b = Number(end);
    if (!Number.isInteger(a) || !Number.isInteger(b)) {
      if (options.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    }
    if (a === 0)
      a = 0;
    if (b === 0)
      b = 0;
    let descending = a > b;
    let startString = String(start);
    let endString = String(end);
    let stepString = String(step);
    step = Math.max(Math.abs(step), 1);
    let padded = zeros(startString) || zeros(endString) || zeros(stepString);
    let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
    let toNumber = padded === false && stringify(start, end, options) === false;
    let format3 = options.transform || transform(toNumber);
    if (options.toRegex && step === 1) {
      return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
    }
    let parts = { negatives: [], positives: [] };
    let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
    let range = [];
    let index = 0;
    while (descending ? a >= b : a <= b) {
      if (options.toRegex === true && step > 1) {
        push(a);
      } else {
        range.push(pad(format3(a, index), maxLen, toNumber));
      }
      a = descending ? a - step : a + step;
      index++;
    }
    if (options.toRegex === true) {
      return step > 1 ? toSequence(parts, options, maxLen) : toRegex(range, null, { wrap: false, ...options });
    }
    return range;
  };
  var fillLetters = (start, end, step = 1, options = {}) => {
    if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
      return invalidRange(start, end, options);
    }
    let format3 = options.transform || ((val) => String.fromCharCode(val));
    let a = `${start}`.charCodeAt(0);
    let b = `${end}`.charCodeAt(0);
    let descending = a > b;
    let min3 = Math.min(a, b);
    let max3 = Math.max(a, b);
    if (options.toRegex && step === 1) {
      return toRange(min3, max3, false, options);
    }
    let range = [];
    let index = 0;
    while (descending ? a >= b : a <= b) {
      range.push(format3(a, index));
      a = descending ? a - step : a + step;
      index++;
    }
    if (options.toRegex === true) {
      return toRegex(range, null, { wrap: false, options });
    }
    return range;
  };
  var fill = (start, end, step, options = {}) => {
    if (end == null && isValidValue(start)) {
      return [start];
    }
    if (!isValidValue(start) || !isValidValue(end)) {
      return invalidRange(start, end, options);
    }
    if (typeof step === "function") {
      return fill(start, end, 1, { transform: step });
    }
    if (isObject(step)) {
      return fill(start, end, 0, step);
    }
    let opts = { ...options };
    if (opts.capture === true)
      opts.wrap = true;
    step = step || opts.step || 1;
    if (!isNumber(step)) {
      if (step != null && !isObject(step))
        return invalidStep(step, opts);
      return fill(start, end, 1, step);
    }
    if (isNumber(start) && isNumber(end)) {
      return fillNumbers(start, end, step, opts);
    }
    return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
  };
  module.exports = fill;
});

// node_modules/braces/lib/compile.js
var require_compile = __commonJS((exports, module) => {
  var fill = require_fill_range();
  var utils = require_utils();
  var compile = (ast, options = {}) => {
    const walk2 = (node, parent = {}) => {
      const invalidBlock = utils.isInvalidBrace(parent);
      const invalidNode = node.invalid === true && options.escapeInvalid === true;
      const invalid = invalidBlock === true || invalidNode === true;
      const prefix = options.escapeInvalid === true ? "\\" : "";
      let output = "";
      if (node.isOpen === true) {
        return prefix + node.value;
      }
      if (node.isClose === true) {
        console.log("node.isClose", prefix, node.value);
        return prefix + node.value;
      }
      if (node.type === "open") {
        return invalid ? prefix + node.value : "(";
      }
      if (node.type === "close") {
        return invalid ? prefix + node.value : ")";
      }
      if (node.type === "comma") {
        return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
      }
      if (node.value) {
        return node.value;
      }
      if (node.nodes && node.ranges > 0) {
        const args = utils.reduce(node.nodes);
        const range = fill(...args, { ...options, wrap: false, toRegex: true, strictZeros: true });
        if (range.length !== 0) {
          return args.length > 1 && range.length > 1 ? `(${range})` : range;
        }
      }
      if (node.nodes) {
        for (const child of node.nodes) {
          output += walk2(child, node);
        }
      }
      return output;
    };
    return walk2(ast);
  };
  module.exports = compile;
});

// node_modules/braces/lib/expand.js
var require_expand = __commonJS((exports, module) => {
  var fill = require_fill_range();
  var stringify = require_stringify();
  var utils = require_utils();
  var append = (queue = "", stash = "", enclose = false) => {
    const result = [];
    queue = [].concat(queue);
    stash = [].concat(stash);
    if (!stash.length)
      return queue;
    if (!queue.length) {
      return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
    }
    for (const item of queue) {
      if (Array.isArray(item)) {
        for (const value of item) {
          result.push(append(value, stash, enclose));
        }
      } else {
        for (let ele of stash) {
          if (enclose === true && typeof ele === "string")
            ele = `{${ele}}`;
          result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
        }
      }
    }
    return utils.flatten(result);
  };
  var expand = (ast, options = {}) => {
    const rangeLimit = options.rangeLimit === undefined ? 1000 : options.rangeLimit;
    const walk2 = (node, parent = {}) => {
      node.queue = [];
      let p = parent;
      let q = parent.queue;
      while (p.type !== "brace" && p.type !== "root" && p.parent) {
        p = p.parent;
        q = p.queue;
      }
      if (node.invalid || node.dollar) {
        q.push(append(q.pop(), stringify(node, options)));
        return;
      }
      if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
        q.push(append(q.pop(), ["{}"]));
        return;
      }
      if (node.nodes && node.ranges > 0) {
        const args = utils.reduce(node.nodes);
        if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
          throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
        }
        let range = fill(...args, options);
        if (range.length === 0) {
          range = stringify(node, options);
        }
        q.push(append(q.pop(), range));
        node.nodes = [];
        return;
      }
      const enclose = utils.encloseBrace(node);
      let queue = node.queue;
      let block = node;
      while (block.type !== "brace" && block.type !== "root" && block.parent) {
        block = block.parent;
        queue = block.queue;
      }
      for (let i = 0;i < node.nodes.length; i++) {
        const child = node.nodes[i];
        if (child.type === "comma" && node.type === "brace") {
          if (i === 1)
            queue.push("");
          queue.push("");
          continue;
        }
        if (child.type === "close") {
          q.push(append(q.pop(), queue, enclose));
          continue;
        }
        if (child.value && child.type !== "open") {
          queue.push(append(queue.pop(), child.value));
          continue;
        }
        if (child.nodes) {
          walk2(child, node);
        }
      }
      return queue;
    };
    return utils.flatten(walk2(ast));
  };
  module.exports = expand;
});

// node_modules/braces/lib/constants.js
var require_constants = __commonJS((exports, module) => {
  module.exports = {
    MAX_LENGTH: 1e4,
    CHAR_0: "0",
    CHAR_9: "9",
    CHAR_UPPERCASE_A: "A",
    CHAR_LOWERCASE_A: "a",
    CHAR_UPPERCASE_Z: "Z",
    CHAR_LOWERCASE_Z: "z",
    CHAR_LEFT_PARENTHESES: "(",
    CHAR_RIGHT_PARENTHESES: ")",
    CHAR_ASTERISK: "*",
    CHAR_AMPERSAND: "&",
    CHAR_AT: "@",
    CHAR_BACKSLASH: "\\",
    CHAR_BACKTICK: "`",
    CHAR_CARRIAGE_RETURN: "\r",
    CHAR_CIRCUMFLEX_ACCENT: "^",
    CHAR_COLON: ":",
    CHAR_COMMA: ",",
    CHAR_DOLLAR: "$",
    CHAR_DOT: ".",
    CHAR_DOUBLE_QUOTE: '"',
    CHAR_EQUAL: "=",
    CHAR_EXCLAMATION_MARK: "!",
    CHAR_FORM_FEED: "\f",
    CHAR_FORWARD_SLASH: "/",
    CHAR_HASH: "#",
    CHAR_HYPHEN_MINUS: "-",
    CHAR_LEFT_ANGLE_BRACKET: "<",
    CHAR_LEFT_CURLY_BRACE: "{",
    CHAR_LEFT_SQUARE_BRACKET: "[",
    CHAR_LINE_FEED: `
`,
    CHAR_NO_BREAK_SPACE: "",
    CHAR_PERCENT: "%",
    CHAR_PLUS: "+",
    CHAR_QUESTION_MARK: "?",
    CHAR_RIGHT_ANGLE_BRACKET: ">",
    CHAR_RIGHT_CURLY_BRACE: "}",
    CHAR_RIGHT_SQUARE_BRACKET: "]",
    CHAR_SEMICOLON: ";",
    CHAR_SINGLE_QUOTE: "'",
    CHAR_SPACE: " ",
    CHAR_TAB: "\t",
    CHAR_UNDERSCORE: "_",
    CHAR_VERTICAL_LINE: "|",
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
  };
});

// node_modules/braces/lib/parse.js
var require_parse = __commonJS((exports, module) => {
  var stringify = require_stringify();
  var {
    MAX_LENGTH,
    CHAR_BACKSLASH,
    CHAR_BACKTICK,
    CHAR_COMMA,
    CHAR_DOT,
    CHAR_LEFT_PARENTHESES,
    CHAR_RIGHT_PARENTHESES,
    CHAR_LEFT_CURLY_BRACE,
    CHAR_RIGHT_CURLY_BRACE,
    CHAR_LEFT_SQUARE_BRACKET,
    CHAR_RIGHT_SQUARE_BRACKET,
    CHAR_DOUBLE_QUOTE,
    CHAR_SINGLE_QUOTE,
    CHAR_NO_BREAK_SPACE,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE
  } = require_constants();
  var parse = (input, options = {}) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected a string");
    }
    const opts = options || {};
    const max3 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    if (input.length > max3) {
      throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max3})`);
    }
    const ast = { type: "root", input, nodes: [] };
    const stack = [ast];
    let block = ast;
    let prev = ast;
    let brackets = 0;
    const length = input.length;
    let index = 0;
    let depth = 0;
    let value;
    const advance = () => input[index++];
    const push = (node) => {
      if (node.type === "text" && prev.type === "dot") {
        prev.type = "text";
      }
      if (prev && prev.type === "text" && node.type === "text") {
        prev.value += node.value;
        return;
      }
      block.nodes.push(node);
      node.parent = block;
      node.prev = prev;
      prev = node;
      return node;
    };
    push({ type: "bos" });
    while (index < length) {
      block = stack[stack.length - 1];
      value = advance();
      if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
        continue;
      }
      if (value === CHAR_BACKSLASH) {
        push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
        continue;
      }
      if (value === CHAR_RIGHT_SQUARE_BRACKET) {
        push({ type: "text", value: "\\" + value });
        continue;
      }
      if (value === CHAR_LEFT_SQUARE_BRACKET) {
        brackets++;
        let next;
        while (index < length && (next = advance())) {
          value += next;
          if (next === CHAR_LEFT_SQUARE_BRACKET) {
            brackets++;
            continue;
          }
          if (next === CHAR_BACKSLASH) {
            value += advance();
            continue;
          }
          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            brackets--;
            if (brackets === 0) {
              break;
            }
          }
        }
        push({ type: "text", value });
        continue;
      }
      if (value === CHAR_LEFT_PARENTHESES) {
        block = push({ type: "paren", nodes: [] });
        stack.push(block);
        push({ type: "text", value });
        continue;
      }
      if (value === CHAR_RIGHT_PARENTHESES) {
        if (block.type !== "paren") {
          push({ type: "text", value });
          continue;
        }
        block = stack.pop();
        push({ type: "text", value });
        block = stack[stack.length - 1];
        continue;
      }
      if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
        const open = value;
        let next;
        if (options.keepQuotes !== true) {
          value = "";
        }
        while (index < length && (next = advance())) {
          if (next === CHAR_BACKSLASH) {
            value += next + advance();
            continue;
          }
          if (next === open) {
            if (options.keepQuotes === true)
              value += next;
            break;
          }
          value += next;
        }
        push({ type: "text", value });
        continue;
      }
      if (value === CHAR_LEFT_CURLY_BRACE) {
        depth++;
        const dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
        const brace = {
          type: "brace",
          open: true,
          close: false,
          dollar,
          depth,
          commas: 0,
          ranges: 0,
          nodes: []
        };
        block = push(brace);
        stack.push(block);
        push({ type: "open", value });
        continue;
      }
      if (value === CHAR_RIGHT_CURLY_BRACE) {
        if (block.type !== "brace") {
          push({ type: "text", value });
          continue;
        }
        const type = "close";
        block = stack.pop();
        block.close = true;
        push({ type, value });
        depth--;
        block = stack[stack.length - 1];
        continue;
      }
      if (value === CHAR_COMMA && depth > 0) {
        if (block.ranges > 0) {
          block.ranges = 0;
          const open = block.nodes.shift();
          block.nodes = [open, { type: "text", value: stringify(block) }];
        }
        push({ type: "comma", value });
        block.commas++;
        continue;
      }
      if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
        const siblings = block.nodes;
        if (depth === 0 || siblings.length === 0) {
          push({ type: "text", value });
          continue;
        }
        if (prev.type === "dot") {
          block.range = [];
          prev.value += value;
          prev.type = "range";
          if (block.nodes.length !== 3 && block.nodes.length !== 5) {
            block.invalid = true;
            block.ranges = 0;
            prev.type = "text";
            continue;
          }
          block.ranges++;
          block.args = [];
          continue;
        }
        if (prev.type === "range") {
          siblings.pop();
          const before = siblings[siblings.length - 1];
          before.value += prev.value + value;
          prev = before;
          block.ranges--;
          continue;
        }
        push({ type: "dot", value });
        continue;
      }
      push({ type: "text", value });
    }
    do {
      block = stack.pop();
      if (block.type !== "root") {
        block.nodes.forEach((node) => {
          if (!node.nodes) {
            if (node.type === "open")
              node.isOpen = true;
            if (node.type === "close")
              node.isClose = true;
            if (!node.nodes)
              node.type = "text";
            node.invalid = true;
          }
        });
        const parent = stack[stack.length - 1];
        const index2 = parent.nodes.indexOf(block);
        parent.nodes.splice(index2, 1, ...block.nodes);
      }
    } while (stack.length > 0);
    push({ type: "eos" });
    return ast;
  };
  module.exports = parse;
});

// node_modules/braces/index.js
var require_braces = __commonJS((exports, module) => {
  var stringify = require_stringify();
  var compile = require_compile();
  var expand = require_expand();
  var parse = require_parse();
  var braces = (input, options = {}) => {
    let output = [];
    if (Array.isArray(input)) {
      for (const pattern of input) {
        const result = braces.create(pattern, options);
        if (Array.isArray(result)) {
          output.push(...result);
        } else {
          output.push(result);
        }
      }
    } else {
      output = [].concat(braces.create(input, options));
    }
    if (options && options.expand === true && options.nodupes === true) {
      output = [...new Set(output)];
    }
    return output;
  };
  braces.parse = (input, options = {}) => parse(input, options);
  braces.stringify = (input, options = {}) => {
    if (typeof input === "string") {
      return stringify(braces.parse(input, options), options);
    }
    return stringify(input, options);
  };
  braces.compile = (input, options = {}) => {
    if (typeof input === "string") {
      input = braces.parse(input, options);
    }
    return compile(input, options);
  };
  braces.expand = (input, options = {}) => {
    if (typeof input === "string") {
      input = braces.parse(input, options);
    }
    let result = expand(input, options);
    if (options.noempty === true) {
      result = result.filter(Boolean);
    }
    if (options.nodupes === true) {
      result = [...new Set(result)];
    }
    return result;
  };
  braces.create = (input, options = {}) => {
    if (input === "" || input.length < 3) {
      return [input];
    }
    return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
  };
  module.exports = braces;
});

// node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS((exports, module) => {
  var path6 = __require("path");
  var WIN_SLASH = "\\\\/";
  var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
  var DOT_LITERAL = "\\.";
  var PLUS_LITERAL = "\\+";
  var QMARK_LITERAL = "\\?";
  var SLASH_LITERAL = "\\/";
  var ONE_CHAR = "(?=.)";
  var QMARK = "[^/]";
  var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
  var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
  var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
  var NO_DOT = `(?!${DOT_LITERAL})`;
  var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
  var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
  var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
  var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
  var STAR = `${QMARK}*?`;
  var POSIX_CHARS = {
    DOT_LITERAL,
    PLUS_LITERAL,
    QMARK_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    QMARK,
    END_ANCHOR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  };
  var WINDOWS_CHARS = {
    ...POSIX_CHARS,
    SLASH_LITERAL: `[${WIN_SLASH}]`,
    QMARK: WIN_NO_SLASH,
    STAR: `${WIN_NO_SLASH}*?`,
    DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
    NO_DOT: `(?!${DOT_LITERAL})`,
    NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
    NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
    START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
    END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
  };
  var POSIX_REGEX_SOURCE = {
    alnum: "a-zA-Z0-9",
    alpha: "a-zA-Z",
    ascii: "\\x00-\\x7F",
    blank: " \\t",
    cntrl: "\\x00-\\x1F\\x7F",
    digit: "0-9",
    graph: "\\x21-\\x7E",
    lower: "a-z",
    print: "\\x20-\\x7E ",
    punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
    space: " \\t\\r\\n\\v\\f",
    upper: "A-Z",
    word: "A-Za-z0-9_",
    xdigit: "A-Fa-f0-9"
  };
  module.exports = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE,
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    REPLACEMENTS: {
      "***": "*",
      "**/**": "**",
      "**/**/**": "**"
    },
    CHAR_0: 48,
    CHAR_9: 57,
    CHAR_UPPERCASE_A: 65,
    CHAR_LOWERCASE_A: 97,
    CHAR_UPPERCASE_Z: 90,
    CHAR_LOWERCASE_Z: 122,
    CHAR_LEFT_PARENTHESES: 40,
    CHAR_RIGHT_PARENTHESES: 41,
    CHAR_ASTERISK: 42,
    CHAR_AMPERSAND: 38,
    CHAR_AT: 64,
    CHAR_BACKWARD_SLASH: 92,
    CHAR_CARRIAGE_RETURN: 13,
    CHAR_CIRCUMFLEX_ACCENT: 94,
    CHAR_COLON: 58,
    CHAR_COMMA: 44,
    CHAR_DOT: 46,
    CHAR_DOUBLE_QUOTE: 34,
    CHAR_EQUAL: 61,
    CHAR_EXCLAMATION_MARK: 33,
    CHAR_FORM_FEED: 12,
    CHAR_FORWARD_SLASH: 47,
    CHAR_GRAVE_ACCENT: 96,
    CHAR_HASH: 35,
    CHAR_HYPHEN_MINUS: 45,
    CHAR_LEFT_ANGLE_BRACKET: 60,
    CHAR_LEFT_CURLY_BRACE: 123,
    CHAR_LEFT_SQUARE_BRACKET: 91,
    CHAR_LINE_FEED: 10,
    CHAR_NO_BREAK_SPACE: 160,
    CHAR_PERCENT: 37,
    CHAR_PLUS: 43,
    CHAR_QUESTION_MARK: 63,
    CHAR_RIGHT_ANGLE_BRACKET: 62,
    CHAR_RIGHT_CURLY_BRACE: 125,
    CHAR_RIGHT_SQUARE_BRACKET: 93,
    CHAR_SEMICOLON: 59,
    CHAR_SINGLE_QUOTE: 39,
    CHAR_SPACE: 32,
    CHAR_TAB: 9,
    CHAR_UNDERSCORE: 95,
    CHAR_VERTICAL_LINE: 124,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
    SEP: path6.sep,
    extglobChars(chars) {
      return {
        "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
        "?": { type: "qmark", open: "(?:", close: ")?" },
        "+": { type: "plus", open: "(?:", close: ")+" },
        "*": { type: "star", open: "(?:", close: ")*" },
        "@": { type: "at", open: "(?:", close: ")" }
      };
    },
    globChars(win32) {
      return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
    }
  };
});

// node_modules/picomatch/lib/utils.js
var require_utils2 = __commonJS((exports) => {
  var path6 = __require("path");
  var win32 = process.platform === "win32";
  var {
    REGEX_BACKSLASH,
    REGEX_REMOVE_BACKSLASH,
    REGEX_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_GLOBAL
  } = require_constants2();
  exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
  exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
  exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
  exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
  exports.removeBackslashes = (str) => {
    return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
      return match === "\\" ? "" : match;
    });
  };
  exports.supportsLookbehinds = () => {
    const segs = process.version.slice(1).split(".").map(Number);
    if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
      return true;
    }
    return false;
  };
  exports.isWindows = (options) => {
    if (options && typeof options.windows === "boolean") {
      return options.windows;
    }
    return win32 === true || path6.sep === "\\";
  };
  exports.escapeLast = (input, char, lastIdx) => {
    const idx2 = input.lastIndexOf(char, lastIdx);
    if (idx2 === -1)
      return input;
    if (input[idx2 - 1] === "\\")
      return exports.escapeLast(input, char, idx2 - 1);
    return `${input.slice(0, idx2)}\\${input.slice(idx2)}`;
  };
  exports.removePrefix = (input, state = {}) => {
    let output = input;
    if (output.startsWith("./")) {
      output = output.slice(2);
      state.prefix = "./";
    }
    return output;
  };
  exports.wrapOutput = (input, state = {}, options = {}) => {
    const prepend = options.contains ? "" : "^";
    const append = options.contains ? "" : "$";
    let output = `${prepend}(?:${input})${append}`;
    if (state.negated === true) {
      output = `(?:^(?!${output}).*$)`;
    }
    return output;
  };
});

// node_modules/picomatch/lib/scan.js
var require_scan = __commonJS((exports, module) => {
  var utils = require_utils2();
  var {
    CHAR_ASTERISK,
    CHAR_AT,
    CHAR_BACKWARD_SLASH,
    CHAR_COMMA,
    CHAR_DOT,
    CHAR_EXCLAMATION_MARK,
    CHAR_FORWARD_SLASH,
    CHAR_LEFT_CURLY_BRACE,
    CHAR_LEFT_PARENTHESES,
    CHAR_LEFT_SQUARE_BRACKET,
    CHAR_PLUS,
    CHAR_QUESTION_MARK,
    CHAR_RIGHT_CURLY_BRACE,
    CHAR_RIGHT_PARENTHESES,
    CHAR_RIGHT_SQUARE_BRACKET
  } = require_constants2();
  var isPathSeparator = (code) => {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
  };
  var depth = (token) => {
    if (token.isPrefix !== true) {
      token.depth = token.isGlobstar ? Infinity : 1;
    }
  };
  var scan3 = (input, options) => {
    const opts = options || {};
    const length = input.length - 1;
    const scanToEnd = opts.parts === true || opts.scanToEnd === true;
    const slashes = [];
    const tokens = [];
    const parts = [];
    let str = input;
    let index = -1;
    let start = 0;
    let lastIndex = 0;
    let isBrace = false;
    let isBracket = false;
    let isGlob = false;
    let isExtglob = false;
    let isGlobstar = false;
    let braceEscaped = false;
    let backslashes = false;
    let negated = false;
    let negatedExtglob = false;
    let finished = false;
    let braces = 0;
    let prev;
    let code;
    let token = { value: "", depth: 0, isGlob: false };
    const eos = () => index >= length;
    const peek = () => str.charCodeAt(index + 1);
    const advance = () => {
      prev = code;
      return str.charCodeAt(++index);
    };
    while (index < length) {
      code = advance();
      let next;
      if (code === CHAR_BACKWARD_SLASH) {
        backslashes = token.backslashes = true;
        code = advance();
        if (code === CHAR_LEFT_CURLY_BRACE) {
          braceEscaped = true;
        }
        continue;
      }
      if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
        braces++;
        while (eos() !== true && (code = advance())) {
          if (code === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            continue;
          }
          if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (braceEscaped !== true && code === CHAR_COMMA) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_RIGHT_CURLY_BRACE) {
            braces--;
            if (braces === 0) {
              braceEscaped = false;
              isBrace = token.isBrace = true;
              finished = true;
              break;
            }
          }
        }
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_FORWARD_SLASH) {
        slashes.push(index);
        tokens.push(token);
        token = { value: "", depth: 0, isGlob: false };
        if (finished === true)
          continue;
        if (prev === CHAR_DOT && index === start + 1) {
          start += 2;
          continue;
        }
        lastIndex = index + 1;
        continue;
      }
      if (opts.noext !== true) {
        const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
        if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          isExtglob = token.isExtglob = true;
          finished = true;
          if (code === CHAR_EXCLAMATION_MARK && index === start) {
            negatedExtglob = true;
          }
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_BACKWARD_SLASH) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                isGlob = token.isGlob = true;
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
      }
      if (code === CHAR_ASTERISK) {
        if (prev === CHAR_ASTERISK)
          isGlobstar = token.isGlobstar = true;
        isGlob = token.isGlob = true;
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_QUESTION_MARK) {
        isGlob = token.isGlob = true;
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (code === CHAR_LEFT_SQUARE_BRACKET) {
        while (eos() !== true && (next = advance())) {
          if (next === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }
          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            isBracket = token.isBracket = true;
            isGlob = token.isGlob = true;
            finished = true;
            break;
          }
        }
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
      if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
        negated = token.negated = true;
        start++;
        continue;
      }
      if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;
        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_LEFT_PARENTHESES) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }
            if (code === CHAR_RIGHT_PARENTHESES) {
              finished = true;
              break;
            }
          }
          continue;
        }
        break;
      }
      if (isGlob === true) {
        finished = true;
        if (scanToEnd === true) {
          continue;
        }
        break;
      }
    }
    if (opts.noext === true) {
      isExtglob = false;
      isGlob = false;
    }
    let base = str;
    let prefix = "";
    let glob = "";
    if (start > 0) {
      prefix = str.slice(0, start);
      str = str.slice(start);
      lastIndex -= start;
    }
    if (base && isGlob === true && lastIndex > 0) {
      base = str.slice(0, lastIndex);
      glob = str.slice(lastIndex);
    } else if (isGlob === true) {
      base = "";
      glob = str;
    } else {
      base = str;
    }
    if (base && base !== "" && base !== "/" && base !== str) {
      if (isPathSeparator(base.charCodeAt(base.length - 1))) {
        base = base.slice(0, -1);
      }
    }
    if (opts.unescape === true) {
      if (glob)
        glob = utils.removeBackslashes(glob);
      if (base && backslashes === true) {
        base = utils.removeBackslashes(base);
      }
    }
    const state = {
      prefix,
      input,
      start,
      base,
      glob,
      isBrace,
      isBracket,
      isGlob,
      isExtglob,
      isGlobstar,
      negated,
      negatedExtglob
    };
    if (opts.tokens === true) {
      state.maxDepth = 0;
      if (!isPathSeparator(code)) {
        tokens.push(token);
      }
      state.tokens = tokens;
    }
    if (opts.parts === true || opts.tokens === true) {
      let prevIndex;
      for (let idx2 = 0;idx2 < slashes.length; idx2++) {
        const n = prevIndex ? prevIndex + 1 : start;
        const i = slashes[idx2];
        const value = input.slice(n, i);
        if (opts.tokens) {
          if (idx2 === 0 && start !== 0) {
            tokens[idx2].isPrefix = true;
            tokens[idx2].value = prefix;
          } else {
            tokens[idx2].value = value;
          }
          depth(tokens[idx2]);
          state.maxDepth += tokens[idx2].depth;
        }
        if (idx2 !== 0 || value !== "") {
          parts.push(value);
        }
        prevIndex = i;
      }
      if (prevIndex && prevIndex + 1 < input.length) {
        const value = input.slice(prevIndex + 1);
        parts.push(value);
        if (opts.tokens) {
          tokens[tokens.length - 1].value = value;
          depth(tokens[tokens.length - 1]);
          state.maxDepth += tokens[tokens.length - 1].depth;
        }
      }
      state.slashes = slashes;
      state.parts = parts;
    }
    return state;
  };
  module.exports = scan3;
});

// node_modules/picomatch/lib/parse.js
var require_parse2 = __commonJS((exports, module) => {
  var constants = require_constants2();
  var utils = require_utils2();
  var {
    MAX_LENGTH,
    POSIX_REGEX_SOURCE,
    REGEX_NON_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_BACKREF,
    REPLACEMENTS
  } = constants;
  var expandRange2 = (args, options) => {
    if (typeof options.expandRange === "function") {
      return options.expandRange(...args, options);
    }
    args.sort();
    const value = `[${args.join("-")}]`;
    try {
      new RegExp(value);
    } catch (ex) {
      return args.map((v) => utils.escapeRegex(v)).join("..");
    }
    return value;
  };
  var syntaxError = (type, char) => {
    return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
  };
  var parse = (input, options) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected a string");
    }
    input = REPLACEMENTS[input] || input;
    const opts = { ...options };
    const max3 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    let len = input.length;
    if (len > max3) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max3}`);
    }
    const bos = { type: "bos", value: "", output: opts.prepend || "" };
    const tokens = [bos];
    const capture = opts.capture ? "" : "?:";
    const win32 = utils.isWindows(options);
    const PLATFORM_CHARS = constants.globChars(win32);
    const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
    const {
      DOT_LITERAL,
      PLUS_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    } = PLATFORM_CHARS;
    const globstar = (opts2) => {
      return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const nodot = opts.dot ? "" : NO_DOT;
    const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
    let star = opts.bash === true ? globstar(opts) : STAR;
    if (opts.capture) {
      star = `(${star})`;
    }
    if (typeof opts.noext === "boolean") {
      opts.noextglob = opts.noext;
    }
    const state = {
      input,
      index: -1,
      start: 0,
      dot: opts.dot === true,
      consumed: "",
      output: "",
      prefix: "",
      backtrack: false,
      negated: false,
      brackets: 0,
      braces: 0,
      parens: 0,
      quotes: 0,
      globstar: false,
      tokens
    };
    input = utils.removePrefix(input, state);
    len = input.length;
    const extglobs = [];
    const braces = [];
    const stack = [];
    let prev = bos;
    let value;
    const eos = () => state.index === len - 1;
    const peek = state.peek = (n = 1) => input[state.index + n];
    const advance = state.advance = () => input[++state.index] || "";
    const remaining = () => input.slice(state.index + 1);
    const consume = (value2 = "", num = 0) => {
      state.consumed += value2;
      state.index += num;
    };
    const append = (token) => {
      state.output += token.output != null ? token.output : token.value;
      consume(token.value);
    };
    const negate = () => {
      let count3 = 1;
      while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
        advance();
        state.start++;
        count3++;
      }
      if (count3 % 2 === 0) {
        return false;
      }
      state.negated = true;
      state.start++;
      return true;
    };
    const increment = (type) => {
      state[type]++;
      stack.push(type);
    };
    const decrement = (type) => {
      state[type]--;
      stack.pop();
    };
    const push = (tok) => {
      if (prev.type === "globstar") {
        const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
        const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
        if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "star";
          prev.value = "*";
          prev.output = star;
          state.output += prev.output;
        }
      }
      if (extglobs.length && tok.type !== "paren") {
        extglobs[extglobs.length - 1].inner += tok.value;
      }
      if (tok.value || tok.output)
        append(tok);
      if (prev && prev.type === "text" && tok.type === "text") {
        prev.value += tok.value;
        prev.output = (prev.output || "") + tok.value;
        return;
      }
      tok.prev = prev;
      tokens.push(tok);
      prev = tok;
    };
    const extglobOpen = (type, value2) => {
      const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
      token.prev = prev;
      token.parens = state.parens;
      token.output = state.output;
      const output = (opts.capture ? "(" : "") + token.open;
      increment("parens");
      push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
      push({ type: "paren", extglob: true, value: advance(), output });
      extglobs.push(token);
    };
    const extglobClose = (token) => {
      let output = token.close + (opts.capture ? ")" : "");
      let rest;
      if (token.type === "negate") {
        let extglobStar = star;
        if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
          extglobStar = globstar(opts);
        }
        if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
          output = token.close = `)$))${extglobStar}`;
        }
        if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
          const expression = parse(rest, { ...options, fastpaths: false }).output;
          output = token.close = `)${expression})${extglobStar})`;
        }
        if (token.prev.type === "bos") {
          state.negatedExtglob = true;
        }
      }
      push({ type: "paren", extglob: true, value, output });
      decrement("parens");
    };
    if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
      let backslashes = false;
      let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first3, rest, index) => {
        if (first3 === "\\") {
          backslashes = true;
          return m;
        }
        if (first3 === "?") {
          if (esc) {
            return esc + first3 + (rest ? QMARK.repeat(rest.length) : "");
          }
          if (index === 0) {
            return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
          }
          return QMARK.repeat(chars.length);
        }
        if (first3 === ".") {
          return DOT_LITERAL.repeat(chars.length);
        }
        if (first3 === "*") {
          if (esc) {
            return esc + first3 + (rest ? star : "");
          }
          return star;
        }
        return esc ? m : `\\${m}`;
      });
      if (backslashes === true) {
        if (opts.unescape === true) {
          output = output.replace(/\\/g, "");
        } else {
          output = output.replace(/\\+/g, (m) => {
            return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
          });
        }
      }
      if (output === input && opts.contains === true) {
        state.output = input;
        return state;
      }
      state.output = utils.wrapOutput(output, state, options);
      return state;
    }
    while (!eos()) {
      value = advance();
      if (value === "\x00") {
        continue;
      }
      if (value === "\\") {
        const next = peek();
        if (next === "/" && opts.bash !== true) {
          continue;
        }
        if (next === "." || next === ";") {
          continue;
        }
        if (!next) {
          value += "\\";
          push({ type: "text", value });
          continue;
        }
        const match = /^\\+/.exec(remaining());
        let slashes = 0;
        if (match && match[0].length > 2) {
          slashes = match[0].length;
          state.index += slashes;
          if (slashes % 2 !== 0) {
            value += "\\";
          }
        }
        if (opts.unescape === true) {
          value = advance();
        } else {
          value += advance();
        }
        if (state.brackets === 0) {
          push({ type: "text", value });
          continue;
        }
      }
      if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
        if (opts.posix !== false && value === ":") {
          const inner = prev.value.slice(1);
          if (inner.includes("[")) {
            prev.posix = true;
            if (inner.includes(":")) {
              const idx2 = prev.value.lastIndexOf("[");
              const pre = prev.value.slice(0, idx2);
              const rest2 = prev.value.slice(idx2 + 2);
              const posix2 = POSIX_REGEX_SOURCE[rest2];
              if (posix2) {
                prev.value = pre + posix2;
                state.backtrack = true;
                advance();
                if (!bos.output && tokens.indexOf(prev) === 1) {
                  bos.output = ONE_CHAR;
                }
                continue;
              }
            }
          }
        }
        if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
          value = `\\${value}`;
        }
        if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
          value = `\\${value}`;
        }
        if (opts.posix === true && value === "!" && prev.value === "[") {
          value = "^";
        }
        prev.value += value;
        append({ value });
        continue;
      }
      if (state.quotes === 1 && value !== '"') {
        value = utils.escapeRegex(value);
        prev.value += value;
        append({ value });
        continue;
      }
      if (value === '"') {
        state.quotes = state.quotes === 1 ? 0 : 1;
        if (opts.keepQuotes === true) {
          push({ type: "text", value });
        }
        continue;
      }
      if (value === "(") {
        increment("parens");
        push({ type: "paren", value });
        continue;
      }
      if (value === ")") {
        if (state.parens === 0 && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError("opening", "("));
        }
        const extglob = extglobs[extglobs.length - 1];
        if (extglob && state.parens === extglob.parens + 1) {
          extglobClose(extglobs.pop());
          continue;
        }
        push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
        decrement("parens");
        continue;
      }
      if (value === "[") {
        if (opts.nobracket === true || !remaining().includes("]")) {
          if (opts.nobracket !== true && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("closing", "]"));
          }
          value = `\\${value}`;
        } else {
          increment("brackets");
        }
        push({ type: "bracket", value });
        continue;
      }
      if (value === "]") {
        if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
          push({ type: "text", value, output: `\\${value}` });
          continue;
        }
        if (state.brackets === 0) {
          if (opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "["));
          }
          push({ type: "text", value, output: `\\${value}` });
          continue;
        }
        decrement("brackets");
        const prevValue = prev.value.slice(1);
        if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
          value = `/${value}`;
        }
        prev.value += value;
        append({ value });
        if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
          continue;
        }
        const escaped = utils.escapeRegex(prev.value);
        state.output = state.output.slice(0, -prev.value.length);
        if (opts.literalBrackets === true) {
          state.output += escaped;
          prev.value = escaped;
          continue;
        }
        prev.value = `(${capture}${escaped}|${prev.value})`;
        state.output += prev.value;
        continue;
      }
      if (value === "{" && opts.nobrace !== true) {
        increment("braces");
        const open = {
          type: "brace",
          value,
          output: "(",
          outputIndex: state.output.length,
          tokensIndex: state.tokens.length
        };
        braces.push(open);
        push(open);
        continue;
      }
      if (value === "}") {
        const brace = braces[braces.length - 1];
        if (opts.nobrace === true || !brace) {
          push({ type: "text", value, output: value });
          continue;
        }
        let output = ")";
        if (brace.dots === true) {
          const arr = tokens.slice();
          const range = [];
          for (let i = arr.length - 1;i >= 0; i--) {
            tokens.pop();
            if (arr[i].type === "brace") {
              break;
            }
            if (arr[i].type !== "dots") {
              range.unshift(arr[i].value);
            }
          }
          output = expandRange2(range, opts);
          state.backtrack = true;
        }
        if (brace.comma !== true && brace.dots !== true) {
          const out = state.output.slice(0, brace.outputIndex);
          const toks = state.tokens.slice(brace.tokensIndex);
          brace.value = brace.output = "\\{";
          value = output = "\\}";
          state.output = out;
          for (const t of toks) {
            state.output += t.output || t.value;
          }
        }
        push({ type: "brace", value, output });
        decrement("braces");
        braces.pop();
        continue;
      }
      if (value === "|") {
        if (extglobs.length > 0) {
          extglobs[extglobs.length - 1].conditions++;
        }
        push({ type: "text", value });
        continue;
      }
      if (value === ",") {
        let output = value;
        const brace = braces[braces.length - 1];
        if (brace && stack[stack.length - 1] === "braces") {
          brace.comma = true;
          output = "|";
        }
        push({ type: "comma", value, output });
        continue;
      }
      if (value === "/") {
        if (prev.type === "dot" && state.index === state.start + 1) {
          state.start = state.index + 1;
          state.consumed = "";
          state.output = "";
          tokens.pop();
          prev = bos;
          continue;
        }
        push({ type: "slash", value, output: SLASH_LITERAL });
        continue;
      }
      if (value === ".") {
        if (state.braces > 0 && prev.type === "dot") {
          if (prev.value === ".")
            prev.output = DOT_LITERAL;
          const brace = braces[braces.length - 1];
          prev.type = "dots";
          prev.output += value;
          prev.value += value;
          brace.dots = true;
          continue;
        }
        if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
          push({ type: "text", value, output: DOT_LITERAL });
          continue;
        }
        push({ type: "dot", value, output: DOT_LITERAL });
        continue;
      }
      if (value === "?") {
        const isGroup = prev && prev.value === "(";
        if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          extglobOpen("qmark", value);
          continue;
        }
        if (prev && prev.type === "paren") {
          const next = peek();
          let output = value;
          if (next === "<" && !utils.supportsLookbehinds()) {
            throw new Error("Node.js v10 or higher is required for regex lookbehinds");
          }
          if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
            output = `\\${value}`;
          }
          push({ type: "text", value, output });
          continue;
        }
        if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
          push({ type: "qmark", value, output: QMARK_NO_DOT });
          continue;
        }
        push({ type: "qmark", value, output: QMARK });
        continue;
      }
      if (value === "!") {
        if (opts.noextglob !== true && peek() === "(") {
          if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
            extglobOpen("negate", value);
            continue;
          }
        }
        if (opts.nonegate !== true && state.index === 0) {
          negate();
          continue;
        }
      }
      if (value === "+") {
        if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          extglobOpen("plus", value);
          continue;
        }
        if (prev && prev.value === "(" || opts.regex === false) {
          push({ type: "plus", value, output: PLUS_LITERAL });
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
          push({ type: "plus", value });
          continue;
        }
        push({ type: "plus", value: PLUS_LITERAL });
        continue;
      }
      if (value === "@") {
        if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          push({ type: "at", extglob: true, value, output: "" });
          continue;
        }
        push({ type: "text", value });
        continue;
      }
      if (value !== "*") {
        if (value === "$" || value === "^") {
          value = `\\${value}`;
        }
        const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
        if (match) {
          value += match[0];
          state.index += match[0].length;
        }
        push({ type: "text", value });
        continue;
      }
      if (prev && (prev.type === "globstar" || prev.star === true)) {
        prev.type = "star";
        prev.star = true;
        prev.value += value;
        prev.output = star;
        state.backtrack = true;
        state.globstar = true;
        consume(value);
        continue;
      }
      let rest = remaining();
      if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
        extglobOpen("star", value);
        continue;
      }
      if (prev.type === "star") {
        if (opts.noglobstar === true) {
          consume(value);
          continue;
        }
        const prior = prev.prev;
        const before = prior.prev;
        const isStart = prior.type === "slash" || prior.type === "bos";
        const afterStar = before && (before.type === "star" || before.type === "globstar");
        if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
          push({ type: "star", value, output: "" });
          continue;
        }
        const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
        const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
        if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
          push({ type: "star", value, output: "" });
          continue;
        }
        while (rest.slice(0, 3) === "/**") {
          const after = input[state.index + 4];
          if (after && after !== "/") {
            break;
          }
          rest = rest.slice(3);
          consume("/**", 3);
        }
        if (prior.type === "bos" && eos()) {
          prev.type = "globstar";
          prev.value += value;
          prev.output = globstar(opts);
          state.output = prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = `(?:${prior.output}`;
          prev.type = "globstar";
          prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
          prev.value += value;
          state.globstar = true;
          state.output += prior.output + prev.output;
          consume(value);
          continue;
        }
        if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
          const end = rest[1] !== undefined ? "|$" : "";
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = `(?:${prior.output}`;
          prev.type = "globstar";
          prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
          prev.value += value;
          state.output += prior.output + prev.output;
          state.globstar = true;
          consume(value + advance());
          push({ type: "slash", value: "/", output: "" });
          continue;
        }
        if (prior.type === "bos" && rest[0] === "/") {
          prev.type = "globstar";
          prev.value += value;
          prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
          state.output = prev.output;
          state.globstar = true;
          consume(value + advance());
          push({ type: "slash", value: "/", output: "" });
          continue;
        }
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = "globstar";
        prev.output = globstar(opts);
        prev.value += value;
        state.output += prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }
      const token = { type: "star", value, output: star };
      if (opts.bash === true) {
        token.output = ".*?";
        if (prev.type === "bos" || prev.type === "slash") {
          token.output = nodot + token.output;
        }
        push(token);
        continue;
      }
      if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
        token.output = value;
        push(token);
        continue;
      }
      if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
        if (prev.type === "dot") {
          state.output += NO_DOT_SLASH;
          prev.output += NO_DOT_SLASH;
        } else if (opts.dot === true) {
          state.output += NO_DOTS_SLASH;
          prev.output += NO_DOTS_SLASH;
        } else {
          state.output += nodot;
          prev.output += nodot;
        }
        if (peek() !== "*") {
          state.output += ONE_CHAR;
          prev.output += ONE_CHAR;
        }
      }
      push(token);
    }
    while (state.brackets > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", "]"));
      state.output = utils.escapeLast(state.output, "[");
      decrement("brackets");
    }
    while (state.parens > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", ")"));
      state.output = utils.escapeLast(state.output, "(");
      decrement("parens");
    }
    while (state.braces > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", "}"));
      state.output = utils.escapeLast(state.output, "{");
      decrement("braces");
    }
    if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
      push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
    }
    if (state.backtrack === true) {
      state.output = "";
      for (const token of state.tokens) {
        state.output += token.output != null ? token.output : token.value;
        if (token.suffix) {
          state.output += token.suffix;
        }
      }
    }
    return state;
  };
  parse.fastpaths = (input, options) => {
    const opts = { ...options };
    const max3 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    const len = input.length;
    if (len > max3) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max3}`);
    }
    input = REPLACEMENTS[input] || input;
    const win32 = utils.isWindows(options);
    const {
      DOT_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOTS_SLASH,
      STAR,
      START_ANCHOR
    } = constants.globChars(win32);
    const nodot = opts.dot ? NO_DOTS : NO_DOT;
    const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
    const capture = opts.capture ? "" : "?:";
    const state = { negated: false, prefix: "" };
    let star = opts.bash === true ? ".*?" : STAR;
    if (opts.capture) {
      star = `(${star})`;
    }
    const globstar = (opts2) => {
      if (opts2.noglobstar === true)
        return star;
      return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const create = (str) => {
      switch (str) {
        case "*":
          return `${nodot}${ONE_CHAR}${star}`;
        case ".*":
          return `${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "*.*":
          return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "*/*":
          return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
        case "**":
          return nodot + globstar(opts);
        case "**/*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
        case "**/*.*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "**/.*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
        default: {
          const match = /^(.*?)\.(\w+)$/.exec(str);
          if (!match)
            return;
          const source2 = create(match[1]);
          if (!source2)
            return;
          return source2 + DOT_LITERAL + match[2];
        }
      }
    };
    const output = utils.removePrefix(input, state);
    let source = create(output);
    if (source && opts.strictSlashes !== true) {
      source += `${SLASH_LITERAL}?`;
    }
    return source;
  };
  module.exports = parse;
});

// node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS((exports, module) => {
  var path6 = __require("path");
  var scan3 = require_scan();
  var parse = require_parse2();
  var utils = require_utils2();
  var constants = require_constants2();
  var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
  var picomatch = (glob, options, returnState = false) => {
    if (Array.isArray(glob)) {
      const fns = glob.map((input) => picomatch(input, options, returnState));
      const arrayMatcher = (str) => {
        for (const isMatch of fns) {
          const state2 = isMatch(str);
          if (state2)
            return state2;
        }
        return false;
      };
      return arrayMatcher;
    }
    const isState = isObject(glob) && glob.tokens && glob.input;
    if (glob === "" || typeof glob !== "string" && !isState) {
      throw new TypeError("Expected pattern to be a non-empty string");
    }
    const opts = options || {};
    const posix2 = utils.isWindows(options);
    const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
    const state = regex.state;
    delete regex.state;
    let isIgnored = () => false;
    if (opts.ignore) {
      const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
      isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
    }
    const matcher = (input, returnObject = false) => {
      const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix: posix2 });
      const result = { glob, state, regex, posix: posix2, input, output, match, isMatch };
      if (typeof opts.onResult === "function") {
        opts.onResult(result);
      }
      if (isMatch === false) {
        result.isMatch = false;
        return returnObject ? result : false;
      }
      if (isIgnored(input)) {
        if (typeof opts.onIgnore === "function") {
          opts.onIgnore(result);
        }
        result.isMatch = false;
        return returnObject ? result : false;
      }
      if (typeof opts.onMatch === "function") {
        opts.onMatch(result);
      }
      return returnObject ? result : true;
    };
    if (returnState) {
      matcher.state = state;
    }
    return matcher;
  };
  picomatch.test = (input, regex, options, { glob, posix: posix2 } = {}) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected input to be a string");
    }
    if (input === "") {
      return { isMatch: false, output: "" };
    }
    const opts = options || {};
    const format3 = opts.format || (posix2 ? utils.toPosixSlashes : null);
    let match = input === glob;
    let output = match && format3 ? format3(input) : input;
    if (match === false) {
      output = format3 ? format3(input) : input;
      match = output === glob;
    }
    if (match === false || opts.capture === true) {
      if (opts.matchBase === true || opts.basename === true) {
        match = picomatch.matchBase(input, regex, options, posix2);
      } else {
        match = regex.exec(output);
      }
    }
    return { isMatch: Boolean(match), match, output };
  };
  picomatch.matchBase = (input, glob, options, posix2 = utils.isWindows(options)) => {
    const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
    return regex.test(path6.basename(input));
  };
  picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
  picomatch.parse = (pattern, options) => {
    if (Array.isArray(pattern))
      return pattern.map((p) => picomatch.parse(p, options));
    return parse(pattern, { ...options, fastpaths: false });
  };
  picomatch.scan = (input, options) => scan3(input, options);
  picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
    if (returnOutput === true) {
      return state.output;
    }
    const opts = options || {};
    const prepend = opts.contains ? "" : "^";
    const append = opts.contains ? "" : "$";
    let source = `${prepend}(?:${state.output})${append}`;
    if (state && state.negated === true) {
      source = `^(?!${source}).*$`;
    }
    const regex = picomatch.toRegex(source, options);
    if (returnState === true) {
      regex.state = state;
    }
    return regex;
  };
  picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
    if (!input || typeof input !== "string") {
      throw new TypeError("Expected a non-empty string");
    }
    let parsed = { negated: false, fastpaths: true };
    if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
      parsed.output = parse.fastpaths(input, options);
    }
    if (!parsed.output) {
      parsed = parse(input, options);
    }
    return picomatch.compileRe(parsed, options, returnOutput, returnState);
  };
  picomatch.toRegex = (source, options) => {
    try {
      const opts = options || {};
      return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
    } catch (err) {
      if (options && options.debug === true)
        throw err;
      return /$^/;
    }
  };
  picomatch.constants = constants;
  module.exports = picomatch;
});

// node_modules/micromatch/index.js
var require_micromatch = __commonJS((exports, module) => {
  var util = __require("util");
  var braces = require_braces();
  var picomatch = require_picomatch();
  var utils = require_utils2();
  var isEmptyString = (v) => v === "" || v === "./";
  var hasBraces = (v) => {
    const index = v.indexOf("{");
    return index > -1 && v.indexOf("}", index) > -1;
  };
  var micromatch = (list, patterns, options) => {
    patterns = [].concat(patterns);
    list = [].concat(list);
    let omit = new Set;
    let keep = new Set;
    let items = new Set;
    let negatives = 0;
    let onResult = (state) => {
      items.add(state.output);
      if (options && options.onResult) {
        options.onResult(state);
      }
    };
    for (let i = 0;i < patterns.length; i++) {
      let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
      let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
      if (negated)
        negatives++;
      for (let item of list) {
        let matched = isMatch(item, true);
        let match = negated ? !matched.isMatch : matched.isMatch;
        if (!match)
          continue;
        if (negated) {
          omit.add(matched.output);
        } else {
          omit.delete(matched.output);
          keep.add(matched.output);
        }
      }
    }
    let result = negatives === patterns.length ? [...items] : [...keep];
    let matches = result.filter((item) => !omit.has(item));
    if (options && matches.length === 0) {
      if (options.failglob === true) {
        throw new Error(`No matches found for "${patterns.join(", ")}"`);
      }
      if (options.nonull === true || options.nullglob === true) {
        return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
      }
    }
    return matches;
  };
  micromatch.match = micromatch;
  micromatch.matcher = (pattern, options) => picomatch(pattern, options);
  micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
  micromatch.any = micromatch.isMatch;
  micromatch.not = (list, patterns, options = {}) => {
    patterns = [].concat(patterns).map(String);
    let result = new Set;
    let items = [];
    let onResult = (state) => {
      if (options.onResult)
        options.onResult(state);
      items.push(state.output);
    };
    let matches = new Set(micromatch(list, patterns, { ...options, onResult }));
    for (let item of items) {
      if (!matches.has(item)) {
        result.add(item);
      }
    }
    return [...result];
  };
  micromatch.contains = (str, pattern, options) => {
    if (typeof str !== "string") {
      throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
    }
    if (Array.isArray(pattern)) {
      return pattern.some((p) => micromatch.contains(str, p, options));
    }
    if (typeof pattern === "string") {
      if (isEmptyString(str) || isEmptyString(pattern)) {
        return false;
      }
      if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
        return true;
      }
    }
    return micromatch.isMatch(str, pattern, { ...options, contains: true });
  };
  micromatch.matchKeys = (obj, patterns, options) => {
    if (!utils.isObject(obj)) {
      throw new TypeError("Expected the first argument to be an object");
    }
    let keys3 = micromatch(Object.keys(obj), patterns, options);
    let res = {};
    for (let key of keys3)
      res[key] = obj[key];
    return res;
  };
  micromatch.some = (list, patterns, options) => {
    let items = [].concat(list);
    for (let pattern of [].concat(patterns)) {
      let isMatch = picomatch(String(pattern), options);
      if (items.some((item) => isMatch(item))) {
        return true;
      }
    }
    return false;
  };
  micromatch.every = (list, patterns, options) => {
    let items = [].concat(list);
    for (let pattern of [].concat(patterns)) {
      let isMatch = picomatch(String(pattern), options);
      if (!items.every((item) => isMatch(item))) {
        return false;
      }
    }
    return true;
  };
  micromatch.all = (str, patterns, options) => {
    if (typeof str !== "string") {
      throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
    }
    return [].concat(patterns).every((p) => picomatch(p, options)(str));
  };
  micromatch.capture = (glob, input, options) => {
    let posix2 = utils.isWindows(options);
    let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
    let match = regex.exec(posix2 ? utils.toPosixSlashes(input) : input);
    if (match) {
      return match.slice(1).map((v) => v === undefined ? "" : v);
    }
  };
  micromatch.makeRe = (...args) => picomatch.makeRe(...args);
  micromatch.scan = (...args) => picomatch.scan(...args);
  micromatch.parse = (patterns, options) => {
    let res = [];
    for (let pattern of [].concat(patterns || [])) {
      for (let str of braces(String(pattern), options)) {
        res.push(picomatch.parse(str, options));
      }
    }
    return res;
  };
  micromatch.braces = (pattern, options) => {
    if (typeof pattern !== "string")
      throw new TypeError("Expected a string");
    if (options && options.nobrace === true || !hasBraces(pattern)) {
      return [pattern];
    }
    return braces(pattern, options);
  };
  micromatch.braceExpand = (pattern, options) => {
    if (typeof pattern !== "string")
      throw new TypeError("Expected a string");
    return micromatch.braces(pattern, { ...options, expand: true });
  };
  micromatch.hasBraces = hasBraces;
  module.exports = micromatch;
});

// node_modules/esprima/dist/esprima.js
var require_esprima = __commonJS((exports, module) => {
  (function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === "object" && typeof module === "object")
      module.exports = factory();
    else if (typeof define === "function" && define.amd)
      define([], factory);
    else if (typeof exports === "object")
      exports["esprima"] = factory();
    else
      root["esprima"] = factory();
  })(exports, function() {
    return function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId])
          return installedModules[moduleId].exports;
        var module2 = installedModules[moduleId] = {
          exports: {},
          id: moduleId,
          loaded: false
        };
        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
        module2.loaded = true;
        return module2.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.p = "";
      return __webpack_require__(0);
    }([
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var comment_handler_1 = __webpack_require__(1);
        var jsx_parser_1 = __webpack_require__(3);
        var parser_1 = __webpack_require__(8);
        var tokenizer_1 = __webpack_require__(15);
        function parse(code, options, delegate) {
          var commentHandler = null;
          var proxyDelegate = function(node, metadata) {
            if (delegate) {
              delegate(node, metadata);
            }
            if (commentHandler) {
              commentHandler.visit(node, metadata);
            }
          };
          var parserDelegate = typeof delegate === "function" ? proxyDelegate : null;
          var collectComment = false;
          if (options) {
            collectComment = typeof options.comment === "boolean" && options.comment;
            var attachComment = typeof options.attachComment === "boolean" && options.attachComment;
            if (collectComment || attachComment) {
              commentHandler = new comment_handler_1.CommentHandler;
              commentHandler.attach = attachComment;
              options.comment = true;
              parserDelegate = proxyDelegate;
            }
          }
          var isModule = false;
          if (options && typeof options.sourceType === "string") {
            isModule = options.sourceType === "module";
          }
          var parser;
          if (options && typeof options.jsx === "boolean" && options.jsx) {
            parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
          } else {
            parser = new parser_1.Parser(code, options, parserDelegate);
          }
          var program = isModule ? parser.parseModule() : parser.parseScript();
          var ast = program;
          if (collectComment && commentHandler) {
            ast.comments = commentHandler.comments;
          }
          if (parser.config.tokens) {
            ast.tokens = parser.tokens;
          }
          if (parser.config.tolerant) {
            ast.errors = parser.errorHandler.errors;
          }
          return ast;
        }
        exports2.parse = parse;
        function parseModule(code, options, delegate) {
          var parsingOptions = options || {};
          parsingOptions.sourceType = "module";
          return parse(code, parsingOptions, delegate);
        }
        exports2.parseModule = parseModule;
        function parseScript(code, options, delegate) {
          var parsingOptions = options || {};
          parsingOptions.sourceType = "script";
          return parse(code, parsingOptions, delegate);
        }
        exports2.parseScript = parseScript;
        function tokenize(code, options, delegate) {
          var tokenizer = new tokenizer_1.Tokenizer(code, options);
          var tokens;
          tokens = [];
          try {
            while (true) {
              var token = tokenizer.getNextToken();
              if (!token) {
                break;
              }
              if (delegate) {
                token = delegate(token);
              }
              tokens.push(token);
            }
          } catch (e) {
            tokenizer.errorHandler.tolerate(e);
          }
          if (tokenizer.errorHandler.tolerant) {
            tokens.errors = tokenizer.errors();
          }
          return tokens;
        }
        exports2.tokenize = tokenize;
        var syntax_1 = __webpack_require__(2);
        exports2.Syntax = syntax_1.Syntax;
        exports2.version = "4.0.1";
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var syntax_1 = __webpack_require__(2);
        var CommentHandler = function() {
          function CommentHandler2() {
            this.attach = false;
            this.comments = [];
            this.stack = [];
            this.leading = [];
            this.trailing = [];
          }
          CommentHandler2.prototype.insertInnerComments = function(node, metadata) {
            if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
              var innerComments = [];
              for (var i = this.leading.length - 1;i >= 0; --i) {
                var entry = this.leading[i];
                if (metadata.end.offset >= entry.start) {
                  innerComments.unshift(entry.comment);
                  this.leading.splice(i, 1);
                  this.trailing.splice(i, 1);
                }
              }
              if (innerComments.length) {
                node.innerComments = innerComments;
              }
            }
          };
          CommentHandler2.prototype.findTrailingComments = function(metadata) {
            var trailingComments = [];
            if (this.trailing.length > 0) {
              for (var i = this.trailing.length - 1;i >= 0; --i) {
                var entry_1 = this.trailing[i];
                if (entry_1.start >= metadata.end.offset) {
                  trailingComments.unshift(entry_1.comment);
                }
              }
              this.trailing.length = 0;
              return trailingComments;
            }
            var entry = this.stack[this.stack.length - 1];
            if (entry && entry.node.trailingComments) {
              var firstComment = entry.node.trailingComments[0];
              if (firstComment && firstComment.range[0] >= metadata.end.offset) {
                trailingComments = entry.node.trailingComments;
                delete entry.node.trailingComments;
              }
            }
            return trailingComments;
          };
          CommentHandler2.prototype.findLeadingComments = function(metadata) {
            var leadingComments = [];
            var target;
            while (this.stack.length > 0) {
              var entry = this.stack[this.stack.length - 1];
              if (entry && entry.start >= metadata.start.offset) {
                target = entry.node;
                this.stack.pop();
              } else {
                break;
              }
            }
            if (target) {
              var count3 = target.leadingComments ? target.leadingComments.length : 0;
              for (var i = count3 - 1;i >= 0; --i) {
                var comment = target.leadingComments[i];
                if (comment.range[1] <= metadata.start.offset) {
                  leadingComments.unshift(comment);
                  target.leadingComments.splice(i, 1);
                }
              }
              if (target.leadingComments && target.leadingComments.length === 0) {
                delete target.leadingComments;
              }
              return leadingComments;
            }
            for (var i = this.leading.length - 1;i >= 0; --i) {
              var entry = this.leading[i];
              if (entry.start <= metadata.start.offset) {
                leadingComments.unshift(entry.comment);
                this.leading.splice(i, 1);
              }
            }
            return leadingComments;
          };
          CommentHandler2.prototype.visitNode = function(node, metadata) {
            if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
              return;
            }
            this.insertInnerComments(node, metadata);
            var trailingComments = this.findTrailingComments(metadata);
            var leadingComments = this.findLeadingComments(metadata);
            if (leadingComments.length > 0) {
              node.leadingComments = leadingComments;
            }
            if (trailingComments.length > 0) {
              node.trailingComments = trailingComments;
            }
            this.stack.push({
              node,
              start: metadata.start.offset
            });
          };
          CommentHandler2.prototype.visitComment = function(node, metadata) {
            var type = node.type[0] === "L" ? "Line" : "Block";
            var comment = {
              type,
              value: node.value
            };
            if (node.range) {
              comment.range = node.range;
            }
            if (node.loc) {
              comment.loc = node.loc;
            }
            this.comments.push(comment);
            if (this.attach) {
              var entry = {
                comment: {
                  type,
                  value: node.value,
                  range: [metadata.start.offset, metadata.end.offset]
                },
                start: metadata.start.offset
              };
              if (node.loc) {
                entry.comment.loc = node.loc;
              }
              node.type = type;
              this.leading.push(entry);
              this.trailing.push(entry);
            }
          };
          CommentHandler2.prototype.visit = function(node, metadata) {
            if (node.type === "LineComment") {
              this.visitComment(node, metadata);
            } else if (node.type === "BlockComment") {
              this.visitComment(node, metadata);
            } else if (this.attach) {
              this.visitNode(node, metadata);
            }
          };
          return CommentHandler2;
        }();
        exports2.CommentHandler = CommentHandler;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.Syntax = {
          AssignmentExpression: "AssignmentExpression",
          AssignmentPattern: "AssignmentPattern",
          ArrayExpression: "ArrayExpression",
          ArrayPattern: "ArrayPattern",
          ArrowFunctionExpression: "ArrowFunctionExpression",
          AwaitExpression: "AwaitExpression",
          BlockStatement: "BlockStatement",
          BinaryExpression: "BinaryExpression",
          BreakStatement: "BreakStatement",
          CallExpression: "CallExpression",
          CatchClause: "CatchClause",
          ClassBody: "ClassBody",
          ClassDeclaration: "ClassDeclaration",
          ClassExpression: "ClassExpression",
          ConditionalExpression: "ConditionalExpression",
          ContinueStatement: "ContinueStatement",
          DoWhileStatement: "DoWhileStatement",
          DebuggerStatement: "DebuggerStatement",
          EmptyStatement: "EmptyStatement",
          ExportAllDeclaration: "ExportAllDeclaration",
          ExportDefaultDeclaration: "ExportDefaultDeclaration",
          ExportNamedDeclaration: "ExportNamedDeclaration",
          ExportSpecifier: "ExportSpecifier",
          ExpressionStatement: "ExpressionStatement",
          ForStatement: "ForStatement",
          ForOfStatement: "ForOfStatement",
          ForInStatement: "ForInStatement",
          FunctionDeclaration: "FunctionDeclaration",
          FunctionExpression: "FunctionExpression",
          Identifier: "Identifier",
          IfStatement: "IfStatement",
          ImportDeclaration: "ImportDeclaration",
          ImportDefaultSpecifier: "ImportDefaultSpecifier",
          ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
          ImportSpecifier: "ImportSpecifier",
          Literal: "Literal",
          LabeledStatement: "LabeledStatement",
          LogicalExpression: "LogicalExpression",
          MemberExpression: "MemberExpression",
          MetaProperty: "MetaProperty",
          MethodDefinition: "MethodDefinition",
          NewExpression: "NewExpression",
          ObjectExpression: "ObjectExpression",
          ObjectPattern: "ObjectPattern",
          Program: "Program",
          Property: "Property",
          RestElement: "RestElement",
          ReturnStatement: "ReturnStatement",
          SequenceExpression: "SequenceExpression",
          SpreadElement: "SpreadElement",
          Super: "Super",
          SwitchCase: "SwitchCase",
          SwitchStatement: "SwitchStatement",
          TaggedTemplateExpression: "TaggedTemplateExpression",
          TemplateElement: "TemplateElement",
          TemplateLiteral: "TemplateLiteral",
          ThisExpression: "ThisExpression",
          ThrowStatement: "ThrowStatement",
          TryStatement: "TryStatement",
          UnaryExpression: "UnaryExpression",
          UpdateExpression: "UpdateExpression",
          VariableDeclaration: "VariableDeclaration",
          VariableDeclarator: "VariableDeclarator",
          WhileStatement: "WhileStatement",
          WithStatement: "WithStatement",
          YieldExpression: "YieldExpression"
        };
      },
      function(module2, exports2, __webpack_require__) {
        var __extends = this && this.__extends || function() {
          var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
            d.__proto__ = b;
          } || function(d, b) {
            for (var p in b)
              if (b.hasOwnProperty(p))
                d[p] = b[p];
          };
          return function(d, b) {
            extendStatics(d, b);
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
          };
        }();
        Object.defineProperty(exports2, "__esModule", { value: true });
        var character_1 = __webpack_require__(4);
        var JSXNode = __webpack_require__(5);
        var jsx_syntax_1 = __webpack_require__(6);
        var Node = __webpack_require__(7);
        var parser_1 = __webpack_require__(8);
        var token_1 = __webpack_require__(13);
        var xhtml_entities_1 = __webpack_require__(14);
        token_1.TokenName[100] = "JSXIdentifier";
        token_1.TokenName[101] = "JSXText";
        function getQualifiedElementName(elementName) {
          var qualifiedName;
          switch (elementName.type) {
            case jsx_syntax_1.JSXSyntax.JSXIdentifier:
              var id = elementName;
              qualifiedName = id.name;
              break;
            case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
              var ns = elementName;
              qualifiedName = getQualifiedElementName(ns.namespace) + ":" + getQualifiedElementName(ns.name);
              break;
            case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
              var expr = elementName;
              qualifiedName = getQualifiedElementName(expr.object) + "." + getQualifiedElementName(expr.property);
              break;
            default:
              break;
          }
          return qualifiedName;
        }
        var JSXParser = function(_super) {
          __extends(JSXParser2, _super);
          function JSXParser2(code, options, delegate) {
            return _super.call(this, code, options, delegate) || this;
          }
          JSXParser2.prototype.parsePrimaryExpression = function() {
            return this.match("<") ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
          };
          JSXParser2.prototype.startJSX = function() {
            this.scanner.index = this.startMarker.index;
            this.scanner.lineNumber = this.startMarker.line;
            this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
          };
          JSXParser2.prototype.finishJSX = function() {
            this.nextToken();
          };
          JSXParser2.prototype.reenterJSX = function() {
            this.startJSX();
            this.expectJSX("}");
            if (this.config.tokens) {
              this.tokens.pop();
            }
          };
          JSXParser2.prototype.createJSXNode = function() {
            this.collectComments();
            return {
              index: this.scanner.index,
              line: this.scanner.lineNumber,
              column: this.scanner.index - this.scanner.lineStart
            };
          };
          JSXParser2.prototype.createJSXChildNode = function() {
            return {
              index: this.scanner.index,
              line: this.scanner.lineNumber,
              column: this.scanner.index - this.scanner.lineStart
            };
          };
          JSXParser2.prototype.scanXHTMLEntity = function(quote) {
            var result = "&";
            var valid = true;
            var terminated = false;
            var numeric = false;
            var hex = false;
            while (!this.scanner.eof() && valid && !terminated) {
              var ch = this.scanner.source[this.scanner.index];
              if (ch === quote) {
                break;
              }
              terminated = ch === ";";
              result += ch;
              ++this.scanner.index;
              if (!terminated) {
                switch (result.length) {
                  case 2:
                    numeric = ch === "#";
                    break;
                  case 3:
                    if (numeric) {
                      hex = ch === "x";
                      valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
                      numeric = numeric && !hex;
                    }
                    break;
                  default:
                    valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
                    valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
                    break;
                }
              }
            }
            if (valid && terminated && result.length > 2) {
              var str = result.substr(1, result.length - 2);
              if (numeric && str.length > 1) {
                result = String.fromCharCode(parseInt(str.substr(1), 10));
              } else if (hex && str.length > 2) {
                result = String.fromCharCode(parseInt("0" + str.substr(1), 16));
              } else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
                result = xhtml_entities_1.XHTMLEntities[str];
              }
            }
            return result;
          };
          JSXParser2.prototype.lexJSX = function() {
            var cp = this.scanner.source.charCodeAt(this.scanner.index);
            if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
              var value = this.scanner.source[this.scanner.index++];
              return {
                type: 7,
                value,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start: this.scanner.index - 1,
                end: this.scanner.index
              };
            }
            if (cp === 34 || cp === 39) {
              var start = this.scanner.index;
              var quote = this.scanner.source[this.scanner.index++];
              var str = "";
              while (!this.scanner.eof()) {
                var ch = this.scanner.source[this.scanner.index++];
                if (ch === quote) {
                  break;
                } else if (ch === "&") {
                  str += this.scanXHTMLEntity(quote);
                } else {
                  str += ch;
                }
              }
              return {
                type: 8,
                value: str,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start,
                end: this.scanner.index
              };
            }
            if (cp === 46) {
              var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
              var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
              var value = n1 === 46 && n2 === 46 ? "..." : ".";
              var start = this.scanner.index;
              this.scanner.index += value.length;
              return {
                type: 7,
                value,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start,
                end: this.scanner.index
              };
            }
            if (cp === 96) {
              return {
                type: 10,
                value: "",
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start: this.scanner.index,
                end: this.scanner.index
              };
            }
            if (character_1.Character.isIdentifierStart(cp) && cp !== 92) {
              var start = this.scanner.index;
              ++this.scanner.index;
              while (!this.scanner.eof()) {
                var ch = this.scanner.source.charCodeAt(this.scanner.index);
                if (character_1.Character.isIdentifierPart(ch) && ch !== 92) {
                  ++this.scanner.index;
                } else if (ch === 45) {
                  ++this.scanner.index;
                } else {
                  break;
                }
              }
              var id = this.scanner.source.slice(start, this.scanner.index);
              return {
                type: 100,
                value: id,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start,
                end: this.scanner.index
              };
            }
            return this.scanner.lex();
          };
          JSXParser2.prototype.nextJSXToken = function() {
            this.collectComments();
            this.startMarker.index = this.scanner.index;
            this.startMarker.line = this.scanner.lineNumber;
            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
            var token = this.lexJSX();
            this.lastMarker.index = this.scanner.index;
            this.lastMarker.line = this.scanner.lineNumber;
            this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
            if (this.config.tokens) {
              this.tokens.push(this.convertToken(token));
            }
            return token;
          };
          JSXParser2.prototype.nextJSXText = function() {
            this.startMarker.index = this.scanner.index;
            this.startMarker.line = this.scanner.lineNumber;
            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
            var start = this.scanner.index;
            var text = "";
            while (!this.scanner.eof()) {
              var ch = this.scanner.source[this.scanner.index];
              if (ch === "{" || ch === "<") {
                break;
              }
              ++this.scanner.index;
              text += ch;
              if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                ++this.scanner.lineNumber;
                if (ch === "\r" && this.scanner.source[this.scanner.index] === `
`) {
                  ++this.scanner.index;
                }
                this.scanner.lineStart = this.scanner.index;
              }
            }
            this.lastMarker.index = this.scanner.index;
            this.lastMarker.line = this.scanner.lineNumber;
            this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
            var token = {
              type: 101,
              value: text,
              lineNumber: this.scanner.lineNumber,
              lineStart: this.scanner.lineStart,
              start,
              end: this.scanner.index
            };
            if (text.length > 0 && this.config.tokens) {
              this.tokens.push(this.convertToken(token));
            }
            return token;
          };
          JSXParser2.prototype.peekJSXToken = function() {
            var state = this.scanner.saveState();
            this.scanner.scanComments();
            var next = this.lexJSX();
            this.scanner.restoreState(state);
            return next;
          };
          JSXParser2.prototype.expectJSX = function(value) {
            var token = this.nextJSXToken();
            if (token.type !== 7 || token.value !== value) {
              this.throwUnexpectedToken(token);
            }
          };
          JSXParser2.prototype.matchJSX = function(value) {
            var next = this.peekJSXToken();
            return next.type === 7 && next.value === value;
          };
          JSXParser2.prototype.parseJSXIdentifier = function() {
            var node = this.createJSXNode();
            var token = this.nextJSXToken();
            if (token.type !== 100) {
              this.throwUnexpectedToken(token);
            }
            return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
          };
          JSXParser2.prototype.parseJSXElementName = function() {
            var node = this.createJSXNode();
            var elementName = this.parseJSXIdentifier();
            if (this.matchJSX(":")) {
              var namespace = elementName;
              this.expectJSX(":");
              var name_1 = this.parseJSXIdentifier();
              elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
            } else if (this.matchJSX(".")) {
              while (this.matchJSX(".")) {
                var object = elementName;
                this.expectJSX(".");
                var property = this.parseJSXIdentifier();
                elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
              }
            }
            return elementName;
          };
          JSXParser2.prototype.parseJSXAttributeName = function() {
            var node = this.createJSXNode();
            var attributeName;
            var identifier = this.parseJSXIdentifier();
            if (this.matchJSX(":")) {
              var namespace = identifier;
              this.expectJSX(":");
              var name_2 = this.parseJSXIdentifier();
              attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
            } else {
              attributeName = identifier;
            }
            return attributeName;
          };
          JSXParser2.prototype.parseJSXStringLiteralAttribute = function() {
            var node = this.createJSXNode();
            var token = this.nextJSXToken();
            if (token.type !== 8) {
              this.throwUnexpectedToken(token);
            }
            var raw = this.getTokenRaw(token);
            return this.finalize(node, new Node.Literal(token.value, raw));
          };
          JSXParser2.prototype.parseJSXExpressionAttribute = function() {
            var node = this.createJSXNode();
            this.expectJSX("{");
            this.finishJSX();
            if (this.match("}")) {
              this.tolerateError("JSX attributes must only be assigned a non-empty expression");
            }
            var expression = this.parseAssignmentExpression();
            this.reenterJSX();
            return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
          };
          JSXParser2.prototype.parseJSXAttributeValue = function() {
            return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
          };
          JSXParser2.prototype.parseJSXNameValueAttribute = function() {
            var node = this.createJSXNode();
            var name = this.parseJSXAttributeName();
            var value = null;
            if (this.matchJSX("=")) {
              this.expectJSX("=");
              value = this.parseJSXAttributeValue();
            }
            return this.finalize(node, new JSXNode.JSXAttribute(name, value));
          };
          JSXParser2.prototype.parseJSXSpreadAttribute = function() {
            var node = this.createJSXNode();
            this.expectJSX("{");
            this.expectJSX("...");
            this.finishJSX();
            var argument = this.parseAssignmentExpression();
            this.reenterJSX();
            return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
          };
          JSXParser2.prototype.parseJSXAttributes = function() {
            var attributes = [];
            while (!this.matchJSX("/") && !this.matchJSX(">")) {
              var attribute = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
              attributes.push(attribute);
            }
            return attributes;
          };
          JSXParser2.prototype.parseJSXOpeningElement = function() {
            var node = this.createJSXNode();
            this.expectJSX("<");
            var name = this.parseJSXElementName();
            var attributes = this.parseJSXAttributes();
            var selfClosing = this.matchJSX("/");
            if (selfClosing) {
              this.expectJSX("/");
            }
            this.expectJSX(">");
            return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
          };
          JSXParser2.prototype.parseJSXBoundaryElement = function() {
            var node = this.createJSXNode();
            this.expectJSX("<");
            if (this.matchJSX("/")) {
              this.expectJSX("/");
              var name_3 = this.parseJSXElementName();
              this.expectJSX(">");
              return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
            }
            var name = this.parseJSXElementName();
            var attributes = this.parseJSXAttributes();
            var selfClosing = this.matchJSX("/");
            if (selfClosing) {
              this.expectJSX("/");
            }
            this.expectJSX(">");
            return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
          };
          JSXParser2.prototype.parseJSXEmptyExpression = function() {
            var node = this.createJSXChildNode();
            this.collectComments();
            this.lastMarker.index = this.scanner.index;
            this.lastMarker.line = this.scanner.lineNumber;
            this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
            return this.finalize(node, new JSXNode.JSXEmptyExpression);
          };
          JSXParser2.prototype.parseJSXExpressionContainer = function() {
            var node = this.createJSXNode();
            this.expectJSX("{");
            var expression;
            if (this.matchJSX("}")) {
              expression = this.parseJSXEmptyExpression();
              this.expectJSX("}");
            } else {
              this.finishJSX();
              expression = this.parseAssignmentExpression();
              this.reenterJSX();
            }
            return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
          };
          JSXParser2.prototype.parseJSXChildren = function() {
            var children = [];
            while (!this.scanner.eof()) {
              var node = this.createJSXChildNode();
              var token = this.nextJSXText();
              if (token.start < token.end) {
                var raw = this.getTokenRaw(token);
                var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
                children.push(child);
              }
              if (this.scanner.source[this.scanner.index] === "{") {
                var container = this.parseJSXExpressionContainer();
                children.push(container);
              } else {
                break;
              }
            }
            return children;
          };
          JSXParser2.prototype.parseComplexJSXElement = function(el) {
            var stack = [];
            while (!this.scanner.eof()) {
              el.children = el.children.concat(this.parseJSXChildren());
              var node = this.createJSXChildNode();
              var element = this.parseJSXBoundaryElement();
              if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
                var opening = element;
                if (opening.selfClosing) {
                  var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
                  el.children.push(child);
                } else {
                  stack.push(el);
                  el = { node, opening, closing: null, children: [] };
                }
              }
              if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
                el.closing = element;
                var open_1 = getQualifiedElementName(el.opening.name);
                var close_1 = getQualifiedElementName(el.closing.name);
                if (open_1 !== close_1) {
                  this.tolerateError("Expected corresponding JSX closing tag for %0", open_1);
                }
                if (stack.length > 0) {
                  var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
                  el = stack[stack.length - 1];
                  el.children.push(child);
                  stack.pop();
                } else {
                  break;
                }
              }
            }
            return el;
          };
          JSXParser2.prototype.parseJSXElement = function() {
            var node = this.createJSXNode();
            var opening = this.parseJSXOpeningElement();
            var children = [];
            var closing = null;
            if (!opening.selfClosing) {
              var el = this.parseComplexJSXElement({ node, opening, closing, children });
              children = el.children;
              closing = el.closing;
            }
            return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
          };
          JSXParser2.prototype.parseJSXRoot = function() {
            if (this.config.tokens) {
              this.tokens.pop();
            }
            this.startJSX();
            var element = this.parseJSXElement();
            this.finishJSX();
            return element;
          };
          JSXParser2.prototype.isStartOfExpression = function() {
            return _super.prototype.isStartOfExpression.call(this) || this.match("<");
          };
          return JSXParser2;
        }(parser_1.Parser);
        exports2.JSXParser = JSXParser;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var Regex = {
          NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
          NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
        };
        exports2.Character = {
          fromCodePoint: function(cp) {
            return cp < 65536 ? String.fromCharCode(cp) : String.fromCharCode(55296 + (cp - 65536 >> 10)) + String.fromCharCode(56320 + (cp - 65536 & 1023));
          },
          isWhiteSpace: function(cp) {
            return cp === 32 || cp === 9 || cp === 11 || cp === 12 || cp === 160 || cp >= 5760 && [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(cp) >= 0;
          },
          isLineTerminator: function(cp) {
            return cp === 10 || cp === 13 || cp === 8232 || cp === 8233;
          },
          isIdentifierStart: function(cp) {
            return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierStart.test(exports2.Character.fromCodePoint(cp));
          },
          isIdentifierPart: function(cp) {
            return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp >= 48 && cp <= 57 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierPart.test(exports2.Character.fromCodePoint(cp));
          },
          isDecimalDigit: function(cp) {
            return cp >= 48 && cp <= 57;
          },
          isHexDigit: function(cp) {
            return cp >= 48 && cp <= 57 || cp >= 65 && cp <= 70 || cp >= 97 && cp <= 102;
          },
          isOctalDigit: function(cp) {
            return cp >= 48 && cp <= 55;
          }
        };
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var jsx_syntax_1 = __webpack_require__(6);
        var JSXClosingElement = function() {
          function JSXClosingElement2(name) {
            this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
            this.name = name;
          }
          return JSXClosingElement2;
        }();
        exports2.JSXClosingElement = JSXClosingElement;
        var JSXElement = function() {
          function JSXElement2(openingElement, children, closingElement) {
            this.type = jsx_syntax_1.JSXSyntax.JSXElement;
            this.openingElement = openingElement;
            this.children = children;
            this.closingElement = closingElement;
          }
          return JSXElement2;
        }();
        exports2.JSXElement = JSXElement;
        var JSXEmptyExpression = function() {
          function JSXEmptyExpression2() {
            this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
          }
          return JSXEmptyExpression2;
        }();
        exports2.JSXEmptyExpression = JSXEmptyExpression;
        var JSXExpressionContainer = function() {
          function JSXExpressionContainer2(expression) {
            this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
            this.expression = expression;
          }
          return JSXExpressionContainer2;
        }();
        exports2.JSXExpressionContainer = JSXExpressionContainer;
        var JSXIdentifier = function() {
          function JSXIdentifier2(name) {
            this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
            this.name = name;
          }
          return JSXIdentifier2;
        }();
        exports2.JSXIdentifier = JSXIdentifier;
        var JSXMemberExpression = function() {
          function JSXMemberExpression2(object, property) {
            this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
            this.object = object;
            this.property = property;
          }
          return JSXMemberExpression2;
        }();
        exports2.JSXMemberExpression = JSXMemberExpression;
        var JSXAttribute = function() {
          function JSXAttribute2(name, value) {
            this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
            this.name = name;
            this.value = value;
          }
          return JSXAttribute2;
        }();
        exports2.JSXAttribute = JSXAttribute;
        var JSXNamespacedName = function() {
          function JSXNamespacedName2(namespace, name) {
            this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
            this.namespace = namespace;
            this.name = name;
          }
          return JSXNamespacedName2;
        }();
        exports2.JSXNamespacedName = JSXNamespacedName;
        var JSXOpeningElement = function() {
          function JSXOpeningElement2(name, selfClosing, attributes) {
            this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
            this.name = name;
            this.selfClosing = selfClosing;
            this.attributes = attributes;
          }
          return JSXOpeningElement2;
        }();
        exports2.JSXOpeningElement = JSXOpeningElement;
        var JSXSpreadAttribute = function() {
          function JSXSpreadAttribute2(argument) {
            this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
            this.argument = argument;
          }
          return JSXSpreadAttribute2;
        }();
        exports2.JSXSpreadAttribute = JSXSpreadAttribute;
        var JSXText = function() {
          function JSXText2(value, raw) {
            this.type = jsx_syntax_1.JSXSyntax.JSXText;
            this.value = value;
            this.raw = raw;
          }
          return JSXText2;
        }();
        exports2.JSXText = JSXText;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.JSXSyntax = {
          JSXAttribute: "JSXAttribute",
          JSXClosingElement: "JSXClosingElement",
          JSXElement: "JSXElement",
          JSXEmptyExpression: "JSXEmptyExpression",
          JSXExpressionContainer: "JSXExpressionContainer",
          JSXIdentifier: "JSXIdentifier",
          JSXMemberExpression: "JSXMemberExpression",
          JSXNamespacedName: "JSXNamespacedName",
          JSXOpeningElement: "JSXOpeningElement",
          JSXSpreadAttribute: "JSXSpreadAttribute",
          JSXText: "JSXText"
        };
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var syntax_1 = __webpack_require__(2);
        var ArrayExpression = function() {
          function ArrayExpression2(elements) {
            this.type = syntax_1.Syntax.ArrayExpression;
            this.elements = elements;
          }
          return ArrayExpression2;
        }();
        exports2.ArrayExpression = ArrayExpression;
        var ArrayPattern = function() {
          function ArrayPattern2(elements) {
            this.type = syntax_1.Syntax.ArrayPattern;
            this.elements = elements;
          }
          return ArrayPattern2;
        }();
        exports2.ArrayPattern = ArrayPattern;
        var ArrowFunctionExpression = function() {
          function ArrowFunctionExpression2(params, body, expression) {
            this.type = syntax_1.Syntax.ArrowFunctionExpression;
            this.id = null;
            this.params = params;
            this.body = body;
            this.generator = false;
            this.expression = expression;
            this.async = false;
          }
          return ArrowFunctionExpression2;
        }();
        exports2.ArrowFunctionExpression = ArrowFunctionExpression;
        var AssignmentExpression = function() {
          function AssignmentExpression2(operator, left, right) {
            this.type = syntax_1.Syntax.AssignmentExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
          }
          return AssignmentExpression2;
        }();
        exports2.AssignmentExpression = AssignmentExpression;
        var AssignmentPattern = function() {
          function AssignmentPattern2(left, right) {
            this.type = syntax_1.Syntax.AssignmentPattern;
            this.left = left;
            this.right = right;
          }
          return AssignmentPattern2;
        }();
        exports2.AssignmentPattern = AssignmentPattern;
        var AsyncArrowFunctionExpression = function() {
          function AsyncArrowFunctionExpression2(params, body, expression) {
            this.type = syntax_1.Syntax.ArrowFunctionExpression;
            this.id = null;
            this.params = params;
            this.body = body;
            this.generator = false;
            this.expression = expression;
            this.async = true;
          }
          return AsyncArrowFunctionExpression2;
        }();
        exports2.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
        var AsyncFunctionDeclaration = function() {
          function AsyncFunctionDeclaration2(id, params, body) {
            this.type = syntax_1.Syntax.FunctionDeclaration;
            this.id = id;
            this.params = params;
            this.body = body;
            this.generator = false;
            this.expression = false;
            this.async = true;
          }
          return AsyncFunctionDeclaration2;
        }();
        exports2.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
        var AsyncFunctionExpression = function() {
          function AsyncFunctionExpression2(id, params, body) {
            this.type = syntax_1.Syntax.FunctionExpression;
            this.id = id;
            this.params = params;
            this.body = body;
            this.generator = false;
            this.expression = false;
            this.async = true;
          }
          return AsyncFunctionExpression2;
        }();
        exports2.AsyncFunctionExpression = AsyncFunctionExpression;
        var AwaitExpression = function() {
          function AwaitExpression2(argument) {
            this.type = syntax_1.Syntax.AwaitExpression;
            this.argument = argument;
          }
          return AwaitExpression2;
        }();
        exports2.AwaitExpression = AwaitExpression;
        var BinaryExpression = function() {
          function BinaryExpression2(operator, left, right) {
            var logical = operator === "||" || operator === "&&";
            this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
          }
          return BinaryExpression2;
        }();
        exports2.BinaryExpression = BinaryExpression;
        var BlockStatement = function() {
          function BlockStatement2(body) {
            this.type = syntax_1.Syntax.BlockStatement;
            this.body = body;
          }
          return BlockStatement2;
        }();
        exports2.BlockStatement = BlockStatement;
        var BreakStatement = function() {
          function BreakStatement2(label) {
            this.type = syntax_1.Syntax.BreakStatement;
            this.label = label;
          }
          return BreakStatement2;
        }();
        exports2.BreakStatement = BreakStatement;
        var CallExpression = function() {
          function CallExpression2(callee, args) {
            this.type = syntax_1.Syntax.CallExpression;
            this.callee = callee;
            this.arguments = args;
          }
          return CallExpression2;
        }();
        exports2.CallExpression = CallExpression;
        var CatchClause = function() {
          function CatchClause2(param, body) {
            this.type = syntax_1.Syntax.CatchClause;
            this.param = param;
            this.body = body;
          }
          return CatchClause2;
        }();
        exports2.CatchClause = CatchClause;
        var ClassBody = function() {
          function ClassBody2(body) {
            this.type = syntax_1.Syntax.ClassBody;
            this.body = body;
          }
          return ClassBody2;
        }();
        exports2.ClassBody = ClassBody;
        var ClassDeclaration = function() {
          function ClassDeclaration2(id, superClass, body) {
            this.type = syntax_1.Syntax.ClassDeclaration;
            this.id = id;
            this.superClass = superClass;
            this.body = body;
          }
          return ClassDeclaration2;
        }();
        exports2.ClassDeclaration = ClassDeclaration;
        var ClassExpression = function() {
          function ClassExpression2(id, superClass, body) {
            this.type = syntax_1.Syntax.ClassExpression;
            this.id = id;
            this.superClass = superClass;
            this.body = body;
          }
          return ClassExpression2;
        }();
        exports2.ClassExpression = ClassExpression;
        var ComputedMemberExpression = function() {
          function ComputedMemberExpression2(object, property) {
            this.type = syntax_1.Syntax.MemberExpression;
            this.computed = true;
            this.object = object;
            this.property = property;
          }
          return ComputedMemberExpression2;
        }();
        exports2.ComputedMemberExpression = ComputedMemberExpression;
        var ConditionalExpression = function() {
          function ConditionalExpression2(test, consequent, alternate) {
            this.type = syntax_1.Syntax.ConditionalExpression;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
          }
          return ConditionalExpression2;
        }();
        exports2.ConditionalExpression = ConditionalExpression;
        var ContinueStatement = function() {
          function ContinueStatement2(label) {
            this.type = syntax_1.Syntax.ContinueStatement;
            this.label = label;
          }
          return ContinueStatement2;
        }();
        exports2.ContinueStatement = ContinueStatement;
        var DebuggerStatement = function() {
          function DebuggerStatement2() {
            this.type = syntax_1.Syntax.DebuggerStatement;
          }
          return DebuggerStatement2;
        }();
        exports2.DebuggerStatement = DebuggerStatement;
        var Directive = function() {
          function Directive2(expression, directive) {
            this.type = syntax_1.Syntax.ExpressionStatement;
            this.expression = expression;
            this.directive = directive;
          }
          return Directive2;
        }();
        exports2.Directive = Directive;
        var DoWhileStatement = function() {
          function DoWhileStatement2(body, test) {
            this.type = syntax_1.Syntax.DoWhileStatement;
            this.body = body;
            this.test = test;
          }
          return DoWhileStatement2;
        }();
        exports2.DoWhileStatement = DoWhileStatement;
        var EmptyStatement = function() {
          function EmptyStatement2() {
            this.type = syntax_1.Syntax.EmptyStatement;
          }
          return EmptyStatement2;
        }();
        exports2.EmptyStatement = EmptyStatement;
        var ExportAllDeclaration = function() {
          function ExportAllDeclaration2(source) {
            this.type = syntax_1.Syntax.ExportAllDeclaration;
            this.source = source;
          }
          return ExportAllDeclaration2;
        }();
        exports2.ExportAllDeclaration = ExportAllDeclaration;
        var ExportDefaultDeclaration = function() {
          function ExportDefaultDeclaration2(declaration) {
            this.type = syntax_1.Syntax.ExportDefaultDeclaration;
            this.declaration = declaration;
          }
          return ExportDefaultDeclaration2;
        }();
        exports2.ExportDefaultDeclaration = ExportDefaultDeclaration;
        var ExportNamedDeclaration = function() {
          function ExportNamedDeclaration2(declaration, specifiers, source) {
            this.type = syntax_1.Syntax.ExportNamedDeclaration;
            this.declaration = declaration;
            this.specifiers = specifiers;
            this.source = source;
          }
          return ExportNamedDeclaration2;
        }();
        exports2.ExportNamedDeclaration = ExportNamedDeclaration;
        var ExportSpecifier = function() {
          function ExportSpecifier2(local, exported) {
            this.type = syntax_1.Syntax.ExportSpecifier;
            this.exported = exported;
            this.local = local;
          }
          return ExportSpecifier2;
        }();
        exports2.ExportSpecifier = ExportSpecifier;
        var ExpressionStatement = function() {
          function ExpressionStatement2(expression) {
            this.type = syntax_1.Syntax.ExpressionStatement;
            this.expression = expression;
          }
          return ExpressionStatement2;
        }();
        exports2.ExpressionStatement = ExpressionStatement;
        var ForInStatement = function() {
          function ForInStatement2(left, right, body) {
            this.type = syntax_1.Syntax.ForInStatement;
            this.left = left;
            this.right = right;
            this.body = body;
            this.each = false;
          }
          return ForInStatement2;
        }();
        exports2.ForInStatement = ForInStatement;
        var ForOfStatement = function() {
          function ForOfStatement2(left, right, body) {
            this.type = syntax_1.Syntax.ForOfStatement;
            this.left = left;
            this.right = right;
            this.body = body;
          }
          return ForOfStatement2;
        }();
        exports2.ForOfStatement = ForOfStatement;
        var ForStatement = function() {
          function ForStatement2(init, test, update, body) {
            this.type = syntax_1.Syntax.ForStatement;
            this.init = init;
            this.test = test;
            this.update = update;
            this.body = body;
          }
          return ForStatement2;
        }();
        exports2.ForStatement = ForStatement;
        var FunctionDeclaration = function() {
          function FunctionDeclaration2(id, params, body, generator) {
            this.type = syntax_1.Syntax.FunctionDeclaration;
            this.id = id;
            this.params = params;
            this.body = body;
            this.generator = generator;
            this.expression = false;
            this.async = false;
          }
          return FunctionDeclaration2;
        }();
        exports2.FunctionDeclaration = FunctionDeclaration;
        var FunctionExpression = function() {
          function FunctionExpression2(id, params, body, generator) {
            this.type = syntax_1.Syntax.FunctionExpression;
            this.id = id;
            this.params = params;
            this.body = body;
            this.generator = generator;
            this.expression = false;
            this.async = false;
          }
          return FunctionExpression2;
        }();
        exports2.FunctionExpression = FunctionExpression;
        var Identifier = function() {
          function Identifier2(name) {
            this.type = syntax_1.Syntax.Identifier;
            this.name = name;
          }
          return Identifier2;
        }();
        exports2.Identifier = Identifier;
        var IfStatement = function() {
          function IfStatement2(test, consequent, alternate) {
            this.type = syntax_1.Syntax.IfStatement;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
          }
          return IfStatement2;
        }();
        exports2.IfStatement = IfStatement;
        var ImportDeclaration = function() {
          function ImportDeclaration2(specifiers, source) {
            this.type = syntax_1.Syntax.ImportDeclaration;
            this.specifiers = specifiers;
            this.source = source;
          }
          return ImportDeclaration2;
        }();
        exports2.ImportDeclaration = ImportDeclaration;
        var ImportDefaultSpecifier = function() {
          function ImportDefaultSpecifier2(local) {
            this.type = syntax_1.Syntax.ImportDefaultSpecifier;
            this.local = local;
          }
          return ImportDefaultSpecifier2;
        }();
        exports2.ImportDefaultSpecifier = ImportDefaultSpecifier;
        var ImportNamespaceSpecifier = function() {
          function ImportNamespaceSpecifier2(local) {
            this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
            this.local = local;
          }
          return ImportNamespaceSpecifier2;
        }();
        exports2.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
        var ImportSpecifier = function() {
          function ImportSpecifier2(local, imported) {
            this.type = syntax_1.Syntax.ImportSpecifier;
            this.local = local;
            this.imported = imported;
          }
          return ImportSpecifier2;
        }();
        exports2.ImportSpecifier = ImportSpecifier;
        var LabeledStatement = function() {
          function LabeledStatement2(label, body) {
            this.type = syntax_1.Syntax.LabeledStatement;
            this.label = label;
            this.body = body;
          }
          return LabeledStatement2;
        }();
        exports2.LabeledStatement = LabeledStatement;
        var Literal = function() {
          function Literal2(value, raw) {
            this.type = syntax_1.Syntax.Literal;
            this.value = value;
            this.raw = raw;
          }
          return Literal2;
        }();
        exports2.Literal = Literal;
        var MetaProperty = function() {
          function MetaProperty2(meta, property) {
            this.type = syntax_1.Syntax.MetaProperty;
            this.meta = meta;
            this.property = property;
          }
          return MetaProperty2;
        }();
        exports2.MetaProperty = MetaProperty;
        var MethodDefinition = function() {
          function MethodDefinition2(key, computed, value, kind, isStatic) {
            this.type = syntax_1.Syntax.MethodDefinition;
            this.key = key;
            this.computed = computed;
            this.value = value;
            this.kind = kind;
            this.static = isStatic;
          }
          return MethodDefinition2;
        }();
        exports2.MethodDefinition = MethodDefinition;
        var Module = function() {
          function Module2(body) {
            this.type = syntax_1.Syntax.Program;
            this.body = body;
            this.sourceType = "module";
          }
          return Module2;
        }();
        exports2.Module = Module;
        var NewExpression = function() {
          function NewExpression2(callee, args) {
            this.type = syntax_1.Syntax.NewExpression;
            this.callee = callee;
            this.arguments = args;
          }
          return NewExpression2;
        }();
        exports2.NewExpression = NewExpression;
        var ObjectExpression = function() {
          function ObjectExpression2(properties) {
            this.type = syntax_1.Syntax.ObjectExpression;
            this.properties = properties;
          }
          return ObjectExpression2;
        }();
        exports2.ObjectExpression = ObjectExpression;
        var ObjectPattern = function() {
          function ObjectPattern2(properties) {
            this.type = syntax_1.Syntax.ObjectPattern;
            this.properties = properties;
          }
          return ObjectPattern2;
        }();
        exports2.ObjectPattern = ObjectPattern;
        var Property = function() {
          function Property2(kind, key, computed, value, method, shorthand) {
            this.type = syntax_1.Syntax.Property;
            this.key = key;
            this.computed = computed;
            this.value = value;
            this.kind = kind;
            this.method = method;
            this.shorthand = shorthand;
          }
          return Property2;
        }();
        exports2.Property = Property;
        var RegexLiteral = function() {
          function RegexLiteral2(value, raw, pattern, flags) {
            this.type = syntax_1.Syntax.Literal;
            this.value = value;
            this.raw = raw;
            this.regex = { pattern, flags };
          }
          return RegexLiteral2;
        }();
        exports2.RegexLiteral = RegexLiteral;
        var RestElement = function() {
          function RestElement2(argument) {
            this.type = syntax_1.Syntax.RestElement;
            this.argument = argument;
          }
          return RestElement2;
        }();
        exports2.RestElement = RestElement;
        var ReturnStatement = function() {
          function ReturnStatement2(argument) {
            this.type = syntax_1.Syntax.ReturnStatement;
            this.argument = argument;
          }
          return ReturnStatement2;
        }();
        exports2.ReturnStatement = ReturnStatement;
        var Script = function() {
          function Script2(body) {
            this.type = syntax_1.Syntax.Program;
            this.body = body;
            this.sourceType = "script";
          }
          return Script2;
        }();
        exports2.Script = Script;
        var SequenceExpression = function() {
          function SequenceExpression2(expressions) {
            this.type = syntax_1.Syntax.SequenceExpression;
            this.expressions = expressions;
          }
          return SequenceExpression2;
        }();
        exports2.SequenceExpression = SequenceExpression;
        var SpreadElement = function() {
          function SpreadElement2(argument) {
            this.type = syntax_1.Syntax.SpreadElement;
            this.argument = argument;
          }
          return SpreadElement2;
        }();
        exports2.SpreadElement = SpreadElement;
        var StaticMemberExpression = function() {
          function StaticMemberExpression2(object, property) {
            this.type = syntax_1.Syntax.MemberExpression;
            this.computed = false;
            this.object = object;
            this.property = property;
          }
          return StaticMemberExpression2;
        }();
        exports2.StaticMemberExpression = StaticMemberExpression;
        var Super = function() {
          function Super2() {
            this.type = syntax_1.Syntax.Super;
          }
          return Super2;
        }();
        exports2.Super = Super;
        var SwitchCase = function() {
          function SwitchCase2(test, consequent) {
            this.type = syntax_1.Syntax.SwitchCase;
            this.test = test;
            this.consequent = consequent;
          }
          return SwitchCase2;
        }();
        exports2.SwitchCase = SwitchCase;
        var SwitchStatement = function() {
          function SwitchStatement2(discriminant, cases) {
            this.type = syntax_1.Syntax.SwitchStatement;
            this.discriminant = discriminant;
            this.cases = cases;
          }
          return SwitchStatement2;
        }();
        exports2.SwitchStatement = SwitchStatement;
        var TaggedTemplateExpression = function() {
          function TaggedTemplateExpression2(tag, quasi) {
            this.type = syntax_1.Syntax.TaggedTemplateExpression;
            this.tag = tag;
            this.quasi = quasi;
          }
          return TaggedTemplateExpression2;
        }();
        exports2.TaggedTemplateExpression = TaggedTemplateExpression;
        var TemplateElement = function() {
          function TemplateElement2(value, tail) {
            this.type = syntax_1.Syntax.TemplateElement;
            this.value = value;
            this.tail = tail;
          }
          return TemplateElement2;
        }();
        exports2.TemplateElement = TemplateElement;
        var TemplateLiteral = function() {
          function TemplateLiteral2(quasis, expressions) {
            this.type = syntax_1.Syntax.TemplateLiteral;
            this.quasis = quasis;
            this.expressions = expressions;
          }
          return TemplateLiteral2;
        }();
        exports2.TemplateLiteral = TemplateLiteral;
        var ThisExpression = function() {
          function ThisExpression2() {
            this.type = syntax_1.Syntax.ThisExpression;
          }
          return ThisExpression2;
        }();
        exports2.ThisExpression = ThisExpression;
        var ThrowStatement = function() {
          function ThrowStatement2(argument) {
            this.type = syntax_1.Syntax.ThrowStatement;
            this.argument = argument;
          }
          return ThrowStatement2;
        }();
        exports2.ThrowStatement = ThrowStatement;
        var TryStatement = function() {
          function TryStatement2(block, handler, finalizer) {
            this.type = syntax_1.Syntax.TryStatement;
            this.block = block;
            this.handler = handler;
            this.finalizer = finalizer;
          }
          return TryStatement2;
        }();
        exports2.TryStatement = TryStatement;
        var UnaryExpression = function() {
          function UnaryExpression2(operator, argument) {
            this.type = syntax_1.Syntax.UnaryExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = true;
          }
          return UnaryExpression2;
        }();
        exports2.UnaryExpression = UnaryExpression;
        var UpdateExpression = function() {
          function UpdateExpression2(operator, argument, prefix) {
            this.type = syntax_1.Syntax.UpdateExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = prefix;
          }
          return UpdateExpression2;
        }();
        exports2.UpdateExpression = UpdateExpression;
        var VariableDeclaration = function() {
          function VariableDeclaration2(declarations, kind) {
            this.type = syntax_1.Syntax.VariableDeclaration;
            this.declarations = declarations;
            this.kind = kind;
          }
          return VariableDeclaration2;
        }();
        exports2.VariableDeclaration = VariableDeclaration;
        var VariableDeclarator = function() {
          function VariableDeclarator2(id, init) {
            this.type = syntax_1.Syntax.VariableDeclarator;
            this.id = id;
            this.init = init;
          }
          return VariableDeclarator2;
        }();
        exports2.VariableDeclarator = VariableDeclarator;
        var WhileStatement = function() {
          function WhileStatement2(test, body) {
            this.type = syntax_1.Syntax.WhileStatement;
            this.test = test;
            this.body = body;
          }
          return WhileStatement2;
        }();
        exports2.WhileStatement = WhileStatement;
        var WithStatement = function() {
          function WithStatement2(object, body) {
            this.type = syntax_1.Syntax.WithStatement;
            this.object = object;
            this.body = body;
          }
          return WithStatement2;
        }();
        exports2.WithStatement = WithStatement;
        var YieldExpression = function() {
          function YieldExpression2(argument, delegate) {
            this.type = syntax_1.Syntax.YieldExpression;
            this.argument = argument;
            this.delegate = delegate;
          }
          return YieldExpression2;
        }();
        exports2.YieldExpression = YieldExpression;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var assert_1 = __webpack_require__(9);
        var error_handler_1 = __webpack_require__(10);
        var messages_1 = __webpack_require__(11);
        var Node = __webpack_require__(7);
        var scanner_1 = __webpack_require__(12);
        var syntax_1 = __webpack_require__(2);
        var token_1 = __webpack_require__(13);
        var ArrowParameterPlaceHolder = "ArrowParameterPlaceHolder";
        var Parser = function() {
          function Parser2(code, options, delegate) {
            if (options === undefined) {
              options = {};
            }
            this.config = {
              range: typeof options.range === "boolean" && options.range,
              loc: typeof options.loc === "boolean" && options.loc,
              source: null,
              tokens: typeof options.tokens === "boolean" && options.tokens,
              comment: typeof options.comment === "boolean" && options.comment,
              tolerant: typeof options.tolerant === "boolean" && options.tolerant
            };
            if (this.config.loc && options.source && options.source !== null) {
              this.config.source = String(options.source);
            }
            this.delegate = delegate;
            this.errorHandler = new error_handler_1.ErrorHandler;
            this.errorHandler.tolerant = this.config.tolerant;
            this.scanner = new scanner_1.Scanner(code, this.errorHandler);
            this.scanner.trackComment = this.config.comment;
            this.operatorPrecedence = {
              ")": 0,
              ";": 0,
              ",": 0,
              "=": 0,
              "]": 0,
              "||": 1,
              "&&": 2,
              "|": 3,
              "^": 4,
              "&": 5,
              "==": 6,
              "!=": 6,
              "===": 6,
              "!==": 6,
              "<": 7,
              ">": 7,
              "<=": 7,
              ">=": 7,
              "<<": 8,
              ">>": 8,
              ">>>": 8,
              "+": 9,
              "-": 9,
              "*": 11,
              "/": 11,
              "%": 11
            };
            this.lookahead = {
              type: 2,
              value: "",
              lineNumber: this.scanner.lineNumber,
              lineStart: 0,
              start: 0,
              end: 0
            };
            this.hasLineTerminator = false;
            this.context = {
              isModule: false,
              await: false,
              allowIn: true,
              allowStrictDirective: true,
              allowYield: true,
              firstCoverInitializedNameError: null,
              isAssignmentTarget: false,
              isBindingElement: false,
              inFunctionBody: false,
              inIteration: false,
              inSwitch: false,
              labelSet: {},
              strict: false
            };
            this.tokens = [];
            this.startMarker = {
              index: 0,
              line: this.scanner.lineNumber,
              column: 0
            };
            this.lastMarker = {
              index: 0,
              line: this.scanner.lineNumber,
              column: 0
            };
            this.nextToken();
            this.lastMarker = {
              index: this.scanner.index,
              line: this.scanner.lineNumber,
              column: this.scanner.index - this.scanner.lineStart
            };
          }
          Parser2.prototype.throwError = function(messageFormat) {
            var values = [];
            for (var _i = 1;_i < arguments.length; _i++) {
              values[_i - 1] = arguments[_i];
            }
            var args = Array.prototype.slice.call(arguments, 1);
            var msg = messageFormat.replace(/%(\d)/g, function(whole, idx2) {
              assert_1.assert(idx2 < args.length, "Message reference must be in range");
              return args[idx2];
            });
            var index = this.lastMarker.index;
            var line = this.lastMarker.line;
            var column = this.lastMarker.column + 1;
            throw this.errorHandler.createError(index, line, column, msg);
          };
          Parser2.prototype.tolerateError = function(messageFormat) {
            var values = [];
            for (var _i = 1;_i < arguments.length; _i++) {
              values[_i - 1] = arguments[_i];
            }
            var args = Array.prototype.slice.call(arguments, 1);
            var msg = messageFormat.replace(/%(\d)/g, function(whole, idx2) {
              assert_1.assert(idx2 < args.length, "Message reference must be in range");
              return args[idx2];
            });
            var index = this.lastMarker.index;
            var line = this.scanner.lineNumber;
            var column = this.lastMarker.column + 1;
            this.errorHandler.tolerateError(index, line, column, msg);
          };
          Parser2.prototype.unexpectedTokenError = function(token, message) {
            var msg = message || messages_1.Messages.UnexpectedToken;
            var value;
            if (token) {
              if (!message) {
                msg = token.type === 2 ? messages_1.Messages.UnexpectedEOS : token.type === 3 ? messages_1.Messages.UnexpectedIdentifier : token.type === 6 ? messages_1.Messages.UnexpectedNumber : token.type === 8 ? messages_1.Messages.UnexpectedString : token.type === 10 ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken;
                if (token.type === 4) {
                  if (this.scanner.isFutureReservedWord(token.value)) {
                    msg = messages_1.Messages.UnexpectedReserved;
                  } else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
                    msg = messages_1.Messages.StrictReservedWord;
                  }
                }
              }
              value = token.value;
            } else {
              value = "ILLEGAL";
            }
            msg = msg.replace("%0", value);
            if (token && typeof token.lineNumber === "number") {
              var index = token.start;
              var line = token.lineNumber;
              var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
              var column = token.start - lastMarkerLineStart + 1;
              return this.errorHandler.createError(index, line, column, msg);
            } else {
              var index = this.lastMarker.index;
              var line = this.lastMarker.line;
              var column = this.lastMarker.column + 1;
              return this.errorHandler.createError(index, line, column, msg);
            }
          };
          Parser2.prototype.throwUnexpectedToken = function(token, message) {
            throw this.unexpectedTokenError(token, message);
          };
          Parser2.prototype.tolerateUnexpectedToken = function(token, message) {
            this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
          };
          Parser2.prototype.collectComments = function() {
            if (!this.config.comment) {
              this.scanner.scanComments();
            } else {
              var comments = this.scanner.scanComments();
              if (comments.length > 0 && this.delegate) {
                for (var i = 0;i < comments.length; ++i) {
                  var e = comments[i];
                  var node = undefined;
                  node = {
                    type: e.multiLine ? "BlockComment" : "LineComment",
                    value: this.scanner.source.slice(e.slice[0], e.slice[1])
                  };
                  if (this.config.range) {
                    node.range = e.range;
                  }
                  if (this.config.loc) {
                    node.loc = e.loc;
                  }
                  var metadata = {
                    start: {
                      line: e.loc.start.line,
                      column: e.loc.start.column,
                      offset: e.range[0]
                    },
                    end: {
                      line: e.loc.end.line,
                      column: e.loc.end.column,
                      offset: e.range[1]
                    }
                  };
                  this.delegate(node, metadata);
                }
              }
            }
          };
          Parser2.prototype.getTokenRaw = function(token) {
            return this.scanner.source.slice(token.start, token.end);
          };
          Parser2.prototype.convertToken = function(token) {
            var t = {
              type: token_1.TokenName[token.type],
              value: this.getTokenRaw(token)
            };
            if (this.config.range) {
              t.range = [token.start, token.end];
            }
            if (this.config.loc) {
              t.loc = {
                start: {
                  line: this.startMarker.line,
                  column: this.startMarker.column
                },
                end: {
                  line: this.scanner.lineNumber,
                  column: this.scanner.index - this.scanner.lineStart
                }
              };
            }
            if (token.type === 9) {
              var pattern = token.pattern;
              var flags = token.flags;
              t.regex = { pattern, flags };
            }
            return t;
          };
          Parser2.prototype.nextToken = function() {
            var token = this.lookahead;
            this.lastMarker.index = this.scanner.index;
            this.lastMarker.line = this.scanner.lineNumber;
            this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
            this.collectComments();
            if (this.scanner.index !== this.startMarker.index) {
              this.startMarker.index = this.scanner.index;
              this.startMarker.line = this.scanner.lineNumber;
              this.startMarker.column = this.scanner.index - this.scanner.lineStart;
            }
            var next = this.scanner.lex();
            this.hasLineTerminator = token.lineNumber !== next.lineNumber;
            if (next && this.context.strict && next.type === 3) {
              if (this.scanner.isStrictModeReservedWord(next.value)) {
                next.type = 4;
              }
            }
            this.lookahead = next;
            if (this.config.tokens && next.type !== 2) {
              this.tokens.push(this.convertToken(next));
            }
            return token;
          };
          Parser2.prototype.nextRegexToken = function() {
            this.collectComments();
            var token = this.scanner.scanRegExp();
            if (this.config.tokens) {
              this.tokens.pop();
              this.tokens.push(this.convertToken(token));
            }
            this.lookahead = token;
            this.nextToken();
            return token;
          };
          Parser2.prototype.createNode = function() {
            return {
              index: this.startMarker.index,
              line: this.startMarker.line,
              column: this.startMarker.column
            };
          };
          Parser2.prototype.startNode = function(token, lastLineStart) {
            if (lastLineStart === undefined) {
              lastLineStart = 0;
            }
            var column = token.start - token.lineStart;
            var line = token.lineNumber;
            if (column < 0) {
              column += lastLineStart;
              line--;
            }
            return {
              index: token.start,
              line,
              column
            };
          };
          Parser2.prototype.finalize = function(marker, node) {
            if (this.config.range) {
              node.range = [marker.index, this.lastMarker.index];
            }
            if (this.config.loc) {
              node.loc = {
                start: {
                  line: marker.line,
                  column: marker.column
                },
                end: {
                  line: this.lastMarker.line,
                  column: this.lastMarker.column
                }
              };
              if (this.config.source) {
                node.loc.source = this.config.source;
              }
            }
            if (this.delegate) {
              var metadata = {
                start: {
                  line: marker.line,
                  column: marker.column,
                  offset: marker.index
                },
                end: {
                  line: this.lastMarker.line,
                  column: this.lastMarker.column,
                  offset: this.lastMarker.index
                }
              };
              this.delegate(node, metadata);
            }
            return node;
          };
          Parser2.prototype.expect = function(value) {
            var token = this.nextToken();
            if (token.type !== 7 || token.value !== value) {
              this.throwUnexpectedToken(token);
            }
          };
          Parser2.prototype.expectCommaSeparator = function() {
            if (this.config.tolerant) {
              var token = this.lookahead;
              if (token.type === 7 && token.value === ",") {
                this.nextToken();
              } else if (token.type === 7 && token.value === ";") {
                this.nextToken();
                this.tolerateUnexpectedToken(token);
              } else {
                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
              }
            } else {
              this.expect(",");
            }
          };
          Parser2.prototype.expectKeyword = function(keyword) {
            var token = this.nextToken();
            if (token.type !== 4 || token.value !== keyword) {
              this.throwUnexpectedToken(token);
            }
          };
          Parser2.prototype.match = function(value) {
            return this.lookahead.type === 7 && this.lookahead.value === value;
          };
          Parser2.prototype.matchKeyword = function(keyword) {
            return this.lookahead.type === 4 && this.lookahead.value === keyword;
          };
          Parser2.prototype.matchContextualKeyword = function(keyword) {
            return this.lookahead.type === 3 && this.lookahead.value === keyword;
          };
          Parser2.prototype.matchAssign = function() {
            if (this.lookahead.type !== 7) {
              return false;
            }
            var op = this.lookahead.value;
            return op === "=" || op === "*=" || op === "**=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|=";
          };
          Parser2.prototype.isolateCoverGrammar = function(parseFunction) {
            var previousIsBindingElement = this.context.isBindingElement;
            var previousIsAssignmentTarget = this.context.isAssignmentTarget;
            var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
            this.context.isBindingElement = true;
            this.context.isAssignmentTarget = true;
            this.context.firstCoverInitializedNameError = null;
            var result = parseFunction.call(this);
            if (this.context.firstCoverInitializedNameError !== null) {
              this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
            }
            this.context.isBindingElement = previousIsBindingElement;
            this.context.isAssignmentTarget = previousIsAssignmentTarget;
            this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
            return result;
          };
          Parser2.prototype.inheritCoverGrammar = function(parseFunction) {
            var previousIsBindingElement = this.context.isBindingElement;
            var previousIsAssignmentTarget = this.context.isAssignmentTarget;
            var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
            this.context.isBindingElement = true;
            this.context.isAssignmentTarget = true;
            this.context.firstCoverInitializedNameError = null;
            var result = parseFunction.call(this);
            this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
            this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
            this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
            return result;
          };
          Parser2.prototype.consumeSemicolon = function() {
            if (this.match(";")) {
              this.nextToken();
            } else if (!this.hasLineTerminator) {
              if (this.lookahead.type !== 2 && !this.match("}")) {
                this.throwUnexpectedToken(this.lookahead);
              }
              this.lastMarker.index = this.startMarker.index;
              this.lastMarker.line = this.startMarker.line;
              this.lastMarker.column = this.startMarker.column;
            }
          };
          Parser2.prototype.parsePrimaryExpression = function() {
            var node = this.createNode();
            var expr;
            var token, raw;
            switch (this.lookahead.type) {
              case 3:
                if ((this.context.isModule || this.context.await) && this.lookahead.value === "await") {
                  this.tolerateUnexpectedToken(this.lookahead);
                }
                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
                break;
              case 6:
              case 8:
                if (this.context.strict && this.lookahead.octal) {
                  this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
                }
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                token = this.nextToken();
                raw = this.getTokenRaw(token);
                expr = this.finalize(node, new Node.Literal(token.value, raw));
                break;
              case 1:
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                token = this.nextToken();
                raw = this.getTokenRaw(token);
                expr = this.finalize(node, new Node.Literal(token.value === "true", raw));
                break;
              case 5:
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                token = this.nextToken();
                raw = this.getTokenRaw(token);
                expr = this.finalize(node, new Node.Literal(null, raw));
                break;
              case 10:
                expr = this.parseTemplateLiteral();
                break;
              case 7:
                switch (this.lookahead.value) {
                  case "(":
                    this.context.isBindingElement = false;
                    expr = this.inheritCoverGrammar(this.parseGroupExpression);
                    break;
                  case "[":
                    expr = this.inheritCoverGrammar(this.parseArrayInitializer);
                    break;
                  case "{":
                    expr = this.inheritCoverGrammar(this.parseObjectInitializer);
                    break;
                  case "/":
                  case "/=":
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    this.scanner.index = this.startMarker.index;
                    token = this.nextRegexToken();
                    raw = this.getTokenRaw(token);
                    expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
                    break;
                  default:
                    expr = this.throwUnexpectedToken(this.nextToken());
                }
                break;
              case 4:
                if (!this.context.strict && this.context.allowYield && this.matchKeyword("yield")) {
                  expr = this.parseIdentifierName();
                } else if (!this.context.strict && this.matchKeyword("let")) {
                  expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
                } else {
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  if (this.matchKeyword("function")) {
                    expr = this.parseFunctionExpression();
                  } else if (this.matchKeyword("this")) {
                    this.nextToken();
                    expr = this.finalize(node, new Node.ThisExpression);
                  } else if (this.matchKeyword("class")) {
                    expr = this.parseClassExpression();
                  } else {
                    expr = this.throwUnexpectedToken(this.nextToken());
                  }
                }
                break;
              default:
                expr = this.throwUnexpectedToken(this.nextToken());
            }
            return expr;
          };
          Parser2.prototype.parseSpreadElement = function() {
            var node = this.createNode();
            this.expect("...");
            var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
            return this.finalize(node, new Node.SpreadElement(arg));
          };
          Parser2.prototype.parseArrayInitializer = function() {
            var node = this.createNode();
            var elements = [];
            this.expect("[");
            while (!this.match("]")) {
              if (this.match(",")) {
                this.nextToken();
                elements.push(null);
              } else if (this.match("...")) {
                var element = this.parseSpreadElement();
                if (!this.match("]")) {
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  this.expect(",");
                }
                elements.push(element);
              } else {
                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                if (!this.match("]")) {
                  this.expect(",");
                }
              }
            }
            this.expect("]");
            return this.finalize(node, new Node.ArrayExpression(elements));
          };
          Parser2.prototype.parsePropertyMethod = function(params) {
            this.context.isAssignmentTarget = false;
            this.context.isBindingElement = false;
            var previousStrict = this.context.strict;
            var previousAllowStrictDirective = this.context.allowStrictDirective;
            this.context.allowStrictDirective = params.simple;
            var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
            if (this.context.strict && params.firstRestricted) {
              this.tolerateUnexpectedToken(params.firstRestricted, params.message);
            }
            if (this.context.strict && params.stricted) {
              this.tolerateUnexpectedToken(params.stricted, params.message);
            }
            this.context.strict = previousStrict;
            this.context.allowStrictDirective = previousAllowStrictDirective;
            return body;
          };
          Parser2.prototype.parsePropertyMethodFunction = function() {
            var isGenerator = false;
            var node = this.createNode();
            var previousAllowYield = this.context.allowYield;
            this.context.allowYield = true;
            var params = this.parseFormalParameters();
            var method = this.parsePropertyMethod(params);
            this.context.allowYield = previousAllowYield;
            return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
          };
          Parser2.prototype.parsePropertyMethodAsyncFunction = function() {
            var node = this.createNode();
            var previousAllowYield = this.context.allowYield;
            var previousAwait = this.context.await;
            this.context.allowYield = false;
            this.context.await = true;
            var params = this.parseFormalParameters();
            var method = this.parsePropertyMethod(params);
            this.context.allowYield = previousAllowYield;
            this.context.await = previousAwait;
            return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
          };
          Parser2.prototype.parseObjectPropertyKey = function() {
            var node = this.createNode();
            var token = this.nextToken();
            var key;
            switch (token.type) {
              case 8:
              case 6:
                if (this.context.strict && token.octal) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
                }
                var raw = this.getTokenRaw(token);
                key = this.finalize(node, new Node.Literal(token.value, raw));
                break;
              case 3:
              case 1:
              case 5:
              case 4:
                key = this.finalize(node, new Node.Identifier(token.value));
                break;
              case 7:
                if (token.value === "[") {
                  key = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  this.expect("]");
                } else {
                  key = this.throwUnexpectedToken(token);
                }
                break;
              default:
                key = this.throwUnexpectedToken(token);
            }
            return key;
          };
          Parser2.prototype.isPropertyKey = function(key, value) {
            return key.type === syntax_1.Syntax.Identifier && key.name === value || key.type === syntax_1.Syntax.Literal && key.value === value;
          };
          Parser2.prototype.parseObjectProperty = function(hasProto) {
            var node = this.createNode();
            var token = this.lookahead;
            var kind;
            var key = null;
            var value = null;
            var computed = false;
            var method = false;
            var shorthand = false;
            var isAsync = false;
            if (token.type === 3) {
              var id = token.value;
              this.nextToken();
              computed = this.match("[");
              isAsync = !this.hasLineTerminator && id === "async" && !this.match(":") && !this.match("(") && !this.match("*") && !this.match(",");
              key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
            } else if (this.match("*")) {
              this.nextToken();
            } else {
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
            }
            var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
            if (token.type === 3 && !isAsync && token.value === "get" && lookaheadPropertyKey) {
              kind = "get";
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
              this.context.allowYield = false;
              value = this.parseGetterMethod();
            } else if (token.type === 3 && !isAsync && token.value === "set" && lookaheadPropertyKey) {
              kind = "set";
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
              value = this.parseSetterMethod();
            } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
              kind = "init";
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
              value = this.parseGeneratorMethod();
              method = true;
            } else {
              if (!key) {
                this.throwUnexpectedToken(this.lookahead);
              }
              kind = "init";
              if (this.match(":") && !isAsync) {
                if (!computed && this.isPropertyKey(key, "__proto__")) {
                  if (hasProto.value) {
                    this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
                  }
                  hasProto.value = true;
                }
                this.nextToken();
                value = this.inheritCoverGrammar(this.parseAssignmentExpression);
              } else if (this.match("(")) {
                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                method = true;
              } else if (token.type === 3) {
                var id = this.finalize(node, new Node.Identifier(token.value));
                if (this.match("=")) {
                  this.context.firstCoverInitializedNameError = this.lookahead;
                  this.nextToken();
                  shorthand = true;
                  var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  value = this.finalize(node, new Node.AssignmentPattern(id, init));
                } else {
                  shorthand = true;
                  value = id;
                }
              } else {
                this.throwUnexpectedToken(this.nextToken());
              }
            }
            return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
          };
          Parser2.prototype.parseObjectInitializer = function() {
            var node = this.createNode();
            this.expect("{");
            var properties = [];
            var hasProto = { value: false };
            while (!this.match("}")) {
              properties.push(this.parseObjectProperty(hasProto));
              if (!this.match("}")) {
                this.expectCommaSeparator();
              }
            }
            this.expect("}");
            return this.finalize(node, new Node.ObjectExpression(properties));
          };
          Parser2.prototype.parseTemplateHead = function() {
            assert_1.assert(this.lookahead.head, "Template literal must start with a template head");
            var node = this.createNode();
            var token = this.nextToken();
            var raw = token.value;
            var cooked = token.cooked;
            return this.finalize(node, new Node.TemplateElement({ raw, cooked }, token.tail));
          };
          Parser2.prototype.parseTemplateElement = function() {
            if (this.lookahead.type !== 10) {
              this.throwUnexpectedToken();
            }
            var node = this.createNode();
            var token = this.nextToken();
            var raw = token.value;
            var cooked = token.cooked;
            return this.finalize(node, new Node.TemplateElement({ raw, cooked }, token.tail));
          };
          Parser2.prototype.parseTemplateLiteral = function() {
            var node = this.createNode();
            var expressions = [];
            var quasis = [];
            var quasi = this.parseTemplateHead();
            quasis.push(quasi);
            while (!quasi.tail) {
              expressions.push(this.parseExpression());
              quasi = this.parseTemplateElement();
              quasis.push(quasi);
            }
            return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
          };
          Parser2.prototype.reinterpretExpressionAsPattern = function(expr) {
            switch (expr.type) {
              case syntax_1.Syntax.Identifier:
              case syntax_1.Syntax.MemberExpression:
              case syntax_1.Syntax.RestElement:
              case syntax_1.Syntax.AssignmentPattern:
                break;
              case syntax_1.Syntax.SpreadElement:
                expr.type = syntax_1.Syntax.RestElement;
                this.reinterpretExpressionAsPattern(expr.argument);
                break;
              case syntax_1.Syntax.ArrayExpression:
                expr.type = syntax_1.Syntax.ArrayPattern;
                for (var i = 0;i < expr.elements.length; i++) {
                  if (expr.elements[i] !== null) {
                    this.reinterpretExpressionAsPattern(expr.elements[i]);
                  }
                }
                break;
              case syntax_1.Syntax.ObjectExpression:
                expr.type = syntax_1.Syntax.ObjectPattern;
                for (var i = 0;i < expr.properties.length; i++) {
                  this.reinterpretExpressionAsPattern(expr.properties[i].value);
                }
                break;
              case syntax_1.Syntax.AssignmentExpression:
                expr.type = syntax_1.Syntax.AssignmentPattern;
                delete expr.operator;
                this.reinterpretExpressionAsPattern(expr.left);
                break;
              default:
                break;
            }
          };
          Parser2.prototype.parseGroupExpression = function() {
            var expr;
            this.expect("(");
            if (this.match(")")) {
              this.nextToken();
              if (!this.match("=>")) {
                this.expect("=>");
              }
              expr = {
                type: ArrowParameterPlaceHolder,
                params: [],
                async: false
              };
            } else {
              var startToken = this.lookahead;
              var params = [];
              if (this.match("...")) {
                expr = this.parseRestElement(params);
                this.expect(")");
                if (!this.match("=>")) {
                  this.expect("=>");
                }
                expr = {
                  type: ArrowParameterPlaceHolder,
                  params: [expr],
                  async: false
                };
              } else {
                var arrow = false;
                this.context.isBindingElement = true;
                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
                if (this.match(",")) {
                  var expressions = [];
                  this.context.isAssignmentTarget = false;
                  expressions.push(expr);
                  while (this.lookahead.type !== 2) {
                    if (!this.match(",")) {
                      break;
                    }
                    this.nextToken();
                    if (this.match(")")) {
                      this.nextToken();
                      for (var i = 0;i < expressions.length; i++) {
                        this.reinterpretExpressionAsPattern(expressions[i]);
                      }
                      arrow = true;
                      expr = {
                        type: ArrowParameterPlaceHolder,
                        params: expressions,
                        async: false
                      };
                    } else if (this.match("...")) {
                      if (!this.context.isBindingElement) {
                        this.throwUnexpectedToken(this.lookahead);
                      }
                      expressions.push(this.parseRestElement(params));
                      this.expect(")");
                      if (!this.match("=>")) {
                        this.expect("=>");
                      }
                      this.context.isBindingElement = false;
                      for (var i = 0;i < expressions.length; i++) {
                        this.reinterpretExpressionAsPattern(expressions[i]);
                      }
                      arrow = true;
                      expr = {
                        type: ArrowParameterPlaceHolder,
                        params: expressions,
                        async: false
                      };
                    } else {
                      expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                    }
                    if (arrow) {
                      break;
                    }
                  }
                  if (!arrow) {
                    expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
                  }
                }
                if (!arrow) {
                  this.expect(")");
                  if (this.match("=>")) {
                    if (expr.type === syntax_1.Syntax.Identifier && expr.name === "yield") {
                      arrow = true;
                      expr = {
                        type: ArrowParameterPlaceHolder,
                        params: [expr],
                        async: false
                      };
                    }
                    if (!arrow) {
                      if (!this.context.isBindingElement) {
                        this.throwUnexpectedToken(this.lookahead);
                      }
                      if (expr.type === syntax_1.Syntax.SequenceExpression) {
                        for (var i = 0;i < expr.expressions.length; i++) {
                          this.reinterpretExpressionAsPattern(expr.expressions[i]);
                        }
                      } else {
                        this.reinterpretExpressionAsPattern(expr);
                      }
                      var parameters = expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr];
                      expr = {
                        type: ArrowParameterPlaceHolder,
                        params: parameters,
                        async: false
                      };
                    }
                  }
                  this.context.isBindingElement = false;
                }
              }
            }
            return expr;
          };
          Parser2.prototype.parseArguments = function() {
            this.expect("(");
            var args = [];
            if (!this.match(")")) {
              while (true) {
                var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
                args.push(expr);
                if (this.match(")")) {
                  break;
                }
                this.expectCommaSeparator();
                if (this.match(")")) {
                  break;
                }
              }
            }
            this.expect(")");
            return args;
          };
          Parser2.prototype.isIdentifierName = function(token) {
            return token.type === 3 || token.type === 4 || token.type === 1 || token.type === 5;
          };
          Parser2.prototype.parseIdentifierName = function() {
            var node = this.createNode();
            var token = this.nextToken();
            if (!this.isIdentifierName(token)) {
              this.throwUnexpectedToken(token);
            }
            return this.finalize(node, new Node.Identifier(token.value));
          };
          Parser2.prototype.parseNewExpression = function() {
            var node = this.createNode();
            var id = this.parseIdentifierName();
            assert_1.assert(id.name === "new", "New expression must start with `new`");
            var expr;
            if (this.match(".")) {
              this.nextToken();
              if (this.lookahead.type === 3 && this.context.inFunctionBody && this.lookahead.value === "target") {
                var property = this.parseIdentifierName();
                expr = new Node.MetaProperty(id, property);
              } else {
                this.throwUnexpectedToken(this.lookahead);
              }
            } else {
              var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
              var args = this.match("(") ? this.parseArguments() : [];
              expr = new Node.NewExpression(callee, args);
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
            }
            return this.finalize(node, expr);
          };
          Parser2.prototype.parseAsyncArgument = function() {
            var arg = this.parseAssignmentExpression();
            this.context.firstCoverInitializedNameError = null;
            return arg;
          };
          Parser2.prototype.parseAsyncArguments = function() {
            this.expect("(");
            var args = [];
            if (!this.match(")")) {
              while (true) {
                var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
                args.push(expr);
                if (this.match(")")) {
                  break;
                }
                this.expectCommaSeparator();
                if (this.match(")")) {
                  break;
                }
              }
            }
            this.expect(")");
            return args;
          };
          Parser2.prototype.parseLeftHandSideExpressionAllowCall = function() {
            var startToken = this.lookahead;
            var maybeAsync = this.matchContextualKeyword("async");
            var previousAllowIn = this.context.allowIn;
            this.context.allowIn = true;
            var expr;
            if (this.matchKeyword("super") && this.context.inFunctionBody) {
              expr = this.createNode();
              this.nextToken();
              expr = this.finalize(expr, new Node.Super);
              if (!this.match("(") && !this.match(".") && !this.match("[")) {
                this.throwUnexpectedToken(this.lookahead);
              }
            } else {
              expr = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
            }
            while (true) {
              if (this.match(".")) {
                this.context.isBindingElement = false;
                this.context.isAssignmentTarget = true;
                this.expect(".");
                var property = this.parseIdentifierName();
                expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
              } else if (this.match("(")) {
                var asyncArrow = maybeAsync && startToken.lineNumber === this.lookahead.lineNumber;
                this.context.isBindingElement = false;
                this.context.isAssignmentTarget = false;
                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
                if (asyncArrow && this.match("=>")) {
                  for (var i = 0;i < args.length; ++i) {
                    this.reinterpretExpressionAsPattern(args[i]);
                  }
                  expr = {
                    type: ArrowParameterPlaceHolder,
                    params: args,
                    async: true
                  };
                }
              } else if (this.match("[")) {
                this.context.isBindingElement = false;
                this.context.isAssignmentTarget = true;
                this.expect("[");
                var property = this.isolateCoverGrammar(this.parseExpression);
                this.expect("]");
                expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
              } else if (this.lookahead.type === 10 && this.lookahead.head) {
                var quasi = this.parseTemplateLiteral();
                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
              } else {
                break;
              }
            }
            this.context.allowIn = previousAllowIn;
            return expr;
          };
          Parser2.prototype.parseSuper = function() {
            var node = this.createNode();
            this.expectKeyword("super");
            if (!this.match("[") && !this.match(".")) {
              this.throwUnexpectedToken(this.lookahead);
            }
            return this.finalize(node, new Node.Super);
          };
          Parser2.prototype.parseLeftHandSideExpression = function() {
            assert_1.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
            var node = this.startNode(this.lookahead);
            var expr = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
            while (true) {
              if (this.match("[")) {
                this.context.isBindingElement = false;
                this.context.isAssignmentTarget = true;
                this.expect("[");
                var property = this.isolateCoverGrammar(this.parseExpression);
                this.expect("]");
                expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
              } else if (this.match(".")) {
                this.context.isBindingElement = false;
                this.context.isAssignmentTarget = true;
                this.expect(".");
                var property = this.parseIdentifierName();
                expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
              } else if (this.lookahead.type === 10 && this.lookahead.head) {
                var quasi = this.parseTemplateLiteral();
                expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
              } else {
                break;
              }
            }
            return expr;
          };
          Parser2.prototype.parseUpdateExpression = function() {
            var expr;
            var startToken = this.lookahead;
            if (this.match("++") || this.match("--")) {
              var node = this.startNode(startToken);
              var token = this.nextToken();
              expr = this.inheritCoverGrammar(this.parseUnaryExpression);
              if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                this.tolerateError(messages_1.Messages.StrictLHSPrefix);
              }
              if (!this.context.isAssignmentTarget) {
                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
              }
              var prefix = true;
              expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
            } else {
              expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
              if (!this.hasLineTerminator && this.lookahead.type === 7) {
                if (this.match("++") || this.match("--")) {
                  if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                    this.tolerateError(messages_1.Messages.StrictLHSPostfix);
                  }
                  if (!this.context.isAssignmentTarget) {
                    this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                  }
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  var operator = this.nextToken().value;
                  var prefix = false;
                  expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
                }
              }
            }
            return expr;
          };
          Parser2.prototype.parseAwaitExpression = function() {
            var node = this.createNode();
            this.nextToken();
            var argument = this.parseUnaryExpression();
            return this.finalize(node, new Node.AwaitExpression(argument));
          };
          Parser2.prototype.parseUnaryExpression = function() {
            var expr;
            if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
              var node = this.startNode(this.lookahead);
              var token = this.nextToken();
              expr = this.inheritCoverGrammar(this.parseUnaryExpression);
              expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
              if (this.context.strict && expr.operator === "delete" && expr.argument.type === syntax_1.Syntax.Identifier) {
                this.tolerateError(messages_1.Messages.StrictDelete);
              }
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
            } else if (this.context.await && this.matchContextualKeyword("await")) {
              expr = this.parseAwaitExpression();
            } else {
              expr = this.parseUpdateExpression();
            }
            return expr;
          };
          Parser2.prototype.parseExponentiationExpression = function() {
            var startToken = this.lookahead;
            var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
            if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match("**")) {
              this.nextToken();
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
              var left = expr;
              var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
              expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression("**", left, right));
            }
            return expr;
          };
          Parser2.prototype.binaryPrecedence = function(token) {
            var op = token.value;
            var precedence;
            if (token.type === 7) {
              precedence = this.operatorPrecedence[op] || 0;
            } else if (token.type === 4) {
              precedence = op === "instanceof" || this.context.allowIn && op === "in" ? 7 : 0;
            } else {
              precedence = 0;
            }
            return precedence;
          };
          Parser2.prototype.parseBinaryExpression = function() {
            var startToken = this.lookahead;
            var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
            var token = this.lookahead;
            var prec = this.binaryPrecedence(token);
            if (prec > 0) {
              this.nextToken();
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
              var markers = [startToken, this.lookahead];
              var left = expr;
              var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
              var stack = [left, token.value, right];
              var precedences = [prec];
              while (true) {
                prec = this.binaryPrecedence(this.lookahead);
                if (prec <= 0) {
                  break;
                }
                while (stack.length > 2 && prec <= precedences[precedences.length - 1]) {
                  right = stack.pop();
                  var operator = stack.pop();
                  precedences.pop();
                  left = stack.pop();
                  markers.pop();
                  var node = this.startNode(markers[markers.length - 1]);
                  stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
                }
                stack.push(this.nextToken().value);
                precedences.push(prec);
                markers.push(this.lookahead);
                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
              }
              var i = stack.length - 1;
              expr = stack[i];
              var lastMarker = markers.pop();
              while (i > 1) {
                var marker = markers.pop();
                var lastLineStart = lastMarker && lastMarker.lineStart;
                var node = this.startNode(marker, lastLineStart);
                var operator = stack[i - 1];
                expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
                i -= 2;
                lastMarker = marker;
              }
            }
            return expr;
          };
          Parser2.prototype.parseConditionalExpression = function() {
            var startToken = this.lookahead;
            var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
            if (this.match("?")) {
              this.nextToken();
              var previousAllowIn = this.context.allowIn;
              this.context.allowIn = true;
              var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
              this.context.allowIn = previousAllowIn;
              this.expect(":");
              var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
              expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
            }
            return expr;
          };
          Parser2.prototype.checkPatternParam = function(options, param) {
            switch (param.type) {
              case syntax_1.Syntax.Identifier:
                this.validateParam(options, param, param.name);
                break;
              case syntax_1.Syntax.RestElement:
                this.checkPatternParam(options, param.argument);
                break;
              case syntax_1.Syntax.AssignmentPattern:
                this.checkPatternParam(options, param.left);
                break;
              case syntax_1.Syntax.ArrayPattern:
                for (var i = 0;i < param.elements.length; i++) {
                  if (param.elements[i] !== null) {
                    this.checkPatternParam(options, param.elements[i]);
                  }
                }
                break;
              case syntax_1.Syntax.ObjectPattern:
                for (var i = 0;i < param.properties.length; i++) {
                  this.checkPatternParam(options, param.properties[i].value);
                }
                break;
              default:
                break;
            }
            options.simple = options.simple && param instanceof Node.Identifier;
          };
          Parser2.prototype.reinterpretAsCoverFormalsList = function(expr) {
            var params = [expr];
            var options;
            var asyncArrow = false;
            switch (expr.type) {
              case syntax_1.Syntax.Identifier:
                break;
              case ArrowParameterPlaceHolder:
                params = expr.params;
                asyncArrow = expr.async;
                break;
              default:
                return null;
            }
            options = {
              simple: true,
              paramSet: {}
            };
            for (var i = 0;i < params.length; ++i) {
              var param = params[i];
              if (param.type === syntax_1.Syntax.AssignmentPattern) {
                if (param.right.type === syntax_1.Syntax.YieldExpression) {
                  if (param.right.argument) {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                  param.right.type = syntax_1.Syntax.Identifier;
                  param.right.name = "yield";
                  delete param.right.argument;
                  delete param.right.delegate;
                }
              } else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === "await") {
                this.throwUnexpectedToken(this.lookahead);
              }
              this.checkPatternParam(options, param);
              params[i] = param;
            }
            if (this.context.strict || !this.context.allowYield) {
              for (var i = 0;i < params.length; ++i) {
                var param = params[i];
                if (param.type === syntax_1.Syntax.YieldExpression) {
                  this.throwUnexpectedToken(this.lookahead);
                }
              }
            }
            if (options.message === messages_1.Messages.StrictParamDupe) {
              var token = this.context.strict ? options.stricted : options.firstRestricted;
              this.throwUnexpectedToken(token, options.message);
            }
            return {
              simple: options.simple,
              params,
              stricted: options.stricted,
              firstRestricted: options.firstRestricted,
              message: options.message
            };
          };
          Parser2.prototype.parseAssignmentExpression = function() {
            var expr;
            if (!this.context.allowYield && this.matchKeyword("yield")) {
              expr = this.parseYieldExpression();
            } else {
              var startToken = this.lookahead;
              var token = startToken;
              expr = this.parseConditionalExpression();
              if (token.type === 3 && token.lineNumber === this.lookahead.lineNumber && token.value === "async") {
                if (this.lookahead.type === 3 || this.matchKeyword("yield")) {
                  var arg = this.parsePrimaryExpression();
                  this.reinterpretExpressionAsPattern(arg);
                  expr = {
                    type: ArrowParameterPlaceHolder,
                    params: [arg],
                    async: true
                  };
                }
              }
              if (expr.type === ArrowParameterPlaceHolder || this.match("=>")) {
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                var isAsync = expr.async;
                var list = this.reinterpretAsCoverFormalsList(expr);
                if (list) {
                  if (this.hasLineTerminator) {
                    this.tolerateUnexpectedToken(this.lookahead);
                  }
                  this.context.firstCoverInitializedNameError = null;
                  var previousStrict = this.context.strict;
                  var previousAllowStrictDirective = this.context.allowStrictDirective;
                  this.context.allowStrictDirective = list.simple;
                  var previousAllowYield = this.context.allowYield;
                  var previousAwait = this.context.await;
                  this.context.allowYield = true;
                  this.context.await = isAsync;
                  var node = this.startNode(startToken);
                  this.expect("=>");
                  var body = undefined;
                  if (this.match("{")) {
                    var previousAllowIn = this.context.allowIn;
                    this.context.allowIn = true;
                    body = this.parseFunctionSourceElements();
                    this.context.allowIn = previousAllowIn;
                  } else {
                    body = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  }
                  var expression = body.type !== syntax_1.Syntax.BlockStatement;
                  if (this.context.strict && list.firstRestricted) {
                    this.throwUnexpectedToken(list.firstRestricted, list.message);
                  }
                  if (this.context.strict && list.stricted) {
                    this.tolerateUnexpectedToken(list.stricted, list.message);
                  }
                  expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) : this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
                  this.context.strict = previousStrict;
                  this.context.allowStrictDirective = previousAllowStrictDirective;
                  this.context.allowYield = previousAllowYield;
                  this.context.await = previousAwait;
                }
              } else {
                if (this.matchAssign()) {
                  if (!this.context.isAssignmentTarget) {
                    this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                  }
                  if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
                    var id = expr;
                    if (this.scanner.isRestrictedWord(id.name)) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
                    }
                    if (this.scanner.isStrictModeReservedWord(id.name)) {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                    }
                  }
                  if (!this.match("=")) {
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                  } else {
                    this.reinterpretExpressionAsPattern(expr);
                  }
                  token = this.nextToken();
                  var operator = token.value;
                  var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
                  this.context.firstCoverInitializedNameError = null;
                }
              }
            }
            return expr;
          };
          Parser2.prototype.parseExpression = function() {
            var startToken = this.lookahead;
            var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
            if (this.match(",")) {
              var expressions = [];
              expressions.push(expr);
              while (this.lookahead.type !== 2) {
                if (!this.match(",")) {
                  break;
                }
                this.nextToken();
                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
              }
              expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
            }
            return expr;
          };
          Parser2.prototype.parseStatementListItem = function() {
            var statement;
            this.context.isAssignmentTarget = true;
            this.context.isBindingElement = true;
            if (this.lookahead.type === 4) {
              switch (this.lookahead.value) {
                case "export":
                  if (!this.context.isModule) {
                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
                  }
                  statement = this.parseExportDeclaration();
                  break;
                case "import":
                  if (!this.context.isModule) {
                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
                  }
                  statement = this.parseImportDeclaration();
                  break;
                case "const":
                  statement = this.parseLexicalDeclaration({ inFor: false });
                  break;
                case "function":
                  statement = this.parseFunctionDeclaration();
                  break;
                case "class":
                  statement = this.parseClassDeclaration();
                  break;
                case "let":
                  statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
                  break;
                default:
                  statement = this.parseStatement();
                  break;
              }
            } else {
              statement = this.parseStatement();
            }
            return statement;
          };
          Parser2.prototype.parseBlock = function() {
            var node = this.createNode();
            this.expect("{");
            var block = [];
            while (true) {
              if (this.match("}")) {
                break;
              }
              block.push(this.parseStatementListItem());
            }
            this.expect("}");
            return this.finalize(node, new Node.BlockStatement(block));
          };
          Parser2.prototype.parseLexicalBinding = function(kind, options) {
            var node = this.createNode();
            var params = [];
            var id = this.parsePattern(params, kind);
            if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
              if (this.scanner.isRestrictedWord(id.name)) {
                this.tolerateError(messages_1.Messages.StrictVarName);
              }
            }
            var init = null;
            if (kind === "const") {
              if (!this.matchKeyword("in") && !this.matchContextualKeyword("of")) {
                if (this.match("=")) {
                  this.nextToken();
                  init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                } else {
                  this.throwError(messages_1.Messages.DeclarationMissingInitializer, "const");
                }
              }
            } else if (!options.inFor && id.type !== syntax_1.Syntax.Identifier || this.match("=")) {
              this.expect("=");
              init = this.isolateCoverGrammar(this.parseAssignmentExpression);
            }
            return this.finalize(node, new Node.VariableDeclarator(id, init));
          };
          Parser2.prototype.parseBindingList = function(kind, options) {
            var list = [this.parseLexicalBinding(kind, options)];
            while (this.match(",")) {
              this.nextToken();
              list.push(this.parseLexicalBinding(kind, options));
            }
            return list;
          };
          Parser2.prototype.isLexicalDeclaration = function() {
            var state = this.scanner.saveState();
            this.scanner.scanComments();
            var next = this.scanner.lex();
            this.scanner.restoreState(state);
            return next.type === 3 || next.type === 7 && next.value === "[" || next.type === 7 && next.value === "{" || next.type === 4 && next.value === "let" || next.type === 4 && next.value === "yield";
          };
          Parser2.prototype.parseLexicalDeclaration = function(options) {
            var node = this.createNode();
            var kind = this.nextToken().value;
            assert_1.assert(kind === "let" || kind === "const", "Lexical declaration must be either let or const");
            var declarations = this.parseBindingList(kind, options);
            this.consumeSemicolon();
            return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
          };
          Parser2.prototype.parseBindingRestElement = function(params, kind) {
            var node = this.createNode();
            this.expect("...");
            var arg = this.parsePattern(params, kind);
            return this.finalize(node, new Node.RestElement(arg));
          };
          Parser2.prototype.parseArrayPattern = function(params, kind) {
            var node = this.createNode();
            this.expect("[");
            var elements = [];
            while (!this.match("]")) {
              if (this.match(",")) {
                this.nextToken();
                elements.push(null);
              } else {
                if (this.match("...")) {
                  elements.push(this.parseBindingRestElement(params, kind));
                  break;
                } else {
                  elements.push(this.parsePatternWithDefault(params, kind));
                }
                if (!this.match("]")) {
                  this.expect(",");
                }
              }
            }
            this.expect("]");
            return this.finalize(node, new Node.ArrayPattern(elements));
          };
          Parser2.prototype.parsePropertyPattern = function(params, kind) {
            var node = this.createNode();
            var computed = false;
            var shorthand = false;
            var method = false;
            var key;
            var value;
            if (this.lookahead.type === 3) {
              var keyToken = this.lookahead;
              key = this.parseVariableIdentifier();
              var init = this.finalize(node, new Node.Identifier(keyToken.value));
              if (this.match("=")) {
                params.push(keyToken);
                shorthand = true;
                this.nextToken();
                var expr = this.parseAssignmentExpression();
                value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
              } else if (!this.match(":")) {
                params.push(keyToken);
                shorthand = true;
                value = init;
              } else {
                this.expect(":");
                value = this.parsePatternWithDefault(params, kind);
              }
            } else {
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
              this.expect(":");
              value = this.parsePatternWithDefault(params, kind);
            }
            return this.finalize(node, new Node.Property("init", key, computed, value, method, shorthand));
          };
          Parser2.prototype.parseObjectPattern = function(params, kind) {
            var node = this.createNode();
            var properties = [];
            this.expect("{");
            while (!this.match("}")) {
              properties.push(this.parsePropertyPattern(params, kind));
              if (!this.match("}")) {
                this.expect(",");
              }
            }
            this.expect("}");
            return this.finalize(node, new Node.ObjectPattern(properties));
          };
          Parser2.prototype.parsePattern = function(params, kind) {
            var pattern;
            if (this.match("[")) {
              pattern = this.parseArrayPattern(params, kind);
            } else if (this.match("{")) {
              pattern = this.parseObjectPattern(params, kind);
            } else {
              if (this.matchKeyword("let") && (kind === "const" || kind === "let")) {
                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
              }
              params.push(this.lookahead);
              pattern = this.parseVariableIdentifier(kind);
            }
            return pattern;
          };
          Parser2.prototype.parsePatternWithDefault = function(params, kind) {
            var startToken = this.lookahead;
            var pattern = this.parsePattern(params, kind);
            if (this.match("=")) {
              this.nextToken();
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = true;
              var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
              this.context.allowYield = previousAllowYield;
              pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
            }
            return pattern;
          };
          Parser2.prototype.parseVariableIdentifier = function(kind) {
            var node = this.createNode();
            var token = this.nextToken();
            if (token.type === 4 && token.value === "yield") {
              if (this.context.strict) {
                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
              } else if (!this.context.allowYield) {
                this.throwUnexpectedToken(token);
              }
            } else if (token.type !== 3) {
              if (this.context.strict && token.type === 4 && this.scanner.isStrictModeReservedWord(token.value)) {
                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
              } else {
                if (this.context.strict || token.value !== "let" || kind !== "var") {
                  this.throwUnexpectedToken(token);
                }
              }
            } else if ((this.context.isModule || this.context.await) && token.type === 3 && token.value === "await") {
              this.tolerateUnexpectedToken(token);
            }
            return this.finalize(node, new Node.Identifier(token.value));
          };
          Parser2.prototype.parseVariableDeclaration = function(options) {
            var node = this.createNode();
            var params = [];
            var id = this.parsePattern(params, "var");
            if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
              if (this.scanner.isRestrictedWord(id.name)) {
                this.tolerateError(messages_1.Messages.StrictVarName);
              }
            }
            var init = null;
            if (this.match("=")) {
              this.nextToken();
              init = this.isolateCoverGrammar(this.parseAssignmentExpression);
            } else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
              this.expect("=");
            }
            return this.finalize(node, new Node.VariableDeclarator(id, init));
          };
          Parser2.prototype.parseVariableDeclarationList = function(options) {
            var opt = { inFor: options.inFor };
            var list = [];
            list.push(this.parseVariableDeclaration(opt));
            while (this.match(",")) {
              this.nextToken();
              list.push(this.parseVariableDeclaration(opt));
            }
            return list;
          };
          Parser2.prototype.parseVariableStatement = function() {
            var node = this.createNode();
            this.expectKeyword("var");
            var declarations = this.parseVariableDeclarationList({ inFor: false });
            this.consumeSemicolon();
            return this.finalize(node, new Node.VariableDeclaration(declarations, "var"));
          };
          Parser2.prototype.parseEmptyStatement = function() {
            var node = this.createNode();
            this.expect(";");
            return this.finalize(node, new Node.EmptyStatement);
          };
          Parser2.prototype.parseExpressionStatement = function() {
            var node = this.createNode();
            var expr = this.parseExpression();
            this.consumeSemicolon();
            return this.finalize(node, new Node.ExpressionStatement(expr));
          };
          Parser2.prototype.parseIfClause = function() {
            if (this.context.strict && this.matchKeyword("function")) {
              this.tolerateError(messages_1.Messages.StrictFunction);
            }
            return this.parseStatement();
          };
          Parser2.prototype.parseIfStatement = function() {
            var node = this.createNode();
            var consequent;
            var alternate = null;
            this.expectKeyword("if");
            this.expect("(");
            var test = this.parseExpression();
            if (!this.match(")") && this.config.tolerant) {
              this.tolerateUnexpectedToken(this.nextToken());
              consequent = this.finalize(this.createNode(), new Node.EmptyStatement);
            } else {
              this.expect(")");
              consequent = this.parseIfClause();
              if (this.matchKeyword("else")) {
                this.nextToken();
                alternate = this.parseIfClause();
              }
            }
            return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
          };
          Parser2.prototype.parseDoWhileStatement = function() {
            var node = this.createNode();
            this.expectKeyword("do");
            var previousInIteration = this.context.inIteration;
            this.context.inIteration = true;
            var body = this.parseStatement();
            this.context.inIteration = previousInIteration;
            this.expectKeyword("while");
            this.expect("(");
            var test = this.parseExpression();
            if (!this.match(")") && this.config.tolerant) {
              this.tolerateUnexpectedToken(this.nextToken());
            } else {
              this.expect(")");
              if (this.match(";")) {
                this.nextToken();
              }
            }
            return this.finalize(node, new Node.DoWhileStatement(body, test));
          };
          Parser2.prototype.parseWhileStatement = function() {
            var node = this.createNode();
            var body;
            this.expectKeyword("while");
            this.expect("(");
            var test = this.parseExpression();
            if (!this.match(")") && this.config.tolerant) {
              this.tolerateUnexpectedToken(this.nextToken());
              body = this.finalize(this.createNode(), new Node.EmptyStatement);
            } else {
              this.expect(")");
              var previousInIteration = this.context.inIteration;
              this.context.inIteration = true;
              body = this.parseStatement();
              this.context.inIteration = previousInIteration;
            }
            return this.finalize(node, new Node.WhileStatement(test, body));
          };
          Parser2.prototype.parseForStatement = function() {
            var init = null;
            var test = null;
            var update = null;
            var forIn = true;
            var left, right;
            var node = this.createNode();
            this.expectKeyword("for");
            this.expect("(");
            if (this.match(";")) {
              this.nextToken();
            } else {
              if (this.matchKeyword("var")) {
                init = this.createNode();
                this.nextToken();
                var previousAllowIn = this.context.allowIn;
                this.context.allowIn = false;
                var declarations = this.parseVariableDeclarationList({ inFor: true });
                this.context.allowIn = previousAllowIn;
                if (declarations.length === 1 && this.matchKeyword("in")) {
                  var decl = declarations[0];
                  if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
                    this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, "for-in");
                  }
                  init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                  this.nextToken();
                  left = init;
                  right = this.parseExpression();
                  init = null;
                } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                  init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                  this.nextToken();
                  left = init;
                  right = this.parseAssignmentExpression();
                  init = null;
                  forIn = false;
                } else {
                  init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                  this.expect(";");
                }
              } else if (this.matchKeyword("const") || this.matchKeyword("let")) {
                init = this.createNode();
                var kind = this.nextToken().value;
                if (!this.context.strict && this.lookahead.value === "in") {
                  init = this.finalize(init, new Node.Identifier(kind));
                  this.nextToken();
                  left = init;
                  right = this.parseExpression();
                  init = null;
                } else {
                  var previousAllowIn = this.context.allowIn;
                  this.context.allowIn = false;
                  var declarations = this.parseBindingList(kind, { inFor: true });
                  this.context.allowIn = previousAllowIn;
                  if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword("in")) {
                    init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                    this.nextToken();
                    left = init;
                    right = this.parseExpression();
                    init = null;
                  } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                    init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                    this.nextToken();
                    left = init;
                    right = this.parseAssignmentExpression();
                    init = null;
                    forIn = false;
                  } else {
                    this.consumeSemicolon();
                    init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                  }
                }
              } else {
                var initStartToken = this.lookahead;
                var previousAllowIn = this.context.allowIn;
                this.context.allowIn = false;
                init = this.inheritCoverGrammar(this.parseAssignmentExpression);
                this.context.allowIn = previousAllowIn;
                if (this.matchKeyword("in")) {
                  if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                    this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
                  }
                  this.nextToken();
                  this.reinterpretExpressionAsPattern(init);
                  left = init;
                  right = this.parseExpression();
                  init = null;
                } else if (this.matchContextualKeyword("of")) {
                  if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                    this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
                  }
                  this.nextToken();
                  this.reinterpretExpressionAsPattern(init);
                  left = init;
                  right = this.parseAssignmentExpression();
                  init = null;
                  forIn = false;
                } else {
                  if (this.match(",")) {
                    var initSeq = [init];
                    while (this.match(",")) {
                      this.nextToken();
                      initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                    }
                    init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
                  }
                  this.expect(";");
                }
              }
            }
            if (typeof left === "undefined") {
              if (!this.match(";")) {
                test = this.parseExpression();
              }
              this.expect(";");
              if (!this.match(")")) {
                update = this.parseExpression();
              }
            }
            var body;
            if (!this.match(")") && this.config.tolerant) {
              this.tolerateUnexpectedToken(this.nextToken());
              body = this.finalize(this.createNode(), new Node.EmptyStatement);
            } else {
              this.expect(")");
              var previousInIteration = this.context.inIteration;
              this.context.inIteration = true;
              body = this.isolateCoverGrammar(this.parseStatement);
              this.context.inIteration = previousInIteration;
            }
            return typeof left === "undefined" ? this.finalize(node, new Node.ForStatement(init, test, update, body)) : forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) : this.finalize(node, new Node.ForOfStatement(left, right, body));
          };
          Parser2.prototype.parseContinueStatement = function() {
            var node = this.createNode();
            this.expectKeyword("continue");
            var label = null;
            if (this.lookahead.type === 3 && !this.hasLineTerminator) {
              var id = this.parseVariableIdentifier();
              label = id;
              var key = "$" + id.name;
              if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                this.throwError(messages_1.Messages.UnknownLabel, id.name);
              }
            }
            this.consumeSemicolon();
            if (label === null && !this.context.inIteration) {
              this.throwError(messages_1.Messages.IllegalContinue);
            }
            return this.finalize(node, new Node.ContinueStatement(label));
          };
          Parser2.prototype.parseBreakStatement = function() {
            var node = this.createNode();
            this.expectKeyword("break");
            var label = null;
            if (this.lookahead.type === 3 && !this.hasLineTerminator) {
              var id = this.parseVariableIdentifier();
              var key = "$" + id.name;
              if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                this.throwError(messages_1.Messages.UnknownLabel, id.name);
              }
              label = id;
            }
            this.consumeSemicolon();
            if (label === null && !this.context.inIteration && !this.context.inSwitch) {
              this.throwError(messages_1.Messages.IllegalBreak);
            }
            return this.finalize(node, new Node.BreakStatement(label));
          };
          Parser2.prototype.parseReturnStatement = function() {
            if (!this.context.inFunctionBody) {
              this.tolerateError(messages_1.Messages.IllegalReturn);
            }
            var node = this.createNode();
            this.expectKeyword("return");
            var hasArgument = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== 2 || this.lookahead.type === 8 || this.lookahead.type === 10;
            var argument = hasArgument ? this.parseExpression() : null;
            this.consumeSemicolon();
            return this.finalize(node, new Node.ReturnStatement(argument));
          };
          Parser2.prototype.parseWithStatement = function() {
            if (this.context.strict) {
              this.tolerateError(messages_1.Messages.StrictModeWith);
            }
            var node = this.createNode();
            var body;
            this.expectKeyword("with");
            this.expect("(");
            var object = this.parseExpression();
            if (!this.match(")") && this.config.tolerant) {
              this.tolerateUnexpectedToken(this.nextToken());
              body = this.finalize(this.createNode(), new Node.EmptyStatement);
            } else {
              this.expect(")");
              body = this.parseStatement();
            }
            return this.finalize(node, new Node.WithStatement(object, body));
          };
          Parser2.prototype.parseSwitchCase = function() {
            var node = this.createNode();
            var test;
            if (this.matchKeyword("default")) {
              this.nextToken();
              test = null;
            } else {
              this.expectKeyword("case");
              test = this.parseExpression();
            }
            this.expect(":");
            var consequent = [];
            while (true) {
              if (this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")) {
                break;
              }
              consequent.push(this.parseStatementListItem());
            }
            return this.finalize(node, new Node.SwitchCase(test, consequent));
          };
          Parser2.prototype.parseSwitchStatement = function() {
            var node = this.createNode();
            this.expectKeyword("switch");
            this.expect("(");
            var discriminant = this.parseExpression();
            this.expect(")");
            var previousInSwitch = this.context.inSwitch;
            this.context.inSwitch = true;
            var cases = [];
            var defaultFound = false;
            this.expect("{");
            while (true) {
              if (this.match("}")) {
                break;
              }
              var clause = this.parseSwitchCase();
              if (clause.test === null) {
                if (defaultFound) {
                  this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
              }
              cases.push(clause);
            }
            this.expect("}");
            this.context.inSwitch = previousInSwitch;
            return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
          };
          Parser2.prototype.parseLabelledStatement = function() {
            var node = this.createNode();
            var expr = this.parseExpression();
            var statement;
            if (expr.type === syntax_1.Syntax.Identifier && this.match(":")) {
              this.nextToken();
              var id = expr;
              var key = "$" + id.name;
              if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                this.throwError(messages_1.Messages.Redeclaration, "Label", id.name);
              }
              this.context.labelSet[key] = true;
              var body = undefined;
              if (this.matchKeyword("class")) {
                this.tolerateUnexpectedToken(this.lookahead);
                body = this.parseClassDeclaration();
              } else if (this.matchKeyword("function")) {
                var token = this.lookahead;
                var declaration = this.parseFunctionDeclaration();
                if (this.context.strict) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
                } else if (declaration.generator) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
                }
                body = declaration;
              } else {
                body = this.parseStatement();
              }
              delete this.context.labelSet[key];
              statement = new Node.LabeledStatement(id, body);
            } else {
              this.consumeSemicolon();
              statement = new Node.ExpressionStatement(expr);
            }
            return this.finalize(node, statement);
          };
          Parser2.prototype.parseThrowStatement = function() {
            var node = this.createNode();
            this.expectKeyword("throw");
            if (this.hasLineTerminator) {
              this.throwError(messages_1.Messages.NewlineAfterThrow);
            }
            var argument = this.parseExpression();
            this.consumeSemicolon();
            return this.finalize(node, new Node.ThrowStatement(argument));
          };
          Parser2.prototype.parseCatchClause = function() {
            var node = this.createNode();
            this.expectKeyword("catch");
            this.expect("(");
            if (this.match(")")) {
              this.throwUnexpectedToken(this.lookahead);
            }
            var params = [];
            var param = this.parsePattern(params);
            var paramMap = {};
            for (var i = 0;i < params.length; i++) {
              var key = "$" + params[i].value;
              if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
                this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
              }
              paramMap[key] = true;
            }
            if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
              if (this.scanner.isRestrictedWord(param.name)) {
                this.tolerateError(messages_1.Messages.StrictCatchVariable);
              }
            }
            this.expect(")");
            var body = this.parseBlock();
            return this.finalize(node, new Node.CatchClause(param, body));
          };
          Parser2.prototype.parseFinallyClause = function() {
            this.expectKeyword("finally");
            return this.parseBlock();
          };
          Parser2.prototype.parseTryStatement = function() {
            var node = this.createNode();
            this.expectKeyword("try");
            var block = this.parseBlock();
            var handler = this.matchKeyword("catch") ? this.parseCatchClause() : null;
            var finalizer = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
            if (!handler && !finalizer) {
              this.throwError(messages_1.Messages.NoCatchOrFinally);
            }
            return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
          };
          Parser2.prototype.parseDebuggerStatement = function() {
            var node = this.createNode();
            this.expectKeyword("debugger");
            this.consumeSemicolon();
            return this.finalize(node, new Node.DebuggerStatement);
          };
          Parser2.prototype.parseStatement = function() {
            var statement;
            switch (this.lookahead.type) {
              case 1:
              case 5:
              case 6:
              case 8:
              case 10:
              case 9:
                statement = this.parseExpressionStatement();
                break;
              case 7:
                var value = this.lookahead.value;
                if (value === "{") {
                  statement = this.parseBlock();
                } else if (value === "(") {
                  statement = this.parseExpressionStatement();
                } else if (value === ";") {
                  statement = this.parseEmptyStatement();
                } else {
                  statement = this.parseExpressionStatement();
                }
                break;
              case 3:
                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
                break;
              case 4:
                switch (this.lookahead.value) {
                  case "break":
                    statement = this.parseBreakStatement();
                    break;
                  case "continue":
                    statement = this.parseContinueStatement();
                    break;
                  case "debugger":
                    statement = this.parseDebuggerStatement();
                    break;
                  case "do":
                    statement = this.parseDoWhileStatement();
                    break;
                  case "for":
                    statement = this.parseForStatement();
                    break;
                  case "function":
                    statement = this.parseFunctionDeclaration();
                    break;
                  case "if":
                    statement = this.parseIfStatement();
                    break;
                  case "return":
                    statement = this.parseReturnStatement();
                    break;
                  case "switch":
                    statement = this.parseSwitchStatement();
                    break;
                  case "throw":
                    statement = this.parseThrowStatement();
                    break;
                  case "try":
                    statement = this.parseTryStatement();
                    break;
                  case "var":
                    statement = this.parseVariableStatement();
                    break;
                  case "while":
                    statement = this.parseWhileStatement();
                    break;
                  case "with":
                    statement = this.parseWithStatement();
                    break;
                  default:
                    statement = this.parseExpressionStatement();
                    break;
                }
                break;
              default:
                statement = this.throwUnexpectedToken(this.lookahead);
            }
            return statement;
          };
          Parser2.prototype.parseFunctionSourceElements = function() {
            var node = this.createNode();
            this.expect("{");
            var body = this.parseDirectivePrologues();
            var previousLabelSet = this.context.labelSet;
            var previousInIteration = this.context.inIteration;
            var previousInSwitch = this.context.inSwitch;
            var previousInFunctionBody = this.context.inFunctionBody;
            this.context.labelSet = {};
            this.context.inIteration = false;
            this.context.inSwitch = false;
            this.context.inFunctionBody = true;
            while (this.lookahead.type !== 2) {
              if (this.match("}")) {
                break;
              }
              body.push(this.parseStatementListItem());
            }
            this.expect("}");
            this.context.labelSet = previousLabelSet;
            this.context.inIteration = previousInIteration;
            this.context.inSwitch = previousInSwitch;
            this.context.inFunctionBody = previousInFunctionBody;
            return this.finalize(node, new Node.BlockStatement(body));
          };
          Parser2.prototype.validateParam = function(options, param, name) {
            var key = "$" + name;
            if (this.context.strict) {
              if (this.scanner.isRestrictedWord(name)) {
                options.stricted = param;
                options.message = messages_1.Messages.StrictParamName;
              }
              if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = messages_1.Messages.StrictParamDupe;
              }
            } else if (!options.firstRestricted) {
              if (this.scanner.isRestrictedWord(name)) {
                options.firstRestricted = param;
                options.message = messages_1.Messages.StrictParamName;
              } else if (this.scanner.isStrictModeReservedWord(name)) {
                options.firstRestricted = param;
                options.message = messages_1.Messages.StrictReservedWord;
              } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = messages_1.Messages.StrictParamDupe;
              }
            }
            if (typeof Object.defineProperty === "function") {
              Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
            } else {
              options.paramSet[key] = true;
            }
          };
          Parser2.prototype.parseRestElement = function(params) {
            var node = this.createNode();
            this.expect("...");
            var arg = this.parsePattern(params);
            if (this.match("=")) {
              this.throwError(messages_1.Messages.DefaultRestParameter);
            }
            if (!this.match(")")) {
              this.throwError(messages_1.Messages.ParameterAfterRestParameter);
            }
            return this.finalize(node, new Node.RestElement(arg));
          };
          Parser2.prototype.parseFormalParameter = function(options) {
            var params = [];
            var param = this.match("...") ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
            for (var i = 0;i < params.length; i++) {
              this.validateParam(options, params[i], params[i].value);
            }
            options.simple = options.simple && param instanceof Node.Identifier;
            options.params.push(param);
          };
          Parser2.prototype.parseFormalParameters = function(firstRestricted) {
            var options;
            options = {
              simple: true,
              params: [],
              firstRestricted
            };
            this.expect("(");
            if (!this.match(")")) {
              options.paramSet = {};
              while (this.lookahead.type !== 2) {
                this.parseFormalParameter(options);
                if (this.match(")")) {
                  break;
                }
                this.expect(",");
                if (this.match(")")) {
                  break;
                }
              }
            }
            this.expect(")");
            return {
              simple: options.simple,
              params: options.params,
              stricted: options.stricted,
              firstRestricted: options.firstRestricted,
              message: options.message
            };
          };
          Parser2.prototype.matchAsyncFunction = function() {
            var match = this.matchContextualKeyword("async");
            if (match) {
              var state = this.scanner.saveState();
              this.scanner.scanComments();
              var next = this.scanner.lex();
              this.scanner.restoreState(state);
              match = state.lineNumber === next.lineNumber && next.type === 4 && next.value === "function";
            }
            return match;
          };
          Parser2.prototype.parseFunctionDeclaration = function(identifierIsOptional) {
            var node = this.createNode();
            var isAsync = this.matchContextualKeyword("async");
            if (isAsync) {
              this.nextToken();
            }
            this.expectKeyword("function");
            var isGenerator = isAsync ? false : this.match("*");
            if (isGenerator) {
              this.nextToken();
            }
            var message;
            var id = null;
            var firstRestricted = null;
            if (!identifierIsOptional || !this.match("(")) {
              var token = this.lookahead;
              id = this.parseVariableIdentifier();
              if (this.context.strict) {
                if (this.scanner.isRestrictedWord(token.value)) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                }
              } else {
                if (this.scanner.isRestrictedWord(token.value)) {
                  firstRestricted = token;
                  message = messages_1.Messages.StrictFunctionName;
                } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                  firstRestricted = token;
                  message = messages_1.Messages.StrictReservedWord;
                }
              }
            }
            var previousAllowAwait = this.context.await;
            var previousAllowYield = this.context.allowYield;
            this.context.await = isAsync;
            this.context.allowYield = !isGenerator;
            var formalParameters = this.parseFormalParameters(firstRestricted);
            var params = formalParameters.params;
            var stricted = formalParameters.stricted;
            firstRestricted = formalParameters.firstRestricted;
            if (formalParameters.message) {
              message = formalParameters.message;
            }
            var previousStrict = this.context.strict;
            var previousAllowStrictDirective = this.context.allowStrictDirective;
            this.context.allowStrictDirective = formalParameters.simple;
            var body = this.parseFunctionSourceElements();
            if (this.context.strict && firstRestricted) {
              this.throwUnexpectedToken(firstRestricted, message);
            }
            if (this.context.strict && stricted) {
              this.tolerateUnexpectedToken(stricted, message);
            }
            this.context.strict = previousStrict;
            this.context.allowStrictDirective = previousAllowStrictDirective;
            this.context.await = previousAllowAwait;
            this.context.allowYield = previousAllowYield;
            return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) : this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
          };
          Parser2.prototype.parseFunctionExpression = function() {
            var node = this.createNode();
            var isAsync = this.matchContextualKeyword("async");
            if (isAsync) {
              this.nextToken();
            }
            this.expectKeyword("function");
            var isGenerator = isAsync ? false : this.match("*");
            if (isGenerator) {
              this.nextToken();
            }
            var message;
            var id = null;
            var firstRestricted;
            var previousAllowAwait = this.context.await;
            var previousAllowYield = this.context.allowYield;
            this.context.await = isAsync;
            this.context.allowYield = !isGenerator;
            if (!this.match("(")) {
              var token = this.lookahead;
              id = !this.context.strict && !isGenerator && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier();
              if (this.context.strict) {
                if (this.scanner.isRestrictedWord(token.value)) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                }
              } else {
                if (this.scanner.isRestrictedWord(token.value)) {
                  firstRestricted = token;
                  message = messages_1.Messages.StrictFunctionName;
                } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                  firstRestricted = token;
                  message = messages_1.Messages.StrictReservedWord;
                }
              }
            }
            var formalParameters = this.parseFormalParameters(firstRestricted);
            var params = formalParameters.params;
            var stricted = formalParameters.stricted;
            firstRestricted = formalParameters.firstRestricted;
            if (formalParameters.message) {
              message = formalParameters.message;
            }
            var previousStrict = this.context.strict;
            var previousAllowStrictDirective = this.context.allowStrictDirective;
            this.context.allowStrictDirective = formalParameters.simple;
            var body = this.parseFunctionSourceElements();
            if (this.context.strict && firstRestricted) {
              this.throwUnexpectedToken(firstRestricted, message);
            }
            if (this.context.strict && stricted) {
              this.tolerateUnexpectedToken(stricted, message);
            }
            this.context.strict = previousStrict;
            this.context.allowStrictDirective = previousAllowStrictDirective;
            this.context.await = previousAllowAwait;
            this.context.allowYield = previousAllowYield;
            return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) : this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
          };
          Parser2.prototype.parseDirective = function() {
            var token = this.lookahead;
            var node = this.createNode();
            var expr = this.parseExpression();
            var directive = expr.type === syntax_1.Syntax.Literal ? this.getTokenRaw(token).slice(1, -1) : null;
            this.consumeSemicolon();
            return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
          };
          Parser2.prototype.parseDirectivePrologues = function() {
            var firstRestricted = null;
            var body = [];
            while (true) {
              var token = this.lookahead;
              if (token.type !== 8) {
                break;
              }
              var statement = this.parseDirective();
              body.push(statement);
              var directive = statement.directive;
              if (typeof directive !== "string") {
                break;
              }
              if (directive === "use strict") {
                this.context.strict = true;
                if (firstRestricted) {
                  this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
                }
                if (!this.context.allowStrictDirective) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
                }
              } else {
                if (!firstRestricted && token.octal) {
                  firstRestricted = token;
                }
              }
            }
            return body;
          };
          Parser2.prototype.qualifiedPropertyName = function(token) {
            switch (token.type) {
              case 3:
              case 8:
              case 1:
              case 5:
              case 6:
              case 4:
                return true;
              case 7:
                return token.value === "[";
              default:
                break;
            }
            return false;
          };
          Parser2.prototype.parseGetterMethod = function() {
            var node = this.createNode();
            var isGenerator = false;
            var previousAllowYield = this.context.allowYield;
            this.context.allowYield = !isGenerator;
            var formalParameters = this.parseFormalParameters();
            if (formalParameters.params.length > 0) {
              this.tolerateError(messages_1.Messages.BadGetterArity);
            }
            var method = this.parsePropertyMethod(formalParameters);
            this.context.allowYield = previousAllowYield;
            return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
          };
          Parser2.prototype.parseSetterMethod = function() {
            var node = this.createNode();
            var isGenerator = false;
            var previousAllowYield = this.context.allowYield;
            this.context.allowYield = !isGenerator;
            var formalParameters = this.parseFormalParameters();
            if (formalParameters.params.length !== 1) {
              this.tolerateError(messages_1.Messages.BadSetterArity);
            } else if (formalParameters.params[0] instanceof Node.RestElement) {
              this.tolerateError(messages_1.Messages.BadSetterRestParameter);
            }
            var method = this.parsePropertyMethod(formalParameters);
            this.context.allowYield = previousAllowYield;
            return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
          };
          Parser2.prototype.parseGeneratorMethod = function() {
            var node = this.createNode();
            var isGenerator = true;
            var previousAllowYield = this.context.allowYield;
            this.context.allowYield = true;
            var params = this.parseFormalParameters();
            this.context.allowYield = false;
            var method = this.parsePropertyMethod(params);
            this.context.allowYield = previousAllowYield;
            return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
          };
          Parser2.prototype.isStartOfExpression = function() {
            var start = true;
            var value = this.lookahead.value;
            switch (this.lookahead.type) {
              case 7:
                start = value === "[" || value === "(" || value === "{" || value === "+" || value === "-" || value === "!" || value === "~" || value === "++" || value === "--" || value === "/" || value === "/=";
                break;
              case 4:
                start = value === "class" || value === "delete" || value === "function" || value === "let" || value === "new" || value === "super" || value === "this" || value === "typeof" || value === "void" || value === "yield";
                break;
              default:
                break;
            }
            return start;
          };
          Parser2.prototype.parseYieldExpression = function() {
            var node = this.createNode();
            this.expectKeyword("yield");
            var argument = null;
            var delegate = false;
            if (!this.hasLineTerminator) {
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = false;
              delegate = this.match("*");
              if (delegate) {
                this.nextToken();
                argument = this.parseAssignmentExpression();
              } else if (this.isStartOfExpression()) {
                argument = this.parseAssignmentExpression();
              }
              this.context.allowYield = previousAllowYield;
            }
            return this.finalize(node, new Node.YieldExpression(argument, delegate));
          };
          Parser2.prototype.parseClassElement = function(hasConstructor) {
            var token = this.lookahead;
            var node = this.createNode();
            var kind = "";
            var key = null;
            var value = null;
            var computed = false;
            var method = false;
            var isStatic = false;
            var isAsync = false;
            if (this.match("*")) {
              this.nextToken();
            } else {
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
              var id = key;
              if (id.name === "static" && (this.qualifiedPropertyName(this.lookahead) || this.match("*"))) {
                token = this.lookahead;
                isStatic = true;
                computed = this.match("[");
                if (this.match("*")) {
                  this.nextToken();
                } else {
                  key = this.parseObjectPropertyKey();
                }
              }
              if (token.type === 3 && !this.hasLineTerminator && token.value === "async") {
                var punctuator = this.lookahead.value;
                if (punctuator !== ":" && punctuator !== "(" && punctuator !== "*") {
                  isAsync = true;
                  token = this.lookahead;
                  key = this.parseObjectPropertyKey();
                  if (token.type === 3 && token.value === "constructor") {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
                  }
                }
              }
            }
            var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
            if (token.type === 3) {
              if (token.value === "get" && lookaheadPropertyKey) {
                kind = "get";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                this.context.allowYield = false;
                value = this.parseGetterMethod();
              } else if (token.value === "set" && lookaheadPropertyKey) {
                kind = "set";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                value = this.parseSetterMethod();
              }
            } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
              kind = "init";
              computed = this.match("[");
              key = this.parseObjectPropertyKey();
              value = this.parseGeneratorMethod();
              method = true;
            }
            if (!kind && key && this.match("(")) {
              kind = "init";
              value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
              method = true;
            }
            if (!kind) {
              this.throwUnexpectedToken(this.lookahead);
            }
            if (kind === "init") {
              kind = "method";
            }
            if (!computed) {
              if (isStatic && this.isPropertyKey(key, "prototype")) {
                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
              }
              if (!isStatic && this.isPropertyKey(key, "constructor")) {
                if (kind !== "method" || !method || value && value.generator) {
                  this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
                }
                if (hasConstructor.value) {
                  this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
                } else {
                  hasConstructor.value = true;
                }
                kind = "constructor";
              }
            }
            return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
          };
          Parser2.prototype.parseClassElementList = function() {
            var body = [];
            var hasConstructor = { value: false };
            this.expect("{");
            while (!this.match("}")) {
              if (this.match(";")) {
                this.nextToken();
              } else {
                body.push(this.parseClassElement(hasConstructor));
              }
            }
            this.expect("}");
            return body;
          };
          Parser2.prototype.parseClassBody = function() {
            var node = this.createNode();
            var elementList = this.parseClassElementList();
            return this.finalize(node, new Node.ClassBody(elementList));
          };
          Parser2.prototype.parseClassDeclaration = function(identifierIsOptional) {
            var node = this.createNode();
            var previousStrict = this.context.strict;
            this.context.strict = true;
            this.expectKeyword("class");
            var id = identifierIsOptional && this.lookahead.type !== 3 ? null : this.parseVariableIdentifier();
            var superClass = null;
            if (this.matchKeyword("extends")) {
              this.nextToken();
              superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
            }
            var classBody = this.parseClassBody();
            this.context.strict = previousStrict;
            return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
          };
          Parser2.prototype.parseClassExpression = function() {
            var node = this.createNode();
            var previousStrict = this.context.strict;
            this.context.strict = true;
            this.expectKeyword("class");
            var id = this.lookahead.type === 3 ? this.parseVariableIdentifier() : null;
            var superClass = null;
            if (this.matchKeyword("extends")) {
              this.nextToken();
              superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
            }
            var classBody = this.parseClassBody();
            this.context.strict = previousStrict;
            return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
          };
          Parser2.prototype.parseModule = function() {
            this.context.strict = true;
            this.context.isModule = true;
            this.scanner.isModule = true;
            var node = this.createNode();
            var body = this.parseDirectivePrologues();
            while (this.lookahead.type !== 2) {
              body.push(this.parseStatementListItem());
            }
            return this.finalize(node, new Node.Module(body));
          };
          Parser2.prototype.parseScript = function() {
            var node = this.createNode();
            var body = this.parseDirectivePrologues();
            while (this.lookahead.type !== 2) {
              body.push(this.parseStatementListItem());
            }
            return this.finalize(node, new Node.Script(body));
          };
          Parser2.prototype.parseModuleSpecifier = function() {
            var node = this.createNode();
            if (this.lookahead.type !== 8) {
              this.throwError(messages_1.Messages.InvalidModuleSpecifier);
            }
            var token = this.nextToken();
            var raw = this.getTokenRaw(token);
            return this.finalize(node, new Node.Literal(token.value, raw));
          };
          Parser2.prototype.parseImportSpecifier = function() {
            var node = this.createNode();
            var imported;
            var local;
            if (this.lookahead.type === 3) {
              imported = this.parseVariableIdentifier();
              local = imported;
              if (this.matchContextualKeyword("as")) {
                this.nextToken();
                local = this.parseVariableIdentifier();
              }
            } else {
              imported = this.parseIdentifierName();
              local = imported;
              if (this.matchContextualKeyword("as")) {
                this.nextToken();
                local = this.parseVariableIdentifier();
              } else {
                this.throwUnexpectedToken(this.nextToken());
              }
            }
            return this.finalize(node, new Node.ImportSpecifier(local, imported));
          };
          Parser2.prototype.parseNamedImports = function() {
            this.expect("{");
            var specifiers = [];
            while (!this.match("}")) {
              specifiers.push(this.parseImportSpecifier());
              if (!this.match("}")) {
                this.expect(",");
              }
            }
            this.expect("}");
            return specifiers;
          };
          Parser2.prototype.parseImportDefaultSpecifier = function() {
            var node = this.createNode();
            var local = this.parseIdentifierName();
            return this.finalize(node, new Node.ImportDefaultSpecifier(local));
          };
          Parser2.prototype.parseImportNamespaceSpecifier = function() {
            var node = this.createNode();
            this.expect("*");
            if (!this.matchContextualKeyword("as")) {
              this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
            }
            this.nextToken();
            var local = this.parseIdentifierName();
            return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
          };
          Parser2.prototype.parseImportDeclaration = function() {
            if (this.context.inFunctionBody) {
              this.throwError(messages_1.Messages.IllegalImportDeclaration);
            }
            var node = this.createNode();
            this.expectKeyword("import");
            var src;
            var specifiers = [];
            if (this.lookahead.type === 8) {
              src = this.parseModuleSpecifier();
            } else {
              if (this.match("{")) {
                specifiers = specifiers.concat(this.parseNamedImports());
              } else if (this.match("*")) {
                specifiers.push(this.parseImportNamespaceSpecifier());
              } else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword("default")) {
                specifiers.push(this.parseImportDefaultSpecifier());
                if (this.match(",")) {
                  this.nextToken();
                  if (this.match("*")) {
                    specifiers.push(this.parseImportNamespaceSpecifier());
                  } else if (this.match("{")) {
                    specifiers = specifiers.concat(this.parseNamedImports());
                  } else {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                }
              } else {
                this.throwUnexpectedToken(this.nextToken());
              }
              if (!this.matchContextualKeyword("from")) {
                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                this.throwError(message, this.lookahead.value);
              }
              this.nextToken();
              src = this.parseModuleSpecifier();
            }
            this.consumeSemicolon();
            return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
          };
          Parser2.prototype.parseExportSpecifier = function() {
            var node = this.createNode();
            var local = this.parseIdentifierName();
            var exported = local;
            if (this.matchContextualKeyword("as")) {
              this.nextToken();
              exported = this.parseIdentifierName();
            }
            return this.finalize(node, new Node.ExportSpecifier(local, exported));
          };
          Parser2.prototype.parseExportDeclaration = function() {
            if (this.context.inFunctionBody) {
              this.throwError(messages_1.Messages.IllegalExportDeclaration);
            }
            var node = this.createNode();
            this.expectKeyword("export");
            var exportDeclaration;
            if (this.matchKeyword("default")) {
              this.nextToken();
              if (this.matchKeyword("function")) {
                var declaration = this.parseFunctionDeclaration(true);
                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
              } else if (this.matchKeyword("class")) {
                var declaration = this.parseClassDeclaration(true);
                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
              } else if (this.matchContextualKeyword("async")) {
                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
              } else {
                if (this.matchContextualKeyword("from")) {
                  this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
                }
                var declaration = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
                this.consumeSemicolon();
                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
              }
            } else if (this.match("*")) {
              this.nextToken();
              if (!this.matchContextualKeyword("from")) {
                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                this.throwError(message, this.lookahead.value);
              }
              this.nextToken();
              var src = this.parseModuleSpecifier();
              this.consumeSemicolon();
              exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
            } else if (this.lookahead.type === 4) {
              var declaration = undefined;
              switch (this.lookahead.value) {
                case "let":
                case "const":
                  declaration = this.parseLexicalDeclaration({ inFor: false });
                  break;
                case "var":
                case "class":
                case "function":
                  declaration = this.parseStatementListItem();
                  break;
                default:
                  this.throwUnexpectedToken(this.lookahead);
              }
              exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
            } else if (this.matchAsyncFunction()) {
              var declaration = this.parseFunctionDeclaration();
              exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
            } else {
              var specifiers = [];
              var source = null;
              var isExportFromIdentifier = false;
              this.expect("{");
              while (!this.match("}")) {
                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword("default");
                specifiers.push(this.parseExportSpecifier());
                if (!this.match("}")) {
                  this.expect(",");
                }
              }
              this.expect("}");
              if (this.matchContextualKeyword("from")) {
                this.nextToken();
                source = this.parseModuleSpecifier();
                this.consumeSemicolon();
              } else if (isExportFromIdentifier) {
                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                this.throwError(message, this.lookahead.value);
              } else {
                this.consumeSemicolon();
              }
              exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
            }
            return exportDeclaration;
          };
          return Parser2;
        }();
        exports2.Parser = Parser;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        function assert6(condition, message) {
          if (!condition) {
            throw new Error("ASSERT: " + message);
          }
        }
        exports2.assert = assert6;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var ErrorHandler = function() {
          function ErrorHandler2() {
            this.errors = [];
            this.tolerant = false;
          }
          ErrorHandler2.prototype.recordError = function(error) {
            this.errors.push(error);
          };
          ErrorHandler2.prototype.tolerate = function(error) {
            if (this.tolerant) {
              this.recordError(error);
            } else {
              throw error;
            }
          };
          ErrorHandler2.prototype.constructError = function(msg, column) {
            var error = new Error(msg);
            try {
              throw error;
            } catch (base) {
              if (Object.create && Object.defineProperty) {
                error = Object.create(base);
                Object.defineProperty(error, "column", { value: column });
              }
            }
            return error;
          };
          ErrorHandler2.prototype.createError = function(index, line, col, description) {
            var msg = "Line " + line + ": " + description;
            var error = this.constructError(msg, col);
            error.index = index;
            error.lineNumber = line;
            error.description = description;
            return error;
          };
          ErrorHandler2.prototype.throwError = function(index, line, col, description) {
            throw this.createError(index, line, col, description);
          };
          ErrorHandler2.prototype.tolerateError = function(index, line, col, description) {
            var error = this.createError(index, line, col, description);
            if (this.tolerant) {
              this.recordError(error);
            } else {
              throw error;
            }
          };
          return ErrorHandler2;
        }();
        exports2.ErrorHandler = ErrorHandler;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.Messages = {
          BadGetterArity: "Getter must not have any formal parameters",
          BadSetterArity: "Setter must have exactly one formal parameter",
          BadSetterRestParameter: "Setter function argument must not be a rest parameter",
          ConstructorIsAsync: "Class constructor may not be an async method",
          ConstructorSpecialMethod: "Class constructor may not be an accessor",
          DeclarationMissingInitializer: "Missing initializer in %0 declaration",
          DefaultRestParameter: "Unexpected token =",
          DuplicateBinding: "Duplicate binding %0",
          DuplicateConstructor: "A class may only have one constructor",
          DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals",
          ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
          GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts",
          IllegalBreak: "Illegal break statement",
          IllegalContinue: "Illegal continue statement",
          IllegalExportDeclaration: "Unexpected token",
          IllegalImportDeclaration: "Unexpected token",
          IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
          IllegalReturn: "Illegal return statement",
          InvalidEscapedReservedWord: "Keyword must not contain escaped characters",
          InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence",
          InvalidLHSInAssignment: "Invalid left-hand side in assignment",
          InvalidLHSInForIn: "Invalid left-hand side in for-in",
          InvalidLHSInForLoop: "Invalid left-hand side in for-loop",
          InvalidModuleSpecifier: "Unexpected token",
          InvalidRegExp: "Invalid regular expression",
          LetInLexicalBinding: "let is disallowed as a lexically bound name",
          MissingFromClause: "Unexpected token",
          MultipleDefaultsInSwitch: "More than one default clause in switch statement",
          NewlineAfterThrow: "Illegal newline after throw",
          NoAsAfterImportNamespace: "Unexpected token",
          NoCatchOrFinally: "Missing catch or finally after try",
          ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
          Redeclaration: "%0 '%1' has already been declared",
          StaticPrototype: "Classes may not have static property named prototype",
          StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
          StrictDelete: "Delete of an unqualified identifier in strict mode.",
          StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
          StrictFunctionName: "Function name may not be eval or arguments in strict mode",
          StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
          StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
          StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
          StrictModeWith: "Strict mode code may not include a with statement",
          StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
          StrictParamDupe: "Strict mode function may not have duplicate parameter names",
          StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
          StrictReservedWord: "Use of future reserved word in strict mode",
          StrictVarName: "Variable name may not be eval or arguments in strict mode",
          TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
          UnexpectedEOS: "Unexpected end of input",
          UnexpectedIdentifier: "Unexpected identifier",
          UnexpectedNumber: "Unexpected number",
          UnexpectedReserved: "Unexpected reserved word",
          UnexpectedString: "Unexpected string",
          UnexpectedTemplate: "Unexpected quasi %0",
          UnexpectedToken: "Unexpected token %0",
          UnexpectedTokenIllegal: "Unexpected token ILLEGAL",
          UnknownLabel: "Undefined label '%0'",
          UnterminatedRegExp: "Invalid regular expression: missing /"
        };
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var assert_1 = __webpack_require__(9);
        var character_1 = __webpack_require__(4);
        var messages_1 = __webpack_require__(11);
        function hexValue(ch) {
          return "0123456789abcdef".indexOf(ch.toLowerCase());
        }
        function octalValue(ch) {
          return "01234567".indexOf(ch);
        }
        var Scanner = function() {
          function Scanner2(code, handler) {
            this.source = code;
            this.errorHandler = handler;
            this.trackComment = false;
            this.isModule = false;
            this.length = code.length;
            this.index = 0;
            this.lineNumber = code.length > 0 ? 1 : 0;
            this.lineStart = 0;
            this.curlyStack = [];
          }
          Scanner2.prototype.saveState = function() {
            return {
              index: this.index,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart
            };
          };
          Scanner2.prototype.restoreState = function(state) {
            this.index = state.index;
            this.lineNumber = state.lineNumber;
            this.lineStart = state.lineStart;
          };
          Scanner2.prototype.eof = function() {
            return this.index >= this.length;
          };
          Scanner2.prototype.throwUnexpectedToken = function(message) {
            if (message === undefined) {
              message = messages_1.Messages.UnexpectedTokenIllegal;
            }
            return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
          };
          Scanner2.prototype.tolerateUnexpectedToken = function(message) {
            if (message === undefined) {
              message = messages_1.Messages.UnexpectedTokenIllegal;
            }
            this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
          };
          Scanner2.prototype.skipSingleLineComment = function(offset) {
            var comments = [];
            var start, loc;
            if (this.trackComment) {
              comments = [];
              start = this.index - offset;
              loc = {
                start: {
                  line: this.lineNumber,
                  column: this.index - this.lineStart - offset
                },
                end: {}
              };
            }
            while (!this.eof()) {
              var ch = this.source.charCodeAt(this.index);
              ++this.index;
              if (character_1.Character.isLineTerminator(ch)) {
                if (this.trackComment) {
                  loc.end = {
                    line: this.lineNumber,
                    column: this.index - this.lineStart - 1
                  };
                  var entry = {
                    multiLine: false,
                    slice: [start + offset, this.index - 1],
                    range: [start, this.index - 1],
                    loc
                  };
                  comments.push(entry);
                }
                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                  ++this.index;
                }
                ++this.lineNumber;
                this.lineStart = this.index;
                return comments;
              }
            }
            if (this.trackComment) {
              loc.end = {
                line: this.lineNumber,
                column: this.index - this.lineStart
              };
              var entry = {
                multiLine: false,
                slice: [start + offset, this.index],
                range: [start, this.index],
                loc
              };
              comments.push(entry);
            }
            return comments;
          };
          Scanner2.prototype.skipMultiLineComment = function() {
            var comments = [];
            var start, loc;
            if (this.trackComment) {
              comments = [];
              start = this.index - 2;
              loc = {
                start: {
                  line: this.lineNumber,
                  column: this.index - this.lineStart - 2
                },
                end: {}
              };
            }
            while (!this.eof()) {
              var ch = this.source.charCodeAt(this.index);
              if (character_1.Character.isLineTerminator(ch)) {
                if (ch === 13 && this.source.charCodeAt(this.index + 1) === 10) {
                  ++this.index;
                }
                ++this.lineNumber;
                ++this.index;
                this.lineStart = this.index;
              } else if (ch === 42) {
                if (this.source.charCodeAt(this.index + 1) === 47) {
                  this.index += 2;
                  if (this.trackComment) {
                    loc.end = {
                      line: this.lineNumber,
                      column: this.index - this.lineStart
                    };
                    var entry = {
                      multiLine: true,
                      slice: [start + 2, this.index - 2],
                      range: [start, this.index],
                      loc
                    };
                    comments.push(entry);
                  }
                  return comments;
                }
                ++this.index;
              } else {
                ++this.index;
              }
            }
            if (this.trackComment) {
              loc.end = {
                line: this.lineNumber,
                column: this.index - this.lineStart
              };
              var entry = {
                multiLine: true,
                slice: [start + 2, this.index],
                range: [start, this.index],
                loc
              };
              comments.push(entry);
            }
            this.tolerateUnexpectedToken();
            return comments;
          };
          Scanner2.prototype.scanComments = function() {
            var comments;
            if (this.trackComment) {
              comments = [];
            }
            var start = this.index === 0;
            while (!this.eof()) {
              var ch = this.source.charCodeAt(this.index);
              if (character_1.Character.isWhiteSpace(ch)) {
                ++this.index;
              } else if (character_1.Character.isLineTerminator(ch)) {
                ++this.index;
                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                  ++this.index;
                }
                ++this.lineNumber;
                this.lineStart = this.index;
                start = true;
              } else if (ch === 47) {
                ch = this.source.charCodeAt(this.index + 1);
                if (ch === 47) {
                  this.index += 2;
                  var comment = this.skipSingleLineComment(2);
                  if (this.trackComment) {
                    comments = comments.concat(comment);
                  }
                  start = true;
                } else if (ch === 42) {
                  this.index += 2;
                  var comment = this.skipMultiLineComment();
                  if (this.trackComment) {
                    comments = comments.concat(comment);
                  }
                } else {
                  break;
                }
              } else if (start && ch === 45) {
                if (this.source.charCodeAt(this.index + 1) === 45 && this.source.charCodeAt(this.index + 2) === 62) {
                  this.index += 3;
                  var comment = this.skipSingleLineComment(3);
                  if (this.trackComment) {
                    comments = comments.concat(comment);
                  }
                } else {
                  break;
                }
              } else if (ch === 60 && !this.isModule) {
                if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
                  this.index += 4;
                  var comment = this.skipSingleLineComment(4);
                  if (this.trackComment) {
                    comments = comments.concat(comment);
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
            }
            return comments;
          };
          Scanner2.prototype.isFutureReservedWord = function(id) {
            switch (id) {
              case "enum":
              case "export":
              case "import":
              case "super":
                return true;
              default:
                return false;
            }
          };
          Scanner2.prototype.isStrictModeReservedWord = function(id) {
            switch (id) {
              case "implements":
              case "interface":
              case "package":
              case "private":
              case "protected":
              case "public":
              case "static":
              case "yield":
              case "let":
                return true;
              default:
                return false;
            }
          };
          Scanner2.prototype.isRestrictedWord = function(id) {
            return id === "eval" || id === "arguments";
          };
          Scanner2.prototype.isKeyword = function(id) {
            switch (id.length) {
              case 2:
                return id === "if" || id === "in" || id === "do";
              case 3:
                return id === "var" || id === "for" || id === "new" || id === "try" || id === "let";
              case 4:
                return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
              case 5:
                return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
              case 6:
                return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
              case 7:
                return id === "default" || id === "finally" || id === "extends";
              case 8:
                return id === "function" || id === "continue" || id === "debugger";
              case 10:
                return id === "instanceof";
              default:
                return false;
            }
          };
          Scanner2.prototype.codePointAt = function(i) {
            var cp = this.source.charCodeAt(i);
            if (cp >= 55296 && cp <= 56319) {
              var second = this.source.charCodeAt(i + 1);
              if (second >= 56320 && second <= 57343) {
                var first3 = cp;
                cp = (first3 - 55296) * 1024 + second - 56320 + 65536;
              }
            }
            return cp;
          };
          Scanner2.prototype.scanHexEscape = function(prefix) {
            var len = prefix === "u" ? 4 : 2;
            var code = 0;
            for (var i = 0;i < len; ++i) {
              if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                code = code * 16 + hexValue(this.source[this.index++]);
              } else {
                return null;
              }
            }
            return String.fromCharCode(code);
          };
          Scanner2.prototype.scanUnicodeCodePointEscape = function() {
            var ch = this.source[this.index];
            var code = 0;
            if (ch === "}") {
              this.throwUnexpectedToken();
            }
            while (!this.eof()) {
              ch = this.source[this.index++];
              if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
                break;
              }
              code = code * 16 + hexValue(ch);
            }
            if (code > 1114111 || ch !== "}") {
              this.throwUnexpectedToken();
            }
            return character_1.Character.fromCodePoint(code);
          };
          Scanner2.prototype.getIdentifier = function() {
            var start = this.index++;
            while (!this.eof()) {
              var ch = this.source.charCodeAt(this.index);
              if (ch === 92) {
                this.index = start;
                return this.getComplexIdentifier();
              } else if (ch >= 55296 && ch < 57343) {
                this.index = start;
                return this.getComplexIdentifier();
              }
              if (character_1.Character.isIdentifierPart(ch)) {
                ++this.index;
              } else {
                break;
              }
            }
            return this.source.slice(start, this.index);
          };
          Scanner2.prototype.getComplexIdentifier = function() {
            var cp = this.codePointAt(this.index);
            var id = character_1.Character.fromCodePoint(cp);
            this.index += id.length;
            var ch;
            if (cp === 92) {
              if (this.source.charCodeAt(this.index) !== 117) {
                this.throwUnexpectedToken();
              }
              ++this.index;
              if (this.source[this.index] === "{") {
                ++this.index;
                ch = this.scanUnicodeCodePointEscape();
              } else {
                ch = this.scanHexEscape("u");
                if (ch === null || ch === "\\" || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
                  this.throwUnexpectedToken();
                }
              }
              id = ch;
            }
            while (!this.eof()) {
              cp = this.codePointAt(this.index);
              if (!character_1.Character.isIdentifierPart(cp)) {
                break;
              }
              ch = character_1.Character.fromCodePoint(cp);
              id += ch;
              this.index += ch.length;
              if (cp === 92) {
                id = id.substr(0, id.length - 1);
                if (this.source.charCodeAt(this.index) !== 117) {
                  this.throwUnexpectedToken();
                }
                ++this.index;
                if (this.source[this.index] === "{") {
                  ++this.index;
                  ch = this.scanUnicodeCodePointEscape();
                } else {
                  ch = this.scanHexEscape("u");
                  if (ch === null || ch === "\\" || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                    this.throwUnexpectedToken();
                  }
                }
                id += ch;
              }
            }
            return id;
          };
          Scanner2.prototype.octalToDecimal = function(ch) {
            var octal = ch !== "0";
            var code = octalValue(ch);
            if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
              octal = true;
              code = code * 8 + octalValue(this.source[this.index++]);
              if ("0123".indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                code = code * 8 + octalValue(this.source[this.index++]);
              }
            }
            return {
              code,
              octal
            };
          };
          Scanner2.prototype.scanIdentifier = function() {
            var type;
            var start = this.index;
            var id = this.source.charCodeAt(start) === 92 ? this.getComplexIdentifier() : this.getIdentifier();
            if (id.length === 1) {
              type = 3;
            } else if (this.isKeyword(id)) {
              type = 4;
            } else if (id === "null") {
              type = 5;
            } else if (id === "true" || id === "false") {
              type = 1;
            } else {
              type = 3;
            }
            if (type !== 3 && start + id.length !== this.index) {
              var restore = this.index;
              this.index = start;
              this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
              this.index = restore;
            }
            return {
              type,
              value: id,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.scanPunctuator = function() {
            var start = this.index;
            var str = this.source[this.index];
            switch (str) {
              case "(":
              case "{":
                if (str === "{") {
                  this.curlyStack.push("{");
                }
                ++this.index;
                break;
              case ".":
                ++this.index;
                if (this.source[this.index] === "." && this.source[this.index + 1] === ".") {
                  this.index += 2;
                  str = "...";
                }
                break;
              case "}":
                ++this.index;
                this.curlyStack.pop();
                break;
              case ")":
              case ";":
              case ",":
              case "[":
              case "]":
              case ":":
              case "?":
              case "~":
                ++this.index;
                break;
              default:
                str = this.source.substr(this.index, 4);
                if (str === ">>>=") {
                  this.index += 4;
                } else {
                  str = str.substr(0, 3);
                  if (str === "===" || str === "!==" || str === ">>>" || str === "<<=" || str === ">>=" || str === "**=") {
                    this.index += 3;
                  } else {
                    str = str.substr(0, 2);
                    if (str === "&&" || str === "||" || str === "==" || str === "!=" || str === "+=" || str === "-=" || str === "*=" || str === "/=" || str === "++" || str === "--" || str === "<<" || str === ">>" || str === "&=" || str === "|=" || str === "^=" || str === "%=" || str === "<=" || str === ">=" || str === "=>" || str === "**") {
                      this.index += 2;
                    } else {
                      str = this.source[this.index];
                      if ("<>=!+-*%&|^/".indexOf(str) >= 0) {
                        ++this.index;
                      }
                    }
                  }
                }
            }
            if (this.index === start) {
              this.throwUnexpectedToken();
            }
            return {
              type: 7,
              value: str,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.scanHexLiteral = function(start) {
            var num = "";
            while (!this.eof()) {
              if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                break;
              }
              num += this.source[this.index++];
            }
            if (num.length === 0) {
              this.throwUnexpectedToken();
            }
            if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
              this.throwUnexpectedToken();
            }
            return {
              type: 6,
              value: parseInt("0x" + num, 16),
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.scanBinaryLiteral = function(start) {
            var num = "";
            var ch;
            while (!this.eof()) {
              ch = this.source[this.index];
              if (ch !== "0" && ch !== "1") {
                break;
              }
              num += this.source[this.index++];
            }
            if (num.length === 0) {
              this.throwUnexpectedToken();
            }
            if (!this.eof()) {
              ch = this.source.charCodeAt(this.index);
              if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
                this.throwUnexpectedToken();
              }
            }
            return {
              type: 6,
              value: parseInt(num, 2),
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.scanOctalLiteral = function(prefix, start) {
            var num = "";
            var octal = false;
            if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
              octal = true;
              num = "0" + this.source[this.index++];
            } else {
              ++this.index;
            }
            while (!this.eof()) {
              if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                break;
              }
              num += this.source[this.index++];
            }
            if (!octal && num.length === 0) {
              this.throwUnexpectedToken();
            }
            if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
              this.throwUnexpectedToken();
            }
            return {
              type: 6,
              value: parseInt(num, 8),
              octal,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.isImplicitOctalLiteral = function() {
            for (var i = this.index + 1;i < this.length; ++i) {
              var ch = this.source[i];
              if (ch === "8" || ch === "9") {
                return false;
              }
              if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                return true;
              }
            }
            return true;
          };
          Scanner2.prototype.scanNumericLiteral = function() {
            var start = this.index;
            var ch = this.source[start];
            assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
            var num = "";
            if (ch !== ".") {
              num = this.source[this.index++];
              ch = this.source[this.index];
              if (num === "0") {
                if (ch === "x" || ch === "X") {
                  ++this.index;
                  return this.scanHexLiteral(start);
                }
                if (ch === "b" || ch === "B") {
                  ++this.index;
                  return this.scanBinaryLiteral(start);
                }
                if (ch === "o" || ch === "O") {
                  return this.scanOctalLiteral(ch, start);
                }
                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                  if (this.isImplicitOctalLiteral()) {
                    return this.scanOctalLiteral(ch, start);
                  }
                }
              }
              while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                num += this.source[this.index++];
              }
              ch = this.source[this.index];
            }
            if (ch === ".") {
              num += this.source[this.index++];
              while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                num += this.source[this.index++];
              }
              ch = this.source[this.index];
            }
            if (ch === "e" || ch === "E") {
              num += this.source[this.index++];
              ch = this.source[this.index];
              if (ch === "+" || ch === "-") {
                num += this.source[this.index++];
              }
              if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                  num += this.source[this.index++];
                }
              } else {
                this.throwUnexpectedToken();
              }
            }
            if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
              this.throwUnexpectedToken();
            }
            return {
              type: 6,
              value: parseFloat(num),
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.scanStringLiteral = function() {
            var start = this.index;
            var quote = this.source[start];
            assert_1.assert(quote === "'" || quote === '"', "String literal must starts with a quote");
            ++this.index;
            var octal = false;
            var str = "";
            while (!this.eof()) {
              var ch = this.source[this.index++];
              if (ch === quote) {
                quote = "";
                break;
              } else if (ch === "\\") {
                ch = this.source[this.index++];
                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  switch (ch) {
                    case "u":
                      if (this.source[this.index] === "{") {
                        ++this.index;
                        str += this.scanUnicodeCodePointEscape();
                      } else {
                        var unescaped_1 = this.scanHexEscape(ch);
                        if (unescaped_1 === null) {
                          this.throwUnexpectedToken();
                        }
                        str += unescaped_1;
                      }
                      break;
                    case "x":
                      var unescaped = this.scanHexEscape(ch);
                      if (unescaped === null) {
                        this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                      }
                      str += unescaped;
                      break;
                    case "n":
                      str += `
`;
                      break;
                    case "r":
                      str += "\r";
                      break;
                    case "t":
                      str += "\t";
                      break;
                    case "b":
                      str += "\b";
                      break;
                    case "f":
                      str += "\f";
                      break;
                    case "v":
                      str += "\v";
                      break;
                    case "8":
                    case "9":
                      str += ch;
                      this.tolerateUnexpectedToken();
                      break;
                    default:
                      if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                        var octToDec = this.octalToDecimal(ch);
                        octal = octToDec.octal || octal;
                        str += String.fromCharCode(octToDec.code);
                      } else {
                        str += ch;
                      }
                      break;
                  }
                } else {
                  ++this.lineNumber;
                  if (ch === "\r" && this.source[this.index] === `
`) {
                    ++this.index;
                  }
                  this.lineStart = this.index;
                }
              } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                break;
              } else {
                str += ch;
              }
            }
            if (quote !== "") {
              this.index = start;
              this.throwUnexpectedToken();
            }
            return {
              type: 8,
              value: str,
              octal,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.scanTemplate = function() {
            var cooked = "";
            var terminated = false;
            var start = this.index;
            var head = this.source[start] === "`";
            var tail = false;
            var rawOffset = 2;
            ++this.index;
            while (!this.eof()) {
              var ch = this.source[this.index++];
              if (ch === "`") {
                rawOffset = 1;
                tail = true;
                terminated = true;
                break;
              } else if (ch === "$") {
                if (this.source[this.index] === "{") {
                  this.curlyStack.push("${");
                  ++this.index;
                  terminated = true;
                  break;
                }
                cooked += ch;
              } else if (ch === "\\") {
                ch = this.source[this.index++];
                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  switch (ch) {
                    case "n":
                      cooked += `
`;
                      break;
                    case "r":
                      cooked += "\r";
                      break;
                    case "t":
                      cooked += "\t";
                      break;
                    case "u":
                      if (this.source[this.index] === "{") {
                        ++this.index;
                        cooked += this.scanUnicodeCodePointEscape();
                      } else {
                        var restore = this.index;
                        var unescaped_2 = this.scanHexEscape(ch);
                        if (unescaped_2 !== null) {
                          cooked += unescaped_2;
                        } else {
                          this.index = restore;
                          cooked += ch;
                        }
                      }
                      break;
                    case "x":
                      var unescaped = this.scanHexEscape(ch);
                      if (unescaped === null) {
                        this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                      }
                      cooked += unescaped;
                      break;
                    case "b":
                      cooked += "\b";
                      break;
                    case "f":
                      cooked += "\f";
                      break;
                    case "v":
                      cooked += "\v";
                      break;
                    default:
                      if (ch === "0") {
                        if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                          this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                        }
                        cooked += "\x00";
                      } else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                        this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                      } else {
                        cooked += ch;
                      }
                      break;
                  }
                } else {
                  ++this.lineNumber;
                  if (ch === "\r" && this.source[this.index] === `
`) {
                    ++this.index;
                  }
                  this.lineStart = this.index;
                }
              } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                ++this.lineNumber;
                if (ch === "\r" && this.source[this.index] === `
`) {
                  ++this.index;
                }
                this.lineStart = this.index;
                cooked += `
`;
              } else {
                cooked += ch;
              }
            }
            if (!terminated) {
              this.throwUnexpectedToken();
            }
            if (!head) {
              this.curlyStack.pop();
            }
            return {
              type: 10,
              value: this.source.slice(start + 1, this.index - rawOffset),
              cooked,
              head,
              tail,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.testRegExp = function(pattern, flags) {
            var astralSubstitute = "";
            var tmp = pattern;
            var self = this;
            if (flags.indexOf("u") >= 0) {
              tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function($0, $1, $2) {
                var codePoint = parseInt($1 || $2, 16);
                if (codePoint > 1114111) {
                  self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                }
                if (codePoint <= 65535) {
                  return String.fromCharCode(codePoint);
                }
                return astralSubstitute;
              }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
            }
            try {
              RegExp(tmp);
            } catch (e) {
              this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
            }
            try {
              return new RegExp(pattern, flags);
            } catch (exception) {
              return null;
            }
          };
          Scanner2.prototype.scanRegExpBody = function() {
            var ch = this.source[this.index];
            assert_1.assert(ch === "/", "Regular expression literal must start with a slash");
            var str = this.source[this.index++];
            var classMarker = false;
            var terminated = false;
            while (!this.eof()) {
              ch = this.source[this.index++];
              str += ch;
              if (ch === "\\") {
                ch = this.source[this.index++];
                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                }
                str += ch;
              } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
              } else if (classMarker) {
                if (ch === "]") {
                  classMarker = false;
                }
              } else {
                if (ch === "/") {
                  terminated = true;
                  break;
                } else if (ch === "[") {
                  classMarker = true;
                }
              }
            }
            if (!terminated) {
              this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
            }
            return str.substr(1, str.length - 2);
          };
          Scanner2.prototype.scanRegExpFlags = function() {
            var str = "";
            var flags = "";
            while (!this.eof()) {
              var ch = this.source[this.index];
              if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                break;
              }
              ++this.index;
              if (ch === "\\" && !this.eof()) {
                ch = this.source[this.index];
                if (ch === "u") {
                  ++this.index;
                  var restore = this.index;
                  var char = this.scanHexEscape("u");
                  if (char !== null) {
                    flags += char;
                    for (str += "\\u";restore < this.index; ++restore) {
                      str += this.source[restore];
                    }
                  } else {
                    this.index = restore;
                    flags += "u";
                    str += "\\u";
                  }
                  this.tolerateUnexpectedToken();
                } else {
                  str += "\\";
                  this.tolerateUnexpectedToken();
                }
              } else {
                flags += ch;
                str += ch;
              }
            }
            return flags;
          };
          Scanner2.prototype.scanRegExp = function() {
            var start = this.index;
            var pattern = this.scanRegExpBody();
            var flags = this.scanRegExpFlags();
            var value = this.testRegExp(pattern, flags);
            return {
              type: 9,
              value: "",
              pattern,
              flags,
              regex: value,
              lineNumber: this.lineNumber,
              lineStart: this.lineStart,
              start,
              end: this.index
            };
          };
          Scanner2.prototype.lex = function() {
            if (this.eof()) {
              return {
                type: 2,
                value: "",
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start: this.index,
                end: this.index
              };
            }
            var cp = this.source.charCodeAt(this.index);
            if (character_1.Character.isIdentifierStart(cp)) {
              return this.scanIdentifier();
            }
            if (cp === 40 || cp === 41 || cp === 59) {
              return this.scanPunctuator();
            }
            if (cp === 39 || cp === 34) {
              return this.scanStringLiteral();
            }
            if (cp === 46) {
              if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
                return this.scanNumericLiteral();
              }
              return this.scanPunctuator();
            }
            if (character_1.Character.isDecimalDigit(cp)) {
              return this.scanNumericLiteral();
            }
            if (cp === 96 || cp === 125 && this.curlyStack[this.curlyStack.length - 1] === "${") {
              return this.scanTemplate();
            }
            if (cp >= 55296 && cp < 57343) {
              if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
                return this.scanIdentifier();
              }
            }
            return this.scanPunctuator();
          };
          return Scanner2;
        }();
        exports2.Scanner = Scanner;
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.TokenName = {};
        exports2.TokenName[1] = "Boolean";
        exports2.TokenName[2] = "<end>";
        exports2.TokenName[3] = "Identifier";
        exports2.TokenName[4] = "Keyword";
        exports2.TokenName[5] = "Null";
        exports2.TokenName[6] = "Numeric";
        exports2.TokenName[7] = "Punctuator";
        exports2.TokenName[8] = "String";
        exports2.TokenName[9] = "RegularExpression";
        exports2.TokenName[10] = "Template";
      },
      function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.XHTMLEntities = {
          quot: '"',
          amp: "&",
          apos: "'",
          gt: ">",
          nbsp: "",
          iexcl: "",
          cent: "",
          pound: "",
          curren: "",
          yen: "",
          brvbar: "",
          sect: "",
          uml: "",
          copy: "",
          ordf: "",
          laquo: "",
          not: "",
          shy: "",
          reg: "",
          macr: "",
          deg: "",
          plusmn: "",
          sup2: "",
          sup3: "",
          acute: "",
          micro: "",
          para: "",
          middot: "",
          cedil: "",
          sup1: "",
          ordm: "",
          raquo: "",
          frac14: "",
          frac12: "",
          frac34: "",
          iquest: "",
          Agrave: "",
          Aacute: "",
          Acirc: "",
          Atilde: "",
          Auml: "",
          Aring: "",
          AElig: "",
          Ccedil: "",
          Egrave: "",
          Eacute: "",
          Ecirc: "",
          Euml: "",
          Igrave: "",
          Iacute: "",
          Icirc: "",
          Iuml: "",
          ETH: "",
          Ntilde: "",
          Ograve: "",
          Oacute: "",
          Ocirc: "",
          Otilde: "",
          Ouml: "",
          times: "",
          Oslash: "",
          Ugrave: "",
          Uacute: "",
          Ucirc: "",
          Uuml: "",
          Yacute: "",
          THORN: "",
          szlig: "",
          agrave: "",
          aacute: "",
          acirc: "",
          atilde: "",
          auml: "",
          aring: "",
          aelig: "",
          ccedil: "",
          egrave: "",
          eacute: "",
          ecirc: "",
          euml: "",
          igrave: "",
          iacute: "",
          icirc: "",
          iuml: "",
          eth: "",
          ntilde: "",
          ograve: "",
          oacute: "",
          ocirc: "",
          otilde: "",
          ouml: "",
          divide: "",
          oslash: "",
          ugrave: "",
          uacute: "",
          ucirc: "",
          uuml: "",
          yacute: "",
          thorn: "",
          yuml: "",
          OElig: "",
          oelig: "",
          Scaron: "",
          scaron: "",
          Yuml: "",
          fnof: "",
          circ: "",
          tilde: "",
          Alpha: "",
          Beta: "",
          Gamma: "",
          Delta: "",
          Epsilon: "",
          Zeta: "",
          Eta: "",
          Theta: "",
          Iota: "",
          Kappa: "",
          Lambda: "",
          Mu: "",
          Nu: "",
          Xi: "",
          Omicron: "",
          Pi: "",
          Rho: "",
          Sigma: "",
          Tau: "",
          Upsilon: "",
          Phi: "",
          Chi: "",
          Psi: "",
          Omega: "",
          alpha: "",
          beta: "",
          gamma: "",
          delta: "",
          epsilon: "",
          zeta: "",
          eta: "",
          theta: "",
          iota: "",
          kappa: "",
          lambda: "",
          mu: "",
          nu: "",
          xi: "",
          omicron: "",
          pi: "",
          rho: "",
          sigmaf: "",
          sigma: "",
          tau: "",
          upsilon: "",
          phi: "",
          chi: "",
          psi: "",
          omega: "",
          thetasym: "",
          upsih: "",
          piv: "",
          ensp: "",
          emsp: "",
          thinsp: "",
          zwnj: "",
          zwj: "",
          lrm: "",
          rlm: "",
          ndash: "",
          mdash: "",
          lsquo: "",
          rsquo: "",
          sbquo: "",
          ldquo: "",
          rdquo: "",
          bdquo: "",
          dagger: "",
          Dagger: "",
          bull: "",
          hellip: "",
          permil: "",
          prime: "",
          Prime: "",
          lsaquo: "",
          rsaquo: "",
          oline: "",
          frasl: "",
          euro: "",
          image: "",
          weierp: "",
          real: "",
          trade: "",
          alefsym: "",
          larr: "",
          uarr: "",
          rarr: "",
          darr: "",
          harr: "",
          crarr: "",
          lArr: "",
          uArr: "",
          rArr: "",
          dArr: "",
          hArr: "",
          forall: "",
          part: "",
          exist: "",
          empty: "",
          nabla: "",
          isin: "",
          notin: "",
          ni: "",
          prod: "",
          sum: "",
          minus: "",
          lowast: "",
          radic: "",
          prop: "",
          infin: "",
          ang: "",
          and: "",
          or: "",
          cap: "",
          cup: "",
          int: "",
          there4: "",
          sim: "",
          cong: "",
          asymp: "",
          ne: "",
          equiv: "",
          le: "",
          ge: "",
          sub: "",
          sup: "",
          nsub: "",
          sube: "",
          supe: "",
          oplus: "",
          otimes: "",
          perp: "",
          sdot: "",
          lceil: "",
          rceil: "",
          lfloor: "",
          rfloor: "",
          loz: "",
          spades: "",
          clubs: "",
          hearts: "",
          diams: "",
          lang: "",
          rang: ""
        };
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var error_handler_1 = __webpack_require__(10);
        var scanner_1 = __webpack_require__(12);
        var token_1 = __webpack_require__(13);
        var Reader = function() {
          function Reader2() {
            this.values = [];
            this.curly = this.paren = -1;
          }
          Reader2.prototype.beforeFunctionExpression = function(t) {
            return [
              "(",
              "{",
              "[",
              "in",
              "typeof",
              "instanceof",
              "new",
              "return",
              "case",
              "delete",
              "throw",
              "void",
              "=",
              "+=",
              "-=",
              "*=",
              "**=",
              "/=",
              "%=",
              "<<=",
              ">>=",
              ">>>=",
              "&=",
              "|=",
              "^=",
              ",",
              "+",
              "-",
              "*",
              "**",
              "/",
              "%",
              "++",
              "--",
              "<<",
              ">>",
              ">>>",
              "&",
              "|",
              "^",
              "!",
              "~",
              "&&",
              "||",
              "?",
              ":",
              "===",
              "==",
              ">=",
              "<=",
              "<",
              ">",
              "!=",
              "!=="
            ].indexOf(t) >= 0;
          };
          Reader2.prototype.isRegexStart = function() {
            var previous = this.values[this.values.length - 1];
            var regex = previous !== null;
            switch (previous) {
              case "this":
              case "]":
                regex = false;
                break;
              case ")":
                var keyword = this.values[this.paren - 1];
                regex = keyword === "if" || keyword === "while" || keyword === "for" || keyword === "with";
                break;
              case "}":
                regex = false;
                if (this.values[this.curly - 3] === "function") {
                  var check = this.values[this.curly - 4];
                  regex = check ? !this.beforeFunctionExpression(check) : false;
                } else if (this.values[this.curly - 4] === "function") {
                  var check = this.values[this.curly - 5];
                  regex = check ? !this.beforeFunctionExpression(check) : true;
                }
                break;
              default:
                break;
            }
            return regex;
          };
          Reader2.prototype.push = function(token) {
            if (token.type === 7 || token.type === 4) {
              if (token.value === "{") {
                this.curly = this.values.length;
              } else if (token.value === "(") {
                this.paren = this.values.length;
              }
              this.values.push(token.value);
            } else {
              this.values.push(null);
            }
          };
          return Reader2;
        }();
        var Tokenizer = function() {
          function Tokenizer2(code, config) {
            this.errorHandler = new error_handler_1.ErrorHandler;
            this.errorHandler.tolerant = config ? typeof config.tolerant === "boolean" && config.tolerant : false;
            this.scanner = new scanner_1.Scanner(code, this.errorHandler);
            this.scanner.trackComment = config ? typeof config.comment === "boolean" && config.comment : false;
            this.trackRange = config ? typeof config.range === "boolean" && config.range : false;
            this.trackLoc = config ? typeof config.loc === "boolean" && config.loc : false;
            this.buffer = [];
            this.reader = new Reader;
          }
          Tokenizer2.prototype.errors = function() {
            return this.errorHandler.errors;
          };
          Tokenizer2.prototype.getNextToken = function() {
            if (this.buffer.length === 0) {
              var comments = this.scanner.scanComments();
              if (this.scanner.trackComment) {
                for (var i = 0;i < comments.length; ++i) {
                  var e = comments[i];
                  var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
                  var comment = {
                    type: e.multiLine ? "BlockComment" : "LineComment",
                    value
                  };
                  if (this.trackRange) {
                    comment.range = e.range;
                  }
                  if (this.trackLoc) {
                    comment.loc = e.loc;
                  }
                  this.buffer.push(comment);
                }
              }
              if (!this.scanner.eof()) {
                var loc = undefined;
                if (this.trackLoc) {
                  loc = {
                    start: {
                      line: this.scanner.lineNumber,
                      column: this.scanner.index - this.scanner.lineStart
                    },
                    end: {}
                  };
                }
                var startRegex = this.scanner.source[this.scanner.index] === "/" && this.reader.isRegexStart();
                var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
                this.reader.push(token);
                var entry = {
                  type: token_1.TokenName[token.type],
                  value: this.scanner.source.slice(token.start, token.end)
                };
                if (this.trackRange) {
                  entry.range = [token.start, token.end];
                }
                if (this.trackLoc) {
                  loc.end = {
                    line: this.scanner.lineNumber,
                    column: this.scanner.index - this.scanner.lineStart
                  };
                  entry.loc = loc;
                }
                if (token.type === 9) {
                  var pattern = token.pattern;
                  var flags = token.flags;
                  entry.regex = { pattern, flags };
                }
                this.buffer.push(entry);
              }
            }
            return this.buffer.shift();
          };
          return Tokenizer2;
        }();
        exports2.Tokenizer = Tokenizer;
      }
    ]);
  });
});

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS((exports) => {
  function isArray3(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === "[object Array]";
  }
  exports.isArray = isArray3;
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  exports.isBoolean = isBoolean;
  function isNull(arg) {
    return arg === null;
  }
  exports.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports.isNullOrUndefined = isNullOrUndefined;
  function isNumber(arg) {
    return typeof arg === "number";
  }
  exports.isNumber = isNumber;
  function isString2(arg) {
    return typeof arg === "string";
  }
  exports.isString = isString2;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  exports.isSymbol = isSymbol;
  function isUndefined(arg) {
    return arg === undefined;
  }
  exports.isUndefined = isUndefined;
  function isRegExp(re) {
    return objectToString(re) === "[object RegExp]";
  }
  exports.isRegExp = isRegExp;
  function isObject(arg) {
    return typeof arg === "object" && arg !== null;
  }
  exports.isObject = isObject;
  function isDate(d) {
    return objectToString(d) === "[object Date]";
  }
  exports.isDate = isDate;
  function isError4(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  exports.isError = isError4;
  function isFunction(arg) {
    return typeof arg === "function";
  }
  exports.isFunction = isFunction;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
  }
  exports.isPrimitive = isPrimitive;
  exports.isBuffer = __require("buffer").Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
});

// node_modules/array-timsort/src/index.js
var require_src = __commonJS((exports, module) => {
  var DEFAULT_MIN_MERGE = 32;
  var DEFAULT_MIN_GALLOPING = 7;
  var DEFAULT_TMP_STORAGE_LENGTH = 256;
  var POWERS_OF_TEN = [1, 10, 100, 1000, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];
  var results;
  var log10 = (x) => x < 1e5 ? x < 100 ? x < 10 ? 0 : 1 : x < 1e4 ? x < 1000 ? 2 : 3 : 4 : x < 1e7 ? x < 1e6 ? 5 : 6 : x < 1e9 ? x < 1e8 ? 7 : 8 : 9;
  function alphabeticalCompare(a, b) {
    if (a === b) {
      return 0;
    }
    if (~~a === a && ~~b === b) {
      if (a === 0 || b === 0) {
        return a < b ? -1 : 1;
      }
      if (a < 0 || b < 0) {
        if (b >= 0) {
          return -1;
        }
        if (a >= 0) {
          return 1;
        }
        a = -a;
        b = -b;
      }
      const al = log10(a);
      const bl = log10(b);
      let t = 0;
      if (al < bl) {
        a *= POWERS_OF_TEN[bl - al - 1];
        b /= 10;
        t = -1;
      } else if (al > bl) {
        b *= POWERS_OF_TEN[al - bl - 1];
        a /= 10;
        t = 1;
      }
      if (a === b) {
        return t;
      }
      return a < b ? -1 : 1;
    }
    const aStr = String(a);
    const bStr = String(b);
    if (aStr === bStr) {
      return 0;
    }
    return aStr < bStr ? -1 : 1;
  }
  function minRunLength(n) {
    let r = 0;
    while (n >= DEFAULT_MIN_MERGE) {
      r |= n & 1;
      n >>= 1;
    }
    return n + r;
  }
  function makeAscendingRun(array, lo, hi, compare4) {
    let runHi = lo + 1;
    if (runHi === hi) {
      return 1;
    }
    if (compare4(array[runHi++], array[lo]) < 0) {
      while (runHi < hi && compare4(array[runHi], array[runHi - 1]) < 0) {
        runHi++;
      }
      reverseRun(array, lo, runHi);
      reverseRun(results, lo, runHi);
    } else {
      while (runHi < hi && compare4(array[runHi], array[runHi - 1]) >= 0) {
        runHi++;
      }
    }
    return runHi - lo;
  }
  function reverseRun(array, lo, hi) {
    hi--;
    while (lo < hi) {
      const t = array[lo];
      array[lo++] = array[hi];
      array[hi--] = t;
    }
  }
  function binaryInsertionSort(array, lo, hi, start, compare4) {
    if (start === lo) {
      start++;
    }
    for (;start < hi; start++) {
      const pivot = array[start];
      const pivotIndex = results[start];
      let left = lo;
      let right = start;
      while (left < right) {
        const mid = left + right >>> 1;
        if (compare4(pivot, array[mid]) < 0) {
          right = mid;
        } else {
          left = mid + 1;
        }
      }
      let n = start - left;
      switch (n) {
        case 3:
          array[left + 3] = array[left + 2];
          results[left + 3] = results[left + 2];
        case 2:
          array[left + 2] = array[left + 1];
          results[left + 2] = results[left + 1];
        case 1:
          array[left + 1] = array[left];
          results[left + 1] = results[left];
          break;
        default:
          while (n > 0) {
            array[left + n] = array[left + n - 1];
            results[left + n] = results[left + n - 1];
            n--;
          }
      }
      array[left] = pivot;
      results[left] = pivotIndex;
    }
  }
  function gallopLeft(value, array, start, length, hint, compare4) {
    let lastOffset = 0;
    let maxOffset = 0;
    let offset = 1;
    if (compare4(value, array[start + hint]) > 0) {
      maxOffset = length - hint;
      while (offset < maxOffset && compare4(value, array[start + hint + offset]) > 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;
        if (offset <= 0) {
          offset = maxOffset;
        }
      }
      if (offset > maxOffset) {
        offset = maxOffset;
      }
      lastOffset += hint;
      offset += hint;
    } else {
      maxOffset = hint + 1;
      while (offset < maxOffset && compare4(value, array[start + hint - offset]) <= 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;
        if (offset <= 0) {
          offset = maxOffset;
        }
      }
      if (offset > maxOffset) {
        offset = maxOffset;
      }
      const tmp = lastOffset;
      lastOffset = hint - offset;
      offset = hint - tmp;
    }
    lastOffset++;
    while (lastOffset < offset) {
      const m = lastOffset + (offset - lastOffset >>> 1);
      if (compare4(value, array[start + m]) > 0) {
        lastOffset = m + 1;
      } else {
        offset = m;
      }
    }
    return offset;
  }
  function gallopRight(value, array, start, length, hint, compare4) {
    let lastOffset = 0;
    let maxOffset = 0;
    let offset = 1;
    if (compare4(value, array[start + hint]) < 0) {
      maxOffset = hint + 1;
      while (offset < maxOffset && compare4(value, array[start + hint - offset]) < 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;
        if (offset <= 0) {
          offset = maxOffset;
        }
      }
      if (offset > maxOffset) {
        offset = maxOffset;
      }
      const tmp = lastOffset;
      lastOffset = hint - offset;
      offset = hint - tmp;
    } else {
      maxOffset = length - hint;
      while (offset < maxOffset && compare4(value, array[start + hint + offset]) >= 0) {
        lastOffset = offset;
        offset = (offset << 1) + 1;
        if (offset <= 0) {
          offset = maxOffset;
        }
      }
      if (offset > maxOffset) {
        offset = maxOffset;
      }
      lastOffset += hint;
      offset += hint;
    }
    lastOffset++;
    while (lastOffset < offset) {
      const m = lastOffset + (offset - lastOffset >>> 1);
      if (compare4(value, array[start + m]) < 0) {
        offset = m;
      } else {
        lastOffset = m + 1;
      }
    }
    return offset;
  }

  class TimSort {
    constructor(array, compare4) {
      this.array = array;
      this.compare = compare4;
      const { length } = array;
      this.length = length;
      this.minGallop = DEFAULT_MIN_GALLOPING;
      this.tmpStorageLength = length < 2 * DEFAULT_TMP_STORAGE_LENGTH ? length >>> 1 : DEFAULT_TMP_STORAGE_LENGTH;
      this.tmp = new Array(this.tmpStorageLength);
      this.tmpIndex = new Array(this.tmpStorageLength);
      this.stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;
      this.runStart = new Array(this.stackLength);
      this.runLength = new Array(this.stackLength);
      this.stackSize = 0;
    }
    pushRun(runStart, runLength) {
      this.runStart[this.stackSize] = runStart;
      this.runLength[this.stackSize] = runLength;
      this.stackSize += 1;
    }
    mergeRuns() {
      while (this.stackSize > 1) {
        let n = this.stackSize - 2;
        if (n >= 1 && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1] || n >= 2 && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]) {
          if (this.runLength[n - 1] < this.runLength[n + 1]) {
            n--;
          }
        } else if (this.runLength[n] > this.runLength[n + 1]) {
          break;
        }
        this.mergeAt(n);
      }
    }
    forceMergeRuns() {
      while (this.stackSize > 1) {
        let n = this.stackSize - 2;
        if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {
          n--;
        }
        this.mergeAt(n);
      }
    }
    mergeAt(i) {
      const { compare: compare4 } = this;
      const { array } = this;
      let start1 = this.runStart[i];
      let length1 = this.runLength[i];
      const start2 = this.runStart[i + 1];
      let length2 = this.runLength[i + 1];
      this.runLength[i] = length1 + length2;
      if (i === this.stackSize - 3) {
        this.runStart[i + 1] = this.runStart[i + 2];
        this.runLength[i + 1] = this.runLength[i + 2];
      }
      this.stackSize--;
      const k = gallopRight(array[start2], array, start1, length1, 0, compare4);
      start1 += k;
      length1 -= k;
      if (length1 === 0) {
        return;
      }
      length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare4);
      if (length2 === 0) {
        return;
      }
      if (length1 <= length2) {
        this.mergeLow(start1, length1, start2, length2);
      } else {
        this.mergeHigh(start1, length1, start2, length2);
      }
    }
    mergeLow(start1, length1, start2, length2) {
      const { compare: compare4 } = this;
      const { array } = this;
      const { tmp } = this;
      const { tmpIndex } = this;
      let i = 0;
      for (i = 0;i < length1; i++) {
        tmp[i] = array[start1 + i];
        tmpIndex[i] = results[start1 + i];
      }
      let cursor1 = 0;
      let cursor2 = start2;
      let dest = start1;
      array[dest] = array[cursor2];
      results[dest] = results[cursor2];
      dest++;
      cursor2++;
      if (--length2 === 0) {
        for (i = 0;i < length1; i++) {
          array[dest + i] = tmp[cursor1 + i];
          results[dest + i] = tmpIndex[cursor1 + i];
        }
        return;
      }
      if (length1 === 1) {
        for (i = 0;i < length2; i++) {
          array[dest + i] = array[cursor2 + i];
          results[dest + i] = results[cursor2 + i];
        }
        array[dest + length2] = tmp[cursor1];
        results[dest + length2] = tmpIndex[cursor1];
        return;
      }
      let { minGallop } = this;
      while (true) {
        let count1 = 0;
        let count22 = 0;
        let exit = false;
        do {
          if (compare4(array[cursor2], tmp[cursor1]) < 0) {
            array[dest] = array[cursor2];
            results[dest] = results[cursor2];
            dest++;
            cursor2++;
            count22++;
            count1 = 0;
            if (--length2 === 0) {
              exit = true;
              break;
            }
          } else {
            array[dest] = tmp[cursor1];
            results[dest] = tmpIndex[cursor1];
            dest++;
            cursor1++;
            count1++;
            count22 = 0;
            if (--length1 === 1) {
              exit = true;
              break;
            }
          }
        } while ((count1 | count22) < minGallop);
        if (exit) {
          break;
        }
        do {
          count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare4);
          if (count1 !== 0) {
            for (i = 0;i < count1; i++) {
              array[dest + i] = tmp[cursor1 + i];
              results[dest + i] = tmpIndex[cursor1 + i];
            }
            dest += count1;
            cursor1 += count1;
            length1 -= count1;
            if (length1 <= 1) {
              exit = true;
              break;
            }
          }
          array[dest] = array[cursor2];
          results[dest] = results[cursor2];
          dest++;
          cursor2++;
          if (--length2 === 0) {
            exit = true;
            break;
          }
          count22 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare4);
          if (count22 !== 0) {
            for (i = 0;i < count22; i++) {
              array[dest + i] = array[cursor2 + i];
              results[dest + i] = results[cursor2 + i];
            }
            dest += count22;
            cursor2 += count22;
            length2 -= count22;
            if (length2 === 0) {
              exit = true;
              break;
            }
          }
          array[dest] = tmp[cursor1];
          results[dest] = tmpIndex[cursor1];
          dest++;
          cursor1++;
          if (--length1 === 1) {
            exit = true;
            break;
          }
          minGallop--;
        } while (count1 >= DEFAULT_MIN_GALLOPING || count22 >= DEFAULT_MIN_GALLOPING);
        if (exit) {
          break;
        }
        if (minGallop < 0) {
          minGallop = 0;
        }
        minGallop += 2;
      }
      this.minGallop = minGallop;
      if (minGallop < 1) {
        this.minGallop = 1;
      }
      if (length1 === 1) {
        for (i = 0;i < length2; i++) {
          array[dest + i] = array[cursor2 + i];
          results[dest + i] = results[cursor2 + i];
        }
        array[dest + length2] = tmp[cursor1];
        results[dest + length2] = tmpIndex[cursor1];
      } else if (length1 === 0) {
        throw new Error("mergeLow preconditions were not respected");
      } else {
        for (i = 0;i < length1; i++) {
          array[dest + i] = tmp[cursor1 + i];
          results[dest + i] = tmpIndex[cursor1 + i];
        }
      }
    }
    mergeHigh(start1, length1, start2, length2) {
      const { compare: compare4 } = this;
      const { array } = this;
      const { tmp } = this;
      const { tmpIndex } = this;
      let i = 0;
      for (i = 0;i < length2; i++) {
        tmp[i] = array[start2 + i];
        tmpIndex[i] = results[start2 + i];
      }
      let cursor1 = start1 + length1 - 1;
      let cursor2 = length2 - 1;
      let dest = start2 + length2 - 1;
      let customCursor = 0;
      let customDest = 0;
      array[dest] = array[cursor1];
      results[dest] = results[cursor1];
      dest--;
      cursor1--;
      if (--length1 === 0) {
        customCursor = dest - (length2 - 1);
        for (i = 0;i < length2; i++) {
          array[customCursor + i] = tmp[i];
          results[customCursor + i] = tmpIndex[i];
        }
        return;
      }
      if (length2 === 1) {
        dest -= length1;
        cursor1 -= length1;
        customDest = dest + 1;
        customCursor = cursor1 + 1;
        for (i = length1 - 1;i >= 0; i--) {
          array[customDest + i] = array[customCursor + i];
          results[customDest + i] = results[customCursor + i];
        }
        array[dest] = tmp[cursor2];
        results[dest] = tmpIndex[cursor2];
        return;
      }
      let { minGallop } = this;
      while (true) {
        let count1 = 0;
        let count22 = 0;
        let exit = false;
        do {
          if (compare4(tmp[cursor2], array[cursor1]) < 0) {
            array[dest] = array[cursor1];
            results[dest] = results[cursor1];
            dest--;
            cursor1--;
            count1++;
            count22 = 0;
            if (--length1 === 0) {
              exit = true;
              break;
            }
          } else {
            array[dest] = tmp[cursor2];
            results[dest] = tmpIndex[cursor2];
            dest--;
            cursor2--;
            count22++;
            count1 = 0;
            if (--length2 === 1) {
              exit = true;
              break;
            }
          }
        } while ((count1 | count22) < minGallop);
        if (exit) {
          break;
        }
        do {
          count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare4);
          if (count1 !== 0) {
            dest -= count1;
            cursor1 -= count1;
            length1 -= count1;
            customDest = dest + 1;
            customCursor = cursor1 + 1;
            for (i = count1 - 1;i >= 0; i--) {
              array[customDest + i] = array[customCursor + i];
              results[customDest + i] = results[customCursor + i];
            }
            if (length1 === 0) {
              exit = true;
              break;
            }
          }
          array[dest] = tmp[cursor2];
          results[dest] = tmpIndex[cursor2];
          dest--;
          cursor2--;
          if (--length2 === 1) {
            exit = true;
            break;
          }
          count22 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare4);
          if (count22 !== 0) {
            dest -= count22;
            cursor2 -= count22;
            length2 -= count22;
            customDest = dest + 1;
            customCursor = cursor2 + 1;
            for (i = 0;i < count22; i++) {
              array[customDest + i] = tmp[customCursor + i];
              results[customDest + i] = tmpIndex[customCursor + i];
            }
            if (length2 <= 1) {
              exit = true;
              break;
            }
          }
          array[dest] = array[cursor1];
          results[dest] = results[cursor1];
          dest--;
          cursor1--;
          if (--length1 === 0) {
            exit = true;
            break;
          }
          minGallop--;
        } while (count1 >= DEFAULT_MIN_GALLOPING || count22 >= DEFAULT_MIN_GALLOPING);
        if (exit) {
          break;
        }
        if (minGallop < 0) {
          minGallop = 0;
        }
        minGallop += 2;
      }
      this.minGallop = minGallop;
      if (minGallop < 1) {
        this.minGallop = 1;
      }
      if (length2 === 1) {
        dest -= length1;
        cursor1 -= length1;
        customDest = dest + 1;
        customCursor = cursor1 + 1;
        for (i = length1 - 1;i >= 0; i--) {
          array[customDest + i] = array[customCursor + i];
          results[customDest + i] = results[customCursor + i];
        }
        array[dest] = tmp[cursor2];
        results[dest] = tmpIndex[cursor2];
      } else if (length2 === 0) {
        throw new Error("mergeHigh preconditions were not respected");
      } else {
        customCursor = dest - (length2 - 1);
        for (i = 0;i < length2; i++) {
          array[customCursor + i] = tmp[i];
          results[customCursor + i] = tmpIndex[i];
        }
      }
    }
  }
  function sort(array, compare4, lo, hi) {
    if (!Array.isArray(array)) {
      throw new TypeError(`The "array" argument must be an array. Received ${array}`);
    }
    results = [];
    const { length } = array;
    let i = 0;
    while (i < length) {
      results[i] = i++;
    }
    if (!compare4) {
      compare4 = alphabeticalCompare;
    } else if (typeof compare4 !== "function") {
      hi = lo;
      lo = compare4;
      compare4 = alphabeticalCompare;
    }
    if (!lo) {
      lo = 0;
    }
    if (!hi) {
      hi = length;
    }
    let remaining = hi - lo;
    if (remaining < 2) {
      return results;
    }
    let runLength = 0;
    if (remaining < DEFAULT_MIN_MERGE) {
      runLength = makeAscendingRun(array, lo, hi, compare4);
      binaryInsertionSort(array, lo, hi, lo + runLength, compare4);
      return results;
    }
    const ts = new TimSort(array, compare4);
    const minRun = minRunLength(remaining);
    do {
      runLength = makeAscendingRun(array, lo, hi, compare4);
      if (runLength < minRun) {
        let force = remaining;
        if (force > minRun) {
          force = minRun;
        }
        binaryInsertionSort(array, lo, lo + force, lo + runLength, compare4);
        runLength = force;
      }
      ts.pushRun(lo, runLength);
      ts.mergeRuns();
      remaining -= runLength;
      lo += runLength;
    } while (remaining !== 0);
    ts.forceMergeRuns();
    return results;
  }
  module.exports = {
    sort
  };
});

// node_modules/has-own-prop/index.js
var require_has_own_prop = __commonJS((exports, module) => {
  var hasOwnProp = Object.prototype.hasOwnProperty;
  module.exports = (object, property) => hasOwnProp.call(object, property);
});

// node_modules/comment-json/src/common.js
var require_common = __commonJS((exports, module) => {
  var hasOwnProperty4 = require_has_own_prop();
  var {
    isObject,
    isArray: isArray3,
    isString: isString2,
    isNumber
  } = require_util();
  var PREFIX_BEFORE = "before";
  var PREFIX_AFTER_PROP = "after-prop";
  var PREFIX_AFTER_COLON = "after-colon";
  var PREFIX_AFTER_VALUE = "after-value";
  var PREFIX_AFTER = "after";
  var PREFIX_BEFORE_ALL = "before-all";
  var PREFIX_AFTER_ALL = "after-all";
  var BRACKET_OPEN = "[";
  var BRACKET_CLOSE = "]";
  var CURLY_BRACKET_OPEN = "{";
  var CURLY_BRACKET_CLOSE = "}";
  var COMMA = ",";
  var EMPTY = "";
  var MINUS = "-";
  var SYMBOL_PREFIXES = [
    PREFIX_BEFORE,
    PREFIX_AFTER_PROP,
    PREFIX_AFTER_COLON,
    PREFIX_AFTER_VALUE,
    PREFIX_AFTER
  ];
  var NON_PROP_SYMBOL_KEYS = [
    PREFIX_BEFORE,
    PREFIX_BEFORE_ALL,
    PREFIX_AFTER_ALL
  ].map(Symbol.for);
  var COLON = ":";
  var UNDEFINED = undefined;
  var symbol = (prefix, key) => Symbol.for(prefix + COLON + key);
  var define2 = (target, key, value) => Object.defineProperty(target, key, {
    value,
    writable: true,
    configurable: true
  });
  var copy_comments_by_kind = (target, source, target_key, source_key, prefix, remove_source) => {
    const source_prop = symbol(prefix, source_key);
    if (!hasOwnProperty4(source, source_prop)) {
      return;
    }
    const target_prop = target_key === source_key ? source_prop : symbol(prefix, target_key);
    define2(target, target_prop, source[source_prop]);
    if (remove_source) {
      delete source[source_prop];
    }
  };
  var copy_comments = (target, source, target_key, source_key, remove_source) => {
    SYMBOL_PREFIXES.forEach((prefix) => {
      copy_comments_by_kind(target, source, target_key, source_key, prefix, remove_source);
    });
  };
  var swap_comments = (array, from, to) => {
    if (from === to) {
      return;
    }
    SYMBOL_PREFIXES.forEach((prefix) => {
      const target_prop = symbol(prefix, to);
      if (!hasOwnProperty4(array, target_prop)) {
        copy_comments_by_kind(array, array, to, from, prefix, true);
        return;
      }
      const comments = array[target_prop];
      delete array[target_prop];
      copy_comments_by_kind(array, array, to, from, prefix, true);
      define2(array, symbol(prefix, from), comments);
    });
  };
  var assign_non_prop_comments = (target, source) => {
    NON_PROP_SYMBOL_KEYS.forEach((key) => {
      const comments = source[key];
      if (comments) {
        define2(target, key, comments);
      }
    });
  };
  var assign3 = (target, source, keys3) => {
    keys3.forEach((key) => {
      if (!isString2(key) && !isNumber(key)) {
        return;
      }
      if (!hasOwnProperty4(source, key)) {
        return;
      }
      target[key] = source[key];
      copy_comments(target, source, key, key);
    });
    return target;
  };
  module.exports = {
    SYMBOL_PREFIXES,
    PREFIX_BEFORE,
    PREFIX_AFTER_PROP,
    PREFIX_AFTER_COLON,
    PREFIX_AFTER_VALUE,
    PREFIX_AFTER,
    PREFIX_BEFORE_ALL,
    PREFIX_AFTER_ALL,
    BRACKET_OPEN,
    BRACKET_CLOSE,
    CURLY_BRACKET_OPEN,
    CURLY_BRACKET_CLOSE,
    COLON,
    COMMA,
    MINUS,
    EMPTY,
    UNDEFINED,
    symbol,
    define: define2,
    copy_comments,
    swap_comments,
    assign_non_prop_comments,
    assign(target, source, keys3) {
      if (!isObject(target)) {
        throw new TypeError("Cannot convert undefined or null to object");
      }
      if (!isObject(source)) {
        return target;
      }
      if (keys3 === UNDEFINED) {
        keys3 = Object.keys(source);
        assign_non_prop_comments(target, source);
      } else if (!isArray3(keys3)) {
        throw new TypeError("keys must be array or undefined");
      } else if (keys3.length === 0) {
        assign_non_prop_comments(target, source);
      }
      return assign3(target, source, keys3);
    }
  };
});

// node_modules/comment-json/src/array.js
var require_array = __commonJS((exports, module) => {
  var { isArray: isArray3 } = require_util();
  var { sort } = require_src();
  var {
    SYMBOL_PREFIXES,
    UNDEFINED,
    symbol,
    copy_comments,
    swap_comments
  } = require_common();
  var reverse_comments = (array) => {
    const { length } = array;
    let i = 0;
    const max4 = length / 2;
    for (;i < max4; i++) {
      swap_comments(array, i, length - i - 1);
    }
  };
  var move_comment = (target, source, i, offset, remove) => {
    copy_comments(target, source, i + offset, i, remove);
  };
  var move_comments = (target, source, start, count3, offset, remove) => {
    if (offset > 0) {
      let i2 = count3;
      while (i2-- > 0) {
        move_comment(target, source, start + i2, offset, remove);
      }
      return;
    }
    let i = 0;
    while (i < count3) {
      const ii = i++;
      move_comment(target, source, start + ii, offset, remove);
    }
  };
  var remove_comments = (array, key) => {
    SYMBOL_PREFIXES.forEach((prefix) => {
      const prop = symbol(prefix, key);
      delete array[prop];
    });
  };
  var get_mapped = (map3, key) => {
    let mapped = key;
    while (mapped in map3) {
      mapped = map3[mapped];
    }
    return mapped;
  };

  class CommentArray extends Array {
    splice(...args) {
      const { length } = this;
      const ret = super.splice(...args);
      let [begin, deleteCount, ...items] = args;
      if (begin < 0) {
        begin += length;
      }
      if (arguments.length === 1) {
        deleteCount = length - begin;
      } else {
        deleteCount = Math.min(length - begin, deleteCount);
      }
      const {
        length: item_length
      } = items;
      const offset = item_length - deleteCount;
      const start = begin + deleteCount;
      const count3 = length - start;
      move_comments(this, this, start, count3, offset, true);
      return ret;
    }
    slice(...args) {
      const { length } = this;
      const array = super.slice(...args);
      if (!array.length) {
        return new CommentArray;
      }
      let [begin, before] = args;
      if (before === UNDEFINED) {
        before = length;
      } else if (before < 0) {
        before += length;
      }
      if (begin < 0) {
        begin += length;
      } else if (begin === UNDEFINED) {
        begin = 0;
      }
      move_comments(array, this, begin, before - begin, -begin);
      return array;
    }
    unshift(...items) {
      const { length } = this;
      const ret = super.unshift(...items);
      const {
        length: items_length
      } = items;
      if (items_length > 0) {
        move_comments(this, this, 0, length, items_length, true);
      }
      return ret;
    }
    shift() {
      const ret = super.shift();
      const { length } = this;
      remove_comments(this, 0);
      move_comments(this, this, 1, length, -1, true);
      return ret;
    }
    reverse() {
      super.reverse();
      reverse_comments(this);
      return this;
    }
    pop() {
      const ret = super.pop();
      remove_comments(this, this.length);
      return ret;
    }
    concat(...items) {
      let { length } = this;
      const ret = super.concat(...items);
      if (!items.length) {
        return ret;
      }
      move_comments(ret, this, 0, this.length, 0);
      items.forEach((item) => {
        const prev = length;
        length += isArray3(item) ? item.length : 1;
        if (!(item instanceof CommentArray)) {
          return;
        }
        move_comments(ret, item, 0, item.length, prev);
      });
      return ret;
    }
    sort(...args) {
      const result = sort(this, ...args.slice(0, 1));
      const map3 = Object.create(null);
      result.forEach((source_index, index) => {
        if (source_index === index) {
          return;
        }
        const real_source_index = get_mapped(map3, source_index);
        if (real_source_index === index) {
          return;
        }
        map3[index] = real_source_index;
        swap_comments(this, index, real_source_index);
      });
      return this;
    }
  }
  module.exports = {
    CommentArray
  };
});

// node_modules/comment-json/src/parse.js
var require_parse3 = __commonJS((exports, module) => {
  var esprima = require_esprima();
  var {
    CommentArray
  } = require_array();
  var {
    PREFIX_BEFORE,
    PREFIX_AFTER_PROP,
    PREFIX_AFTER_COLON,
    PREFIX_AFTER_VALUE,
    PREFIX_AFTER,
    PREFIX_BEFORE_ALL,
    PREFIX_AFTER_ALL,
    BRACKET_OPEN,
    BRACKET_CLOSE,
    CURLY_BRACKET_OPEN,
    CURLY_BRACKET_CLOSE,
    COLON,
    COMMA,
    MINUS,
    EMPTY,
    UNDEFINED,
    define: define2,
    assign_non_prop_comments
  } = require_common();
  var tokenize = (code) => esprima.tokenize(code, {
    comment: true,
    loc: true
  });
  var previous_hosts = [];
  var comments_host = null;
  var unassigned_comments = null;
  var previous_props = [];
  var last_prop;
  var remove_comments = false;
  var inline = false;
  var tokens = null;
  var last = null;
  var current = null;
  var index;
  var reviver = null;
  var clean4 = () => {
    previous_props.length = previous_hosts.length = 0;
    last = null;
    last_prop = UNDEFINED;
  };
  var free = () => {
    clean4();
    tokens.length = 0;
    unassigned_comments = comments_host = tokens = last = current = reviver = null;
  };
  var symbolFor = (prefix) => Symbol.for(last_prop !== UNDEFINED ? prefix + COLON + last_prop : prefix);
  var transform = (k, v) => reviver ? reviver(k, v) : v;
  var unexpected = () => {
    const error = new SyntaxError(`Unexpected token ${current.value.slice(0, 1)}`);
    Object.assign(error, current.loc.start);
    throw error;
  };
  var unexpected_end = () => {
    const error = new SyntaxError("Unexpected end of JSON input");
    Object.assign(error, last ? last.loc.end : {
      line: 1,
      column: 0
    });
    throw error;
  };
  var next = () => {
    const new_token = tokens[++index];
    inline = current && new_token && current.loc.end.line === new_token.loc.start.line || false;
    last = current;
    current = new_token;
  };
  var type = () => {
    if (!current) {
      unexpected_end();
    }
    return current.type === "Punctuator" ? current.value : current.type;
  };
  var is = (t) => type() === t;
  var expect = (a) => {
    if (!is(a)) {
      unexpected();
    }
  };
  var set_comments_host = (new_host) => {
    previous_hosts.push(comments_host);
    comments_host = new_host;
  };
  var restore_comments_host = () => {
    comments_host = previous_hosts.pop();
  };
  var assign_after_comments = () => {
    if (!unassigned_comments) {
      return;
    }
    const after_comments = [];
    for (const comment of unassigned_comments) {
      if (comment.inline) {
        after_comments.push(comment);
      } else {
        break;
      }
    }
    const { length } = after_comments;
    if (!length) {
      return;
    }
    if (length === unassigned_comments.length) {
      unassigned_comments = null;
    } else {
      unassigned_comments.splice(0, length);
    }
    define2(comments_host, symbolFor(PREFIX_AFTER), after_comments);
  };
  var assign_comments = (prefix) => {
    if (!unassigned_comments) {
      return;
    }
    define2(comments_host, symbolFor(prefix), unassigned_comments);
    unassigned_comments = null;
  };
  var parse_comments = (prefix) => {
    const comments = [];
    while (current && (is("LineComment") || is("BlockComment"))) {
      const comment = {
        ...current,
        inline
      };
      comments.push(comment);
      next();
    }
    if (remove_comments) {
      return;
    }
    if (!comments.length) {
      return;
    }
    if (prefix) {
      define2(comments_host, symbolFor(prefix), comments);
      return;
    }
    unassigned_comments = comments;
  };
  var set_prop = (prop, push) => {
    if (push) {
      previous_props.push(last_prop);
    }
    last_prop = prop;
  };
  var restore_prop = () => {
    last_prop = previous_props.pop();
  };
  var parse_object = () => {
    const obj = {};
    set_comments_host(obj);
    set_prop(UNDEFINED, true);
    let started = false;
    let name;
    parse_comments();
    while (!is(CURLY_BRACKET_CLOSE)) {
      if (started) {
        assign_comments(PREFIX_AFTER_VALUE);
        expect(COMMA);
        next();
        parse_comments();
        assign_after_comments();
        if (is(CURLY_BRACKET_CLOSE)) {
          break;
        }
      }
      started = true;
      expect("String");
      name = JSON.parse(current.value);
      set_prop(name);
      assign_comments(PREFIX_BEFORE);
      next();
      parse_comments(PREFIX_AFTER_PROP);
      expect(COLON);
      next();
      parse_comments(PREFIX_AFTER_COLON);
      obj[name] = transform(name, walk2());
      parse_comments();
    }
    if (started) {
      assign_comments(PREFIX_AFTER);
    }
    next();
    last_prop = undefined;
    if (!started) {
      assign_comments(PREFIX_BEFORE);
    }
    restore_comments_host();
    restore_prop();
    return obj;
  };
  var parse_array = () => {
    const array = new CommentArray;
    set_comments_host(array);
    set_prop(UNDEFINED, true);
    let started = false;
    let i = 0;
    parse_comments();
    while (!is(BRACKET_CLOSE)) {
      if (started) {
        assign_comments(PREFIX_AFTER_VALUE);
        expect(COMMA);
        next();
        parse_comments();
        assign_after_comments();
        if (is(BRACKET_CLOSE)) {
          break;
        }
      }
      started = true;
      set_prop(i);
      assign_comments(PREFIX_BEFORE);
      array[i] = transform(i, walk2());
      i++;
      parse_comments();
    }
    if (started) {
      assign_comments(PREFIX_AFTER);
    }
    next();
    last_prop = undefined;
    if (!started) {
      assign_comments(PREFIX_BEFORE);
    }
    restore_comments_host();
    restore_prop();
    return array;
  };
  function walk2() {
    let tt = type();
    if (tt === CURLY_BRACKET_OPEN) {
      next();
      return parse_object();
    }
    if (tt === BRACKET_OPEN) {
      next();
      return parse_array();
    }
    let negative = EMPTY;
    if (tt === MINUS) {
      next();
      tt = type();
      negative = MINUS;
    }
    let v;
    switch (tt) {
      case "String":
      case "Boolean":
      case "Null":
      case "Numeric":
        v = current.value;
        next();
        return JSON.parse(negative + v);
      default:
    }
  }
  var isObject = (subject) => Object(subject) === subject;
  var parse = (code, rev, no_comments) => {
    clean4();
    tokens = tokenize(code);
    reviver = rev;
    remove_comments = no_comments;
    if (!tokens.length) {
      unexpected_end();
    }
    index = -1;
    next();
    set_comments_host({});
    parse_comments(PREFIX_BEFORE_ALL);
    let result = walk2();
    parse_comments(PREFIX_AFTER_ALL);
    if (current) {
      unexpected();
    }
    if (!no_comments && result !== null) {
      if (!isObject(result)) {
        result = new Object(result);
      }
      assign_non_prop_comments(result, comments_host);
    }
    restore_comments_host();
    result = transform("", result);
    free();
    return result;
  };
  module.exports = {
    parse,
    tokenize
  };
});

// node_modules/repeat-string/index.js
var require_repeat_string = __commonJS((exports, module) => {
  /*!
   * repeat-string <https://github.com/jonschlinkert/repeat-string>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  var res = "";
  var cache5;
  module.exports = repeat;
  function repeat(str, num) {
    if (typeof str !== "string") {
      throw new TypeError("expected a string");
    }
    if (num === 1)
      return str;
    if (num === 2)
      return str + str;
    var max4 = str.length * num;
    if (cache5 !== str || typeof cache5 === "undefined") {
      cache5 = str;
      res = "";
    } else if (res.length >= max4) {
      return res.substr(0, max4);
    }
    while (max4 > res.length && num > 1) {
      if (num & 1) {
        res += str;
      }
      num >>= 1;
      str += str;
    }
    res += str;
    res = res.substr(0, max4);
    return res;
  }
});

// node_modules/comment-json/src/stringify.js
var require_stringify2 = __commonJS((exports, module) => {
  var {
    isArray: isArray3,
    isObject,
    isFunction,
    isNumber,
    isString: isString2
  } = require_util();
  var repeat = require_repeat_string();
  var {
    PREFIX_BEFORE_ALL,
    PREFIX_BEFORE,
    PREFIX_AFTER_PROP,
    PREFIX_AFTER_COLON,
    PREFIX_AFTER_VALUE,
    PREFIX_AFTER,
    PREFIX_AFTER_ALL,
    BRACKET_OPEN,
    BRACKET_CLOSE,
    CURLY_BRACKET_OPEN,
    CURLY_BRACKET_CLOSE,
    COLON,
    COMMA,
    EMPTY,
    UNDEFINED
  } = require_common();
  var ESCAPABLE = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
  var SPACE = " ";
  var LF2 = `
`;
  var STR_NULL = "null";
  var BEFORE = (prop) => `${PREFIX_BEFORE}:${prop}`;
  var AFTER_PROP = (prop) => `${PREFIX_AFTER_PROP}:${prop}`;
  var AFTER_COLON = (prop) => `${PREFIX_AFTER_COLON}:${prop}`;
  var AFTER_VALUE = (prop) => `${PREFIX_AFTER_VALUE}:${prop}`;
  var AFTER = (prop) => `${PREFIX_AFTER}:${prop}`;
  var meta = {
    "\b": "\\b",
    "\t": "\\t",
    "\n": "\\n",
    "\f": "\\f",
    "\r": "\\r",
    '"': "\\\"",
    "\\": "\\\\"
  };
  var escape = (string) => {
    ESCAPABLE.lastIndex = 0;
    if (!ESCAPABLE.test(string)) {
      return string;
    }
    return string.replace(ESCAPABLE, (a) => {
      const c = meta[a];
      return typeof c === "string" ? c : a;
    });
  };
  var quote = (string) => `"${escape(string)}"`;
  var comment_stringify = (value, line) => line ? `//${value}` : `/*${value}*/`;
  var process_comments = (host, symbol_tag, deeper_gap, display_block) => {
    const comments = host[Symbol.for(symbol_tag)];
    if (!comments || !comments.length) {
      return EMPTY;
    }
    let is_line_comment = false;
    const str = comments.reduce((prev, {
      inline,
      type,
      value
    }) => {
      const delimiter = inline ? SPACE : LF2 + deeper_gap;
      is_line_comment = type === "LineComment";
      return prev + delimiter + comment_stringify(value, is_line_comment);
    }, EMPTY);
    return display_block || is_line_comment ? str + LF2 + deeper_gap : str;
  };
  var replacer = null;
  var indent = EMPTY;
  var clean4 = () => {
    replacer = null;
    indent = EMPTY;
  };
  var join2 = (one, two, gap) => one ? two ? one + two.trim() + LF2 + gap : one.trimRight() + LF2 + gap : two ? two.trimRight() + LF2 + gap : EMPTY;
  var join_content = (inside, value, gap) => {
    const comment = process_comments(value, PREFIX_BEFORE, gap + indent, true);
    return join2(comment, inside, gap);
  };
  var array_stringify = (value, gap) => {
    const deeper_gap = gap + indent;
    const { length } = value;
    let inside = EMPTY;
    let after_comma = EMPTY;
    for (let i = 0;i < length; i++) {
      if (i !== 0) {
        inside += COMMA;
      }
      const before = join2(after_comma, process_comments(value, BEFORE(i), deeper_gap), deeper_gap);
      inside += before || LF2 + deeper_gap;
      inside += stringify(i, value, deeper_gap) || STR_NULL;
      inside += process_comments(value, AFTER_VALUE(i), deeper_gap);
      after_comma = process_comments(value, AFTER(i), deeper_gap);
    }
    inside += join2(after_comma, process_comments(value, PREFIX_AFTER, deeper_gap), deeper_gap);
    return BRACKET_OPEN + join_content(inside, value, gap) + BRACKET_CLOSE;
  };
  var object_stringify = (value, gap) => {
    if (!value) {
      return "null";
    }
    const deeper_gap = gap + indent;
    let inside = EMPTY;
    let after_comma = EMPTY;
    let first3 = true;
    const keys3 = isArray3(replacer) ? replacer : Object.keys(value);
    const iteratee = (key) => {
      const sv = stringify(key, value, deeper_gap);
      if (sv === UNDEFINED) {
        return;
      }
      if (!first3) {
        inside += COMMA;
      }
      first3 = false;
      const before = join2(after_comma, process_comments(value, BEFORE(key), deeper_gap), deeper_gap);
      inside += before || LF2 + deeper_gap;
      inside += quote(key) + process_comments(value, AFTER_PROP(key), deeper_gap) + COLON + process_comments(value, AFTER_COLON(key), deeper_gap) + SPACE + sv + process_comments(value, AFTER_VALUE(key), deeper_gap);
      after_comma = process_comments(value, AFTER(key), deeper_gap);
    };
    keys3.forEach(iteratee);
    inside += join2(after_comma, process_comments(value, PREFIX_AFTER, deeper_gap), deeper_gap);
    return CURLY_BRACKET_OPEN + join_content(inside, value, gap) + CURLY_BRACKET_CLOSE;
  };
  function stringify(key, holder, gap) {
    let value = holder[key];
    if (isObject(value) && isFunction(value.toJSON)) {
      value = value.toJSON(key);
    }
    if (isFunction(replacer)) {
      value = replacer.call(holder, key, value);
    }
    switch (typeof value) {
      case "string":
        return quote(value);
      case "number":
        return Number.isFinite(value) ? String(value) : STR_NULL;
      case "boolean":
      case "null":
        return String(value);
      case "object":
        return isArray3(value) ? array_stringify(value, gap) : object_stringify(value, gap);
      default:
    }
  }
  var get_indent = (space) => isString2(space) ? space : isNumber(space) ? repeat(SPACE, space) : EMPTY;
  var { toString } = Object.prototype;
  var PRIMITIVE_OBJECT_TYPES = [
    "[object Number]",
    "[object String]",
    "[object Boolean]"
  ];
  var is_primitive_object = (subject) => {
    if (typeof subject !== "object") {
      return false;
    }
    const str = toString.call(subject);
    return PRIMITIVE_OBJECT_TYPES.includes(str);
  };
  module.exports = (value, replacer_, space) => {
    const indent_ = get_indent(space);
    if (!indent_) {
      return JSON.stringify(value, replacer_);
    }
    if (!isFunction(replacer_) && !isArray3(replacer_)) {
      replacer_ = null;
    }
    replacer = replacer_;
    indent = indent_;
    const str = is_primitive_object(value) ? JSON.stringify(value) : stringify("", { "": value }, EMPTY);
    clean4();
    return isObject(value) ? process_comments(value, PREFIX_BEFORE_ALL, EMPTY).trimLeft() + str + process_comments(value, PREFIX_AFTER_ALL, EMPTY).trimRight() : str;
  };
});

// node_modules/comment-json/src/index.js
var require_src2 = __commonJS((exports, module) => {
  var { parse, tokenize } = require_parse3();
  var stringify = require_stringify2();
  var { CommentArray } = require_array();
  var { assign: assign3 } = require_common();
  module.exports = {
    parse,
    stringify,
    tokenize,
    CommentArray,
    assign: assign3
  };
});

// node_modules/yaml/dist/nodes/identity.js
var require_identity = __commonJS((exports) => {
  var ALIAS = Symbol.for("yaml.alias");
  var DOC = Symbol.for("yaml.document");
  var MAP = Symbol.for("yaml.map");
  var PAIR = Symbol.for("yaml.pair");
  var SCALAR = Symbol.for("yaml.scalar");
  var SEQ = Symbol.for("yaml.seq");
  var NODE_TYPE = Symbol.for("yaml.node.type");
  var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
  var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
  var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
  var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
  var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
  var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
  function isCollection(node) {
    if (node && typeof node === "object")
      switch (node[NODE_TYPE]) {
        case MAP:
        case SEQ:
          return true;
      }
    return false;
  }
  function isNode(node) {
    if (node && typeof node === "object")
      switch (node[NODE_TYPE]) {
        case ALIAS:
        case MAP:
        case SCALAR:
        case SEQ:
          return true;
      }
    return false;
  }
  var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
  exports.ALIAS = ALIAS;
  exports.DOC = DOC;
  exports.MAP = MAP;
  exports.NODE_TYPE = NODE_TYPE;
  exports.PAIR = PAIR;
  exports.SCALAR = SCALAR;
  exports.SEQ = SEQ;
  exports.hasAnchor = hasAnchor;
  exports.isAlias = isAlias;
  exports.isCollection = isCollection;
  exports.isDocument = isDocument;
  exports.isMap = isMap;
  exports.isNode = isNode;
  exports.isPair = isPair;
  exports.isScalar = isScalar;
  exports.isSeq = isSeq;
});

// node_modules/yaml/dist/visit.js
var require_visit = __commonJS((exports) => {
  var identity = require_identity();
  var BREAK = Symbol("break visit");
  var SKIP = Symbol("skip children");
  var REMOVE = Symbol("remove node");
  function visit(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
      const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      visit_(null, node, visitor_, Object.freeze([]));
  }
  visit.BREAK = BREAK;
  visit.SKIP = SKIP;
  visit.REMOVE = REMOVE;
  function visit_(key, node, visitor, path6) {
    const ctrl = callVisitor(key, node, visitor, path6);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
      replaceNode(key, path6, ctrl);
      return visit_(key, ctrl, visitor, path6);
    }
    if (typeof ctrl !== "symbol") {
      if (identity.isCollection(node)) {
        path6 = Object.freeze(path6.concat(node));
        for (let i = 0;i < node.items.length; ++i) {
          const ci = visit_(i, node.items[i], visitor, path6);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if (identity.isPair(node)) {
        path6 = Object.freeze(path6.concat(node));
        const ck = visit_("key", node.key, visitor, path6);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = visit_("value", node.value, visitor, path6);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  async function visitAsync(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
      const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      await visitAsync_(null, node, visitor_, Object.freeze([]));
  }
  visitAsync.BREAK = BREAK;
  visitAsync.SKIP = SKIP;
  visitAsync.REMOVE = REMOVE;
  async function visitAsync_(key, node, visitor, path6) {
    const ctrl = await callVisitor(key, node, visitor, path6);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
      replaceNode(key, path6, ctrl);
      return visitAsync_(key, ctrl, visitor, path6);
    }
    if (typeof ctrl !== "symbol") {
      if (identity.isCollection(node)) {
        path6 = Object.freeze(path6.concat(node));
        for (let i = 0;i < node.items.length; ++i) {
          const ci = await visitAsync_(i, node.items[i], visitor, path6);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if (identity.isPair(node)) {
        path6 = Object.freeze(path6.concat(node));
        const ck = await visitAsync_("key", node.key, visitor, path6);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = await visitAsync_("value", node.value, visitor, path6);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  function initVisitor(visitor) {
    if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
      return Object.assign({
        Alias: visitor.Node,
        Map: visitor.Node,
        Scalar: visitor.Node,
        Seq: visitor.Node
      }, visitor.Value && {
        Map: visitor.Value,
        Scalar: visitor.Value,
        Seq: visitor.Value
      }, visitor.Collection && {
        Map: visitor.Collection,
        Seq: visitor.Collection
      }, visitor);
    }
    return visitor;
  }
  function callVisitor(key, node, visitor, path6) {
    if (typeof visitor === "function")
      return visitor(key, node, path6);
    if (identity.isMap(node))
      return visitor.Map?.(key, node, path6);
    if (identity.isSeq(node))
      return visitor.Seq?.(key, node, path6);
    if (identity.isPair(node))
      return visitor.Pair?.(key, node, path6);
    if (identity.isScalar(node))
      return visitor.Scalar?.(key, node, path6);
    if (identity.isAlias(node))
      return visitor.Alias?.(key, node, path6);
    return;
  }
  function replaceNode(key, path6, node) {
    const parent = path6[path6.length - 1];
    if (identity.isCollection(parent)) {
      parent.items[key] = node;
    } else if (identity.isPair(parent)) {
      if (key === "key")
        parent.key = node;
      else
        parent.value = node;
    } else if (identity.isDocument(parent)) {
      parent.contents = node;
    } else {
      const pt = identity.isAlias(parent) ? "alias" : "scalar";
      throw new Error(`Cannot replace node with ${pt} parent`);
    }
  }
  exports.visit = visit;
  exports.visitAsync = visitAsync;
});

// node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS((exports) => {
  var identity = require_identity();
  var visit = require_visit();
  var escapeChars = {
    "!": "%21",
    ",": "%2C",
    "[": "%5B",
    "]": "%5D",
    "{": "%7B",
    "}": "%7D"
  };
  var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);

  class Directives {
    constructor(yaml, tags) {
      this.docStart = null;
      this.docEnd = false;
      this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
      this.tags = Object.assign({}, Directives.defaultTags, tags);
    }
    clone() {
      const copy = new Directives(this.yaml, this.tags);
      copy.docStart = this.docStart;
      return copy;
    }
    atDocument() {
      const res = new Directives(this.yaml, this.tags);
      switch (this.yaml.version) {
        case "1.1":
          this.atNextDocument = true;
          break;
        case "1.2":
          this.atNextDocument = false;
          this.yaml = {
            explicit: Directives.defaultYaml.explicit,
            version: "1.2"
          };
          this.tags = Object.assign({}, Directives.defaultTags);
          break;
      }
      return res;
    }
    add(line, onError) {
      if (this.atNextDocument) {
        this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
        this.tags = Object.assign({}, Directives.defaultTags);
        this.atNextDocument = false;
      }
      const parts = line.trim().split(/[ \t]+/);
      const name = parts.shift();
      switch (name) {
        case "%TAG": {
          if (parts.length !== 2) {
            onError(0, "%TAG directive should contain exactly two parts");
            if (parts.length < 2)
              return false;
          }
          const [handle, prefix] = parts;
          this.tags[handle] = prefix;
          return true;
        }
        case "%YAML": {
          this.yaml.explicit = true;
          if (parts.length !== 1) {
            onError(0, "%YAML directive should contain exactly one part");
            return false;
          }
          const [version2] = parts;
          if (version2 === "1.1" || version2 === "1.2") {
            this.yaml.version = version2;
            return true;
          } else {
            const isValid = /^\d+\.\d+$/.test(version2);
            onError(6, `Unsupported YAML version ${version2}`, isValid);
            return false;
          }
        }
        default:
          onError(0, `Unknown directive ${name}`, true);
          return false;
      }
    }
    tagName(source, onError) {
      if (source === "!")
        return "!";
      if (source[0] !== "!") {
        onError(`Not a valid tag: ${source}`);
        return null;
      }
      if (source[1] === "<") {
        const verbatim = source.slice(2, -1);
        if (verbatim === "!" || verbatim === "!!") {
          onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
          return null;
        }
        if (source[source.length - 1] !== ">")
          onError("Verbatim tags must end with a >");
        return verbatim;
      }
      const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
      if (!suffix)
        onError(`The ${source} tag has no suffix`);
      const prefix = this.tags[handle];
      if (prefix) {
        try {
          return prefix + decodeURIComponent(suffix);
        } catch (error) {
          onError(String(error));
          return null;
        }
      }
      if (handle === "!")
        return source;
      onError(`Could not resolve tag: ${source}`);
      return null;
    }
    tagString(tag) {
      for (const [handle, prefix] of Object.entries(this.tags)) {
        if (tag.startsWith(prefix))
          return handle + escapeTagName(tag.substring(prefix.length));
      }
      return tag[0] === "!" ? tag : `!<${tag}>`;
    }
    toString(doc) {
      const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
      const tagEntries = Object.entries(this.tags);
      let tagNames;
      if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
        const tags = {};
        visit.visit(doc.contents, (_key, node) => {
          if (identity.isNode(node) && node.tag)
            tags[node.tag] = true;
        });
        tagNames = Object.keys(tags);
      } else
        tagNames = [];
      for (const [handle, prefix] of tagEntries) {
        if (handle === "!!" && prefix === "tag:yaml.org,2002:")
          continue;
        if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
          lines.push(`%TAG ${handle} ${prefix}`);
      }
      return lines.join(`
`);
    }
  }
  Directives.defaultYaml = { explicit: false, version: "1.2" };
  Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
  exports.Directives = Directives;
});

// node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS((exports) => {
  var identity = require_identity();
  var visit = require_visit();
  function anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
      const sa = JSON.stringify(anchor);
      const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
      throw new Error(msg);
    }
    return true;
  }
  function anchorNames(root) {
    const anchors = new Set;
    visit.visit(root, {
      Value(_key, node) {
        if (node.anchor)
          anchors.add(node.anchor);
      }
    });
    return anchors;
  }
  function findNewAnchor(prefix, exclude) {
    for (let i = 1;; ++i) {
      const name = `${prefix}${i}`;
      if (!exclude.has(name))
        return name;
    }
  }
  function createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = new Map;
    let prevAnchors = null;
    return {
      onAnchor: (source) => {
        aliasObjects.push(source);
        if (!prevAnchors)
          prevAnchors = anchorNames(doc);
        const anchor = findNewAnchor(prefix, prevAnchors);
        prevAnchors.add(anchor);
        return anchor;
      },
      setAnchors: () => {
        for (const source of aliasObjects) {
          const ref = sourceObjects.get(source);
          if (typeof ref === "object" && ref.anchor && (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {
            ref.node.anchor = ref.anchor;
          } else {
            const error = new Error("Failed to resolve repeated object (this should not happen)");
            error.source = source;
            throw error;
          }
        }
      },
      sourceObjects
    };
  }
  exports.anchorIsValid = anchorIsValid;
  exports.anchorNames = anchorNames;
  exports.createNodeAnchors = createNodeAnchors;
  exports.findNewAnchor = findNewAnchor;
});

// node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS((exports) => {
  function applyReviver(reviver, obj, key, val) {
    if (val && typeof val === "object") {
      if (Array.isArray(val)) {
        for (let i = 0, len = val.length;i < len; ++i) {
          const v0 = val[i];
          const v1 = applyReviver(reviver, val, String(i), v0);
          if (v1 === undefined)
            delete val[i];
          else if (v1 !== v0)
            val[i] = v1;
        }
      } else if (val instanceof Map) {
        for (const k of Array.from(val.keys())) {
          const v0 = val.get(k);
          const v1 = applyReviver(reviver, val, k, v0);
          if (v1 === undefined)
            val.delete(k);
          else if (v1 !== v0)
            val.set(k, v1);
        }
      } else if (val instanceof Set) {
        for (const v0 of Array.from(val)) {
          const v1 = applyReviver(reviver, val, v0, v0);
          if (v1 === undefined)
            val.delete(v0);
          else if (v1 !== v0) {
            val.delete(v0);
            val.add(v1);
          }
        }
      } else {
        for (const [k, v0] of Object.entries(val)) {
          const v1 = applyReviver(reviver, val, k, v0);
          if (v1 === undefined)
            delete val[k];
          else if (v1 !== v0)
            val[k] = v1;
        }
      }
    }
    return reviver.call(obj, key, val);
  }
  exports.applyReviver = applyReviver;
});

// node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS((exports) => {
  var identity = require_identity();
  function toJS(value, arg, ctx) {
    if (Array.isArray(value))
      return value.map((v, i) => toJS(v, String(i), ctx));
    if (value && typeof value.toJSON === "function") {
      if (!ctx || !identity.hasAnchor(value))
        return value.toJSON(arg, ctx);
      const data = { aliasCount: 0, count: 1, res: undefined };
      ctx.anchors.set(value, data);
      ctx.onCreate = (res2) => {
        data.res = res2;
        delete ctx.onCreate;
      };
      const res = value.toJSON(arg, ctx);
      if (ctx.onCreate)
        ctx.onCreate(res);
      return res;
    }
    if (typeof value === "bigint" && !ctx?.keep)
      return Number(value);
    return value;
  }
  exports.toJS = toJS;
});

// node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS((exports) => {
  var applyReviver = require_applyReviver();
  var identity = require_identity();
  var toJS = require_toJS();

  class NodeBase {
    constructor(type) {
      Object.defineProperty(this, identity.NODE_TYPE, { value: type });
    }
    clone() {
      const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      if (!identity.isDocument(doc))
        throw new TypeError("A document argument is required");
      const ctx = {
        anchors: new Map,
        doc,
        keep: true,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = toJS.toJS(this, "", ctx);
      if (typeof onAnchor === "function")
        for (const { count: count3, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count3);
      return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
    }
  }
  exports.NodeBase = NodeBase;
});

// node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS((exports) => {
  var anchors = require_anchors();
  var visit = require_visit();
  var identity = require_identity();
  var Node = require_Node();
  var toJS = require_toJS();

  class Alias extends Node.NodeBase {
    constructor(source) {
      super(identity.ALIAS);
      this.source = source;
      Object.defineProperty(this, "tag", {
        set() {
          throw new Error("Alias nodes cannot have tags");
        }
      });
    }
    resolve(doc) {
      let found = undefined;
      visit.visit(doc, {
        Node: (_key, node) => {
          if (node === this)
            return visit.visit.BREAK;
          if (node.anchor === this.source)
            found = node;
        }
      });
      return found;
    }
    toJSON(_arg, ctx) {
      if (!ctx)
        return { source: this.source };
      const { anchors: anchors2, doc, maxAliasCount } = ctx;
      const source = this.resolve(doc);
      if (!source) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new ReferenceError(msg);
      }
      let data = anchors2.get(source);
      if (!data) {
        toJS.toJS(source, null, ctx);
        data = anchors2.get(source);
      }
      if (!data || data.res === undefined) {
        const msg = "This should not happen: Alias anchor was not resolved?";
        throw new ReferenceError(msg);
      }
      if (maxAliasCount >= 0) {
        data.count += 1;
        if (data.aliasCount === 0)
          data.aliasCount = getAliasCount(doc, source, anchors2);
        if (data.count * data.aliasCount > maxAliasCount) {
          const msg = "Excessive alias count indicates a resource exhaustion attack";
          throw new ReferenceError(msg);
        }
      }
      return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
      const src = `*${this.source}`;
      if (ctx) {
        anchors.anchorIsValid(this.source);
        if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new Error(msg);
        }
        if (ctx.implicitKey)
          return `${src} `;
      }
      return src;
    }
  }
  function getAliasCount(doc, node, anchors2) {
    if (identity.isAlias(node)) {
      const source = node.resolve(doc);
      const anchor = anchors2 && source && anchors2.get(source);
      return anchor ? anchor.count * anchor.aliasCount : 0;
    } else if (identity.isCollection(node)) {
      let count3 = 0;
      for (const item of node.items) {
        const c = getAliasCount(doc, item, anchors2);
        if (c > count3)
          count3 = c;
      }
      return count3;
    } else if (identity.isPair(node)) {
      const kc = getAliasCount(doc, node.key, anchors2);
      const vc = getAliasCount(doc, node.value, anchors2);
      return Math.max(kc, vc);
    }
    return 1;
  }
  exports.Alias = Alias;
});

// node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS((exports) => {
  var identity = require_identity();
  var Node = require_Node();
  var toJS = require_toJS();
  var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";

  class Scalar extends Node.NodeBase {
    constructor(value) {
      super(identity.SCALAR);
      this.value = value;
    }
    toJSON(arg, ctx) {
      return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
    }
    toString() {
      return String(this.value);
    }
  }
  Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
  Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
  Scalar.PLAIN = "PLAIN";
  Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
  Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
  exports.Scalar = Scalar;
  exports.isScalarValue = isScalarValue;
});

// node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS((exports) => {
  var Alias = require_Alias();
  var identity = require_identity();
  var Scalar = require_Scalar();
  var defaultTagPrefix = "tag:yaml.org,2002:";
  function findTagObject(value, tagName, tags) {
    if (tagName) {
      const match = tags.filter((t) => t.tag === tagName);
      const tagObj = match.find((t) => !t.format) ?? match[0];
      if (!tagObj)
        throw new Error(`Tag ${tagName} not found`);
      return tagObj;
    }
    return tags.find((t) => t.identify?.(value) && !t.format);
  }
  function createNode(value, tagName, ctx) {
    if (identity.isDocument(value))
      value = value.contents;
    if (identity.isNode(value))
      return value;
    if (identity.isPair(value)) {
      const map3 = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
      map3.items.push(value);
      return map3;
    }
    if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
      value = value.valueOf();
    }
    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
    let ref = undefined;
    if (aliasDuplicateObjects && value && typeof value === "object") {
      ref = sourceObjects.get(value);
      if (ref) {
        if (!ref.anchor)
          ref.anchor = onAnchor(value);
        return new Alias.Alias(ref.anchor);
      } else {
        ref = { anchor: null, node: null };
        sourceObjects.set(value, ref);
      }
    }
    if (tagName?.startsWith("!!"))
      tagName = defaultTagPrefix + tagName.slice(2);
    let tagObj = findTagObject(value, tagName, schema.tags);
    if (!tagObj) {
      if (value && typeof value.toJSON === "function") {
        value = value.toJSON();
      }
      if (!value || typeof value !== "object") {
        const node2 = new Scalar.Scalar(value);
        if (ref)
          ref.node = node2;
        return node2;
      }
      tagObj = value instanceof Map ? schema[identity.MAP] : (Symbol.iterator in Object(value)) ? schema[identity.SEQ] : schema[identity.MAP];
    }
    if (onTagObj) {
      onTagObj(tagObj);
      delete ctx.onTagObj;
    }
    const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar.Scalar(value);
    if (tagName)
      node.tag = tagName;
    else if (!tagObj.default)
      node.tag = tagObj.tag;
    if (ref)
      ref.node = node;
    return node;
  }
  exports.createNode = createNode;
});

// node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS((exports) => {
  var createNode = require_createNode();
  var identity = require_identity();
  var Node = require_Node();
  function collectionFromPath(schema, path6, value) {
    let v = value;
    for (let i = path6.length - 1;i >= 0; --i) {
      const k = path6[i];
      if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
        const a = [];
        a[k] = v;
        v = a;
      } else {
        v = new Map([[k, v]]);
      }
    }
    return createNode.createNode(v, undefined, {
      aliasDuplicateObjects: false,
      keepUndefined: false,
      onAnchor: () => {
        throw new Error("This should not happen, please report a bug.");
      },
      schema,
      sourceObjects: new Map
    });
  }
  var isEmptyPath = (path6) => path6 == null || typeof path6 === "object" && !!path6[Symbol.iterator]().next().done;

  class Collection extends Node.NodeBase {
    constructor(type, schema) {
      super(type);
      Object.defineProperty(this, "schema", {
        value: schema,
        configurable: true,
        enumerable: false,
        writable: true
      });
    }
    clone(schema) {
      const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (schema)
        copy.schema = schema;
      copy.items = copy.items.map((it) => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    addIn(path6, value) {
      if (isEmptyPath(path6))
        this.add(value);
      else {
        const [key, ...rest] = path6;
        const node = this.get(key, true);
        if (identity.isCollection(node))
          node.addIn(rest, value);
        else if (node === undefined && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
    deleteIn(path6) {
      const [key, ...rest] = path6;
      if (rest.length === 0)
        return this.delete(key);
      const node = this.get(key, true);
      if (identity.isCollection(node))
        return node.deleteIn(rest);
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    getIn(path6, keepScalar) {
      const [key, ...rest] = path6;
      const node = this.get(key, true);
      if (rest.length === 0)
        return !keepScalar && identity.isScalar(node) ? node.value : node;
      else
        return identity.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
    }
    hasAllNullValues(allowScalar) {
      return this.items.every((node) => {
        if (!identity.isPair(node))
          return false;
        const n = node.value;
        return n == null || allowScalar && identity.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
      });
    }
    hasIn(path6) {
      const [key, ...rest] = path6;
      if (rest.length === 0)
        return this.has(key);
      const node = this.get(key, true);
      return identity.isCollection(node) ? node.hasIn(rest) : false;
    }
    setIn(path6, value) {
      const [key, ...rest] = path6;
      if (rest.length === 0) {
        this.set(key, value);
      } else {
        const node = this.get(key, true);
        if (identity.isCollection(node))
          node.setIn(rest, value);
        else if (node === undefined && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
  }
  exports.Collection = Collection;
  exports.collectionFromPath = collectionFromPath;
  exports.isEmptyPath = isEmptyPath;
});

// node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS((exports) => {
  var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
  function indentComment(comment, indent) {
    if (/^\n+$/.test(comment))
      return comment.substring(1);
    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
  }
  var lineComment = (str, indent, comment) => str.endsWith(`
`) ? indentComment(comment, indent) : comment.includes(`
`) ? `
` + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
  exports.indentComment = indentComment;
  exports.lineComment = lineComment;
  exports.stringifyComment = stringifyComment;
});

// node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS((exports) => {
  var FOLD_FLOW = "flow";
  var FOLD_BLOCK = "block";
  var FOLD_QUOTED = "quoted";
  function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0)
      return text;
    if (lineWidth < minContentWidth)
      minContentWidth = 0;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep)
      return text;
    const folds = [];
    const escapedFolds = {};
    let end = lineWidth - indent.length;
    if (typeof indentAtStart === "number") {
      if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
        folds.push(0);
      else
        end = lineWidth - indentAtStart;
    }
    let split = undefined;
    let prev = undefined;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === FOLD_BLOCK) {
      i = consumeMoreIndentedLines(text, i, indent.length);
      if (i !== -1)
        end = i + endStep;
    }
    for (let ch;ch = text[i += 1]; ) {
      if (mode === FOLD_QUOTED && ch === "\\") {
        escStart = i;
        switch (text[i + 1]) {
          case "x":
            i += 3;
            break;
          case "u":
            i += 5;
            break;
          case "U":
            i += 9;
            break;
          default:
            i += 1;
        }
        escEnd = i;
      }
      if (ch === `
`) {
        if (mode === FOLD_BLOCK)
          i = consumeMoreIndentedLines(text, i, indent.length);
        end = i + indent.length + endStep;
        split = undefined;
      } else {
        if (ch === " " && prev && prev !== " " && prev !== `
` && prev !== "\t") {
          const next = text[i + 1];
          if (next && next !== " " && next !== `
` && next !== "\t")
            split = i;
        }
        if (i >= end) {
          if (split) {
            folds.push(split);
            end = split + endStep;
            split = undefined;
          } else if (mode === FOLD_QUOTED) {
            while (prev === " " || prev === "\t") {
              prev = ch;
              ch = text[i += 1];
              overflow = true;
            }
            const j = i > escEnd + 1 ? i - 2 : escStart - 1;
            if (escapedFolds[j])
              return text;
            folds.push(j);
            escapedFolds[j] = true;
            end = j + endStep;
            split = undefined;
          } else {
            overflow = true;
          }
        }
      }
      prev = ch;
    }
    if (overflow && onOverflow)
      onOverflow();
    if (folds.length === 0)
      return text;
    if (onFold)
      onFold();
    let res = text.slice(0, folds[0]);
    for (let i2 = 0;i2 < folds.length; ++i2) {
      const fold = folds[i2];
      const end2 = folds[i2 + 1] || text.length;
      if (fold === 0)
        res = `
${indent}${text.slice(0, end2)}`;
      else {
        if (mode === FOLD_QUOTED && escapedFolds[fold])
          res += `${text[fold]}\\`;
        res += `
${indent}${text.slice(fold + 1, end2)}`;
      }
    }
    return res;
  }
  function consumeMoreIndentedLines(text, i, indent) {
    let end = i;
    let start = i + 1;
    let ch = text[start];
    while (ch === " " || ch === "\t") {
      if (i < start + indent) {
        ch = text[++i];
      } else {
        do {
          ch = text[++i];
        } while (ch && ch !== `
`);
        end = i;
        start = i + 1;
        ch = text[start];
      }
    }
    return end;
  }
  exports.FOLD_BLOCK = FOLD_BLOCK;
  exports.FOLD_FLOW = FOLD_FLOW;
  exports.FOLD_QUOTED = FOLD_QUOTED;
  exports.foldFlowLines = foldFlowLines;
});

// node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var foldFlowLines = require_foldFlowLines();
  var getFoldOptions = (ctx, isBlock) => ({
    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
  });
  var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
  function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
      return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
      return false;
    for (let i = 0, start = 0;i < strLen; ++i) {
      if (str[i] === `
`) {
        if (i - start > limit)
          return true;
        start = i + 1;
        if (strLen - start <= limit)
          return false;
      }
    }
    return true;
  }
  function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
      return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    let str = "";
    let start = 0;
    for (let i = 0, ch = json[i];ch; ch = json[++i]) {
      if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
        str += json.slice(start, i) + "\\ ";
        i += 1;
        start = i;
        ch = "\\";
      }
      if (ch === "\\")
        switch (json[i + 1]) {
          case "u":
            {
              str += json.slice(start, i);
              const code = json.substr(i + 2, 4);
              switch (code) {
                case "0000":
                  str += "\\0";
                  break;
                case "0007":
                  str += "\\a";
                  break;
                case "000b":
                  str += "\\v";
                  break;
                case "001b":
                  str += "\\e";
                  break;
                case "0085":
                  str += "\\N";
                  break;
                case "00a0":
                  str += "\\_";
                  break;
                case "2028":
                  str += "\\L";
                  break;
                case "2029":
                  str += "\\P";
                  break;
                default:
                  if (code.substr(0, 2) === "00")
                    str += "\\x" + code.substr(2);
                  else
                    str += json.substr(i, 6);
              }
              i += 5;
              start = i + 1;
            }
            break;
          case "n":
            if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
              i += 1;
            } else {
              str += json.slice(start, i) + `

`;
              while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
                str += `
`;
                i += 2;
              }
              str += indent;
              if (json[i + 2] === " ")
                str += "\\";
              i += 1;
              start = i + 1;
            }
            break;
          default:
            i += 1;
        }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
  }
  function singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes(`
`) || /[ \t]\n|\n[ \t]/.test(value))
      return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
    return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
  }
  function quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
      qs = doubleQuotedString;
    else {
      const hasDouble = value.includes('"');
      const hasSingle = value.includes("'");
      if (hasDouble && !hasSingle)
        qs = singleQuotedString;
      else if (hasSingle && !hasDouble)
        qs = doubleQuotedString;
      else
        qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
  }
  var blockEndNewlines;
  try {
    blockEndNewlines = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
  } catch {
    blockEndNewlines = /\n+(?!\n|$)/g;
  }
  function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
      return quotedString(value, ctx);
    }
    const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
    const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value)
      return literal ? `|
` : `>
`;
    let chomp;
    let endStart;
    for (endStart = value.length;endStart > 0; --endStart) {
      const ch = value[endStart - 1];
      if (ch !== `
` && ch !== "\t" && ch !== " ")
        break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf(`
`);
    if (endNlPos === -1) {
      chomp = "-";
    } else if (value === end || endNlPos !== end.length - 1) {
      chomp = "+";
      if (onChompKeep)
        onChompKeep();
    } else {
      chomp = "";
    }
    if (end) {
      value = value.slice(0, -end.length);
      if (end[end.length - 1] === `
`)
        end = end.slice(0, -1);
      end = end.replace(blockEndNewlines, `$&${indent}`);
    }
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0;startEnd < value.length; ++startEnd) {
      const ch = value[startEnd];
      if (ch === " ")
        startWithSpace = true;
      else if (ch === `
`)
        startNlPos = startEnd;
      else
        break;
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start) {
      value = value.substring(start.length);
      start = start.replace(/\n+/g, `$&${indent}`);
    }
    const indentSize = indent ? "2" : "1";
    let header = (startWithSpace ? indentSize : "") + chomp;
    if (comment) {
      header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
      if (onComment)
        onComment();
    }
    if (!literal) {
      const foldedValue = value.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
      let literalFallback = false;
      const foldOptions = getFoldOptions(ctx, true);
      if (blockQuote !== "folded" && type !== Scalar.Scalar.BLOCK_FOLDED) {
        foldOptions.onOverflow = () => {
          literalFallback = true;
        };
      }
      const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end}`, indent, foldFlowLines.FOLD_BLOCK, foldOptions);
      if (!literalFallback)
        return `>${header}
${indent}${body}`;
    }
    value = value.replace(/\n+/g, `$&${indent}`);
    return `|${header}
${indent}${start}${value}${end}`;
  }
  function plainString(item, ctx, onComment, onChompKeep) {
    const { type, value } = item;
    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
    if (implicitKey && value.includes(`
`) || inFlow && /[[\]{},]/.test(value)) {
      return quotedString(value, ctx);
    }
    if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
      return implicitKey || inFlow || !value.includes(`
`) ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
    }
    if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes(`
`)) {
      return blockString(item, ctx, onComment, onChompKeep);
    }
    if (containsDocumentMarker(value)) {
      if (indent === "") {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
      } else if (implicitKey && indent === indentStep) {
        return quotedString(value, ctx);
      }
    }
    const str = value.replace(/\n+/g, `$&
${indent}`);
    if (actualString) {
      const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
      const { compat, tags } = ctx.doc.schema;
      if (tags.some(test) || compat?.some(test))
        return quotedString(value, ctx);
    }
    return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
  }
  function stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey, inFlow } = ctx;
    const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
    let { type } = item;
    if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
      if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
        type = Scalar.Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type) => {
      switch (_type) {
        case Scalar.Scalar.BLOCK_FOLDED:
        case Scalar.Scalar.BLOCK_LITERAL:
          return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
        case Scalar.Scalar.QUOTE_DOUBLE:
          return doubleQuotedString(ss.value, ctx);
        case Scalar.Scalar.QUOTE_SINGLE:
          return singleQuotedString(ss.value, ctx);
        case Scalar.Scalar.PLAIN:
          return plainString(ss, ctx, onComment, onChompKeep);
        default:
          return null;
      }
    };
    let res = _stringify(type);
    if (res === null) {
      const { defaultKeyType, defaultStringType } = ctx.options;
      const t = implicitKey && defaultKeyType || defaultStringType;
      res = _stringify(t);
      if (res === null)
        throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
  }
  exports.stringifyString = stringifyString;
});

// node_modules/yaml/dist/stringify/stringify.js
var require_stringify3 = __commonJS((exports) => {
  var anchors = require_anchors();
  var identity = require_identity();
  var stringifyComment = require_stringifyComment();
  var stringifyString = require_stringifyString();
  function createStringifyContext(doc, options) {
    const opt = Object.assign({
      blockQuote: true,
      commentString: stringifyComment.stringifyComment,
      defaultKeyType: null,
      defaultStringType: "PLAIN",
      directives: null,
      doubleQuotedAsJSON: false,
      doubleQuotedMinMultiLineLength: 40,
      falseStr: "false",
      flowCollectionPadding: true,
      indentSeq: true,
      lineWidth: 80,
      minContentWidth: 20,
      nullStr: "null",
      simpleKeys: false,
      singleQuote: null,
      trueStr: "true",
      verifyAliasOrder: true
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch (opt.collectionStyle) {
      case "block":
        inFlow = false;
        break;
      case "flow":
        inFlow = true;
        break;
      default:
        inFlow = null;
    }
    return {
      anchors: new Set,
      doc,
      flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
      indent: "",
      indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
      inFlow,
      options: opt
    };
  }
  function getTagObject(tags, item) {
    if (item.tag) {
      const match = tags.filter((t) => t.tag === item.tag);
      if (match.length > 0)
        return match.find((t) => t.format === item.format) ?? match[0];
    }
    let tagObj = undefined;
    let obj;
    if (identity.isScalar(item)) {
      obj = item.value;
      let match = tags.filter((t) => t.identify?.(obj));
      if (match.length > 1) {
        const testMatch = match.filter((t) => t.test);
        if (testMatch.length > 0)
          match = testMatch;
      }
      tagObj = match.find((t) => t.format === item.format) ?? match.find((t) => !t.format);
    } else {
      obj = item;
      tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
      const name = obj?.constructor?.name ?? typeof obj;
      throw new Error(`Tag not resolved for ${name} value`);
    }
    return tagObj;
  }
  function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
    if (!doc.directives)
      return "";
    const props = [];
    const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
    if (anchor && anchors.anchorIsValid(anchor)) {
      anchors$1.add(anchor);
      props.push(`&${anchor}`);
    }
    const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
    if (tag)
      props.push(doc.directives.tagString(tag));
    return props.join(" ");
  }
  function stringify2(item, ctx, onComment, onChompKeep) {
    if (identity.isPair(item))
      return item.toString(ctx, onComment, onChompKeep);
    if (identity.isAlias(item)) {
      if (ctx.doc.directives)
        return item.toString(ctx);
      if (ctx.resolvedAliases?.has(item)) {
        throw new TypeError(`Cannot stringify circular structure without alias nodes`);
      } else {
        if (ctx.resolvedAliases)
          ctx.resolvedAliases.add(item);
        else
          ctx.resolvedAliases = new Set([item]);
        item = item.resolve(ctx.doc);
      }
    }
    let tagObj = undefined;
    const node = identity.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
    if (!tagObj)
      tagObj = getTagObject(ctx.doc.schema.tags, node);
    const props = stringifyProps(node, tagObj, ctx);
    if (props.length > 0)
      ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
    if (!props)
      return str;
    return identity.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
  }
  exports.createStringifyContext = createStringifyContext;
  exports.stringify = stringify2;
});

// node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var stringify2 = require_stringify3();
  var stringifyComment = require_stringifyComment();
  function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
    let keyComment = identity.isNode(key) && key.comment || null;
    if (simpleKeys) {
      if (keyComment) {
        throw new Error("With simple keys, key nodes cannot have comments");
      }
      if (identity.isCollection(key) || !identity.isNode(key) && typeof key === "object") {
        const msg = "With simple keys, collection cannot be used as a key value";
        throw new Error(msg);
      }
    }
    let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
    ctx = Object.assign({}, ctx, {
      allNullValues: false,
      implicitKey: !explicitKey && (simpleKeys || !allNullValues),
      indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = stringify2.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
      if (simpleKeys)
        throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
      explicitKey = true;
    }
    if (ctx.inFlow) {
      if (allNullValues || value == null) {
        if (keyCommentDone && onComment)
          onComment();
        return str === "" ? "?" : explicitKey ? `? ${str}` : str;
      }
    } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
      str = `? ${str}`;
      if (keyComment && !keyCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str;
    }
    if (keyCommentDone)
      keyComment = null;
    if (explicitKey) {
      if (keyComment)
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      str = `? ${str}
${indent}:`;
    } else {
      str = `${str}:`;
      if (keyComment)
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vsb, vcb, valueComment;
    if (identity.isNode(value)) {
      vsb = !!value.spaceBefore;
      vcb = value.commentBefore;
      valueComment = value.comment;
    } else {
      vsb = false;
      vcb = null;
      valueComment = null;
      if (value && typeof value === "object")
        value = doc.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && identity.isScalar(value))
      ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity.isSeq(value) && !value.flow && !value.tag && !value.anchor) {
      ctx.indent = ctx.indent.substring(2);
    }
    let valueCommentDone = false;
    const valueStr = stringify2.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
    let ws = " ";
    if (keyComment || vsb || vcb) {
      ws = vsb ? `
` : "";
      if (vcb) {
        const cs = commentString(vcb);
        ws += `
${stringifyComment.indentComment(cs, ctx.indent)}`;
      }
      if (valueStr === "" && !ctx.inFlow) {
        if (ws === `
`)
          ws = `

`;
      } else {
        ws += `
${ctx.indent}`;
      }
    } else if (!explicitKey && identity.isCollection(value)) {
      const vs0 = valueStr[0];
      const nl0 = valueStr.indexOf(`
`);
      const hasNewline = nl0 !== -1;
      const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
      if (hasNewline || !flow) {
        let hasPropsLine = false;
        if (hasNewline && (vs0 === "&" || vs0 === "!")) {
          let sp0 = valueStr.indexOf(" ");
          if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
            sp0 = valueStr.indexOf(" ", sp0 + 1);
          }
          if (sp0 === -1 || nl0 < sp0)
            hasPropsLine = true;
        }
        if (!hasPropsLine)
          ws = `
${ctx.indent}`;
      }
    } else if (valueStr === "" || valueStr[0] === `
`) {
      ws = "";
    }
    str += ws + valueStr;
    if (ctx.inFlow) {
      if (valueCommentDone && onComment)
        onComment();
    } else if (valueComment && !valueCommentDone) {
      str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
    } else if (chompKeep && onChompKeep) {
      onChompKeep();
    }
    return str;
  }
  exports.stringifyPair = stringifyPair;
});

// node_modules/yaml/dist/log.js
var require_log = __commonJS((exports) => {
  var node_process = __require("node:process");
  function debug2(logLevel, ...messages2) {
    if (logLevel === "debug")
      console.log(...messages2);
  }
  function warn(logLevel, warning) {
    if (logLevel === "debug" || logLevel === "warn") {
      if (typeof node_process.emitWarning === "function")
        node_process.emitWarning(warning);
      else
        console.warn(warning);
    }
  }
  exports.debug = debug2;
  exports.warn = warn;
});

// node_modules/yaml/dist/schema/yaml-1.1/merge.js
var require_merge = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var MERGE_KEY = "<<";
  var merge3 = {
    identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
    default: "key",
    tag: "tag:yaml.org,2002:merge",
    test: /^<<$/,
    resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {
      addToJSMap: addMergeToJSMap
    }),
    stringify: () => MERGE_KEY
  };
  var isMergeKey = (ctx, key) => (merge3.identify(key) || identity.isScalar(key) && (!key.type || key.type === Scalar.Scalar.PLAIN) && merge3.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge3.tag && tag.default);
  function addMergeToJSMap(ctx, map3, value) {
    value = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (identity.isSeq(value))
      for (const it of value.items)
        mergeValue(ctx, map3, it);
    else if (Array.isArray(value))
      for (const it of value)
        mergeValue(ctx, map3, it);
    else
      mergeValue(ctx, map3, value);
  }
  function mergeValue(ctx, map3, value) {
    const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!identity.isMap(source))
      throw new Error("Merge sources must be maps or map aliases");
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value2] of srcMap) {
      if (map3 instanceof Map) {
        if (!map3.has(key))
          map3.set(key, value2);
      } else if (map3 instanceof Set) {
        map3.add(key);
      } else if (!Object.prototype.hasOwnProperty.call(map3, key)) {
        Object.defineProperty(map3, key, {
          value: value2,
          writable: true,
          enumerable: true,
          configurable: true
        });
      }
    }
    return map3;
  }
  exports.addMergeToJSMap = addMergeToJSMap;
  exports.isMergeKey = isMergeKey;
  exports.merge = merge3;
});

// node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS((exports) => {
  var log2 = require_log();
  var merge3 = require_merge();
  var stringify2 = require_stringify3();
  var identity = require_identity();
  var toJS = require_toJS();
  function addPairToJSMap(ctx, map3, { key, value }) {
    if (identity.isNode(key) && key.addToJSMap)
      key.addToJSMap(ctx, map3, value);
    else if (merge3.isMergeKey(ctx, key))
      merge3.addMergeToJSMap(ctx, map3, value);
    else {
      const jsKey = toJS.toJS(key, "", ctx);
      if (map3 instanceof Map) {
        map3.set(jsKey, toJS.toJS(value, jsKey, ctx));
      } else if (map3 instanceof Set) {
        map3.add(jsKey);
      } else {
        const stringKey = stringifyKey(key, jsKey, ctx);
        const jsValue = toJS.toJS(value, stringKey, ctx);
        if (stringKey in map3)
          Object.defineProperty(map3, stringKey, {
            value: jsValue,
            writable: true,
            enumerable: true,
            configurable: true
          });
        else
          map3[stringKey] = jsValue;
      }
    }
    return map3;
  }
  function stringifyKey(key, jsKey, ctx) {
    if (jsKey === null)
      return "";
    if (typeof jsKey !== "object")
      return String(jsKey);
    if (identity.isNode(key) && ctx?.doc) {
      const strCtx = stringify2.createStringifyContext(ctx.doc, {});
      strCtx.anchors = new Set;
      for (const node of ctx.anchors.keys())
        strCtx.anchors.add(node.anchor);
      strCtx.inFlow = true;
      strCtx.inStringifyKey = true;
      const strKey = key.toString(strCtx);
      if (!ctx.mapKeyWarned) {
        let jsonStr = JSON.stringify(strKey);
        if (jsonStr.length > 40)
          jsonStr = jsonStr.substring(0, 36) + '..."';
        log2.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
        ctx.mapKeyWarned = true;
      }
      return strKey;
    }
    return JSON.stringify(jsKey);
  }
  exports.addPairToJSMap = addPairToJSMap;
});

// node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS((exports) => {
  var createNode = require_createNode();
  var stringifyPair = require_stringifyPair();
  var addPairToJSMap = require_addPairToJSMap();
  var identity = require_identity();
  function createPair(key, value, ctx) {
    const k = createNode.createNode(key, undefined, ctx);
    const v = createNode.createNode(value, undefined, ctx);
    return new Pair(k, v);
  }

  class Pair {
    constructor(key, value = null) {
      Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });
      this.key = key;
      this.value = value;
    }
    clone(schema) {
      let { key, value } = this;
      if (identity.isNode(key))
        key = key.clone(schema);
      if (identity.isNode(value))
        value = value.clone(schema);
      return new Pair(key, value);
    }
    toJSON(_, ctx) {
      const pair = ctx?.mapAsMap ? new Map : {};
      return addPairToJSMap.addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
      return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
    }
  }
  exports.Pair = Pair;
  exports.createPair = createPair;
});

// node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS((exports) => {
  var identity = require_identity();
  var stringify2 = require_stringify3();
  var stringifyComment = require_stringifyComment();
  function stringifyCollection(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify3 = flow ? stringifyFlowCollection : stringifyBlockCollection;
    return stringify3(collection, ctx, options);
  }
  function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent, options: { commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
    let chompKeep = false;
    const lines = [];
    for (let i = 0;i < items.length; ++i) {
      const item = items[i];
      let comment2 = null;
      if (identity.isNode(item)) {
        if (!chompKeep && item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
        if (item.comment)
          comment2 = item.comment;
      } else if (identity.isPair(item)) {
        const ik = identity.isNode(item.key) ? item.key : null;
        if (ik) {
          if (!chompKeep && ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
        }
      }
      chompKeep = false;
      let str2 = stringify2.stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
      if (comment2)
        str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2));
      if (chompKeep && comment2)
        chompKeep = false;
      lines.push(blockItemPrefix + str2);
    }
    let str;
    if (lines.length === 0) {
      str = flowChars.start + flowChars.end;
    } else {
      str = lines[0];
      for (let i = 1;i < lines.length; ++i) {
        const line = lines[i];
        str += line ? `
${indent}${line}` : `
`;
      }
    }
    if (comment) {
      str += `
` + stringifyComment.indentComment(commentString(comment), indent);
      if (onComment)
        onComment();
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
      indent: itemIndent,
      inFlow: true,
      type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for (let i = 0;i < items.length; ++i) {
      const item = items[i];
      let comment = null;
      if (identity.isNode(item)) {
        if (item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, false);
        if (item.comment)
          comment = item.comment;
      } else if (identity.isPair(item)) {
        const ik = identity.isNode(item.key) ? item.key : null;
        if (ik) {
          if (ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, false);
          if (ik.comment)
            reqNewline = true;
        }
        const iv = identity.isNode(item.value) ? item.value : null;
        if (iv) {
          if (iv.comment)
            comment = iv.comment;
          if (iv.commentBefore)
            reqNewline = true;
        } else if (item.value == null && ik?.comment) {
          comment = ik.comment;
        }
      }
      if (comment)
        reqNewline = true;
      let str = stringify2.stringify(item, itemCtx, () => comment = null);
      if (i < items.length - 1)
        str += ",";
      if (comment)
        str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
      if (!reqNewline && (lines.length > linesAtValue || str.includes(`
`)))
        reqNewline = true;
      lines.push(str);
      linesAtValue = lines.length;
    }
    const { start, end } = flowChars;
    if (lines.length === 0) {
      return start + end;
    } else {
      if (!reqNewline) {
        const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
        reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
      }
      if (reqNewline) {
        let str = start;
        for (const line of lines)
          str += line ? `
${indentStep}${indent}${line}` : `
`;
        return `${str}
${indent}${end}`;
      } else {
        return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
      }
    }
  }
  function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
    if (comment && chompKeep)
      comment = comment.replace(/^\n+/, "");
    if (comment) {
      const ic = stringifyComment.indentComment(commentString(comment), indent);
      lines.push(ic.trimStart());
    }
  }
  exports.stringifyCollection = stringifyCollection;
});

// node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS((exports) => {
  var stringifyCollection = require_stringifyCollection();
  var addPairToJSMap = require_addPairToJSMap();
  var Collection = require_Collection();
  var identity = require_identity();
  var Pair = require_Pair();
  var Scalar = require_Scalar();
  function findPair(items, key) {
    const k = identity.isScalar(key) ? key.value : key;
    for (const it of items) {
      if (identity.isPair(it)) {
        if (it.key === key || it.key === k)
          return it;
        if (identity.isScalar(it.key) && it.key.value === k)
          return it;
      }
    }
    return;
  }

  class YAMLMap extends Collection.Collection {
    static get tagName() {
      return "tag:yaml.org,2002:map";
    }
    constructor(schema) {
      super(identity.MAP, schema);
      this.items = [];
    }
    static from(schema, obj, ctx) {
      const { keepUndefined, replacer } = ctx;
      const map3 = new this(schema);
      const add = (key, value) => {
        if (typeof replacer === "function")
          value = replacer.call(obj, key, value);
        else if (Array.isArray(replacer) && !replacer.includes(key))
          return;
        if (value !== undefined || keepUndefined)
          map3.items.push(Pair.createPair(key, value, ctx));
      };
      if (obj instanceof Map) {
        for (const [key, value] of obj)
          add(key, value);
      } else if (obj && typeof obj === "object") {
        for (const key of Object.keys(obj))
          add(key, obj[key]);
      }
      if (typeof schema.sortMapEntries === "function") {
        map3.items.sort(schema.sortMapEntries);
      }
      return map3;
    }
    add(pair, overwrite) {
      let _pair;
      if (identity.isPair(pair))
        _pair = pair;
      else if (!pair || typeof pair !== "object" || !("key" in pair)) {
        _pair = new Pair.Pair(pair, pair?.value);
      } else
        _pair = new Pair.Pair(pair.key, pair.value);
      const prev = findPair(this.items, _pair.key);
      const sortEntries = this.schema?.sortMapEntries;
      if (prev) {
        if (!overwrite)
          throw new Error(`Key ${_pair.key} already set`);
        if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
          prev.value.value = _pair.value;
        else
          prev.value = _pair.value;
      } else if (sortEntries) {
        const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
        if (i === -1)
          this.items.push(_pair);
        else
          this.items.splice(i, 0, _pair);
      } else {
        this.items.push(_pair);
      }
    }
    delete(key) {
      const it = findPair(this.items, key);
      if (!it)
        return false;
      const del = this.items.splice(this.items.indexOf(it), 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const it = findPair(this.items, key);
      const node = it?.value;
      return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? undefined;
    }
    has(key) {
      return !!findPair(this.items, key);
    }
    set(key, value) {
      this.add(new Pair.Pair(key, value), true);
    }
    toJSON(_, ctx, Type) {
      const map3 = Type ? new Type : ctx?.mapAsMap ? new Map : {};
      if (ctx?.onCreate)
        ctx.onCreate(map3);
      for (const item of this.items)
        addPairToJSMap.addPairToJSMap(ctx, map3, item);
      return map3;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      for (const item of this.items) {
        if (!identity.isPair(item))
          throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
      }
      if (!ctx.allNullValues && this.hasAllNullValues(false))
        ctx = Object.assign({}, ctx, { allNullValues: true });
      return stringifyCollection.stringifyCollection(this, ctx, {
        blockItemPrefix: "",
        flowChars: { start: "{", end: "}" },
        itemIndent: ctx.indent || "",
        onChompKeep,
        onComment
      });
    }
  }
  exports.YAMLMap = YAMLMap;
  exports.findPair = findPair;
});

// node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS((exports) => {
  var identity = require_identity();
  var YAMLMap = require_YAMLMap();
  var map3 = {
    collection: "map",
    default: true,
    nodeClass: YAMLMap.YAMLMap,
    tag: "tag:yaml.org,2002:map",
    resolve(map4, onError) {
      if (!identity.isMap(map4))
        onError("Expected a mapping for this tag");
      return map4;
    },
    createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
  };
  exports.map = map3;
});

// node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS((exports) => {
  var createNode = require_createNode();
  var stringifyCollection = require_stringifyCollection();
  var Collection = require_Collection();
  var identity = require_identity();
  var Scalar = require_Scalar();
  var toJS = require_toJS();

  class YAMLSeq extends Collection.Collection {
    static get tagName() {
      return "tag:yaml.org,2002:seq";
    }
    constructor(schema) {
      super(identity.SEQ, schema);
      this.items = [];
    }
    add(value) {
      this.items.push(value);
    }
    delete(key) {
      const idx2 = asItemIndex(key);
      if (typeof idx2 !== "number")
        return false;
      const del = this.items.splice(idx2, 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const idx2 = asItemIndex(key);
      if (typeof idx2 !== "number")
        return;
      const it = this.items[idx2];
      return !keepScalar && identity.isScalar(it) ? it.value : it;
    }
    has(key) {
      const idx2 = asItemIndex(key);
      return typeof idx2 === "number" && idx2 < this.items.length;
    }
    set(key, value) {
      const idx2 = asItemIndex(key);
      if (typeof idx2 !== "number")
        throw new Error(`Expected a valid index, not ${key}.`);
      const prev = this.items[idx2];
      if (identity.isScalar(prev) && Scalar.isScalarValue(value))
        prev.value = value;
      else
        this.items[idx2] = value;
    }
    toJSON(_, ctx) {
      const seq = [];
      if (ctx?.onCreate)
        ctx.onCreate(seq);
      let i = 0;
      for (const item of this.items)
        seq.push(toJS.toJS(item, String(i++), ctx));
      return seq;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      return stringifyCollection.stringifyCollection(this, ctx, {
        blockItemPrefix: "- ",
        flowChars: { start: "[", end: "]" },
        itemIndent: (ctx.indent || "") + "  ",
        onChompKeep,
        onComment
      });
    }
    static from(schema, obj, ctx) {
      const { replacer } = ctx;
      const seq = new this(schema);
      if (obj && Symbol.iterator in Object(obj)) {
        let i = 0;
        for (let it of obj) {
          if (typeof replacer === "function") {
            const key = obj instanceof Set ? it : String(i++);
            it = replacer.call(obj, key, it);
          }
          seq.items.push(createNode.createNode(it, undefined, ctx));
        }
      }
      return seq;
    }
  }
  function asItemIndex(key) {
    let idx2 = identity.isScalar(key) ? key.value : key;
    if (idx2 && typeof idx2 === "string")
      idx2 = Number(idx2);
    return typeof idx2 === "number" && Number.isInteger(idx2) && idx2 >= 0 ? idx2 : null;
  }
  exports.YAMLSeq = YAMLSeq;
});

// node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS((exports) => {
  var identity = require_identity();
  var YAMLSeq = require_YAMLSeq();
  var seq = {
    collection: "seq",
    default: true,
    nodeClass: YAMLSeq.YAMLSeq,
    tag: "tag:yaml.org,2002:seq",
    resolve(seq2, onError) {
      if (!identity.isSeq(seq2))
        onError("Expected a sequence for this tag");
      return seq2;
    },
    createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
  };
  exports.seq = seq;
});

// node_modules/yaml/dist/schema/common/string.js
var require_string = __commonJS((exports) => {
  var stringifyString = require_stringifyString();
  var string = {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify(item, ctx, onComment, onChompKeep) {
      ctx = Object.assign({ actualString: true }, ctx);
      return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
    }
  };
  exports.string = string;
});

// node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var nullTag = {
    identify: (value) => value == null,
    createNode: () => new Scalar.Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new Scalar.Scalar(null),
    stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
  };
  exports.nullTag = nullTag;
});

// node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var boolTag = {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
    stringify({ source, value }, ctx) {
      if (source && boolTag.test.test(source)) {
        const sv = source[0] === "t" || source[0] === "T";
        if (value === sv)
          return source;
      }
      return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
  };
  exports.boolTag = boolTag;
});

// node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS((exports) => {
  function stringifyNumber({ format: format3, minFractionDigits, tag, value }) {
    if (typeof value === "bigint")
      return String(value);
    const num = typeof value === "number" ? value : Number(value);
    if (!isFinite(num))
      return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
    let n = JSON.stringify(value);
    if (!format3 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
      let i = n.indexOf(".");
      if (i < 0) {
        i = n.length;
        n += ".";
      }
      let d = minFractionDigits - (n.length - i - 1);
      while (d-- > 0)
        n += "0";
    }
    return n;
  }
  exports.stringifyNumber = stringifyNumber;
});

// node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var stringifyNumber = require_stringifyNumber();
  var floatNaN = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
  };
  var floatExp = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str),
    stringify(node) {
      const num = Number(node.value);
      return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
  };
  var float = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
      const node = new Scalar.Scalar(parseFloat(str));
      const dot = str.indexOf(".");
      if (dot !== -1 && str[str.length - 1] === "0")
        node.minFractionDigits = str.length - dot - 1;
      return node;
    },
    stringify: stringifyNumber.stringifyNumber
  };
  exports.float = float;
  exports.floatExp = floatExp;
  exports.floatNaN = floatNaN;
});

// node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
  var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
  function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value) && value >= 0)
      return prefix + value.toString(radix);
    return stringifyNumber.stringifyNumber(node);
  }
  var intOct = {
    identify: (value) => intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
    stringify: (node) => intStringify(node, 8, "0o")
  };
  var int = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
  };
  var intHex = {
    identify: (value) => intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: (node) => intStringify(node, 16, "0x")
  };
  exports.int = int;
  exports.intHex = intHex;
  exports.intOct = intOct;
});

// node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS((exports) => {
  var map3 = require_map();
  var _null = require_null();
  var seq = require_seq();
  var string = require_string();
  var bool = require_bool();
  var float = require_float();
  var int = require_int();
  var schema = [
    map3.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.boolTag,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float
  ];
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var map3 = require_map();
  var seq = require_seq();
  function intIdentify(value) {
    return typeof value === "bigint" || Number.isInteger(value);
  }
  var stringifyJSON = ({ value }) => JSON.stringify(value);
  var jsonScalars = [
    {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify: stringifyJSON
    },
    {
      identify: (value) => value == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^null$/,
      resolve: () => null,
      stringify: stringifyJSON
    },
    {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^true$|^false$/,
      resolve: (str) => str === "true",
      stringify: stringifyJSON
    },
    {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^-?(?:0|[1-9][0-9]*)$/,
      resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
      stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
    },
    {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
      resolve: (str) => parseFloat(str),
      stringify: stringifyJSON
    }
  ];
  var jsonError = {
    default: true,
    tag: "",
    test: /^/,
    resolve(str, onError) {
      onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
      return str;
    }
  };
  var schema = [map3.map, seq.seq].concat(jsonScalars, jsonError);
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS((exports) => {
  var node_buffer = __require("node:buffer");
  var Scalar = require_Scalar();
  var stringifyString = require_stringifyString();
  var binary = {
    identify: (value) => value instanceof Uint8Array,
    default: false,
    tag: "tag:yaml.org,2002:binary",
    resolve(src, onError) {
      if (typeof node_buffer.Buffer === "function") {
        return node_buffer.Buffer.from(src, "base64");
      } else if (typeof atob === "function") {
        const str = atob(src.replace(/[\n\r]/g, ""));
        const buffer = new Uint8Array(str.length);
        for (let i = 0;i < str.length; ++i)
          buffer[i] = str.charCodeAt(i);
        return buffer;
      } else {
        onError("This environment does not support reading binary tags; either Buffer or atob is required");
        return src;
      }
    },
    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
      const buf = value;
      let str;
      if (typeof node_buffer.Buffer === "function") {
        str = buf instanceof node_buffer.Buffer ? buf.toString("base64") : node_buffer.Buffer.from(buf.buffer).toString("base64");
      } else if (typeof btoa === "function") {
        let s = "";
        for (let i = 0;i < buf.length; ++i)
          s += String.fromCharCode(buf[i]);
        str = btoa(s);
      } else {
        throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
      }
      if (!type)
        type = Scalar.Scalar.BLOCK_LITERAL;
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
        const n = Math.ceil(str.length / lineWidth);
        const lines = new Array(n);
        for (let i = 0, o = 0;i < n; ++i, o += lineWidth) {
          lines[i] = str.substr(o, lineWidth);
        }
        str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? `
` : " ");
      }
      return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
    }
  };
  exports.binary = binary;
});

// node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS((exports) => {
  var identity = require_identity();
  var Pair = require_Pair();
  var Scalar = require_Scalar();
  var YAMLSeq = require_YAMLSeq();
  function resolvePairs(seq, onError) {
    if (identity.isSeq(seq)) {
      for (let i = 0;i < seq.items.length; ++i) {
        let item = seq.items[i];
        if (identity.isPair(item))
          continue;
        else if (identity.isMap(item)) {
          if (item.items.length > 1)
            onError("Each pair must have its own sequence indicator");
          const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
          if (item.commentBefore)
            pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
          if (item.comment) {
            const cn = pair.value ?? pair.key;
            cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
          }
          item = pair;
        }
        seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
      }
    } else
      onError("Expected a sequence for this tag");
    return seq;
  }
  function createPairs(schema, iterable, ctx) {
    const { replacer } = ctx;
    const pairs2 = new YAMLSeq.YAMLSeq(schema);
    pairs2.tag = "tag:yaml.org,2002:pairs";
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable))
      for (let it of iterable) {
        if (typeof replacer === "function")
          it = replacer.call(iterable, String(i++), it);
        let key, value;
        if (Array.isArray(it)) {
          if (it.length === 2) {
            key = it[0];
            value = it[1];
          } else
            throw new TypeError(`Expected [key, value] tuple: ${it}`);
        } else if (it && it instanceof Object) {
          const keys3 = Object.keys(it);
          if (keys3.length === 1) {
            key = keys3[0];
            value = it[key];
          } else {
            throw new TypeError(`Expected tuple with one key, not ${keys3.length} keys`);
          }
        } else {
          key = it;
        }
        pairs2.items.push(Pair.createPair(key, value, ctx));
      }
    return pairs2;
  }
  var pairs = {
    collection: "seq",
    default: false,
    tag: "tag:yaml.org,2002:pairs",
    resolve: resolvePairs,
    createNode: createPairs
  };
  exports.createPairs = createPairs;
  exports.pairs = pairs;
  exports.resolvePairs = resolvePairs;
});

// node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS((exports) => {
  var identity = require_identity();
  var toJS = require_toJS();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var pairs = require_pairs();

  class YAMLOMap extends YAMLSeq.YAMLSeq {
    constructor() {
      super();
      this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
      this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
      this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
      this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
      this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
      this.tag = YAMLOMap.tag;
    }
    toJSON(_, ctx) {
      if (!ctx)
        return super.toJSON(_);
      const map3 = new Map;
      if (ctx?.onCreate)
        ctx.onCreate(map3);
      for (const pair of this.items) {
        let key, value;
        if (identity.isPair(pair)) {
          key = toJS.toJS(pair.key, "", ctx);
          value = toJS.toJS(pair.value, key, ctx);
        } else {
          key = toJS.toJS(pair, "", ctx);
        }
        if (map3.has(key))
          throw new Error("Ordered maps must not include duplicate keys");
        map3.set(key, value);
      }
      return map3;
    }
    static from(schema, iterable, ctx) {
      const pairs$1 = pairs.createPairs(schema, iterable, ctx);
      const omap2 = new this;
      omap2.items = pairs$1.items;
      return omap2;
    }
  }
  YAMLOMap.tag = "tag:yaml.org,2002:omap";
  var omap = {
    collection: "seq",
    identify: (value) => value instanceof Map,
    nodeClass: YAMLOMap,
    default: false,
    tag: "tag:yaml.org,2002:omap",
    resolve(seq, onError) {
      const pairs$1 = pairs.resolvePairs(seq, onError);
      const seenKeys = [];
      for (const { key } of pairs$1.items) {
        if (identity.isScalar(key)) {
          if (seenKeys.includes(key.value)) {
            onError(`Ordered maps must not include duplicate keys: ${key.value}`);
          } else {
            seenKeys.push(key.value);
          }
        }
      }
      return Object.assign(new YAMLOMap, pairs$1);
    },
    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
  };
  exports.YAMLOMap = YAMLOMap;
  exports.omap = omap;
});

// node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  function boolStringify({ value, source }, ctx) {
    const boolObj = value ? trueTag : falseTag;
    if (source && boolObj.test.test(source))
      return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
  var trueTag = {
    identify: (value) => value === true,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new Scalar.Scalar(true),
    stringify: boolStringify
  };
  var falseTag = {
    identify: (value) => value === false,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
    resolve: () => new Scalar.Scalar(false),
    stringify: boolStringify
  };
  exports.falseTag = falseTag;
  exports.trueTag = trueTag;
});

// node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var stringifyNumber = require_stringifyNumber();
  var floatNaN = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
  };
  var floatExp = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str.replace(/_/g, "")),
    stringify(node) {
      const num = Number(node.value);
      return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
  };
  var float = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
      const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, "")));
      const dot = str.indexOf(".");
      if (dot !== -1) {
        const f = str.substring(dot + 1).replace(/_/g, "");
        if (f[f.length - 1] === "0")
          node.minFractionDigits = f.length;
      }
      return node;
    },
    stringify: stringifyNumber.stringifyNumber
  };
  exports.float = float;
  exports.floatExp = floatExp;
  exports.floatNaN = floatNaN;
});

// node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
  function intResolve(str, offset, radix, { intAsBigInt }) {
    const sign = str[0];
    if (sign === "-" || sign === "+")
      offset += 1;
    str = str.substring(offset).replace(/_/g, "");
    if (intAsBigInt) {
      switch (radix) {
        case 2:
          str = `0b${str}`;
          break;
        case 8:
          str = `0o${str}`;
          break;
        case 16:
          str = `0x${str}`;
          break;
      }
      const n2 = BigInt(str);
      return sign === "-" ? BigInt(-1) * n2 : n2;
    }
    const n = parseInt(str, radix);
    return sign === "-" ? -1 * n : n;
  }
  function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value)) {
      const str = value.toString(radix);
      return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber.stringifyNumber(node);
  }
  var intBin = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "BIN",
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
    stringify: (node) => intStringify(node, 2, "0b")
  };
  var intOct = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
    stringify: (node) => intStringify(node, 8, "0")
  };
  var int = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
  };
  var intHex = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: (node) => intStringify(node, 16, "0x")
  };
  exports.int = int;
  exports.intBin = intBin;
  exports.intHex = intHex;
  exports.intOct = intOct;
});

// node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS((exports) => {
  var identity = require_identity();
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();

  class YAMLSet extends YAMLMap.YAMLMap {
    constructor(schema) {
      super(schema);
      this.tag = YAMLSet.tag;
    }
    add(key) {
      let pair;
      if (identity.isPair(key))
        pair = key;
      else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
        pair = new Pair.Pair(key.key, null);
      else
        pair = new Pair.Pair(key, null);
      const prev = YAMLMap.findPair(this.items, pair.key);
      if (!prev)
        this.items.push(pair);
    }
    get(key, keepPair) {
      const pair = YAMLMap.findPair(this.items, key);
      return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
    }
    set(key, value) {
      if (typeof value !== "boolean")
        throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
      const prev = YAMLMap.findPair(this.items, key);
      if (prev && !value) {
        this.items.splice(this.items.indexOf(prev), 1);
      } else if (!prev && value) {
        this.items.push(new Pair.Pair(key));
      }
    }
    toJSON(_, ctx) {
      return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      if (this.hasAllNullValues(true))
        return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
      else
        throw new Error("Set items must all have null values");
    }
    static from(schema, iterable, ctx) {
      const { replacer } = ctx;
      const set2 = new this(schema);
      if (iterable && Symbol.iterator in Object(iterable))
        for (let value of iterable) {
          if (typeof replacer === "function")
            value = replacer.call(iterable, value, value);
          set2.items.push(Pair.createPair(value, null, ctx));
        }
      return set2;
    }
  }
  YAMLSet.tag = "tag:yaml.org,2002:set";
  var set = {
    collection: "map",
    identify: (value) => value instanceof Set,
    nodeClass: YAMLSet,
    default: false,
    tag: "tag:yaml.org,2002:set",
    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
    resolve(map3, onError) {
      if (identity.isMap(map3)) {
        if (map3.hasAllNullValues(true))
          return Object.assign(new YAMLSet, map3);
        else
          onError("Set items must all have null values");
      } else
        onError("Expected a mapping for this tag");
      return map3;
    }
  };
  exports.YAMLSet = YAMLSet;
  exports.set = set;
});

// node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  function parseSexagesimal(str, asBigInt) {
    const sign = str[0];
    const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
    const num = (n) => asBigInt ? BigInt(n) : Number(n);
    const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
    return sign === "-" ? num(-1) * res : res;
  }
  function stringifySexagesimal(node) {
    let { value } = node;
    let num = (n) => n;
    if (typeof value === "bigint")
      num = (n) => BigInt(n);
    else if (isNaN(value) || !isFinite(value))
      return stringifyNumber.stringifyNumber(node);
    let sign = "";
    if (value < 0) {
      sign = "-";
      value *= num(-1);
    }
    const _60 = num(60);
    const parts = [value % _60];
    if (value < 60) {
      parts.unshift(0);
    } else {
      value = (value - parts[0]) / _60;
      parts.unshift(value % _60);
      if (value >= 60) {
        value = (value - parts[0]) / _60;
        parts.unshift(value);
      }
    }
    return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
  }
  var intTime = {
    identify: (value) => typeof value === "bigint" || Number.isInteger(value),
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
    stringify: stringifySexagesimal
  };
  var floatTime = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: (str) => parseSexagesimal(str, false),
    stringify: stringifySexagesimal
  };
  var timestamp = {
    identify: (value) => value instanceof Date,
    default: true,
    tag: "tag:yaml.org,2002:timestamp",
    test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})" + "(?:" + "(?:t|T|[ \\t]+)" + "([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)" + "(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?" + ")?$"),
    resolve(str) {
      const match = str.match(timestamp.test);
      if (!match)
        throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
      const [, year, month, day, hour, minute, second] = match.map(Number);
      const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
      let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
      const tz = match[8];
      if (tz && tz !== "Z") {
        let d = parseSexagesimal(tz, false);
        if (Math.abs(d) < 30)
          d *= 60;
        date -= 60000 * d;
      }
      return new Date(date);
    },
    stringify: ({ value }) => value.toISOString().replace(/(T00:00:00)?\.000Z$/, "")
  };
  exports.floatTime = floatTime;
  exports.intTime = intTime;
  exports.timestamp = timestamp;
});

// node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS((exports) => {
  var map3 = require_map();
  var _null = require_null();
  var seq = require_seq();
  var string = require_string();
  var binary = require_binary();
  var bool = require_bool2();
  var float = require_float2();
  var int = require_int2();
  var merge3 = require_merge();
  var omap = require_omap();
  var pairs = require_pairs();
  var set = require_set();
  var timestamp = require_timestamp();
  var schema = [
    map3.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.trueTag,
    bool.falseTag,
    int.intBin,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float,
    binary.binary,
    merge3.merge,
    omap.omap,
    pairs.pairs,
    set.set,
    timestamp.intTime,
    timestamp.floatTime,
    timestamp.timestamp
  ];
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS((exports) => {
  var map3 = require_map();
  var _null = require_null();
  var seq = require_seq();
  var string = require_string();
  var bool = require_bool();
  var float = require_float();
  var int = require_int();
  var schema = require_schema();
  var schema$1 = require_schema2();
  var binary = require_binary();
  var merge3 = require_merge();
  var omap = require_omap();
  var pairs = require_pairs();
  var schema$2 = require_schema3();
  var set = require_set();
  var timestamp = require_timestamp();
  var schemas = new Map([
    ["core", schema.schema],
    ["failsafe", [map3.map, seq.seq, string.string]],
    ["json", schema$1.schema],
    ["yaml11", schema$2.schema],
    ["yaml-1.1", schema$2.schema]
  ]);
  var tagsByName = {
    binary: binary.binary,
    bool: bool.boolTag,
    float: float.float,
    floatExp: float.floatExp,
    floatNaN: float.floatNaN,
    floatTime: timestamp.floatTime,
    int: int.int,
    intHex: int.intHex,
    intOct: int.intOct,
    intTime: timestamp.intTime,
    map: map3.map,
    merge: merge3.merge,
    null: _null.nullTag,
    omap: omap.omap,
    pairs: pairs.pairs,
    seq: seq.seq,
    set: set.set,
    timestamp: timestamp.timestamp
  };
  var coreKnownTags = {
    "tag:yaml.org,2002:binary": binary.binary,
    "tag:yaml.org,2002:merge": merge3.merge,
    "tag:yaml.org,2002:omap": omap.omap,
    "tag:yaml.org,2002:pairs": pairs.pairs,
    "tag:yaml.org,2002:set": set.set,
    "tag:yaml.org,2002:timestamp": timestamp.timestamp
  };
  function getTags(customTags, schemaName, addMergeTag) {
    const schemaTags = schemas.get(schemaName);
    if (schemaTags && !customTags) {
      return addMergeTag && !schemaTags.includes(merge3.merge) ? schemaTags.concat(merge3.merge) : schemaTags.slice();
    }
    let tags = schemaTags;
    if (!tags) {
      if (Array.isArray(customTags))
        tags = [];
      else {
        const keys3 = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown schema "${schemaName}"; use one of ${keys3} or define customTags array`);
      }
    }
    if (Array.isArray(customTags)) {
      for (const tag of customTags)
        tags = tags.concat(tag);
    } else if (typeof customTags === "function") {
      tags = customTags(tags.slice());
    }
    if (addMergeTag)
      tags = tags.concat(merge3.merge);
    return tags.reduce((tags2, tag) => {
      const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
      if (!tagObj) {
        const tagName = JSON.stringify(tag);
        const keys3 = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown custom tag ${tagName}; use one of ${keys3}`);
      }
      if (!tags2.includes(tagObj))
        tags2.push(tagObj);
      return tags2;
    }, []);
  }
  exports.coreKnownTags = coreKnownTags;
  exports.getTags = getTags;
});

// node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS((exports) => {
  var identity = require_identity();
  var map3 = require_map();
  var seq = require_seq();
  var string = require_string();
  var tags = require_tags();
  var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;

  class Schema {
    constructor({ compat, customTags, merge: merge3, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
      this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
      this.name = typeof schema === "string" && schema || "core";
      this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
      this.tags = tags.getTags(customTags, this.name, merge3);
      this.toStringOptions = toStringDefaults ?? null;
      Object.defineProperty(this, identity.MAP, { value: map3.map });
      Object.defineProperty(this, identity.SCALAR, { value: string.string });
      Object.defineProperty(this, identity.SEQ, { value: seq.seq });
      this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
    }
    clone() {
      const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
      copy.tags = this.tags.slice();
      return copy;
    }
  }
  exports.Schema = Schema;
});

// node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS((exports) => {
  var identity = require_identity();
  var stringify2 = require_stringify3();
  var stringifyComment = require_stringifyComment();
  function stringifyDocument(doc, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false && doc.directives) {
      const dir = doc.directives.toString(doc);
      if (dir) {
        lines.push(dir);
        hasDirectives = true;
      } else if (doc.directives.docStart)
        hasDirectives = true;
    }
    if (hasDirectives)
      lines.push("---");
    const ctx = stringify2.createStringifyContext(doc, options);
    const { commentString } = ctx.options;
    if (doc.commentBefore) {
      if (lines.length !== 1)
        lines.unshift("");
      const cs = commentString(doc.commentBefore);
      lines.unshift(stringifyComment.indentComment(cs, ""));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
      if (identity.isNode(doc.contents)) {
        if (doc.contents.spaceBefore && hasDirectives)
          lines.push("");
        if (doc.contents.commentBefore) {
          const cs = commentString(doc.contents.commentBefore);
          lines.push(stringifyComment.indentComment(cs, ""));
        }
        ctx.forceBlockIndent = !!doc.comment;
        contentComment = doc.contents.comment;
      }
      const onChompKeep = contentComment ? undefined : () => chompKeep = true;
      let body = stringify2.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
      if (contentComment)
        body += stringifyComment.lineComment(body, "", commentString(contentComment));
      if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
        lines[lines.length - 1] = `--- ${body}`;
      } else
        lines.push(body);
    } else {
      lines.push(stringify2.stringify(doc.contents, ctx));
    }
    if (doc.directives?.docEnd) {
      if (doc.comment) {
        const cs = commentString(doc.comment);
        if (cs.includes(`
`)) {
          lines.push("...");
          lines.push(stringifyComment.indentComment(cs, ""));
        } else {
          lines.push(`... ${cs}`);
        }
      } else {
        lines.push("...");
      }
    } else {
      let dc = doc.comment;
      if (dc && chompKeep)
        dc = dc.replace(/^\n+/, "");
      if (dc) {
        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
          lines.push("");
        lines.push(stringifyComment.indentComment(commentString(dc), ""));
      }
    }
    return lines.join(`
`) + `
`;
  }
  exports.stringifyDocument = stringifyDocument;
});

// node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS((exports) => {
  var Alias = require_Alias();
  var Collection = require_Collection();
  var identity = require_identity();
  var Pair = require_Pair();
  var toJS = require_toJS();
  var Schema = require_Schema();
  var stringifyDocument = require_stringifyDocument();
  var anchors = require_anchors();
  var applyReviver = require_applyReviver();
  var createNode = require_createNode();
  var directives = require_directives();

  class Document {
    constructor(value, replacer, options) {
      this.commentBefore = null;
      this.comment = null;
      this.errors = [];
      this.warnings = [];
      Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === undefined && replacer) {
        options = replacer;
        replacer = undefined;
      }
      const opt = Object.assign({
        intAsBigInt: false,
        keepSourceTokens: false,
        logLevel: "warn",
        prettyErrors: true,
        strict: true,
        stringKeys: false,
        uniqueKeys: true,
        version: "1.2"
      }, options);
      this.options = opt;
      let { version: version2 } = opt;
      if (options?._directives) {
        this.directives = options._directives.atDocument();
        if (this.directives.yaml.explicit)
          version2 = this.directives.yaml.version;
      } else
        this.directives = new directives.Directives({ version: version2 });
      this.setSchema(version2, options);
      this.contents = value === undefined ? null : this.createNode(value, _replacer, options);
    }
    clone() {
      const copy = Object.create(Document.prototype, {
        [identity.NODE_TYPE]: { value: identity.DOC }
      });
      copy.commentBefore = this.commentBefore;
      copy.comment = this.comment;
      copy.errors = this.errors.slice();
      copy.warnings = this.warnings.slice();
      copy.options = Object.assign({}, this.options);
      if (this.directives)
        copy.directives = this.directives.clone();
      copy.schema = this.schema.clone();
      copy.contents = identity.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    add(value) {
      if (assertCollection(this.contents))
        this.contents.add(value);
    }
    addIn(path6, value) {
      if (assertCollection(this.contents))
        this.contents.addIn(path6, value);
    }
    createAlias(node, name) {
      if (!node.anchor) {
        const prev = anchors.anchorNames(this);
        node.anchor = !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
      }
      return new Alias.Alias(node.anchor);
    }
    createNode(value, replacer, options) {
      let _replacer = undefined;
      if (typeof replacer === "function") {
        value = replacer.call({ "": value }, "", value);
        _replacer = replacer;
      } else if (Array.isArray(replacer)) {
        const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
        const asStr = replacer.filter(keyToStr).map(String);
        if (asStr.length > 0)
          replacer = replacer.concat(asStr);
        _replacer = replacer;
      } else if (options === undefined && replacer) {
        options = replacer;
        replacer = undefined;
      }
      const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
      const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, anchorPrefix || "a");
      const ctx = {
        aliasDuplicateObjects: aliasDuplicateObjects ?? true,
        keepUndefined: keepUndefined ?? false,
        onAnchor,
        onTagObj,
        replacer: _replacer,
        schema: this.schema,
        sourceObjects
      };
      const node = createNode.createNode(value, tag, ctx);
      if (flow && identity.isCollection(node))
        node.flow = true;
      setAnchors();
      return node;
    }
    createPair(key, value, options = {}) {
      const k = this.createNode(key, null, options);
      const v = this.createNode(value, null, options);
      return new Pair.Pair(k, v);
    }
    delete(key) {
      return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    deleteIn(path6) {
      if (Collection.isEmptyPath(path6)) {
        if (this.contents == null)
          return false;
        this.contents = null;
        return true;
      }
      return assertCollection(this.contents) ? this.contents.deleteIn(path6) : false;
    }
    get(key, keepScalar) {
      return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : undefined;
    }
    getIn(path6, keepScalar) {
      if (Collection.isEmptyPath(path6))
        return !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents;
      return identity.isCollection(this.contents) ? this.contents.getIn(path6, keepScalar) : undefined;
    }
    has(key) {
      return identity.isCollection(this.contents) ? this.contents.has(key) : false;
    }
    hasIn(path6) {
      if (Collection.isEmptyPath(path6))
        return this.contents !== undefined;
      return identity.isCollection(this.contents) ? this.contents.hasIn(path6) : false;
    }
    set(key, value) {
      if (this.contents == null) {
        this.contents = Collection.collectionFromPath(this.schema, [key], value);
      } else if (assertCollection(this.contents)) {
        this.contents.set(key, value);
      }
    }
    setIn(path6, value) {
      if (Collection.isEmptyPath(path6)) {
        this.contents = value;
      } else if (this.contents == null) {
        this.contents = Collection.collectionFromPath(this.schema, Array.from(path6), value);
      } else if (assertCollection(this.contents)) {
        this.contents.setIn(path6, value);
      }
    }
    setSchema(version2, options = {}) {
      if (typeof version2 === "number")
        version2 = String(version2);
      let opt;
      switch (version2) {
        case "1.1":
          if (this.directives)
            this.directives.yaml.version = "1.1";
          else
            this.directives = new directives.Directives({ version: "1.1" });
          opt = { resolveKnownTags: false, schema: "yaml-1.1" };
          break;
        case "1.2":
        case "next":
          if (this.directives)
            this.directives.yaml.version = version2;
          else
            this.directives = new directives.Directives({ version: version2 });
          opt = { resolveKnownTags: true, schema: "core" };
          break;
        case null:
          if (this.directives)
            delete this.directives;
          opt = null;
          break;
        default: {
          const sv = JSON.stringify(version2);
          throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
        }
      }
      if (options.schema instanceof Object)
        this.schema = options.schema;
      else if (opt)
        this.schema = new Schema.Schema(Object.assign(opt, options));
      else
        throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
    }
    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      const ctx = {
        anchors: new Map,
        doc: this,
        keep: !json,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
      if (typeof onAnchor === "function")
        for (const { count: count3, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count3);
      return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
    }
    toJSON(jsonArg, onAnchor) {
      return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
    }
    toString(options = {}) {
      if (this.errors.length > 0)
        throw new Error("Document with errors cannot be stringified");
      if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
        const s = JSON.stringify(options.indent);
        throw new Error(`"indent" option must be a positive integer, not ${s}`);
      }
      return stringifyDocument.stringifyDocument(this, options);
    }
  }
  function assertCollection(contents) {
    if (identity.isCollection(contents))
      return true;
    throw new Error("Expected a YAML collection as document contents");
  }
  exports.Document = Document;
});

// node_modules/yaml/dist/errors.js
var require_errors = __commonJS((exports) => {
  class YAMLError extends Error {
    constructor(name, pos, code, message) {
      super();
      this.name = name;
      this.code = code;
      this.message = message;
      this.pos = pos;
    }
  }

  class YAMLParseError extends YAMLError {
    constructor(pos, code, message) {
      super("YAMLParseError", pos, code, message);
    }
  }

  class YAMLWarning extends YAMLError {
    constructor(pos, code, message) {
      super("YAMLWarning", pos, code, message);
    }
  }
  var prettifyError = (src, lc) => (error) => {
    if (error.pos[0] === -1)
      return;
    error.linePos = error.pos.map((pos) => lc.linePos(pos));
    const { line, col } = error.linePos[0];
    error.message += ` at line ${line}, column ${col}`;
    let ci = col - 1;
    let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
    if (ci >= 60 && lineStr.length > 80) {
      const trimStart = Math.min(ci - 39, lineStr.length - 79);
      lineStr = "" + lineStr.substring(trimStart);
      ci -= trimStart - 1;
    }
    if (lineStr.length > 80)
      lineStr = lineStr.substring(0, 79) + "";
    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
      let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
      if (prev.length > 80)
        prev = prev.substring(0, 79) + `
`;
      lineStr = prev + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
      let count3 = 1;
      const end = error.linePos[1];
      if (end && end.line === line && end.col > col) {
        count3 = Math.max(1, Math.min(end.col - col, 80 - ci));
      }
      const pointer = " ".repeat(ci) + "^".repeat(count3);
      error.message += `:

${lineStr}
${pointer}
`;
    }
  };
  exports.YAMLError = YAMLError;
  exports.YAMLParseError = YAMLParseError;
  exports.YAMLWarning = YAMLWarning;
  exports.prettifyError = prettifyError;
});

// node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS((exports) => {
  function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = "";
    let commentSep = "";
    let hasNewline = false;
    let reqSpace = false;
    let tab = null;
    let anchor = null;
    let tag = null;
    let newlineAfterProp = null;
    let comma = null;
    let found = null;
    let start = null;
    for (const token of tokens) {
      if (reqSpace) {
        if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
          onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
        reqSpace = false;
      }
      if (tab) {
        if (atNewline && token.type !== "comment" && token.type !== "newline") {
          onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        }
        tab = null;
      }
      switch (token.type) {
        case "space":
          if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("\t")) {
            tab = token;
          }
          hasSpace = true;
          break;
        case "comment": {
          if (!hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = token.source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += commentSep + cb;
          commentSep = "";
          atNewline = false;
          break;
        }
        case "newline":
          if (atNewline) {
            if (comment)
              comment += token.source;
            else if (!found || indicator !== "seq-item-ind")
              spaceBefore = true;
          } else
            commentSep += token.source;
          atNewline = true;
          hasNewline = true;
          if (anchor || tag)
            newlineAfterProp = token;
          hasSpace = true;
          break;
        case "anchor":
          if (anchor)
            onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
          if (token.source.endsWith(":"))
            onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
          anchor = token;
          if (start === null)
            start = token.offset;
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        case "tag": {
          if (tag)
            onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
          tag = token;
          if (start === null)
            start = token.offset;
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        }
        case indicator:
          if (anchor || tag)
            onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
          if (found)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
          found = token;
          atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
          hasSpace = false;
          break;
        case "comma":
          if (flow) {
            if (comma)
              onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
            comma = token;
            atNewline = false;
            hasSpace = false;
            break;
          }
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
          atNewline = false;
          hasSpace = false;
      }
    }
    const last = tokens[tokens.length - 1];
    const end = last ? last.offset + last.source.length : offset;
    if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
      onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
    }
    if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq"))
      onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
    return {
      comma,
      found,
      spaceBefore,
      comment,
      hasNewline,
      anchor,
      tag,
      newlineAfterProp,
      end,
      start: start ?? end
    };
  }
  exports.resolveProps = resolveProps;
});

// node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS((exports) => {
  function containsNewline(key) {
    if (!key)
      return null;
    switch (key.type) {
      case "alias":
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        if (key.source.includes(`
`))
          return true;
        if (key.end) {
          for (const st of key.end)
            if (st.type === "newline")
              return true;
        }
        return false;
      case "flow-collection":
        for (const it of key.items) {
          for (const st of it.start)
            if (st.type === "newline")
              return true;
          if (it.sep) {
            for (const st of it.sep)
              if (st.type === "newline")
                return true;
          }
          if (containsNewline(it.key) || containsNewline(it.value))
            return true;
        }
        return false;
      default:
        return true;
    }
  }
  exports.containsNewline = containsNewline;
});

// node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS((exports) => {
  var utilContainsNewline = require_util_contains_newline();
  function flowIndentCheck(indent, fc, onError) {
    if (fc?.type === "flow-collection") {
      const end = fc.end[0];
      if (end.indent === indent && (end.source === "]" || end.source === "}") && utilContainsNewline.containsNewline(fc)) {
        const msg = "Flow end indicator should be more indented than parent";
        onError(end, "BAD_INDENT", msg, true);
      }
    }
  }
  exports.flowIndentCheck = flowIndentCheck;
});

// node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS((exports) => {
  var identity = require_identity();
  function mapIncludes(ctx, items, search) {
    const { uniqueKeys } = ctx.options;
    if (uniqueKeys === false)
      return false;
    const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || identity.isScalar(a) && identity.isScalar(b) && a.value === b.value;
    return items.some((pair) => isEqual(pair.key, search));
  }
  exports.mapIncludes = mapIncludes;
});

// node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS((exports) => {
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();
  var resolveProps = require_resolve_props();
  var utilContainsNewline = require_util_contains_newline();
  var utilFlowIndentCheck = require_util_flow_indent_check();
  var utilMapIncludes = require_util_map_includes();
  var startColMsg = "All mapping items must start at the same column";
  function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
    const map3 = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    let offset = bm.offset;
    let commentEnd = null;
    for (const collItem of bm.items) {
      const { start, key, sep: sep2, value } = collItem;
      const keyProps = resolveProps.resolveProps(start, {
        indicator: "explicit-key-ind",
        next: key ?? sep2?.[0],
        offset,
        onError,
        parentIndent: bm.indent,
        startOnNewline: true
      });
      const implicitKey = !keyProps.found;
      if (implicitKey) {
        if (key) {
          if (key.type === "block-seq")
            onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
          else if ("indent" in key && key.indent !== bm.indent)
            onError(offset, "BAD_INDENT", startColMsg);
        }
        if (!keyProps.anchor && !keyProps.tag && !sep2) {
          commentEnd = keyProps.end;
          if (keyProps.comment) {
            if (map3.comment)
              map3.comment += `
` + keyProps.comment;
            else
              map3.comment = keyProps.comment;
          }
          continue;
        }
        if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {
          onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
        }
      } else if (keyProps.found?.indent !== bm.indent) {
        onError(offset, "BAD_INDENT", startColMsg);
      }
      ctx.atKey = true;
      const keyStart = keyProps.end;
      const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
      if (ctx.schema.compat)
        utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
      ctx.atKey = false;
      if (utilMapIncludes.mapIncludes(ctx, map3.items, keyNode))
        onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
      const valueProps = resolveProps.resolveProps(sep2 ?? [], {
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        parentIndent: bm.indent,
        startOnNewline: !key || key.type === "block-scalar"
      });
      offset = valueProps.end;
      if (valueProps.found) {
        if (implicitKey) {
          if (value?.type === "block-map" && !valueProps.hasNewline)
            onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
          if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
            onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
        }
        const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep2, null, valueProps, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
        offset = valueNode.range[2];
        const pair = new Pair.Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map3.items.push(pair);
      } else {
        if (implicitKey)
          onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
        if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += `
` + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair.Pair(keyNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map3.items.push(pair);
      }
    }
    if (commentEnd && commentEnd < offset)
      onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
    map3.range = [bm.offset, offset, commentEnd ?? offset];
    return map3;
  }
  exports.resolveBlockMap = resolveBlockMap;
});

// node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS((exports) => {
  var YAMLSeq = require_YAMLSeq();
  var resolveProps = require_resolve_props();
  var utilFlowIndentCheck = require_util_flow_indent_check();
  function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
    const seq = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    if (ctx.atKey)
      ctx.atKey = false;
    let offset = bs.offset;
    let commentEnd = null;
    for (const { start, value } of bs.items) {
      const props = resolveProps.resolveProps(start, {
        indicator: "seq-item-ind",
        next: value,
        offset,
        onError,
        parentIndent: bs.indent,
        startOnNewline: true
      });
      if (!props.found) {
        if (props.anchor || props.tag || value) {
          if (value && value.type === "block-seq")
            onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
          else
            onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
        } else {
          commentEnd = props.end;
          if (props.comment)
            seq.comment = props.comment;
          continue;
        }
      }
      const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
      if (ctx.schema.compat)
        utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
      offset = node.range[2];
      seq.items.push(node);
    }
    seq.range = [bs.offset, offset, commentEnd ?? offset];
    return seq;
  }
  exports.resolveBlockSeq = resolveBlockSeq;
});

// node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS((exports) => {
  function resolveEnd(end, offset, reqSpace, onError) {
    let comment = "";
    if (end) {
      let hasSpace = false;
      let sep2 = "";
      for (const token of end) {
        const { source, type } = token;
        switch (type) {
          case "space":
            hasSpace = true;
            break;
          case "comment": {
            if (reqSpace && !hasSpace)
              onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = source.substring(1) || " ";
            if (!comment)
              comment = cb;
            else
              comment += sep2 + cb;
            sep2 = "";
            break;
          }
          case "newline":
            if (comment)
              sep2 += source;
            hasSpace = true;
            break;
          default:
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
        }
        offset += source.length;
      }
    }
    return { comment, offset };
  }
  exports.resolveEnd = resolveEnd;
});

// node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS((exports) => {
  var identity = require_identity();
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var resolveEnd = require_resolve_end();
  var resolveProps = require_resolve_props();
  var utilContainsNewline = require_util_contains_newline();
  var utilMapIncludes = require_util_map_includes();
  var blockMsg = "Block collections are not allowed within flow collections";
  var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
  function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
    const isMap = fc.start.source === "{";
    const fcName = isMap ? "flow map" : "flow sequence";
    const NodeClass = tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq);
    const coll = new NodeClass(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot)
      ctx.atRoot = false;
    if (ctx.atKey)
      ctx.atKey = false;
    let offset = fc.offset + fc.start.source.length;
    for (let i = 0;i < fc.items.length; ++i) {
      const collItem = fc.items[i];
      const { start, key, sep: sep2, value } = collItem;
      const props = resolveProps.resolveProps(start, {
        flow: fcName,
        indicator: "explicit-key-ind",
        next: key ?? sep2?.[0],
        offset,
        onError,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (!props.found) {
        if (!props.anchor && !props.tag && !sep2 && !value) {
          if (i === 0 && props.comma)
            onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
          else if (i < fc.items.length - 1)
            onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
          if (props.comment) {
            if (coll.comment)
              coll.comment += `
` + props.comment;
            else
              coll.comment = props.comment;
          }
          offset = props.end;
          continue;
        }
        if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
          onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
      }
      if (i === 0) {
        if (props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
      } else {
        if (!props.comma)
          onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
        if (props.comment) {
          let prevItemComment = "";
          loop:
            for (const st of start) {
              switch (st.type) {
                case "comma":
                case "space":
                  break;
                case "comment":
                  prevItemComment = st.source.substring(1);
                  break loop;
                default:
                  break loop;
              }
            }
          if (prevItemComment) {
            let prev = coll.items[coll.items.length - 1];
            if (identity.isPair(prev))
              prev = prev.value ?? prev.key;
            if (prev.comment)
              prev.comment += `
` + prevItemComment;
            else
              prev.comment = prevItemComment;
            props.comment = props.comment.substring(prevItemComment.length + 1);
          }
        }
      }
      if (!isMap && !sep2 && !props.found) {
        const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep2, null, props, onError);
        coll.items.push(valueNode);
        offset = valueNode.range[2];
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else {
        ctx.atKey = true;
        const keyStart = props.end;
        const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
        if (isBlock(key))
          onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
        ctx.atKey = false;
        const valueProps = resolveProps.resolveProps(sep2 ?? [], {
          flow: fcName,
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError,
          parentIndent: fc.indent,
          startOnNewline: false
        });
        if (valueProps.found) {
          if (!isMap && !props.found && ctx.options.strict) {
            if (sep2)
              for (const st of sep2) {
                if (st === valueProps.found)
                  break;
                if (st.type === "newline") {
                  onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                  break;
                }
              }
            if (props.start < valueProps.found.offset - 1024)
              onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
          }
        } else if (value) {
          if ("source" in value && value.source && value.source[0] === ":")
            onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
          else
            onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
        }
        const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep2, null, valueProps, onError) : null;
        if (valueNode) {
          if (isBlock(value))
            onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += `
` + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair.Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        if (isMap) {
          const map3 = coll;
          if (utilMapIncludes.mapIncludes(ctx, map3.items, keyNode))
            onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
          map3.items.push(pair);
        } else {
          const map3 = new YAMLMap.YAMLMap(ctx.schema);
          map3.flow = true;
          map3.items.push(pair);
          const endRange = (valueNode ?? keyNode).range;
          map3.range = [keyNode.range[0], endRange[1], endRange[2]];
          coll.items.push(map3);
        }
        offset = valueNode ? valueNode.range[2] : valueProps.end;
      }
    }
    const expectedEnd = isMap ? "}" : "]";
    const [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce && ce.source === expectedEnd)
      cePos = ce.offset + ce.source.length;
    else {
      const name = fcName[0].toUpperCase() + fcName.substring(1);
      const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
      onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
      if (ce && ce.source.length !== 1)
        ee.unshift(ce);
    }
    if (ee.length > 0) {
      const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
      if (end.comment) {
        if (coll.comment)
          coll.comment += `
` + end.comment;
        else
          coll.comment = end.comment;
      }
      coll.range = [fc.offset, cePos, end.offset];
    } else {
      coll.range = [fc.offset, cePos, cePos];
    }
    return coll;
  }
  exports.resolveFlowCollection = resolveFlowCollection;
});

// node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var resolveBlockMap = require_resolve_block_map();
  var resolveBlockSeq = require_resolve_block_seq();
  var resolveFlowCollection = require_resolve_flow_collection();
  function resolveCollection(CN, ctx, token, onError, tagName, tag) {
    const coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);
    const Coll = coll.constructor;
    if (tagName === "!" || tagName === Coll.tagName) {
      coll.tag = Coll.tagName;
      return coll;
    }
    if (tagName)
      coll.tag = tagName;
    return coll;
  }
  function composeCollection(CN, ctx, token, props, onError) {
    const tagToken = props.tag;
    const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
    if (token.type === "block-seq") {
      const { anchor, newlineAfterProp: nl } = props;
      const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
      if (lastProp && (!nl || nl.offset < lastProp.offset)) {
        const message = "Missing newline after block sequence props";
        onError(lastProp, "MISSING_CHAR", message);
      }
    }
    const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
    if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq") {
      return resolveCollection(CN, ctx, token, onError, tagName);
    }
    let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
    if (!tag) {
      const kt = ctx.schema.knownTags[tagName];
      if (kt && kt.collection === expType) {
        ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
        tag = kt;
      } else {
        if (kt?.collection) {
          onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
        } else {
          onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
        }
        return resolveCollection(CN, ctx, token, onError, tagName);
      }
    }
    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
    const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
    const node = identity.isNode(res) ? res : new Scalar.Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag?.format)
      node.format = tag.format;
    return node;
  }
  exports.composeCollection = composeCollection;
});

// node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS((exports) => {
  var Scalar = require_Scalar();
  function resolveBlockScalar(ctx, scalar, onError) {
    const start = scalar.offset;
    const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
    if (!header)
      return { value: "", type: null, comment: "", range: [start, start, start] };
    const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? splitLines(scalar.source) : [];
    let chompStart = lines.length;
    for (let i = lines.length - 1;i >= 0; --i) {
      const content = lines[i][1];
      if (content === "" || content === "\r")
        chompStart = i;
      else
        break;
    }
    if (chompStart === 0) {
      const value2 = header.chomp === "+" && lines.length > 0 ? `
`.repeat(Math.max(1, lines.length - 1)) : "";
      let end2 = start + header.length;
      if (scalar.source)
        end2 += scalar.source.length;
      return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
    }
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for (let i = 0;i < chompStart; ++i) {
      const [indent, content] = lines[i];
      if (content === "" || content === "\r") {
        if (header.indent === 0 && indent.length > trimIndent)
          trimIndent = indent.length;
      } else {
        if (indent.length < trimIndent) {
          const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
          onError(offset + indent.length, "MISSING_CHAR", message);
        }
        if (header.indent === 0)
          trimIndent = indent.length;
        contentStart = i;
        if (trimIndent === 0 && !ctx.atRoot) {
          const message = "Block scalar values in collections must be indented";
          onError(offset, "BAD_INDENT", message);
        }
        break;
      }
      offset += indent.length + content.length + 1;
    }
    for (let i = lines.length - 1;i >= chompStart; --i) {
      if (lines[i][0].length > trimIndent)
        chompStart = i + 1;
    }
    let value = "";
    let sep2 = "";
    let prevMoreIndented = false;
    for (let i = 0;i < contentStart; ++i)
      value += lines[i][0].slice(trimIndent) + `
`;
    for (let i = contentStart;i < chompStart; ++i) {
      let [indent, content] = lines[i];
      offset += indent.length + content.length + 1;
      const crlf = content[content.length - 1] === "\r";
      if (crlf)
        content = content.slice(0, -1);
      if (content && indent.length < trimIndent) {
        const src = header.indent ? "explicit indentation indicator" : "first line";
        const message = `Block scalar lines must not be less indented than their ${src}`;
        onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
        indent = "";
      }
      if (type === Scalar.Scalar.BLOCK_LITERAL) {
        value += sep2 + indent.slice(trimIndent) + content;
        sep2 = `
`;
      } else if (indent.length > trimIndent || content[0] === "\t") {
        if (sep2 === " ")
          sep2 = `
`;
        else if (!prevMoreIndented && sep2 === `
`)
          sep2 = `

`;
        value += sep2 + indent.slice(trimIndent) + content;
        sep2 = `
`;
        prevMoreIndented = true;
      } else if (content === "") {
        if (sep2 === `
`)
          value += `
`;
        else
          sep2 = `
`;
      } else {
        value += sep2 + content;
        sep2 = " ";
        prevMoreIndented = false;
      }
    }
    switch (header.chomp) {
      case "-":
        break;
      case "+":
        for (let i = chompStart;i < lines.length; ++i)
          value += `
` + lines[i][0].slice(trimIndent);
        if (value[value.length - 1] !== `
`)
          value += `
`;
        break;
      default:
        value += `
`;
    }
    const end = start + header.length + scalar.source.length;
    return { value, type, comment: header.comment, range: [start, end, end] };
  }
  function parseBlockScalarHeader({ offset, props }, strict, onError) {
    if (props[0].type !== "block-scalar-header") {
      onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
      return null;
    }
    const { source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = "";
    let error = -1;
    for (let i = 1;i < source.length; ++i) {
      const ch = source[i];
      if (!chomp && (ch === "-" || ch === "+"))
        chomp = ch;
      else {
        const n = Number(ch);
        if (!indent && n)
          indent = n;
        else if (error === -1)
          error = offset + i;
      }
    }
    if (error !== -1)
      onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = "";
    let length = source.length;
    for (let i = 1;i < props.length; ++i) {
      const token = props[i];
      switch (token.type) {
        case "space":
          hasSpace = true;
        case "newline":
          length += token.source.length;
          break;
        case "comment":
          if (strict && !hasSpace) {
            const message = "Comments must be separated from other tokens by white space characters";
            onError(token, "MISSING_CHAR", message);
          }
          length += token.source.length;
          comment = token.source.substring(1);
          break;
        case "error":
          onError(token, "UNEXPECTED_TOKEN", token.message);
          length += token.source.length;
          break;
        default: {
          const message = `Unexpected token in block scalar header: ${token.type}`;
          onError(token, "UNEXPECTED_TOKEN", message);
          const ts = token.source;
          if (ts && typeof ts === "string")
            length += ts.length;
        }
      }
    }
    return { mode, indent, chomp, comment, length };
  }
  function splitLines(source) {
    const split = source.split(/\n( *)/);
    const first3 = split[0];
    const m = first3.match(/^( *)/);
    const line0 = m?.[1] ? [m[1], first3.slice(m[1].length)] : ["", first3];
    const lines = [line0];
    for (let i = 1;i < split.length; i += 2)
      lines.push([split[i], split[i + 1]]);
    return lines;
  }
  exports.resolveBlockScalar = resolveBlockScalar;
});

// node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var resolveEnd = require_resolve_end();
  function resolveFlowScalar(scalar, strict, onError) {
    const { offset, type, source, end } = scalar;
    let _type;
    let value;
    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
    switch (type) {
      case "scalar":
        _type = Scalar.Scalar.PLAIN;
        value = plainValue(source, _onError);
        break;
      case "single-quoted-scalar":
        _type = Scalar.Scalar.QUOTE_SINGLE;
        value = singleQuotedValue(source, _onError);
        break;
      case "double-quoted-scalar":
        _type = Scalar.Scalar.QUOTE_DOUBLE;
        value = doubleQuotedValue(source, _onError);
        break;
      default:
        onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
        return {
          value: "",
          type: null,
          comment: "",
          range: [offset, offset + source.length, offset + source.length]
        };
    }
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
    return {
      value,
      type: _type,
      comment: re.comment,
      range: [offset, valueEnd, re.offset]
    };
  }
  function plainValue(source, onError) {
    let badChar = "";
    switch (source[0]) {
      case "\t":
        badChar = "a tab character";
        break;
      case ",":
        badChar = "flow indicator character ,";
        break;
      case "%":
        badChar = "directive indicator character %";
        break;
      case "|":
      case ">": {
        badChar = `block scalar indicator ${source[0]}`;
        break;
      }
      case "@":
      case "`": {
        badChar = `reserved character ${source[0]}`;
        break;
      }
    }
    if (badChar)
      onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
    return foldLines(source);
  }
  function singleQuotedValue(source, onError) {
    if (source[source.length - 1] !== "'" || source.length === 1)
      onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
    return foldLines(source.slice(1, -1)).replace(/''/g, "'");
  }
  function foldLines(source) {
    let first3, line;
    try {
      first3 = new RegExp(`(.*?)(?<![ \t])[ \t]*\r?
`, "sy");
      line = new RegExp(`[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?
`, "sy");
    } catch {
      first3 = /(.*?)[ \t]*\r?\n/sy;
      line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first3.exec(source);
    if (!match)
      return source;
    let res = match[1];
    let sep2 = " ";
    let pos = first3.lastIndex;
    line.lastIndex = pos;
    while (match = line.exec(source)) {
      if (match[1] === "") {
        if (sep2 === `
`)
          res += sep2;
        else
          sep2 = `
`;
      } else {
        res += sep2 + match[1];
        sep2 = " ";
      }
      pos = line.lastIndex;
    }
    const last = /[ \t]*(.*)/sy;
    last.lastIndex = pos;
    match = last.exec(source);
    return res + sep2 + (match?.[1] ?? "");
  }
  function doubleQuotedValue(source, onError) {
    let res = "";
    for (let i = 1;i < source.length - 1; ++i) {
      const ch = source[i];
      if (ch === "\r" && source[i + 1] === `
`)
        continue;
      if (ch === `
`) {
        const { fold, offset } = foldNewline(source, i);
        res += fold;
        i = offset;
      } else if (ch === "\\") {
        let next = source[++i];
        const cc = escapeCodes[next];
        if (cc)
          res += cc;
        else if (next === `
`) {
          next = source[i + 1];
          while (next === " " || next === "\t")
            next = source[++i + 1];
        } else if (next === "\r" && source[i + 1] === `
`) {
          next = source[++i + 1];
          while (next === " " || next === "\t")
            next = source[++i + 1];
        } else if (next === "x" || next === "u" || next === "U") {
          const length = { x: 2, u: 4, U: 8 }[next];
          res += parseCharCode(source, i + 1, length, onError);
          i += length;
        } else {
          const raw = source.substr(i - 1, 2);
          onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
          res += raw;
        }
      } else if (ch === " " || ch === "\t") {
        const wsStart = i;
        let next = source[i + 1];
        while (next === " " || next === "\t")
          next = source[++i + 1];
        if (next !== `
` && !(next === "\r" && source[i + 2] === `
`))
          res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
      } else {
        res += ch;
      }
    }
    if (source[source.length - 1] !== '"' || source.length === 1)
      onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
    return res;
  }
  function foldNewline(source, offset) {
    let fold = "";
    let ch = source[offset + 1];
    while (ch === " " || ch === "\t" || ch === `
` || ch === "\r") {
      if (ch === "\r" && source[offset + 2] !== `
`)
        break;
      if (ch === `
`)
        fold += `
`;
      offset += 1;
      ch = source[offset + 1];
    }
    if (!fold)
      fold = " ";
    return { fold, offset };
  }
  var escapeCodes = {
    "0": "\x00",
    a: "\x07",
    b: "\b",
    e: "\x1B",
    f: "\f",
    n: `
`,
    r: "\r",
    t: "\t",
    v: "\v",
    N: "",
    _: "",
    L: "\u2028",
    P: "\u2029",
    " ": " ",
    '"': '"',
    "/": "/",
    "\\": "\\",
    "\t": "\t"
  };
  function parseCharCode(source, offset, length, onError) {
    const cc = source.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
      const raw = source.substr(offset - 2, length + 2);
      onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
      return raw;
    }
    return String.fromCodePoint(code);
  }
  exports.resolveFlowScalar = resolveFlowScalar;
});

// node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var resolveBlockScalar = require_resolve_block_scalar();
  var resolveFlowScalar = require_resolve_flow_scalar();
  function composeScalar(ctx, token, tagToken, onError) {
    const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
    const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
    let tag;
    if (ctx.options.stringKeys && ctx.atKey) {
      tag = ctx.schema[identity.SCALAR];
    } else if (tagName)
      tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
    else if (token.type === "scalar")
      tag = findScalarTagByTest(ctx, value, token, onError);
    else
      tag = ctx.schema[identity.SCALAR];
    let scalar;
    try {
      const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
      scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error);
      onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
      scalar = new Scalar.Scalar(value);
    }
    scalar.range = range;
    scalar.source = value;
    if (type)
      scalar.type = type;
    if (tagName)
      scalar.tag = tagName;
    if (tag.format)
      scalar.format = tag.format;
    if (comment)
      scalar.comment = comment;
    return scalar;
  }
  function findScalarTagByName(schema, value, tagName, tagToken, onError) {
    if (tagName === "!")
      return schema[identity.SCALAR];
    const matchWithTest = [];
    for (const tag of schema.tags) {
      if (!tag.collection && tag.tag === tagName) {
        if (tag.default && tag.test)
          matchWithTest.push(tag);
        else
          return tag;
      }
    }
    for (const tag of matchWithTest)
      if (tag.test?.test(value))
        return tag;
    const kt = schema.knownTags[tagName];
    if (kt && !kt.collection) {
      schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));
      return kt;
    }
    onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
    return schema[identity.SCALAR];
  }
  function findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {
    const tag = schema.tags.find((tag2) => (tag2.default === true || atKey && tag2.default === "key") && tag2.test?.test(value)) || schema[identity.SCALAR];
    if (schema.compat) {
      const compat = schema.compat.find((tag2) => tag2.default && tag2.test?.test(value)) ?? schema[identity.SCALAR];
      if (tag.tag !== compat.tag) {
        const ts = directives.tagString(tag.tag);
        const cs = directives.tagString(compat.tag);
        const msg = `Value may be parsed as either ${ts} or ${cs}`;
        onError(token, "TAG_RESOLVE_FAILED", msg, true);
      }
    }
    return tag;
  }
  exports.composeScalar = composeScalar;
});

// node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS((exports) => {
  function emptyScalarPosition(offset, before, pos) {
    if (before) {
      if (pos === null)
        pos = before.length;
      for (let i = pos - 1;i >= 0; --i) {
        let st = before[i];
        switch (st.type) {
          case "space":
          case "comment":
          case "newline":
            offset -= st.source.length;
            continue;
        }
        st = before[++i];
        while (st?.type === "space") {
          offset += st.source.length;
          st = before[++i];
        }
        break;
      }
    }
    return offset;
  }
  exports.emptyScalarPosition = emptyScalarPosition;
});

// node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS((exports) => {
  var Alias = require_Alias();
  var identity = require_identity();
  var composeCollection = require_compose_collection();
  var composeScalar = require_compose_scalar();
  var resolveEnd = require_resolve_end();
  var utilEmptyScalarPosition = require_util_empty_scalar_position();
  var CN = { composeNode, composeEmptyNode };
  function composeNode(ctx, token, props, onError) {
    const atKey = ctx.atKey;
    const { spaceBefore, comment, anchor, tag } = props;
    let node;
    let isSrcToken = true;
    switch (token.type) {
      case "alias":
        node = composeAlias(ctx, token, onError);
        if (anchor || tag)
          onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
        break;
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "block-scalar":
        node = composeScalar.composeScalar(ctx, token, tag, onError);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      case "block-map":
      case "block-seq":
      case "flow-collection":
        node = composeCollection.composeCollection(CN, ctx, token, props, onError);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      default: {
        const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
        onError(token, "UNEXPECTED_TOKEN", message);
        node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);
        isSrcToken = false;
      }
    }
    if (anchor && node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    if (atKey && ctx.options.stringKeys && (!identity.isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
      const msg = "With stringKeys, all keys must be strings";
      onError(tag ?? token, "NON_STRING_KEY", msg);
    }
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment) {
      if (token.type === "scalar" && token.source === "")
        node.comment = comment;
      else
        node.commentBefore = comment;
    }
    if (ctx.options.keepSourceTokens && isSrcToken)
      node.srcToken = token;
    return node;
  }
  function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
    const token = {
      type: "scalar",
      offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
      indent: -1,
      source: ""
    };
    const node = composeScalar.composeScalar(ctx, token, tag, onError);
    if (anchor) {
      node.anchor = anchor.source.substring(1);
      if (node.anchor === "")
        onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    }
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment) {
      node.comment = comment;
      node.range[2] = end;
    }
    return node;
  }
  function composeAlias({ options }, { offset, source, end }, onError) {
    const alias = new Alias.Alias(source.substring(1));
    if (alias.source === "")
      onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
    if (alias.source.endsWith(":"))
      onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
    alias.range = [offset, valueEnd, re.offset];
    if (re.comment)
      alias.comment = re.comment;
    return alias;
  }
  exports.composeEmptyNode = composeEmptyNode;
  exports.composeNode = composeNode;
});

// node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS((exports) => {
  var Document = require_Document();
  var composeNode = require_compose_node();
  var resolveEnd = require_resolve_end();
  var resolveProps = require_resolve_props();
  function composeDoc(options, directives, { offset, start, value, end }, onError) {
    const opts = Object.assign({ _directives: directives }, options);
    const doc = new Document.Document(undefined, opts);
    const ctx = {
      atKey: false,
      atRoot: true,
      directives: doc.directives,
      options: doc.options,
      schema: doc.schema
    };
    const props = resolveProps.resolveProps(start, {
      indicator: "doc-start",
      next: value ?? end?.[0],
      offset,
      onError,
      parentIndent: 0,
      startOnNewline: true
    });
    if (props.found) {
      doc.directives.docStart = true;
      if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
        onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
    }
    doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc.contents.range[2];
    const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
    if (re.comment)
      doc.comment = re.comment;
    doc.range = [offset, contentEnd, re.offset];
    return doc;
  }
  exports.composeDoc = composeDoc;
});

// node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS((exports) => {
  var node_process = __require("node:process");
  var directives = require_directives();
  var Document = require_Document();
  var errors = require_errors();
  var identity = require_identity();
  var composeDoc = require_compose_doc();
  var resolveEnd = require_resolve_end();
  function getErrorPos(src) {
    if (typeof src === "number")
      return [src, src + 1];
    if (Array.isArray(src))
      return src.length === 2 ? src : [src[0], src[1]];
    const { offset, source } = src;
    return [offset, offset + (typeof source === "string" ? source.length : 1)];
  }
  function parsePrelude(prelude) {
    let comment = "";
    let atComment = false;
    let afterEmptyLine = false;
    for (let i = 0;i < prelude.length; ++i) {
      const source = prelude[i];
      switch (source[0]) {
        case "#":
          comment += (comment === "" ? "" : afterEmptyLine ? `

` : `
`) + (source.substring(1) || " ");
          atComment = true;
          afterEmptyLine = false;
          break;
        case "%":
          if (prelude[i + 1]?.[0] !== "#")
            i += 1;
          atComment = false;
          break;
        default:
          if (!atComment)
            afterEmptyLine = true;
          atComment = false;
      }
    }
    return { comment, afterEmptyLine };
  }

  class Composer {
    constructor(options = {}) {
      this.doc = null;
      this.atDirectives = false;
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
      this.onError = (source, code, message, warning) => {
        const pos = getErrorPos(source);
        if (warning)
          this.warnings.push(new errors.YAMLWarning(pos, code, message));
        else
          this.errors.push(new errors.YAMLParseError(pos, code, message));
      };
      this.directives = new directives.Directives({ version: options.version || "1.2" });
      this.options = options;
    }
    decorate(doc, afterDoc) {
      const { comment, afterEmptyLine } = parsePrelude(this.prelude);
      if (comment) {
        const dc = doc.contents;
        if (afterDoc) {
          doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
        } else if (afterEmptyLine || doc.directives.docStart || !dc) {
          doc.commentBefore = comment;
        } else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
          let it = dc.items[0];
          if (identity.isPair(it))
            it = it.key;
          const cb = it.commentBefore;
          it.commentBefore = cb ? `${comment}
${cb}` : comment;
        } else {
          const cb = dc.commentBefore;
          dc.commentBefore = cb ? `${comment}
${cb}` : comment;
        }
      }
      if (afterDoc) {
        Array.prototype.push.apply(doc.errors, this.errors);
        Array.prototype.push.apply(doc.warnings, this.warnings);
      } else {
        doc.errors = this.errors;
        doc.warnings = this.warnings;
      }
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
    }
    streamInfo() {
      return {
        comment: parsePrelude(this.prelude).comment,
        directives: this.directives,
        errors: this.errors,
        warnings: this.warnings
      };
    }
    *compose(tokens, forceDoc = false, endOffset = -1) {
      for (const token of tokens)
        yield* this.next(token);
      yield* this.end(forceDoc, endOffset);
    }
    *next(token) {
      if (node_process.env.LOG_STREAM)
        console.dir(token, { depth: null });
      switch (token.type) {
        case "directive":
          this.directives.add(token.source, (offset, message, warning) => {
            const pos = getErrorPos(token);
            pos[0] += offset;
            this.onError(pos, "BAD_DIRECTIVE", message, warning);
          });
          this.prelude.push(token.source);
          this.atDirectives = true;
          break;
        case "document": {
          const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
          if (this.atDirectives && !doc.directives.docStart)
            this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
          this.decorate(doc, false);
          if (this.doc)
            yield this.doc;
          this.doc = doc;
          this.atDirectives = false;
          break;
        }
        case "byte-order-mark":
        case "space":
          break;
        case "comment":
        case "newline":
          this.prelude.push(token.source);
          break;
        case "error": {
          const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
          const error = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
          if (this.atDirectives || !this.doc)
            this.errors.push(error);
          else
            this.doc.errors.push(error);
          break;
        }
        case "doc-end": {
          if (!this.doc) {
            const msg = "Unexpected doc-end without preceding document";
            this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
            break;
          }
          this.doc.directives.docEnd = true;
          const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
          this.decorate(this.doc, true);
          if (end.comment) {
            const dc = this.doc.comment;
            this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
          }
          this.doc.range[2] = end.offset;
          break;
        }
        default:
          this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
      }
    }
    *end(forceDoc = false, endOffset = -1) {
      if (this.doc) {
        this.decorate(this.doc, true);
        yield this.doc;
        this.doc = null;
      } else if (forceDoc) {
        const opts = Object.assign({ _directives: this.directives }, this.options);
        const doc = new Document.Document(undefined, opts);
        if (this.atDirectives)
          this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
        doc.range = [0, endOffset, endOffset];
        this.decorate(doc, false);
        yield doc;
      }
    }
  }
  exports.Composer = Composer;
});

// node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS((exports) => {
  var resolveBlockScalar = require_resolve_block_scalar();
  var resolveFlowScalar = require_resolve_flow_scalar();
  var errors = require_errors();
  var stringifyString = require_stringifyString();
  function resolveAsScalar(token, strict = true, onError) {
    if (token) {
      const _onError = (pos, code, message) => {
        const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
        if (onError)
          onError(offset, code, message);
        else
          throw new errors.YAMLParseError([offset, offset + 1], code, message);
      };
      switch (token.type) {
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
        case "block-scalar":
          return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);
      }
    }
    return null;
  }
  function createScalarToken(value, context) {
    const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
    const source = stringifyString.stringifyString({ type, value }, {
      implicitKey,
      indent: indent > 0 ? " ".repeat(indent) : "",
      inFlow,
      options: { blockQuote: true, lineWidth: -1 }
    });
    const end = context.end ?? [
      { type: "newline", offset: -1, indent, source: `
` }
    ];
    switch (source[0]) {
      case "|":
      case ">": {
        const he = source.indexOf(`
`);
        const head = source.substring(0, he);
        const body = source.substring(he + 1) + `
`;
        const props = [
          { type: "block-scalar-header", offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, end))
          props.push({ type: "newline", offset: -1, indent, source: `
` });
        return { type: "block-scalar", offset, indent, props, source: body };
      }
      case '"':
        return { type: "double-quoted-scalar", offset, indent, source, end };
      case "'":
        return { type: "single-quoted-scalar", offset, indent, source, end };
      default:
        return { type: "scalar", offset, indent, source, end };
    }
  }
  function setScalarValue(token, value, context = {}) {
    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
    let indent = "indent" in token ? token.indent : null;
    if (afterKey && typeof indent === "number")
      indent += 2;
    if (!type)
      switch (token.type) {
        case "single-quoted-scalar":
          type = "QUOTE_SINGLE";
          break;
        case "double-quoted-scalar":
          type = "QUOTE_DOUBLE";
          break;
        case "block-scalar": {
          const header = token.props[0];
          if (header.type !== "block-scalar-header")
            throw new Error("Invalid block scalar header");
          type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
          break;
        }
        default:
          type = "PLAIN";
      }
    const source = stringifyString.stringifyString({ type, value }, {
      implicitKey: implicitKey || indent === null,
      indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
      inFlow,
      options: { blockQuote: true, lineWidth: -1 }
    });
    switch (source[0]) {
      case "|":
      case ">":
        setBlockScalarValue(token, source);
        break;
      case '"':
        setFlowScalarValue(token, source, "double-quoted-scalar");
        break;
      case "'":
        setFlowScalarValue(token, source, "single-quoted-scalar");
        break;
      default:
        setFlowScalarValue(token, source, "scalar");
    }
  }
  function setBlockScalarValue(token, source) {
    const he = source.indexOf(`
`);
    const head = source.substring(0, he);
    const body = source.substring(he + 1) + `
`;
    if (token.type === "block-scalar") {
      const header = token.props[0];
      if (header.type !== "block-scalar-header")
        throw new Error("Invalid block scalar header");
      header.source = head;
      token.source = body;
    } else {
      const { offset } = token;
      const indent = "indent" in token ? token.indent : -1;
      const props = [
        { type: "block-scalar-header", offset, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, "end" in token ? token.end : undefined))
        props.push({ type: "newline", offset: -1, indent, source: `
` });
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type: "block-scalar", indent, props, source: body });
    }
  }
  function addEndtoBlockProps(props, end) {
    if (end)
      for (const st of end)
        switch (st.type) {
          case "space":
          case "comment":
            props.push(st);
            break;
          case "newline":
            props.push(st);
            return true;
        }
    return false;
  }
  function setFlowScalarValue(token, source, type) {
    switch (token.type) {
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        token.type = type;
        token.source = source;
        break;
      case "block-scalar": {
        const end = token.props.slice(1);
        let oa = source.length;
        if (token.props[0].type === "block-scalar-header")
          oa -= token.props[0].source.length;
        for (const tok of end)
          tok.offset += oa;
        delete token.props;
        Object.assign(token, { type, source, end });
        break;
      }
      case "block-map":
      case "block-seq": {
        const offset = token.offset + source.length;
        const nl = { type: "newline", offset, indent: token.indent, source: `
` };
        delete token.items;
        Object.assign(token, { type, source, end: [nl] });
        break;
      }
      default: {
        const indent = "indent" in token ? token.indent : -1;
        const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
        for (const key of Object.keys(token))
          if (key !== "type" && key !== "offset")
            delete token[key];
        Object.assign(token, { type, indent, source, end });
      }
    }
  }
  exports.createScalarToken = createScalarToken;
  exports.resolveAsScalar = resolveAsScalar;
  exports.setScalarValue = setScalarValue;
});

// node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS((exports) => {
  var stringify2 = (cst) => ("type" in cst) ? stringifyToken(cst) : stringifyItem(cst);
  function stringifyToken(token) {
    switch (token.type) {
      case "block-scalar": {
        let res = "";
        for (const tok of token.props)
          res += stringifyToken(tok);
        return res + token.source;
      }
      case "block-map":
      case "block-seq": {
        let res = "";
        for (const item of token.items)
          res += stringifyItem(item);
        return res;
      }
      case "flow-collection": {
        let res = token.start.source;
        for (const item of token.items)
          res += stringifyItem(item);
        for (const st of token.end)
          res += st.source;
        return res;
      }
      case "document": {
        let res = stringifyItem(token);
        if (token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
      default: {
        let res = token.source;
        if ("end" in token && token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
    }
  }
  function stringifyItem({ start, key, sep: sep2, value }) {
    let res = "";
    for (const st of start)
      res += st.source;
    if (key)
      res += stringifyToken(key);
    if (sep2)
      for (const st of sep2)
        res += st.source;
    if (value)
      res += stringifyToken(value);
    return res;
  }
  exports.stringify = stringify2;
});

// node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS((exports) => {
  var BREAK = Symbol("break visit");
  var SKIP = Symbol("skip children");
  var REMOVE = Symbol("remove item");
  function visit(cst, visitor) {
    if ("type" in cst && cst.type === "document")
      cst = { start: cst.start, value: cst.value };
    _visit(Object.freeze([]), cst, visitor);
  }
  visit.BREAK = BREAK;
  visit.SKIP = SKIP;
  visit.REMOVE = REMOVE;
  visit.itemAtPath = (cst, path6) => {
    let item = cst;
    for (const [field, index] of path6) {
      const tok = item?.[field];
      if (tok && "items" in tok) {
        item = tok.items[index];
      } else
        return;
    }
    return item;
  };
  visit.parentCollection = (cst, path6) => {
    const parent = visit.itemAtPath(cst, path6.slice(0, -1));
    const field = path6[path6.length - 1][0];
    const coll = parent?.[field];
    if (coll && "items" in coll)
      return coll;
    throw new Error("Parent collection not found");
  };
  function _visit(path6, item, visitor) {
    let ctrl = visitor(item, path6);
    if (typeof ctrl === "symbol")
      return ctrl;
    for (const field of ["key", "value"]) {
      const token = item[field];
      if (token && "items" in token) {
        for (let i = 0;i < token.items.length; ++i) {
          const ci = _visit(Object.freeze(path6.concat([[field, i]])), token.items[i], visitor);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            token.items.splice(i, 1);
            i -= 1;
          }
        }
        if (typeof ctrl === "function" && field === "key")
          ctrl = ctrl(item, path6);
      }
    }
    return typeof ctrl === "function" ? ctrl(item, path6) : ctrl;
  }
  exports.visit = visit;
});

// node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS((exports) => {
  var cstScalar = require_cst_scalar();
  var cstStringify = require_cst_stringify();
  var cstVisit = require_cst_visit();
  var BOM = "\uFEFF";
  var DOCUMENT = "\x02";
  var FLOW_END = "\x18";
  var SCALAR = "\x1F";
  var isCollection = (token) => !!token && ("items" in token);
  var isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
  function prettyToken(token) {
    switch (token) {
      case BOM:
        return "<BOM>";
      case DOCUMENT:
        return "<DOC>";
      case FLOW_END:
        return "<FLOW_END>";
      case SCALAR:
        return "<SCALAR>";
      default:
        return JSON.stringify(token);
    }
  }
  function tokenType(source) {
    switch (source) {
      case BOM:
        return "byte-order-mark";
      case DOCUMENT:
        return "doc-mode";
      case FLOW_END:
        return "flow-error-end";
      case SCALAR:
        return "scalar";
      case "---":
        return "doc-start";
      case "...":
        return "doc-end";
      case "":
      case `
`:
      case `\r
`:
        return "newline";
      case "-":
        return "seq-item-ind";
      case "?":
        return "explicit-key-ind";
      case ":":
        return "map-value-ind";
      case "{":
        return "flow-map-start";
      case "}":
        return "flow-map-end";
      case "[":
        return "flow-seq-start";
      case "]":
        return "flow-seq-end";
      case ",":
        return "comma";
    }
    switch (source[0]) {
      case " ":
      case "\t":
        return "space";
      case "#":
        return "comment";
      case "%":
        return "directive-line";
      case "*":
        return "alias";
      case "&":
        return "anchor";
      case "!":
        return "tag";
      case "'":
        return "single-quoted-scalar";
      case '"':
        return "double-quoted-scalar";
      case "|":
      case ">":
        return "block-scalar-header";
    }
    return null;
  }
  exports.createScalarToken = cstScalar.createScalarToken;
  exports.resolveAsScalar = cstScalar.resolveAsScalar;
  exports.setScalarValue = cstScalar.setScalarValue;
  exports.stringify = cstStringify.stringify;
  exports.visit = cstVisit.visit;
  exports.BOM = BOM;
  exports.DOCUMENT = DOCUMENT;
  exports.FLOW_END = FLOW_END;
  exports.SCALAR = SCALAR;
  exports.isCollection = isCollection;
  exports.isScalar = isScalar;
  exports.prettyToken = prettyToken;
  exports.tokenType = tokenType;
});

// node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS((exports) => {
  var cst = require_cst();
  function isEmpty2(ch) {
    switch (ch) {
      case undefined:
      case " ":
      case `
`:
      case "\r":
      case "\t":
        return true;
      default:
        return false;
    }
  }
  var hexDigits = new Set("0123456789ABCDEFabcdef");
  var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
  var flowIndicatorChars = new Set(",[]{}");
  var invalidAnchorChars = new Set(` ,[]{}
\r\t`);
  var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);

  class Lexer {
    constructor() {
      this.atEnd = false;
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      this.buffer = "";
      this.flowKey = false;
      this.flowLevel = 0;
      this.indentNext = 0;
      this.indentValue = 0;
      this.lineEndPos = null;
      this.next = null;
      this.pos = 0;
    }
    *lex(source, incomplete = false) {
      if (source) {
        if (typeof source !== "string")
          throw TypeError("source is not a string");
        this.buffer = this.buffer ? this.buffer + source : source;
        this.lineEndPos = null;
      }
      this.atEnd = !incomplete;
      let next = this.next ?? "stream";
      while (next && (incomplete || this.hasChars(1)))
        next = yield* this.parseNext(next);
    }
    atLineEnd() {
      let i = this.pos;
      let ch = this.buffer[i];
      while (ch === " " || ch === "\t")
        ch = this.buffer[++i];
      if (!ch || ch === "#" || ch === `
`)
        return true;
      if (ch === "\r")
        return this.buffer[i + 1] === `
`;
      return false;
    }
    charAt(n) {
      return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
      let ch = this.buffer[offset];
      if (this.indentNext > 0) {
        let indent = 0;
        while (ch === " ")
          ch = this.buffer[++indent + offset];
        if (ch === "\r") {
          const next = this.buffer[indent + offset + 1];
          if (next === `
` || !next && !this.atEnd)
            return offset + indent + 1;
        }
        return ch === `
` || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
      }
      if (ch === "-" || ch === ".") {
        const dt = this.buffer.substr(offset, 3);
        if ((dt === "---" || dt === "...") && isEmpty2(this.buffer[offset + 3]))
          return -1;
      }
      return offset;
    }
    getLine() {
      let end = this.lineEndPos;
      if (typeof end !== "number" || end !== -1 && end < this.pos) {
        end = this.buffer.indexOf(`
`, this.pos);
        this.lineEndPos = end;
      }
      if (end === -1)
        return this.atEnd ? this.buffer.substring(this.pos) : null;
      if (this.buffer[end - 1] === "\r")
        end -= 1;
      return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
      return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
      this.buffer = this.buffer.substring(this.pos);
      this.pos = 0;
      this.lineEndPos = null;
      this.next = state;
      return null;
    }
    peek(n) {
      return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
      switch (next) {
        case "stream":
          return yield* this.parseStream();
        case "line-start":
          return yield* this.parseLineStart();
        case "block-start":
          return yield* this.parseBlockStart();
        case "doc":
          return yield* this.parseDocument();
        case "flow":
          return yield* this.parseFlowCollection();
        case "quoted-scalar":
          return yield* this.parseQuotedScalar();
        case "block-scalar":
          return yield* this.parseBlockScalar();
        case "plain-scalar":
          return yield* this.parsePlainScalar();
      }
    }
    *parseStream() {
      let line = this.getLine();
      if (line === null)
        return this.setNext("stream");
      if (line[0] === cst.BOM) {
        yield* this.pushCount(1);
        line = line.substring(1);
      }
      if (line[0] === "%") {
        let dirEnd = line.length;
        let cs = line.indexOf("#");
        while (cs !== -1) {
          const ch = line[cs - 1];
          if (ch === " " || ch === "\t") {
            dirEnd = cs - 1;
            break;
          } else {
            cs = line.indexOf("#", cs + 1);
          }
        }
        while (true) {
          const ch = line[dirEnd - 1];
          if (ch === " " || ch === "\t")
            dirEnd -= 1;
          else
            break;
        }
        const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
        yield* this.pushCount(line.length - n);
        this.pushNewline();
        return "stream";
      }
      if (this.atLineEnd()) {
        const sp = yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - sp);
        yield* this.pushNewline();
        return "stream";
      }
      yield cst.DOCUMENT;
      return yield* this.parseLineStart();
    }
    *parseLineStart() {
      const ch = this.charAt(0);
      if (!ch && !this.atEnd)
        return this.setNext("line-start");
      if (ch === "-" || ch === ".") {
        if (!this.atEnd && !this.hasChars(4))
          return this.setNext("line-start");
        const s = this.peek(3);
        if ((s === "---" || s === "...") && isEmpty2(this.charAt(3))) {
          yield* this.pushCount(3);
          this.indentValue = 0;
          this.indentNext = 0;
          return s === "---" ? "doc" : "stream";
        }
      }
      this.indentValue = yield* this.pushSpaces(false);
      if (this.indentNext > this.indentValue && !isEmpty2(this.charAt(1)))
        this.indentNext = this.indentValue;
      return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
      const [ch0, ch1] = this.peek(2);
      if (!ch1 && !this.atEnd)
        return this.setNext("block-start");
      if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty2(ch1)) {
        const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
        this.indentNext = this.indentValue + 1;
        this.indentValue += n;
        return yield* this.parseBlockStart();
      }
      return "doc";
    }
    *parseDocument() {
      yield* this.pushSpaces(true);
      const line = this.getLine();
      if (line === null)
        return this.setNext("doc");
      let n = yield* this.pushIndicators();
      switch (line[n]) {
        case "#":
          yield* this.pushCount(line.length - n);
        case undefined:
          yield* this.pushNewline();
          return yield* this.parseLineStart();
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel = 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          return "doc";
        case "*":
          yield* this.pushUntil(isNotAnchorChar);
          return "doc";
        case '"':
        case "'":
          return yield* this.parseQuotedScalar();
        case "|":
        case ">":
          n += yield* this.parseBlockScalarHeader();
          n += yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - n);
          yield* this.pushNewline();
          return yield* this.parseBlockScalar();
        default:
          return yield* this.parsePlainScalar();
      }
    }
    *parseFlowCollection() {
      let nl, sp;
      let indent = -1;
      do {
        nl = yield* this.pushNewline();
        if (nl > 0) {
          sp = yield* this.pushSpaces(false);
          this.indentValue = indent = sp;
        } else {
          sp = 0;
        }
        sp += yield* this.pushSpaces(true);
      } while (nl + sp > 0);
      const line = this.getLine();
      if (line === null)
        return this.setNext("flow");
      if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty2(line[3])) {
        const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
        if (!atFlowEndMarker) {
          this.flowLevel = 0;
          yield cst.FLOW_END;
          return yield* this.parseLineStart();
        }
      }
      let n = 0;
      while (line[n] === ",") {
        n += yield* this.pushCount(1);
        n += yield* this.pushSpaces(true);
        this.flowKey = false;
      }
      n += yield* this.pushIndicators();
      switch (line[n]) {
        case undefined:
          return "flow";
        case "#":
          yield* this.pushCount(line.length - n);
          return "flow";
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel += 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          this.flowKey = true;
          this.flowLevel -= 1;
          return this.flowLevel ? "flow" : "doc";
        case "*":
          yield* this.pushUntil(isNotAnchorChar);
          return "flow";
        case '"':
        case "'":
          this.flowKey = true;
          return yield* this.parseQuotedScalar();
        case ":": {
          const next = this.charAt(1);
          if (this.flowKey || isEmpty2(next) || next === ",") {
            this.flowKey = false;
            yield* this.pushCount(1);
            yield* this.pushSpaces(true);
            return "flow";
          }
        }
        default:
          this.flowKey = false;
          return yield* this.parsePlainScalar();
      }
    }
    *parseQuotedScalar() {
      const quote = this.charAt(0);
      let end = this.buffer.indexOf(quote, this.pos + 1);
      if (quote === "'") {
        while (end !== -1 && this.buffer[end + 1] === "'")
          end = this.buffer.indexOf("'", end + 2);
      } else {
        while (end !== -1) {
          let n = 0;
          while (this.buffer[end - 1 - n] === "\\")
            n += 1;
          if (n % 2 === 0)
            break;
          end = this.buffer.indexOf('"', end + 1);
        }
      }
      const qb = this.buffer.substring(0, end);
      let nl = qb.indexOf(`
`, this.pos);
      if (nl !== -1) {
        while (nl !== -1) {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = qb.indexOf(`
`, cs);
        }
        if (nl !== -1) {
          end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
        }
      }
      if (end === -1) {
        if (!this.atEnd)
          return this.setNext("quoted-scalar");
        end = this.buffer.length;
      }
      yield* this.pushToIndex(end + 1, false);
      return this.flowLevel ? "flow" : "doc";
    }
    *parseBlockScalarHeader() {
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      let i = this.pos;
      while (true) {
        const ch = this.buffer[++i];
        if (ch === "+")
          this.blockScalarKeep = true;
        else if (ch > "0" && ch <= "9")
          this.blockScalarIndent = Number(ch) - 1;
        else if (ch !== "-")
          break;
      }
      return yield* this.pushUntil((ch) => isEmpty2(ch) || ch === "#");
    }
    *parseBlockScalar() {
      let nl = this.pos - 1;
      let indent = 0;
      let ch;
      loop:
        for (let i2 = this.pos;ch = this.buffer[i2]; ++i2) {
          switch (ch) {
            case " ":
              indent += 1;
              break;
            case `
`:
              nl = i2;
              indent = 0;
              break;
            case "\r": {
              const next = this.buffer[i2 + 1];
              if (!next && !this.atEnd)
                return this.setNext("block-scalar");
              if (next === `
`)
                break;
            }
            default:
              break loop;
          }
        }
      if (!ch && !this.atEnd)
        return this.setNext("block-scalar");
      if (indent >= this.indentNext) {
        if (this.blockScalarIndent === -1)
          this.indentNext = indent;
        else {
          this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
        }
        do {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = this.buffer.indexOf(`
`, cs);
        } while (nl !== -1);
        if (nl === -1) {
          if (!this.atEnd)
            return this.setNext("block-scalar");
          nl = this.buffer.length;
        }
      }
      let i = nl + 1;
      ch = this.buffer[i];
      while (ch === " ")
        ch = this.buffer[++i];
      if (ch === "\t") {
        while (ch === "\t" || ch === " " || ch === "\r" || ch === `
`)
          ch = this.buffer[++i];
        nl = i - 1;
      } else if (!this.blockScalarKeep) {
        do {
          let i2 = nl - 1;
          let ch2 = this.buffer[i2];
          if (ch2 === "\r")
            ch2 = this.buffer[--i2];
          const lastChar = i2;
          while (ch2 === " ")
            ch2 = this.buffer[--i2];
          if (ch2 === `
` && i2 >= this.pos && i2 + 1 + indent > lastChar)
            nl = i2;
          else
            break;
        } while (true);
      }
      yield cst.SCALAR;
      yield* this.pushToIndex(nl + 1, true);
      return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
      const inFlow = this.flowLevel > 0;
      let end = this.pos - 1;
      let i = this.pos - 1;
      let ch;
      while (ch = this.buffer[++i]) {
        if (ch === ":") {
          const next = this.buffer[i + 1];
          if (isEmpty2(next) || inFlow && flowIndicatorChars.has(next))
            break;
          end = i;
        } else if (isEmpty2(ch)) {
          let next = this.buffer[i + 1];
          if (ch === "\r") {
            if (next === `
`) {
              i += 1;
              ch = `
`;
              next = this.buffer[i + 1];
            } else
              end = i;
          }
          if (next === "#" || inFlow && flowIndicatorChars.has(next))
            break;
          if (ch === `
`) {
            const cs = this.continueScalar(i + 1);
            if (cs === -1)
              break;
            i = Math.max(i, cs - 2);
          }
        } else {
          if (inFlow && flowIndicatorChars.has(ch))
            break;
          end = i;
        }
      }
      if (!ch && !this.atEnd)
        return this.setNext("plain-scalar");
      yield cst.SCALAR;
      yield* this.pushToIndex(end + 1, true);
      return inFlow ? "flow" : "doc";
    }
    *pushCount(n) {
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos += n;
        return n;
      }
      return 0;
    }
    *pushToIndex(i, allowEmpty) {
      const s = this.buffer.slice(this.pos, i);
      if (s) {
        yield s;
        this.pos += s.length;
        return s.length;
      } else if (allowEmpty)
        yield "";
      return 0;
    }
    *pushIndicators() {
      switch (this.charAt(0)) {
        case "!":
          return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "&":
          return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "-":
        case "?":
        case ":": {
          const inFlow = this.flowLevel > 0;
          const ch1 = this.charAt(1);
          if (isEmpty2(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
            if (!inFlow)
              this.indentNext = this.indentValue + 1;
            else if (this.flowKey)
              this.flowKey = false;
            return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          }
        }
      }
      return 0;
    }
    *pushTag() {
      if (this.charAt(1) === "<") {
        let i = this.pos + 2;
        let ch = this.buffer[i];
        while (!isEmpty2(ch) && ch !== ">")
          ch = this.buffer[++i];
        return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
      } else {
        let i = this.pos + 1;
        let ch = this.buffer[i];
        while (ch) {
          if (tagChars.has(ch))
            ch = this.buffer[++i];
          else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
            ch = this.buffer[i += 3];
          } else
            break;
        }
        return yield* this.pushToIndex(i, false);
      }
    }
    *pushNewline() {
      const ch = this.buffer[this.pos];
      if (ch === `
`)
        return yield* this.pushCount(1);
      else if (ch === "\r" && this.charAt(1) === `
`)
        return yield* this.pushCount(2);
      else
        return 0;
    }
    *pushSpaces(allowTabs) {
      let i = this.pos - 1;
      let ch;
      do {
        ch = this.buffer[++i];
      } while (ch === " " || allowTabs && ch === "\t");
      const n = i - this.pos;
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos = i;
      }
      return n;
    }
    *pushUntil(test) {
      let i = this.pos;
      let ch = this.buffer[i];
      while (!test(ch))
        ch = this.buffer[++i];
      return yield* this.pushToIndex(i, false);
    }
  }
  exports.Lexer = Lexer;
});

// node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS((exports) => {
  class LineCounter {
    constructor() {
      this.lineStarts = [];
      this.addNewLine = (offset) => this.lineStarts.push(offset);
      this.linePos = (offset) => {
        let low = 0;
        let high = this.lineStarts.length;
        while (low < high) {
          const mid = low + high >> 1;
          if (this.lineStarts[mid] < offset)
            low = mid + 1;
          else
            high = mid;
        }
        if (this.lineStarts[low] === offset)
          return { line: low + 1, col: 1 };
        if (low === 0)
          return { line: 0, col: offset };
        const start = this.lineStarts[low - 1];
        return { line: low, col: offset - start + 1 };
      };
    }
  }
  exports.LineCounter = LineCounter;
});

// node_modules/yaml/dist/parse/parser.js
var require_parser = __commonJS((exports) => {
  var node_process = __require("node:process");
  var cst = require_cst();
  var lexer = require_lexer();
  function includesToken(list, type) {
    for (let i = 0;i < list.length; ++i)
      if (list[i].type === type)
        return true;
    return false;
  }
  function findNonEmptyIndex(list) {
    for (let i = 0;i < list.length; ++i) {
      switch (list[i].type) {
        case "space":
        case "comment":
        case "newline":
          break;
        default:
          return i;
      }
    }
    return -1;
  }
  function isFlowToken(token) {
    switch (token?.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "flow-collection":
        return true;
      default:
        return false;
    }
  }
  function getPrevProps(parent) {
    switch (parent.type) {
      case "document":
        return parent.start;
      case "block-map": {
        const it = parent.items[parent.items.length - 1];
        return it.sep ?? it.start;
      }
      case "block-seq":
        return parent.items[parent.items.length - 1].start;
      default:
        return [];
    }
  }
  function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
      return [];
    let i = prev.length;
    loop:
      while (--i >= 0) {
        switch (prev[i].type) {
          case "doc-start":
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
          case "newline":
            break loop;
        }
      }
    while (prev[++i]?.type === "space") {
    }
    return prev.splice(i, prev.length);
  }
  function fixFlowSeqItems(fc) {
    if (fc.start.type === "flow-seq-start") {
      for (const it of fc.items) {
        if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
          if (it.key)
            it.value = it.key;
          delete it.key;
          if (isFlowToken(it.value)) {
            if (it.value.end)
              Array.prototype.push.apply(it.value.end, it.sep);
            else
              it.value.end = it.sep;
          } else
            Array.prototype.push.apply(it.start, it.sep);
          delete it.sep;
        }
      }
    }
  }

  class Parser {
    constructor(onNewLine) {
      this.atNewLine = true;
      this.atScalar = false;
      this.indent = 0;
      this.offset = 0;
      this.onKeyLine = false;
      this.stack = [];
      this.source = "";
      this.type = "";
      this.lexer = new lexer.Lexer;
      this.onNewLine = onNewLine;
    }
    *parse(source, incomplete = false) {
      if (this.onNewLine && this.offset === 0)
        this.onNewLine(0);
      for (const lexeme of this.lexer.lex(source, incomplete))
        yield* this.next(lexeme);
      if (!incomplete)
        yield* this.end();
    }
    *next(source) {
      this.source = source;
      if (node_process.env.LOG_TOKENS)
        console.log("|", cst.prettyToken(source));
      if (this.atScalar) {
        this.atScalar = false;
        yield* this.step();
        this.offset += source.length;
        return;
      }
      const type = cst.tokenType(source);
      if (!type) {
        const message = `Not a YAML token: ${source}`;
        yield* this.pop({ type: "error", offset: this.offset, message, source });
        this.offset += source.length;
      } else if (type === "scalar") {
        this.atNewLine = false;
        this.atScalar = true;
        this.type = "scalar";
      } else {
        this.type = type;
        yield* this.step();
        switch (type) {
          case "newline":
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine)
              this.onNewLine(this.offset + source.length);
            break;
          case "space":
            if (this.atNewLine && source[0] === " ")
              this.indent += source.length;
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            if (this.atNewLine)
              this.indent += source.length;
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = false;
        }
        this.offset += source.length;
      }
    }
    *end() {
      while (this.stack.length > 0)
        yield* this.pop();
    }
    get sourceToken() {
      const st = {
        type: this.type,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
      return st;
    }
    *step() {
      const top = this.peek(1);
      if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
        while (this.stack.length > 0)
          yield* this.pop();
        this.stack.push({
          type: "doc-end",
          offset: this.offset,
          source: this.source
        });
        return;
      }
      if (!top)
        return yield* this.stream();
      switch (top.type) {
        case "document":
          return yield* this.document(top);
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return yield* this.scalar(top);
        case "block-scalar":
          return yield* this.blockScalar(top);
        case "block-map":
          return yield* this.blockMap(top);
        case "block-seq":
          return yield* this.blockSequence(top);
        case "flow-collection":
          return yield* this.flowCollection(top);
        case "doc-end":
          return yield* this.documentEnd(top);
      }
      yield* this.pop();
    }
    peek(n) {
      return this.stack[this.stack.length - n];
    }
    *pop(error) {
      const token = error ?? this.stack.pop();
      if (!token) {
        const message = "Tried to pop an empty stack";
        yield { type: "error", offset: this.offset, source: "", message };
      } else if (this.stack.length === 0) {
        yield token;
      } else {
        const top = this.peek(1);
        if (token.type === "block-scalar") {
          token.indent = "indent" in top ? top.indent : 0;
        } else if (token.type === "flow-collection" && top.type === "document") {
          token.indent = 0;
        }
        if (token.type === "flow-collection")
          fixFlowSeqItems(token);
        switch (top.type) {
          case "document":
            top.value = token;
            break;
          case "block-scalar":
            top.props.push(token);
            break;
          case "block-map": {
            const it = top.items[top.items.length - 1];
            if (it.value) {
              top.items.push({ start: [], key: token, sep: [] });
              this.onKeyLine = true;
              return;
            } else if (it.sep) {
              it.value = token;
            } else {
              Object.assign(it, { key: token, sep: [] });
              this.onKeyLine = !it.explicitKey;
              return;
            }
            break;
          }
          case "block-seq": {
            const it = top.items[top.items.length - 1];
            if (it.value)
              top.items.push({ start: [], value: token });
            else
              it.value = token;
            break;
          }
          case "flow-collection": {
            const it = top.items[top.items.length - 1];
            if (!it || it.value)
              top.items.push({ start: [], key: token, sep: [] });
            else if (it.sep)
              it.value = token;
            else
              Object.assign(it, { key: token, sep: [] });
            return;
          }
          default:
            yield* this.pop();
            yield* this.pop(token);
        }
        if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
          const last = token.items[token.items.length - 1];
          if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
            if (top.type === "document")
              top.end = last.start;
            else
              top.items.push({ start: last.start });
            token.items.splice(-1, 1);
          }
        }
      }
    }
    *stream() {
      switch (this.type) {
        case "directive-line":
          yield { type: "directive", offset: this.offset, source: this.source };
          return;
        case "byte-order-mark":
        case "space":
        case "comment":
        case "newline":
          yield this.sourceToken;
          return;
        case "doc-mode":
        case "doc-start": {
          const doc = {
            type: "document",
            offset: this.offset,
            start: []
          };
          if (this.type === "doc-start")
            doc.start.push(this.sourceToken);
          this.stack.push(doc);
          return;
        }
      }
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML stream`,
        source: this.source
      };
    }
    *document(doc) {
      if (doc.value)
        return yield* this.lineEnd(doc);
      switch (this.type) {
        case "doc-start": {
          if (findNonEmptyIndex(doc.start) !== -1) {
            yield* this.pop();
            yield* this.step();
          } else
            doc.start.push(this.sourceToken);
          return;
        }
        case "anchor":
        case "tag":
        case "space":
        case "comment":
        case "newline":
          doc.start.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(doc);
      if (bv)
        this.stack.push(bv);
      else {
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML document`,
          source: this.source
        };
      }
    }
    *scalar(scalar) {
      if (this.type === "map-value-ind") {
        const prev = getPrevProps(this.peek(2));
        const start = getFirstKeyStartProps(prev);
        let sep2;
        if (scalar.end) {
          sep2 = scalar.end;
          sep2.push(this.sourceToken);
          delete scalar.end;
        } else
          sep2 = [this.sourceToken];
        const map3 = {
          type: "block-map",
          offset: scalar.offset,
          indent: scalar.indent,
          items: [{ start, key: scalar, sep: sep2 }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map3;
      } else
        yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
      switch (this.type) {
        case "space":
        case "comment":
        case "newline":
          scalar.props.push(this.sourceToken);
          return;
        case "scalar":
          scalar.source = this.source;
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine) {
            let nl = this.source.indexOf(`
`) + 1;
            while (nl !== 0) {
              this.onNewLine(this.offset + nl);
              nl = this.source.indexOf(`
`, nl) + 1;
            }
          }
          yield* this.pop();
          break;
        default:
          yield* this.pop();
          yield* this.step();
      }
    }
    *blockMap(map3) {
      const it = map3.items[map3.items.length - 1];
      switch (this.type) {
        case "newline":
          this.onKeyLine = false;
          if (it.value) {
            const end = "end" in it.value ? it.value.end : undefined;
            const last = Array.isArray(end) ? end[end.length - 1] : undefined;
            if (last?.type === "comment")
              end?.push(this.sourceToken);
            else
              map3.items.push({ start: [this.sourceToken] });
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "space":
        case "comment":
          if (it.value) {
            map3.items.push({ start: [this.sourceToken] });
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            if (this.atIndentedComment(it.start, map3.indent)) {
              const prev = map3.items[map3.items.length - 2];
              const end = prev?.value?.end;
              if (Array.isArray(end)) {
                Array.prototype.push.apply(end, it.start);
                end.push(this.sourceToken);
                map3.items.pop();
                return;
              }
            }
            it.start.push(this.sourceToken);
          }
          return;
      }
      if (this.indent >= map3.indent) {
        const atMapIndent = !this.onKeyLine && this.indent === map3.indent;
        const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
        let start = [];
        if (atNextItem && it.sep && !it.value) {
          const nl = [];
          for (let i = 0;i < it.sep.length; ++i) {
            const st = it.sep[i];
            switch (st.type) {
              case "newline":
                nl.push(i);
                break;
              case "space":
                break;
              case "comment":
                if (st.indent > map3.indent)
                  nl.length = 0;
                break;
              default:
                nl.length = 0;
            }
          }
          if (nl.length >= 2)
            start = it.sep.splice(nl[1]);
        }
        switch (this.type) {
          case "anchor":
          case "tag":
            if (atNextItem || it.value) {
              start.push(this.sourceToken);
              map3.items.push({ start });
              this.onKeyLine = true;
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "explicit-key-ind":
            if (!it.sep && !it.explicitKey) {
              it.start.push(this.sourceToken);
              it.explicitKey = true;
            } else if (atNextItem || it.value) {
              start.push(this.sourceToken);
              map3.items.push({ start, explicitKey: true });
            } else {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [this.sourceToken], explicitKey: true }]
              });
            }
            this.onKeyLine = true;
            return;
          case "map-value-ind":
            if (it.explicitKey) {
              if (!it.sep) {
                if (includesToken(it.start, "newline")) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else {
                  const start2 = getFirstKeyStartProps(it.start);
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                  });
                }
              } else if (it.value) {
                map3.items.push({ start: [], key: null, sep: [this.sourceToken] });
              } else if (includesToken(it.sep, "map-value-ind")) {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start, key: null, sep: [this.sourceToken] }]
                });
              } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                const start2 = getFirstKeyStartProps(it.start);
                const key = it.key;
                const sep2 = it.sep;
                sep2.push(this.sourceToken);
                delete it.key;
                delete it.sep;
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start2, key, sep: sep2 }]
                });
              } else if (start.length > 0) {
                it.sep = it.sep.concat(start, this.sourceToken);
              } else {
                it.sep.push(this.sourceToken);
              }
            } else {
              if (!it.sep) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else if (it.value || atNextItem) {
                map3.items.push({ start, key: null, sep: [this.sourceToken] });
              } else if (includesToken(it.sep, "map-value-ind")) {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [], key: null, sep: [this.sourceToken] }]
                });
              } else {
                it.sep.push(this.sourceToken);
              }
            }
            this.onKeyLine = true;
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs4 = this.flowScalar(this.type);
            if (atNextItem || it.value) {
              map3.items.push({ start, key: fs4, sep: [] });
              this.onKeyLine = true;
            } else if (it.sep) {
              this.stack.push(fs4);
            } else {
              Object.assign(it, { key: fs4, sep: [] });
              this.onKeyLine = true;
            }
            return;
          }
          default: {
            const bv = this.startBlockValue(map3);
            if (bv) {
              if (atMapIndent && bv.type !== "block-seq") {
                map3.items.push({ start });
              }
              this.stack.push(bv);
              return;
            }
          }
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *blockSequence(seq) {
      const it = seq.items[seq.items.length - 1];
      switch (this.type) {
        case "newline":
          if (it.value) {
            const end = "end" in it.value ? it.value.end : undefined;
            const last = Array.isArray(end) ? end[end.length - 1] : undefined;
            if (last?.type === "comment")
              end?.push(this.sourceToken);
            else
              seq.items.push({ start: [this.sourceToken] });
          } else
            it.start.push(this.sourceToken);
          return;
        case "space":
        case "comment":
          if (it.value)
            seq.items.push({ start: [this.sourceToken] });
          else {
            if (this.atIndentedComment(it.start, seq.indent)) {
              const prev = seq.items[seq.items.length - 2];
              const end = prev?.value?.end;
              if (Array.isArray(end)) {
                Array.prototype.push.apply(end, it.start);
                end.push(this.sourceToken);
                seq.items.pop();
                return;
              }
            }
            it.start.push(this.sourceToken);
          }
          return;
        case "anchor":
        case "tag":
          if (it.value || this.indent <= seq.indent)
            break;
          it.start.push(this.sourceToken);
          return;
        case "seq-item-ind":
          if (this.indent !== seq.indent)
            break;
          if (it.value || includesToken(it.start, "seq-item-ind"))
            seq.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
      }
      if (this.indent > seq.indent) {
        const bv = this.startBlockValue(seq);
        if (bv) {
          this.stack.push(bv);
          return;
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *flowCollection(fc) {
      const it = fc.items[fc.items.length - 1];
      if (this.type === "flow-error-end") {
        let top;
        do {
          yield* this.pop();
          top = this.peek(1);
        } while (top && top.type === "flow-collection");
      } else if (fc.end.length === 0) {
        switch (this.type) {
          case "comma":
          case "explicit-key-ind":
            if (!it || it.sep)
              fc.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
          case "map-value-ind":
            if (!it || it.value)
              fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            return;
          case "space":
          case "comment":
          case "newline":
          case "anchor":
          case "tag":
            if (!it || it.value)
              fc.items.push({ start: [this.sourceToken] });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              it.start.push(this.sourceToken);
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs4 = this.flowScalar(this.type);
            if (!it || it.value)
              fc.items.push({ start: [], key: fs4, sep: [] });
            else if (it.sep)
              this.stack.push(fs4);
            else
              Object.assign(it, { key: fs4, sep: [] });
            return;
          }
          case "flow-map-end":
          case "flow-seq-end":
            fc.end.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(fc);
        if (bv)
          this.stack.push(bv);
        else {
          yield* this.pop();
          yield* this.step();
        }
      } else {
        const parent = this.peek(2);
        if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
          yield* this.pop();
          yield* this.step();
        } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          fixFlowSeqItems(fc);
          const sep2 = fc.end.splice(1, fc.end.length);
          sep2.push(this.sourceToken);
          const map3 = {
            type: "block-map",
            offset: fc.offset,
            indent: fc.indent,
            items: [{ start, key: fc, sep: sep2 }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map3;
        } else {
          yield* this.lineEnd(fc);
        }
      }
    }
    flowScalar(type) {
      if (this.onNewLine) {
        let nl = this.source.indexOf(`
`) + 1;
        while (nl !== 0) {
          this.onNewLine(this.offset + nl);
          nl = this.source.indexOf(`
`, nl) + 1;
        }
      }
      return {
        type,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
    }
    startBlockValue(parent) {
      switch (this.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return this.flowScalar(this.type);
        case "block-scalar-header":
          return {
            type: "block-scalar",
            offset: this.offset,
            indent: this.indent,
            props: [this.sourceToken],
            source: ""
          };
        case "flow-map-start":
        case "flow-seq-start":
          return {
            type: "flow-collection",
            offset: this.offset,
            indent: this.indent,
            start: this.sourceToken,
            items: [],
            end: []
          };
        case "seq-item-ind":
          return {
            type: "block-seq",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: [this.sourceToken] }]
          };
        case "explicit-key-ind": {
          this.onKeyLine = true;
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          start.push(this.sourceToken);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start, explicitKey: true }]
          };
        }
        case "map-value-ind": {
          this.onKeyLine = true;
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start, key: null, sep: [this.sourceToken] }]
          };
        }
      }
      return null;
    }
    atIndentedComment(start, indent) {
      if (this.type !== "comment")
        return false;
      if (this.indent <= indent)
        return false;
      return start.every((st) => st.type === "newline" || st.type === "space");
    }
    *documentEnd(docEnd) {
      if (this.type !== "doc-mode") {
        if (docEnd.end)
          docEnd.end.push(this.sourceToken);
        else
          docEnd.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
      }
    }
    *lineEnd(token) {
      switch (this.type) {
        case "comma":
        case "doc-start":
        case "doc-end":
        case "flow-seq-end":
        case "flow-map-end":
        case "map-value-ind":
          yield* this.pop();
          yield* this.step();
          break;
        case "newline":
          this.onKeyLine = false;
        case "space":
        case "comment":
        default:
          if (token.end)
            token.end.push(this.sourceToken);
          else
            token.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
      }
    }
  }
  exports.Parser = Parser;
});

// node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS((exports) => {
  var composer = require_composer();
  var Document = require_Document();
  var errors = require_errors();
  var log2 = require_log();
  var identity = require_identity();
  var lineCounter = require_line_counter();
  var parser = require_parser();
  function parseOptions(options) {
    const prettyErrors = options.prettyErrors !== false;
    const lineCounter$1 = options.lineCounter || prettyErrors && new lineCounter.LineCounter || null;
    return { lineCounter: lineCounter$1, prettyErrors };
  }
  function parseAllDocuments(source, options = {}) {
    const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
    const composer$1 = new composer.Composer(options);
    const docs = Array.from(composer$1.compose(parser$1.parse(source)));
    if (prettyErrors && lineCounter2)
      for (const doc of docs) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter2));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
      }
    if (docs.length > 0)
      return docs;
    return Object.assign([], { empty: true }, composer$1.streamInfo());
  }
  function parseDocument(source, options = {}) {
    const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
    const composer$1 = new composer.Composer(options);
    let doc = null;
    for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
      if (!doc)
        doc = _doc;
      else if (doc.options.logLevel !== "silent") {
        doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
        break;
      }
    }
    if (prettyErrors && lineCounter2) {
      doc.errors.forEach(errors.prettifyError(source, lineCounter2));
      doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
    }
    return doc;
  }
  function parse2(src, reviver, options) {
    let _reviver = undefined;
    if (typeof reviver === "function") {
      _reviver = reviver;
    } else if (options === undefined && reviver && typeof reviver === "object") {
      options = reviver;
    }
    const doc = parseDocument(src, options);
    if (!doc)
      return null;
    doc.warnings.forEach((warning) => log2.warn(doc.options.logLevel, warning));
    if (doc.errors.length > 0) {
      if (doc.options.logLevel !== "silent")
        throw doc.errors[0];
      else
        doc.errors = [];
    }
    return doc.toJS(Object.assign({ reviver: _reviver }, options));
  }
  function stringify2(value, replacer, options) {
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === undefined && replacer) {
      options = replacer;
    }
    if (typeof options === "string")
      options = options.length;
    if (typeof options === "number") {
      const indent = Math.round(options);
      options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };
    }
    if (value === undefined) {
      const { keepUndefined } = options ?? replacer ?? {};
      if (!keepUndefined)
        return;
    }
    if (identity.isDocument(value) && !_replacer)
      return value.toString(options);
    return new Document.Document(value, _replacer, options).toString(options);
  }
  exports.parse = parse2;
  exports.parseAllDocuments = parseAllDocuments;
  exports.parseDocument = parseDocument;
  exports.stringify = stringify2;
});

// node_modules/callsites/index.js
var require_callsites = __commonJS((exports, module) => {
  var callsites = () => {
    const _prepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = (_, stack2) => stack2;
    const stack = new Error().stack.slice(1);
    Error.prepareStackTrace = _prepareStackTrace;
    return stack;
  };
  module.exports = callsites;
  module.exports.default = callsites;
});

// node_modules/parent-module/index.js
var require_parent_module = __commonJS((exports, module) => {
  var callsites = require_callsites();
  module.exports = (filePath) => {
    const stacks = callsites();
    if (!filePath) {
      return stacks[2].getFileName();
    }
    let hasSeenValue = false;
    stacks.shift();
    for (const stack of stacks) {
      const parentFilePath = stack.getFileName();
      if (typeof parentFilePath !== "string") {
        continue;
      }
      if (parentFilePath === filePath) {
        hasSeenValue = true;
        continue;
      }
      if (parentFilePath === "module.js") {
        continue;
      }
      if (hasSeenValue && parentFilePath !== filePath) {
        return parentFilePath;
      }
    }
  };
});

// node_modules/clear-module/index.js
var require_clear_module = __commonJS((exports, module) => {
  var __filename = "D:\\cspell-lsp\\node_modules\\clear-module\\index.js";
  var path9 = __require("path");
  var resolveFrom2 = require_resolve_from();
  var parentModule = require_parent_module();
  var resolve3 = (moduleId) => {
    try {
      return resolveFrom2(path9.dirname(parentModule(__filename)), moduleId);
    } catch (_) {
    }
  };
  var clear = (moduleId) => {
    if (typeof moduleId !== "string") {
      throw new TypeError(`Expected a \`string\`, got \`${typeof moduleId}\``);
    }
    const filePath = resolve3(moduleId);
    if (!filePath) {
      return;
    }
    if (__require.cache[filePath] && __require.cache[filePath].parent) {
      let i = __require.cache[filePath].parent.children.length;
      while (i--) {
        if (__require.cache[filePath].parent.children[i].id === filePath) {
          __require.cache[filePath].parent.children.splice(i, 1);
        }
      }
    }
    if (__require.cache[filePath]) {
      const children = __require.cache[filePath].children.map((child) => child.id);
      delete __require.cache[filePath];
      for (const id of children) {
        clear(id);
      }
    }
  };
  clear.all = () => {
    const directory = path9.dirname(parentModule(__filename));
    for (const moduleId of Object.keys(__require.cache)) {
      delete __require.cache[resolveFrom2(directory, moduleId)];
    }
  };
  clear.match = (regex) => {
    for (const moduleId of Object.keys(__require.cache)) {
      if (regex.test(moduleId)) {
        clear(moduleId);
      }
    }
  };
  clear.single = (moduleId) => {
    if (typeof moduleId !== "string") {
      throw new TypeError(`Expected a \`string\`, got \`${typeof moduleId}\``);
    }
    delete __require.cache[resolve3(moduleId)];
  };
  module.exports = clear;
});

// node_modules/import-fresh/node_modules/resolve-from/index.js
var require_resolve_from2 = __commonJS((exports, module) => {
  var path9 = __require("path");
  var Module = __require("module");
  var fs5 = __require("fs");
  var resolveFrom2 = (fromDir, moduleId, silent) => {
    if (typeof fromDir !== "string") {
      throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDir}\``);
    }
    if (typeof moduleId !== "string") {
      throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
    }
    try {
      fromDir = fs5.realpathSync(fromDir);
    } catch (err) {
      if (err.code === "ENOENT") {
        fromDir = path9.resolve(fromDir);
      } else if (silent) {
        return null;
      } else {
        throw err;
      }
    }
    const fromFile = path9.join(fromDir, "noop.js");
    const resolveFileName = () => Module._resolveFilename(moduleId, {
      id: fromFile,
      filename: fromFile,
      paths: Module._nodeModulePaths(fromDir)
    });
    if (silent) {
      try {
        return resolveFileName();
      } catch (err) {
        return null;
      }
    }
    return resolveFileName();
  };
  module.exports = (fromDir, moduleId) => resolveFrom2(fromDir, moduleId);
  module.exports.silent = (fromDir, moduleId) => resolveFrom2(fromDir, moduleId, true);
});

// node_modules/import-fresh/node_modules/parent-module/index.js
var require_parent_module2 = __commonJS((exports, module) => {
  var callsites = require_callsites();
  module.exports = (filepath) => {
    const stacks = callsites();
    if (!filepath) {
      return stacks[2].getFileName();
    }
    let seenVal = false;
    stacks.shift();
    for (const stack of stacks) {
      const parentFilepath = stack.getFileName();
      if (typeof parentFilepath !== "string") {
        continue;
      }
      if (parentFilepath === filepath) {
        seenVal = true;
        continue;
      }
      if (parentFilepath === "module.js") {
        continue;
      }
      if (seenVal && parentFilepath !== filepath) {
        return parentFilepath;
      }
    }
  };
});

// node_modules/import-fresh/index.js
var require_import_fresh = __commonJS((exports, module) => {
  var __dirname = "D:\\cspell-lsp\\node_modules\\import-fresh", __filename = "D:\\cspell-lsp\\node_modules\\import-fresh\\index.js";
  var path9 = __require("path");
  var resolveFrom2 = require_resolve_from2();
  var parentModule = require_parent_module2();
  module.exports = (moduleId) => {
    if (typeof moduleId !== "string") {
      throw new TypeError("Expected a string");
    }
    const parentPath = parentModule(__filename);
    const cwd = parentPath ? path9.dirname(parentPath) : __dirname;
    const filePath = resolveFrom2(cwd, moduleId);
    const oldModule = __require.cache[filePath];
    if (oldModule && oldModule.parent) {
      let i = oldModule.parent.children.length;
      while (i--) {
        if (oldModule.parent.children[i].id === filePath) {
          oldModule.parent.children.splice(i, 1);
        }
      }
    }
    delete __require.cache[filePath];
    const parent = __require.cache[parentPath];
    return parent === undefined ? __require(filePath) : parent.require(filePath);
  };
});

// src/main.ts
var import_node2 = __toESM(require_main4(), 1);
import * as fs7 from "fs";
import * as readline from "readline";

// node_modules/vscode-languageserver-textdocument/lib/esm/main.js
class FullTextDocument {
  constructor(uri, languageId, version, content) {
    this._uri = uri;
    this._languageId = languageId;
    this._version = version;
    this._content = content;
    this._lineOffsets = undefined;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(range) {
    if (range) {
      const start = this.offsetAt(range.start);
      const end = this.offsetAt(range.end);
      return this._content.substring(start, end);
    }
    return this._content;
  }
  update(changes, version) {
    for (const change of changes) {
      if (FullTextDocument.isIncremental(change)) {
        const range = getWellformedRange(change.range);
        const startOffset = this.offsetAt(range.start);
        const endOffset = this.offsetAt(range.end);
        this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
        const startLine = Math.max(range.start.line, 0);
        const endLine = Math.max(range.end.line, 0);
        let lineOffsets = this._lineOffsets;
        const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
        if (endLine - startLine === addedLineOffsets.length) {
          for (let i = 0, len = addedLineOffsets.length;i < len; i++) {
            lineOffsets[i + startLine + 1] = addedLineOffsets[i];
          }
        } else {
          if (addedLineOffsets.length < 1e4) {
            lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
          } else {
            this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
          }
        }
        const diff = change.text.length - (endOffset - startOffset);
        if (diff !== 0) {
          for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length;i < len; i++) {
            lineOffsets[i] = lineOffsets[i] + diff;
          }
        }
      } else if (FullTextDocument.isFull(change)) {
        this._content = change.text;
        this._lineOffsets = undefined;
      } else {
        throw new Error("Unknown change event received");
      }
    }
    this._version = version;
  }
  getLineOffsets() {
    if (this._lineOffsets === undefined) {
      this._lineOffsets = computeLineOffsets(this._content, true);
    }
    return this._lineOffsets;
  }
  positionAt(offset) {
    offset = Math.max(Math.min(offset, this._content.length), 0);
    const lineOffsets = this.getLineOffsets();
    let low = 0, high = lineOffsets.length;
    if (high === 0) {
      return { line: 0, character: offset };
    }
    while (low < high) {
      const mid = Math.floor((low + high) / 2);
      if (lineOffsets[mid] > offset) {
        high = mid;
      } else {
        low = mid + 1;
      }
    }
    const line = low - 1;
    offset = this.ensureBeforeEOL(offset, lineOffsets[line]);
    return { line, character: offset - lineOffsets[line] };
  }
  offsetAt(position) {
    const lineOffsets = this.getLineOffsets();
    if (position.line >= lineOffsets.length) {
      return this._content.length;
    } else if (position.line < 0) {
      return 0;
    }
    const lineOffset = lineOffsets[position.line];
    if (position.character <= 0) {
      return lineOffset;
    }
    const nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
    const offset = Math.min(lineOffset + position.character, nextLineOffset);
    return this.ensureBeforeEOL(offset, lineOffset);
  }
  ensureBeforeEOL(offset, lineOffset) {
    while (offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))) {
      offset--;
    }
    return offset;
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
  static isIncremental(event) {
    const candidate = event;
    return candidate !== undefined && candidate !== null && typeof candidate.text === "string" && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === "number");
  }
  static isFull(event) {
    const candidate = event;
    return candidate !== undefined && candidate !== null && typeof candidate.text === "string" && candidate.range === undefined && candidate.rangeLength === undefined;
  }
}
var TextDocument;
(function(TextDocument2) {
  function create(uri, languageId, version, content) {
    return new FullTextDocument(uri, languageId, version, content);
  }
  TextDocument2.create = create;
  function update(document, changes, version) {
    if (document instanceof FullTextDocument) {
      document.update(changes, version);
      return document;
    } else {
      throw new Error("TextDocument.update: document must be created by TextDocument.create");
    }
  }
  TextDocument2.update = update;
  function applyEdits(document, edits) {
    const text = document.getText();
    const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
      const diff = a.range.start.line - b.range.start.line;
      if (diff === 0) {
        return a.range.start.character - b.range.start.character;
      }
      return diff;
    });
    let lastModifiedOffset = 0;
    const spans = [];
    for (const e of sortedEdits) {
      const startOffset = document.offsetAt(e.range.start);
      if (startOffset < lastModifiedOffset) {
        throw new Error("Overlapping edit");
      } else if (startOffset > lastModifiedOffset) {
        spans.push(text.substring(lastModifiedOffset, startOffset));
      }
      if (e.newText.length) {
        spans.push(e.newText);
      }
      lastModifiedOffset = document.offsetAt(e.range.end);
    }
    spans.push(text.substr(lastModifiedOffset));
    return spans.join("");
  }
  TextDocument2.applyEdits = applyEdits;
})(TextDocument || (TextDocument = {}));
function mergeSort(data, compare) {
  if (data.length <= 1) {
    return data;
  }
  const p = data.length / 2 | 0;
  const left = data.slice(0, p);
  const right = data.slice(p);
  mergeSort(left, compare);
  mergeSort(right, compare);
  let leftIdx = 0;
  let rightIdx = 0;
  let i = 0;
  while (leftIdx < left.length && rightIdx < right.length) {
    const ret = compare(left[leftIdx], right[rightIdx]);
    if (ret <= 0) {
      data[i++] = left[leftIdx++];
    } else {
      data[i++] = right[rightIdx++];
    }
  }
  while (leftIdx < left.length) {
    data[i++] = left[leftIdx++];
  }
  while (rightIdx < right.length) {
    data[i++] = right[rightIdx++];
  }
  return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
  const result = isAtLineStart ? [textOffset] : [];
  for (let i = 0;i < text.length; i++) {
    const ch = text.charCodeAt(i);
    if (isEOL(ch)) {
      if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
        i++;
      }
      result.push(textOffset + i + 1);
    }
  }
  return result;
}
function isEOL(char) {
  return char === 13 || char === 10;
}
function getWellformedRange(range) {
  const start = range.start;
  const end = range.end;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    return { start: end, end: start };
  }
  return range;
}
function getWellformedEdit(textEdit) {
  const range = getWellformedRange(textEdit.range);
  if (range !== textEdit.range) {
    return { newText: textEdit.newText, range };
  }
  return textEdit;
}

// node_modules/cspell-lib/dist/lib/util/errors.js
import { format } from "node:util";
var allowStringOrUndefined = {
  string: true,
  undefined: true
};
function isError(e) {
  if (e instanceof Error)
    return true;
  if (!e || typeof e !== "object")
    return false;
  const ex = e;
  return typeof ex.name == "string" && typeof ex.message == "string" && typeof ex.stack in allowStringOrUndefined;
}
function toError(e, errorFactory = UnknownError) {
  if (isError(e))
    return e;
  return new errorFactory(e);
}

class UnknownError extends Error {
  cause;
  constructor(cause) {
    super(format(cause));
    this.cause = cause;
  }
}
function catchPromiseError(p, handler) {
  if (p === undefined)
    return;
  return _catchPromiseError(p, handler);
}
async function _catchPromiseError(p, handler) {
  try {
    return await p;
  } catch (e) {
    return handler(e);
  }
}

// node_modules/cspell-lib/dist/lib/events/events.js
class EventEmitter {
  name;
  #listeners = new Set;
  constructor(name) {
    this.name = name;
  }
  on = (listener) => {
    this.#listeners.add(listener);
    return {
      dispose: () => {
        this.#listeners.delete(listener);
      }
    };
  };
  fire(event) {
    let errors;
    for (const listener of this.#listeners) {
      try {
        listener(event);
      } catch (e) {
        errors = errors ?? [];
        errors.push(toError(e));
      }
    }
    return errors;
  }
  dispose = () => {
    this.#listeners.clear();
  };
}

class ClearCacheEvent extends EventEmitter {
  constructor() {
    super(ClearCacheEvent.eventName);
  }
  static eventName = "clear-cache";
}
var clearCacheEvent = new ClearCacheEvent;
function onClearCache(listener) {
  return clearCacheEvent.on(listener);
}
// node_modules/cspell-dictionary/dist/util/AutoCache.js
var CACHE_SIZE = 100;

class Cache01 {
  maxSize;
  hits = 0;
  misses = 0;
  swaps = 0;
  constructor(maxSize) {
    this.maxSize = maxSize;
  }
}

class Cache01Map extends Cache01 {
  count = 0;
  cache0 = new Map;
  cache1 = new Map;
  constructor(maxSize) {
    super(maxSize);
  }
  get(key) {
    const cache0 = this.cache0;
    const cache1 = this.cache1;
    let found = cache0.get(key);
    if (found !== undefined) {
      ++this.hits;
      return found;
    }
    found = cache1.get(key);
    if (found !== undefined) {
      ++this.hits;
      ++this.count;
      cache0.set(key, found);
      return found;
    }
    ++this.misses;
    return;
  }
  set(key, value) {
    if (this.count >= this.maxSize) {
      const c = this.cache1;
      this.cache1 = this.cache0;
      this.cache0 = c;
      c.clear();
      this.swaps++;
      this.count = 0;
    }
    ++this.count;
    this.cache0.set(key, value);
    return this;
  }
}
function createCache01(size) {
  return new Cache01Map(size);
}
function autoCache(fn, size = CACHE_SIZE) {
  const cache = createCache01(size);
  const ac = get;
  ac.hits = 0;
  ac.misses = 0;
  ac.swaps = 0;
  function get(k) {
    const f = cache.get(k);
    if (f !== undefined) {
      ++ac.hits;
      return f;
    }
    const r = fn(k);
    cache.set(k, r);
    ac.swaps = cache.swaps;
    ++ac.misses;
    return r;
  }
  return ac;
}
function extractStats(ac) {
  const { hits, misses, swaps } = ac;
  return { hits, misses, swaps };
}

// node_modules/@cspell/cspell-pipe/dist/helpers/iteratorToIterable.js
function* iteratorToIterable(iterator) {
  try {
    let n;
    while (!(n = iterator.next()).done) {
      yield n.value;
    }
  } catch (e) {
    if (iterator.throw) {
      return iterator.throw(e);
    }
    throw e;
  } finally {
    iterator.return?.();
  }
}
// node_modules/@cspell/cspell-pipe/dist/operators/append.js
function opAppendSync(...iterablesToAppend) {
  function* fnAppend(iter) {
    yield* iter;
    for (const i of iterablesToAppend) {
      yield* i;
    }
  }
  return fnAppend;
}
// node_modules/@cspell/cspell-pipe/dist/operators/combine.js
function opCombineSync(...fns) {
  function combine(iter) {
    for (const fn of fns) {
      iter = fn(iter);
    }
    return iter;
  }
  return combine;
}
// node_modules/@cspell/cspell-pipe/dist/operators/concatMap.js
function opConcatMapSync(mapFn) {
  function fnConcatMapSync(iterable) {
    function opConcatMapIterator() {
      const iter = iterable[Symbol.iterator]();
      let resultsIter = undefined;
      function nextConcatMap() {
        while (true) {
          if (resultsIter) {
            const { done: done2, value: value2 } = resultsIter.next();
            if (!done2) {
              return { value: value2 };
            }
            resultsIter = undefined;
          }
          const { done, value } = iter.next();
          if (done) {
            return { done, value: undefined };
          }
          resultsIter = mapFn(value)[Symbol.iterator]();
        }
      }
      return {
        next: nextConcatMap
      };
    }
    return {
      [Symbol.iterator]: opConcatMapIterator
    };
  }
  return fnConcatMapSync;
}
// node_modules/@cspell/cspell-pipe/dist/operators/filter.js
function opFilterSync(filterFn) {
  function opFilterIterable(iterable) {
    function opFilterIterator() {
      const iter = iterable[Symbol.iterator]();
      function nextOpFilter() {
        while (true) {
          const { done, value } = iter.next();
          if (done)
            return { done, value: undefined };
          if (filterFn(value))
            return { value };
        }
      }
      return {
        next: nextOpFilter
      };
    }
    return {
      [Symbol.iterator]: opFilterIterator
    };
  }
  return opFilterIterable;
}
// node_modules/@cspell/cspell-pipe/dist/operators/flatten.js
function opFlattenSync() {
  function* fn(iter) {
    for (const v of iter) {
      yield* v;
    }
  }
  return fn;
}
// node_modules/@cspell/cspell-pipe/dist/operators/map.js
function opMapSync(mapFn) {
  function opMapIterable(iterable) {
    function opMapIterator() {
      const iter = iterable[Symbol.iterator]();
      function nextOpMap() {
        const { done, value } = iter.next();
        if (done)
          return { done, value: undefined };
        return { value: mapFn(value) };
      }
      return {
        next: nextOpMap
      };
    }
    return {
      [Symbol.iterator]: opMapIterator
    };
  }
  return opMapIterable;
}
// node_modules/@cspell/cspell-pipe/dist/operators/reduce.js
function opReduceSync(reduceFn, initialValue) {
  function* reduce(head, tail) {
    for (const v of tail) {
      head = reduceFn(head, v);
    }
    yield head;
  }
  function* fn(iter) {
    const ht = initialValue === undefined ? headTail(iter) : { head: initialValue, tail: iter };
    if (!ht)
      return;
    yield* reduce(ht.head, ht.tail);
  }
  return fn;
}
function headTail(iter) {
  const iterator = iter[Symbol.iterator]();
  const first = iterator.next();
  if (first.done)
    return;
  return { head: first.value, tail: iteratorToIterable(iterator) };
}
// node_modules/@cspell/cspell-pipe/dist/operators/unique.js
function opUniqueSync(k) {
  function fnK(key) {
    function* fn2(iter) {
      const s = new Set;
      for (const v of iter) {
        const kk = key(v);
        if (s.has(kk))
          continue;
        s.add(kk);
        yield v;
      }
    }
    return fn2;
  }
  function* fn(iter) {
    const s = new Set;
    for (const v of iter) {
      if (s.has(v))
        continue;
      s.add(v);
      yield v;
    }
  }
  return k ? fnK(k) : fn;
}
// node_modules/@cspell/cspell-pipe/dist/pipe.js
function pipeSync(i, ...fns) {
  return opCombineSync(...fns)(i);
}
// node_modules/@cspell/cspell-pipe/dist/reduce.js
function reduceSync(iter, reduceFn, initialValue) {
  const i = initialValue === undefined ? pipeSync(iter, opReduceSync(reduceFn)) : pipeSync(iter, opReduceSync(reduceFn, initialValue));
  return [...i][0];
}
// node_modules/cspell-trie-lib/dist/index.js
import assert from "node:assert";
import assert2 from "node:assert";
import { endianness } from "node:os";
import assert3 from "node:assert";

// node_modules/gensequence/dist/util/util.js
function* toIterableIterator(i) {
  yield* i;
}

// node_modules/gensequence/dist/operators/operatorsBase.js
function* filter(i, fnFilter) {
  for (const v of i) {
    if (fnFilter(v)) {
      yield v;
    }
  }
}
function* skip(i, n) {
  let a = 0;
  for (const t of i) {
    if (a >= n) {
      yield t;
    }
    a += 1;
  }
}
function* take(i, n) {
  let a = 0;
  if (n) {
    for (const t of i) {
      if (a >= n) {
        break;
      }
      yield t;
      a += 1;
    }
  }
}
function* concat(i, j) {
  yield* i;
  yield* j;
}
function* concatMap(i, fn) {
  for (const t of i) {
    yield* fn(t);
  }
}
function* combine(i, j, fnMap) {
  const jit = j[Symbol.iterator]();
  for (const r of i) {
    const s = jit.next().value;
    yield fnMap(r, s);
  }
}
function map(i, fnMap) {
  function* fn(i2, fnMap2) {
    for (const v of i2) {
      yield fnMap2(v);
    }
  }
  return fn(i, fnMap);
}
function* scan(i, fnReduce, initValue) {
  let index = 0;
  if (initValue === undefined) {
    index = 1;
    const iter = i[Symbol.iterator]();
    let r = iter.next();
    if (!r.done)
      yield r.value;
    initValue = r.value;
    i = makeIterable(iter);
  }
  let prevValue = initValue;
  for (const t of i) {
    const nextValue = fnReduce(prevValue, t, index);
    yield nextValue;
    prevValue = nextValue;
    index += 1;
  }
}
function all(i, fn) {
  for (const t of i) {
    if (!fn(t)) {
      return false;
    }
  }
  return true;
}
function any(i, fn) {
  for (const t of i) {
    if (fn(t)) {
      return true;
    }
  }
  return false;
}
function count(i) {
  return reduce(i, (p) => p + 1, 0);
}
function first(i, fn, defaultValue) {
  fn = fn || (() => true);
  for (const t of i) {
    if (fn(t)) {
      return t;
    }
  }
  return defaultValue;
}
function forEach(i, fn) {
  let index = 0;
  for (const t of i) {
    fn(t, index);
    index += 1;
  }
}
function max(i, selector = (t) => t) {
  return reduce(i, (p, c) => selector(c) > selector(p) ? c : p, undefined);
}
function min(i, selector = (t) => t) {
  return reduce(i, (p, c) => selector(c) < selector(p) ? c : p, undefined);
}
function reduce(i, fnReduce, initialValue) {
  const iter = makeIterable(i[Symbol.iterator]());
  let index = 0;
  if (initialValue === undefined) {
    index = 1;
    const r = iter.next();
    initialValue = r.value;
  }
  let prevValue = initialValue;
  for (const t of iter) {
    const nextValue = fnReduce(prevValue, t, index);
    prevValue = nextValue;
    index += 1;
  }
  return prevValue;
}
async function reduceAsync(i, fnReduce, initialValue) {
  const iter = makeIterable(i[Symbol.iterator]());
  let index = 0;
  if (initialValue === undefined) {
    index = 1;
    const r = iter.next();
    initialValue = r.value;
  }
  let previousValue = await initialValue;
  for (const p of iter) {
    const t = await p;
    const nextValue = await fnReduce(previousValue, t, index);
    previousValue = nextValue;
    index += 1;
  }
  return previousValue;
}
function makeIterable(i) {
  function* fromIterator(i2) {
    for (let r = i2.next();!r.done; r = i2.next()) {
      yield r.value;
    }
  }
  function* fromIterable(i2) {
    yield* i2;
  }
  return isIterable(i) ? isIterableIterator(i) ? i : fromIterable(i) : fromIterator(i);
}
function isIterable(i) {
  return !!i[Symbol.iterator];
}
function isIterableIterator(i) {
  return typeof i.next == "function";
}

// node_modules/gensequence/dist/operators/operators.js
function filter2(fnFilter) {
  return (i) => filter(i, fnFilter);
}
function skip2(n) {
  return (i) => skip(i, n);
}
function take2(n) {
  return (i) => take(i, n);
}
function concat2(j) {
  return (i) => concat(i, j);
}
function concatMap2(fn) {
  return (i) => concatMap(i, fn);
}
function combine2(fnMap, j) {
  return (i) => combine(i, j, fnMap);
}
function map2(fnMap) {
  return (i) => map(i, fnMap);
}
function scan2(fnReduce, initValue) {
  return (i) => scan(i, fnReduce, initValue);
}
function all2(fn) {
  return (i) => all(i, fn);
}
function any2(fn) {
  return (i) => any(i, fn);
}
function count2() {
  return (i) => count(i);
}
function first2(fn, defaultValue) {
  return (i) => first(i, fn, defaultValue);
}
function forEach2(fn) {
  return (i) => forEach(i, fn);
}
function max2(selector) {
  return (i) => max(i, selector);
}
function min2(selector) {
  return (i) => min(i, selector);
}
function reduce2(fnReduce, initialValue) {
  return (i) => reduce(i, fnReduce, initialValue);
}
function reduceAsync2(fnReduceAsync, initialValue) {
  return (i) => reduceAsync(i, fnReduceAsync, initialValue);
}
function pipe(...fns) {
  return (i) => {
    for (const fn of fns) {
      i = fn ? fn(i) : i;
    }
    return i;
  };
}

// node_modules/gensequence/dist/ImplSequence.js
class ImplSequence {
  i;
  _iterator;
  constructor(i) {
    this.i = i;
  }
  get iter() {
    return typeof this.i === "function" ? this.i() : this.i;
  }
  get iterator() {
    if (!this._iterator) {
      this._iterator = this.iter[Symbol.iterator]();
    }
    return this._iterator;
  }
  inject(fn) {
    const iter = this.i;
    return () => fn(typeof iter === "function" ? iter() : iter);
  }
  chain(fn) {
    return new ImplSequence(this.inject(fn));
  }
  [Symbol.iterator]() {
    return this.iter[Symbol.iterator]();
  }
  next() {
    return this.iterator.next();
  }
  filter(fnFilter) {
    return this.chain(filter2(fnFilter));
  }
  skip(n) {
    return this.chain(skip2(n));
  }
  take(n) {
    return this.chain(take2(n));
  }
  concat(j) {
    return this.chain(concat2(j));
  }
  concatMap(fn) {
    return this.chain(concatMap2(fn));
  }
  combine(fn, j) {
    return this.chain(combine2(fn, j));
  }
  map(fn) {
    return this.chain(map2(fn));
  }
  scan(fnReduce, initValue) {
    return this.chain(scan2(fnReduce, initValue));
  }
  pipe(...fns) {
    if (!fns.length)
      return this;
    return this.chain(pipe.apply(null, fns));
  }
  all(fnFilter) {
    return all2(fnFilter)(this.iter);
  }
  any(fnFilter) {
    return any2(fnFilter)(this.iter);
  }
  count() {
    return count2()(this.iter);
  }
  first(fnFilter, defaultValue) {
    return first2(fnFilter, defaultValue)(this.iter);
  }
  forEach(fn) {
    return forEach2(fn)(this.iter);
  }
  max(fnSelector) {
    return max2(fnSelector)(this.iter);
  }
  min(fnSelector) {
    return min2(fnSelector)(this.iter);
  }
  reduce(fnReduce, initValue) {
    return reduce2(fnReduce, initValue)(this.iter);
  }
  reduceAsync(fnReduceAsync, initialValue) {
    return reduceAsync2(fnReduceAsync, initialValue)(this.iter);
  }
  reduceToSequence(fnReduce, initialValue) {
    return this.chain(reduce2(fnReduce, initialValue));
  }
  toArray() {
    return [...this.iter];
  }
  toIterable() {
    return toIterableIterator(this.iter);
  }
}

// node_modules/gensequence/dist/GenSequence.js
function genSequence(i) {
  return new ImplSequence(i);
}

// node_modules/cspell-trie-lib/dist/index.js
var SymEmpty = Symbol("memorizeLastCall");
function memorizeLastCall(fn) {
  let lastP = undefined;
  let lastR = SymEmpty;
  function calc(p) {
    if (lastR !== SymEmpty && lastP === p)
      return lastR;
    lastP = p;
    lastR = fn(p);
    return lastR;
  }
  return calc;
}
var defaultLegacyMinCompoundLength = 3;
var _defaultFindOptions = {
  matchCase: false,
  compoundMode: "compound",
  legacyMinCompoundLength: defaultLegacyMinCompoundLength
};
Object.freeze(_defaultFindOptions);
var arrayCompoundModes = ["none", "compound", "legacy"];
var knownCompoundModes = new Map(arrayCompoundModes.map((a) => [a, a]));
var notFound = { found: false, compoundUsed: false, caseMatched: false, forbidden: undefined };
Object.freeze(notFound);
function findWordNode(root, word, options) {
  return _findWordNode(root, word, options);
}
function findWord(root, word, options) {
  if (root.find) {
    const found = root.find(word, options?.matchCase || false);
    if (found)
      return found;
    if (!root.hasCompoundWords) {
      return notFound;
    }
  }
  const v = _findWordNode(root, word, options);
  return {
    found: v.found,
    compoundUsed: v.compoundUsed,
    caseMatched: v.caseMatched,
    forbidden: v.forbidden
  };
}
function _findWordNode(root, word, options) {
  const trieInfo = root.info;
  const matchCase = options?.matchCase || false;
  const compoundMode = knownCompoundModes.get(options?.compoundMode) || _defaultFindOptions.compoundMode;
  const compoundPrefix = compoundMode === "compound" ? trieInfo.compoundCharacter ?? root.compoundFix : "";
  const ignoreCasePrefix = matchCase ? "" : trieInfo.stripCaseAndAccentsPrefix ?? root.caseInsensitivePrefix;
  const checkForbidden = options?.checkForbidden ?? true;
  function __findCompound() {
    const f = findCompoundWord(root, word, compoundPrefix, ignoreCasePrefix);
    const result = { ...f };
    if (f.found !== false && f.compoundUsed) {
      const r = !f.caseMatched ? walk(root, root.caseInsensitivePrefix) : root;
      result.forbidden = checkForbidden ? isForbiddenWord(r, word, root.forbidPrefix) : undefined;
    }
    return result;
  }
  function __findExact() {
    const n = root.getNode ? root.getNode(word) : walk(root, word);
    const isFound = isEndOfWordNode(n);
    const result = {
      found: isFound && word,
      compoundUsed: false,
      forbidden: checkForbidden ? isForbiddenWord(root, word, root.forbidPrefix) : undefined,
      node: n,
      caseMatched: true
    };
    return result;
  }
  switch (compoundMode) {
    case "none": {
      return matchCase ? __findExact() : __findCompound();
    }
    case "compound": {
      return __findCompound();
    }
    case "legacy": {
      return findLegacyCompound(root, word, options);
    }
  }
}
function findLegacyCompound(root, word, options) {
  const roots = [root];
  if (!options?.matchCase) {
    roots.push(walk(root, root.caseInsensitivePrefix));
  }
  return findLegacyCompoundNode(roots, word, options?.legacyMinCompoundLength || defaultLegacyMinCompoundLength);
}
function findCompoundNode(root, word, compoundCharacter, ignoreCasePrefix) {
  const stack = [
    { n: root, compoundPrefix: ignoreCasePrefix, cr: undefined, caseMatched: true }
  ];
  const compoundPrefix = compoundCharacter || ignoreCasePrefix;
  const possibleCompoundPrefix = ignoreCasePrefix && compoundCharacter ? ignoreCasePrefix + compoundCharacter : "";
  const nw = word.normalize();
  const w = [...nw];
  function determineRoot(s) {
    const prefix = s.compoundPrefix;
    let r = root;
    let i2;
    for (i2 = 0;i2 < prefix.length && r; ++i2) {
      r = r.get(prefix[i2]);
    }
    const caseMatched2 = s.caseMatched && prefix[0] !== ignoreCasePrefix;
    return {
      n: s.n,
      compoundPrefix: prefix === compoundPrefix ? possibleCompoundPrefix : "",
      cr: r,
      caseMatched: caseMatched2
    };
  }
  let compoundUsed = false;
  let caseMatched = true;
  let i = 0;
  let node;
  while (true) {
    const s = stack[i];
    const h = w[i++];
    const n = s.cr || s.n;
    const c = h && n?.get(h) || undefined;
    if (c && i < word.length) {
      caseMatched = s.caseMatched;
      stack[i] = { n: c, compoundPrefix, cr: undefined, caseMatched };
    } else if (!c || !c.eow) {
      node = node || c;
      while (--i > 0) {
        const s2 = stack[i];
        if (!s2.compoundPrefix || !s2.n?.hasChildren())
          continue;
        if (s2.n.get(compoundCharacter))
          break;
      }
      if (i >= 0 && stack[i].compoundPrefix) {
        compoundUsed = i > 0;
        const r = determineRoot(stack[i]);
        stack[i] = r;
        if (!r.cr) {
          break;
        }
        if (!i && !r.caseMatched && nw !== nw.toLowerCase()) {
          break;
        }
      } else {
        break;
      }
    } else {
      node = c;
      caseMatched = s.caseMatched;
      break;
    }
  }
  const found = i === word.length && word || false;
  const result = { found, compoundUsed, node, forbidden: undefined, caseMatched };
  return result;
}
function findCompoundWord(root, word, compoundCharacter, ignoreCasePrefix) {
  const { found, compoundUsed, node, caseMatched } = findCompoundNode(root, word, compoundCharacter, ignoreCasePrefix);
  if (!node || !node.eow) {
    return { found: false, compoundUsed, node, forbidden: undefined, caseMatched };
  }
  return { found, compoundUsed, node, forbidden: undefined, caseMatched };
}
function findWordExact(root, word) {
  const r = root;
  if (r?.findExact)
    return r.findExact(word);
  return isEndOfWordNode(walk(root, word));
}
function isEndOfWordNode(n) {
  return !!n?.eow;
}
function walk(root, word) {
  const w = [...word];
  let n = root;
  let i = 0;
  while (n && i < w.length) {
    const h = w[i++];
    n = n.get(h);
  }
  return n;
}
function findLegacyCompoundNode(roots, word, minCompoundLength) {
  const root = roots[0];
  const numRoots = roots.length;
  const stack = [
    { n: root, usedRoots: 1, subLength: 0, isCompound: false, cr: undefined, caseMatched: true }
  ];
  const w = word;
  const wLen = w.length;
  let compoundUsed = false;
  let caseMatched = true;
  let i = 0;
  let node;
  while (true) {
    const s = stack[i];
    const h = w[i++];
    const n = s.cr || s.n;
    const c = n?.get(h);
    if (c && i < wLen) {
      stack[i] = {
        n: c,
        usedRoots: 0,
        subLength: s.subLength + 1,
        isCompound: s.isCompound,
        cr: undefined,
        caseMatched: s.caseMatched
      };
    } else if (!c || !c.eow || c.eow && s.subLength < minCompoundLength - 1) {
      while (--i > 0) {
        const s2 = stack[i];
        if (s2.usedRoots < numRoots && s2.n?.eow && (s2.subLength >= minCompoundLength || !s2.subLength) && wLen - i >= minCompoundLength) {
          break;
        }
      }
      if (i > 0 || stack[i].usedRoots < numRoots) {
        compoundUsed = i > 0;
        const s2 = stack[i];
        s2.cr = roots[s2.usedRoots++];
        s2.subLength = 0;
        s2.isCompound = compoundUsed;
        s2.caseMatched = s2.caseMatched && s2.usedRoots <= 1;
      } else {
        break;
      }
    } else {
      node = c;
      caseMatched = s.caseMatched;
      break;
    }
  }
  function extractWord() {
    if (!word || i < word.length)
      return false;
    const letters = [];
    let subLen = 0;
    for (let j = 0;j < i; ++j) {
      const { subLength } = stack[j];
      if (subLength < subLen) {
        letters.push("+");
      }
      letters.push(word[j]);
      subLen = subLength;
    }
    return letters.join("");
  }
  const found = extractWord();
  const result = { found, compoundUsed, node, forbidden: undefined, caseMatched };
  return result;
}
function isForbiddenWord(root, word, forbiddenPrefix) {
  const r = root;
  if (r?.isForbidden)
    return r.isForbidden(word);
  return findWordExact(root?.get(forbiddenPrefix), word);
}
var createFindOptions = memorizeLastCall(_createFindOptions);
function _createFindOptions(options) {
  if (!options)
    return _defaultFindOptions;
  const d = _defaultFindOptions;
  return {
    matchCase: options.matchCase ?? d.matchCase,
    compoundMode: options.compoundMode ?? d.compoundMode,
    legacyMinCompoundLength: options.legacyMinCompoundLength ?? d.legacyMinCompoundLength,
    checkForbidden: options.checkForbidden ?? d.checkForbidden
  };
}
var JOIN_SEPARATOR = "+";
var WORD_SEPARATOR = " ";
var CompoundWordsMethod = /* @__PURE__ */ ((CompoundWordsMethod2) => {
  CompoundWordsMethod2[CompoundWordsMethod2["NONE"] = 0] = "NONE";
  CompoundWordsMethod2[CompoundWordsMethod2["SEPARATE_WORDS"] = 1] = "SEPARATE_WORDS";
  CompoundWordsMethod2[CompoundWordsMethod2["JOIN_WORDS"] = 2] = "JOIN_WORDS";
  return CompoundWordsMethod2;
})(CompoundWordsMethod || {});
function* compoundWalker(root, compoundingMethod) {
  const empty = Object.freeze([]);
  const roots = {
    [0]: empty,
    [2]: [[JOIN_SEPARATOR, root]],
    [1]: [[WORD_SEPARATOR, root]]
  };
  const rc = roots[compoundingMethod].length ? roots[compoundingMethod] : undefined;
  function children(n) {
    if (n.hasChildren()) {
      const entries = n.entries();
      const c = Array.isArray(entries) ? entries : [...entries];
      return n.eow && rc ? [...c, ...rc] : c;
    }
    if (n.eow) {
      return roots[compoundingMethod];
    }
    return empty;
  }
  let depth = 0;
  const stack = [];
  stack[depth] = { t: "", c: children(root), ci: 0 };
  while (depth >= 0) {
    let s = stack[depth];
    let baseText = s.t;
    while (s.ci < s.c.length) {
      const [char, node] = s.c[s.ci++];
      const text = baseText + char;
      const goDeeper = yield { text, node, depth };
      if (goDeeper ?? true) {
        depth++;
        baseText = text;
        stack[depth] = { t: text, c: children(node), ci: 0 };
      }
      s = stack[depth];
    }
    depth -= 1;
  }
}
function* nodeWalker(root) {
  let depth = 0;
  const stack = [];
  const entries = root.entries();
  stack[depth] = { t: "", n: root, c: Array.isArray(entries) ? entries : [...entries], ci: 0 };
  while (depth >= 0) {
    let s = stack[depth];
    let baseText = s.t;
    while (s.ci < s.c.length && s.n) {
      const idx2 = s.ci++;
      const [char, node] = s.c[idx2];
      const text = baseText + char;
      const goDeeper = yield { text, node, depth };
      if (goDeeper !== false) {
        depth++;
        baseText = text;
        const s2 = stack[depth];
        const entries2 = node.entries();
        const c = Array.isArray(entries2) ? entries2 : [...entries2];
        if (s2) {
          s2.t = text;
          s2.n = node;
          s2.c = c;
          s2.ci = 0;
        } else {
          stack[depth] = { t: text, n: node, c, ci: 0 };
        }
      }
      s = stack[depth];
    }
    depth -= 1;
  }
}
function walker(root, compoundingMethod = 0) {
  return compoundingMethod === 0 ? nodeWalker(root) : compoundWalker(root, compoundingMethod);
}
function walkerWords(root) {
  return walkerWordsITrie(root);
}
function* walkerWordsITrie(root) {
  let depth = 0;
  const stack = [];
  const entries = root.entries();
  const c = Array.isArray(entries) ? entries : [...entries];
  stack[depth] = { t: "", n: root, c, ci: 0 };
  while (depth >= 0) {
    let s = stack[depth];
    let baseText = s.t;
    while (s.ci < s.c.length && s.n) {
      const [char, node] = s.c[s.ci++];
      if (!node)
        continue;
      const text = baseText + char;
      if (node.eow)
        yield text;
      depth++;
      baseText = text;
      const entries2 = node.entries();
      const c2 = Array.isArray(entries2) ? entries2 : [...entries2];
      if (stack[depth]) {
        s = stack[depth];
        s.t = text;
        s.n = node;
        s.c = c2;
        s.ci = 0;
      } else {
        stack[depth] = { t: text, n: node, c: c2, ci: 0 };
      }
      s = stack[depth];
    }
    depth -= 1;
  }
}
function iteratorTrieWords(node) {
  return walkerWords(node);
}
function findNode(node, word) {
  for (let i = 0;i < word.length; ++i) {
    const n = node.get(word[i]);
    if (!n)
      return;
    node = n;
  }
  return node;
}
function countWords(root) {
  const visited = /* @__PURE__ */ new Map;
  function walk4(n) {
    const nestedCount = visited.get(n.id);
    if (nestedCount !== undefined) {
      return nestedCount;
    }
    let cnt = n.eow ? 1 : 0;
    visited.set(n, cnt);
    for (const c of n.values()) {
      cnt += walk4(c);
    }
    visited.set(n, cnt);
    return cnt;
  }
  return walk4(root);
}
function isDefined(t) {
  return t !== undefined;
}
function hintedWalker(root, ignoreCase, hint, compoundingMethod, emitWordSeparator) {
  return hintedWalkerNext(root, ignoreCase, hint, compoundingMethod, emitWordSeparator);
}
function* hintedWalkerNext(root, ignoreCase, hint, compoundingMethod, emitWordSeparator = "") {
  const _compoundingMethod = compoundingMethod ?? 0;
  const compoundCharacter = root.compoundCharacter;
  const noCaseCharacter = root.stripCaseAndAccentsPrefix;
  const rawRoots = [root, ignoreCase ? root.c[noCaseCharacter] : undefined].filter(isDefined);
  const specialRootsPrefix = existMap([compoundCharacter, noCaseCharacter, root.forbiddenWordPrefix]);
  function filterRoot(root2) {
    const children2 = root2.c && Object.entries(root2.c);
    const c = children2?.filter(([v]) => !(v in specialRootsPrefix));
    return {
      c: c && Object.fromEntries(c)
    };
  }
  const roots = rawRoots.map(filterRoot);
  const compoundRoots = rawRoots.map((r) => r.c?.[compoundCharacter]).filter(isDefined);
  const setOfCompoundRoots = new Set(compoundRoots);
  const rootsForCompoundMethods = [...roots, ...compoundRoots];
  const compoundMethodRoots = {
    [0]: [],
    [2]: rootsForCompoundMethods.map((r) => [JOIN_SEPARATOR, r]),
    [1]: rootsForCompoundMethods.map((r) => [WORD_SEPARATOR, r])
  };
  function* children(n, hintOffset) {
    if (n.c) {
      const h = hint.slice(hintOffset, hintOffset + 3) + hint.slice(Math.max(0, hintOffset - 2), hintOffset);
      const hints = new Set(h);
      const c = n.c;
      yield* [...hints].filter((a) => (a in c)).map((letter) => ({
        letter,
        node: c[letter],
        hintOffset: hintOffset + 1
      }));
      hints.add(compoundCharacter);
      yield* Object.entries(c).filter((a) => !hints.has(a[0])).map(([letter, node]) => ({
        letter,
        node,
        hintOffset: hintOffset + 1
      }));
      if (compoundCharacter in c && !setOfCompoundRoots.has(n)) {
        for (const compoundRoot of compoundRoots) {
          for (const child of children(compoundRoot, hintOffset)) {
            const { letter, node, hintOffset: hintOffset2 } = child;
            yield { letter: emitWordSeparator + letter, node, hintOffset: hintOffset2 };
          }
        }
      }
    }
    if (n.f) {
      yield* [...compoundMethodRoots[_compoundingMethod]].map(([letter, node]) => ({
        letter,
        node,
        hintOffset
      }));
    }
  }
  for (const root2 of roots) {
    let depth = 0;
    const stack = [];
    const stackText = [""];
    stack[depth] = children(root2, depth);
    let ir;
    while (depth >= 0) {
      while (!(ir = stack[depth].next()).done) {
        const { letter: char, node, hintOffset } = ir.value;
        const text = stackText[depth] + char;
        const hinting = yield { text, node, depth };
        if (hinting && hinting.goDeeper) {
          depth++;
          stackText[depth] = text;
          stack[depth] = children(node, hintOffset);
        }
      }
      depth -= 1;
    }
  }
}
function existMap(values) {
  const m = /* @__PURE__ */ Object.create(null);
  for (const v of values) {
    m[v] = true;
  }
  return m;
}
function trieRootToITrieRoot(root) {
  return ImplITrieRoot.toITrieNode(root);
}
function trieNodeToITrieNode(node) {
  return ImplITrieNode.toITrieNode(node);
}
var EmptyKeys = Object.freeze([]);
var EmptyValues = Object.freeze([]);
var EmptyEntries = Object.freeze([]);
var ImplITrieNode = class _ImplITrieNode {
  constructor(node) {
    this.node = node;
    this.id = node;
  }
  id;
  _keys;
  get eow() {
    return !!this.node.f;
  }
  get size() {
    if (!this.node.c)
      return 0;
    return this.keys().length;
  }
  keys() {
    if (this._keys)
      return this._keys;
    const keys = this.node.c ? Object.keys(this.node.c) : EmptyKeys;
    this._keys = keys;
    return keys;
  }
  values() {
    return !this.node.c ? EmptyValues : Object.values(this.node.c).map((n) => _ImplITrieNode.toITrieNode(n));
  }
  entries() {
    return !this.node.c ? EmptyEntries : Object.entries(this.node.c).map(([k, n]) => [k, _ImplITrieNode.toITrieNode(n)]);
  }
  get(char) {
    const n = this.node.c?.[char];
    if (!n)
      return;
    return _ImplITrieNode.toITrieNode(n);
  }
  getNode(chars) {
    return this.findNode(chars);
  }
  has(char) {
    const c = this.node.c;
    return c && char in c || false;
  }
  child(keyIdx) {
    const char = this.keys()[keyIdx];
    const n = char && this.get(char);
    if (!n)
      throw new Error("Index out of range.");
    return n;
  }
  hasChildren() {
    return !!this.node.c;
  }
  #findTrieNode(word) {
    let node = this.node;
    for (const char of word) {
      if (!node)
        return;
      node = node.c?.[char];
    }
    return node;
  }
  findNode(word) {
    const node = this.#findTrieNode(word);
    return node && _ImplITrieNode.toITrieNode(node);
  }
  findExact(word) {
    const node = this.#findTrieNode(word);
    return !!node && !!node.f;
  }
  static toITrieNode(node) {
    return new this(node);
  }
};
var ImplITrieRoot = class extends ImplITrieNode {
  constructor(root) {
    super(root);
    this.root = root;
    const { stripCaseAndAccentsPrefix, compoundCharacter, forbiddenWordPrefix, isCaseAware } = root;
    this.info = { stripCaseAndAccentsPrefix, compoundCharacter, forbiddenWordPrefix, isCaseAware };
    this.hasForbiddenWords = !!root.c[forbiddenWordPrefix];
    this.hasCompoundWords = !!root.c[compoundCharacter];
    this.hasNonStrictWords = !!root.c[stripCaseAndAccentsPrefix];
  }
  info;
  hasForbiddenWords;
  hasCompoundWords;
  hasNonStrictWords;
  get eow() {
    return false;
  }
  resolveId(id) {
    const n = id;
    return new ImplITrieNode(n);
  }
  get forbidPrefix() {
    return this.root.forbiddenWordPrefix;
  }
  get compoundFix() {
    return this.root.compoundCharacter;
  }
  get caseInsensitivePrefix() {
    return this.root.stripCaseAndAccentsPrefix;
  }
  static toITrieNode(node) {
    return new this(node);
  }
};
function* compoundWalker2(root, compoundingMethod) {
  const roots = {
    [0]: [],
    [2]: [[JOIN_SEPARATOR, root]],
    [1]: [[WORD_SEPARATOR, root]]
  };
  const rc = roots[compoundingMethod].length ? roots[compoundingMethod] : undefined;
  const empty = [];
  function children(n) {
    if (n.c && n.f && rc) {
      return [...Object.entries(n.c), ...rc];
    }
    if (n.c) {
      return Object.entries(n.c);
    }
    if (n.f && rc) {
      return rc;
    }
    return empty;
  }
  let depth = 0;
  const stack = [];
  stack[depth] = { t: "", c: children(root), ci: 0 };
  while (depth >= 0) {
    let s = stack[depth];
    let baseText = s.t;
    while (s.ci < s.c.length) {
      const [char, node] = s.c[s.ci++];
      const text = baseText + char;
      const goDeeper = yield { text, node, depth };
      if (goDeeper ?? true) {
        depth++;
        baseText = text;
        stack[depth] = { t: text, c: children(node), ci: 0 };
      }
      s = stack[depth];
    }
    depth -= 1;
  }
}
function* nodeWalker2(root) {
  const empty = [];
  function children(n) {
    if (n.c) {
      return Object.keys(n.c);
    }
    return empty;
  }
  let depth = 0;
  const stack = [];
  stack[depth] = { t: "", n: root.c, c: children(root), ci: 0 };
  while (depth >= 0) {
    let s = stack[depth];
    let baseText = s.t;
    while (s.ci < s.c.length && s.n) {
      const char = s.c[s.ci++];
      const node = s.n[char];
      const text = baseText + char;
      const goDeeper = yield { text, node, depth };
      if (goDeeper !== false) {
        depth++;
        baseText = text;
        const s2 = stack[depth];
        const c = children(node);
        if (s2) {
          s2.t = text;
          s2.n = node.c;
          s2.c = c;
          s2.ci = 0;
        } else {
          stack[depth] = { t: text, n: node.c, c, ci: 0 };
        }
      }
      s = stack[depth];
    }
    depth -= 1;
  }
}
var useITrie = false;
var walkerWords2 = useITrie ? _walkerWords2 : _walkerWords;
function* _walkerWords(root) {
  const empty = [];
  function children(n) {
    if (n.c) {
      return Object.keys(n.c);
    }
    return empty;
  }
  let depth = 0;
  const stack = [];
  stack[depth] = { t: "", n: root.c, c: children(root), ci: 0 };
  while (depth >= 0) {
    let s = stack[depth];
    let baseText = s.t;
    while (s.ci < s.c.length && s.n) {
      const char = s.c[s.ci++];
      const node = s.n[char];
      const text = baseText + char;
      if (node.f)
        yield text;
      depth++;
      baseText = text;
      const c = children(node);
      if (stack[depth]) {
        s = stack[depth];
        s.t = text;
        s.n = node.c;
        s.c = c;
        s.ci = 0;
      } else {
        stack[depth] = { t: text, n: node.c, c, ci: 0 };
      }
      s = stack[depth];
    }
    depth -= 1;
  }
}
function walker2(root, compoundingMethod = 0) {
  return compoundingMethod === 0 ? nodeWalker2(root) : compoundWalker2(root, compoundingMethod);
}
function _walkerWords2(root) {
  return walkerWordsITrie2(trieNodeToITrieNode(root));
}
function* walkerWordsITrie2(root) {
  let depth = 0;
  const stack = [];
  stack[depth] = { t: "", n: root, c: [...root.entries()], ci: 0 };
  while (depth >= 0) {
    let s = stack[depth];
    let baseText = s.t;
    while (s.ci < s.c.length && s.n) {
      const [char, node] = s.c[s.ci++];
      if (!node)
        continue;
      const text = baseText + char;
      if (node.eow)
        yield text;
      depth++;
      baseText = text;
      const c = [...node.entries()];
      if (stack[depth]) {
        s = stack[depth];
        s.t = text;
        s.n = node;
        s.c = c;
        s.ci = 0;
      } else {
        stack[depth] = { t: text, n: node, c, ci: 0 };
      }
      s = stack[depth];
    }
    depth -= 1;
  }
}
var defaultGenSuggestionOptions = {
  compoundMethod: 0,
  ignoreCase: true,
  changeLimit: 5
};
var defaultSuggestionOptions = {
  ...defaultGenSuggestionOptions,
  numSuggestions: 8,
  includeTies: true,
  timeout: 5000
};
var keyMapOfGenSuggestionOptionsStrict = {
  changeLimit: "changeLimit",
  compoundMethod: "compoundMethod",
  ignoreCase: "ignoreCase",
  compoundSeparator: "compoundSeparator"
};
var keyMapOfSuggestionOptionsStrict = {
  ...keyMapOfGenSuggestionOptionsStrict,
  filter: "filter",
  includeTies: "includeTies",
  numSuggestions: "numSuggestions",
  timeout: "timeout",
  weightMap: "weightMap"
};
function createSuggestionOptions(...opts) {
  const options = { ...defaultSuggestionOptions };
  const keys = Object.keys(keyMapOfSuggestionOptionsStrict);
  for (const opt of opts) {
    for (const key of keys) {
      assign(options, opt, key);
    }
  }
  return options;
}
function assign(dest, src, k) {
  dest[k] = src[k] ?? dest[k];
}
var PairingHeap = class {
  constructor(compare4) {
    this.compare = compare4;
  }
  _heap;
  _size = 0;
  add(v) {
    this._heap = insert(this.compare, this._heap, v);
    ++this._size;
    return this;
  }
  dequeue() {
    const n = this.next();
    if (n.done)
      return;
    return n.value;
  }
  append(i) {
    for (const v of i) {
      this.add(v);
    }
    return this;
  }
  next() {
    if (!this._heap) {
      return { value: undefined, done: true };
    }
    const value = this._heap.v;
    --this._size;
    this._heap = removeHead(this.compare, this._heap);
    return { value };
  }
  peek() {
    return this._heap?.v;
  }
  [Symbol.iterator]() {
    return this;
  }
  get length() {
    return this._size;
  }
  get size() {
    return this._size;
  }
};
function removeHead(compare4, heap) {
  if (!heap || !heap.c)
    return;
  return mergeSiblings(compare4, heap.c);
}
function insert(compare4, heap, v) {
  const n = {
    v,
    s: undefined,
    c: undefined
  };
  if (!heap || compare4(v, heap.v) <= 0) {
    n.c = heap;
    return n;
  }
  n.s = heap.c;
  heap.c = n;
  return heap;
}
function merge(compare4, a, b) {
  if (compare4(a.v, b.v) <= 0) {
    a.s = undefined;
    b.s = a.c;
    a.c = b;
    return a;
  }
  b.s = undefined;
  a.s = b.c;
  b.c = a;
  return b;
}
function mergeSiblings(compare4, n) {
  if (!n.s)
    return n;
  const s = n.s;
  const ss = s.s;
  const m = merge(compare4, n, s);
  return ss ? merge(compare4, m, mergeSiblings(compare4, ss)) : m;
}
var DEFAULT_COMPOUNDED_WORD_SEPARATOR = "";
var opCosts = {
  baseCost: 100,
  swapCost: 75,
  duplicateLetterCost: 80,
  compound: 1,
  visuallySimilar: 1,
  firstLetterBias: 5,
  wordBreak: 99,
  wordLengthCostFactor: 0.5
};
var intl = new Intl.Collator("en", { sensitivity: "base" });
var compare = intl.compare;
var visualLetterGroups = [
  forms("Aa") + "",
  forms("Bb"),
  forms("cC"),
  forms("Dd"),
  forms("eE"),
  forms("fF"),
  forms("Gg"),
  forms("Hh"),
  forms("Ii"),
  forms("jJ"),
  forms("Kk"),
  forms("Ll"),
  forms("Mm"),
  forms("nN"),
  forms("Oo"),
  forms("Pp"),
  forms("Qq"),
  forms("Rr"),
  forms("sS"),
  forms("tT"),
  forms("uU"),
  forms("Vv"),
  forms("wW"),
  forms("xX"),
  forms("Yy"),
  forms("Zz")
];
function forms(letters) {
  const n = letters.normalize("NFC").replaceAll(/\p{M}/gu, "");
  const na = n.normalize("NFD").replaceAll(/\p{M}/gu, "");
  const s = new Set(n + n.toLowerCase() + n.toUpperCase() + na + na.toLowerCase() + na.toUpperCase());
  return [...s].join("");
}
var visualLetterMaskMap = calcVisualLetterMasks(visualLetterGroups);
function calcVisualLetterMasks(groups) {
  const map3 = /* @__PURE__ */ Object.create(null);
  for (let i = 0;i < groups.length; ++i) {
    const m = 1 << i;
    const g = groups[i];
    for (const c of g) {
      map3[c] = (map3[c] || 0) | m;
    }
  }
  return map3;
}
var matchPossibleWordSeparators = /[+]/g;
function createWeightMap(...defs) {
  const map3 = _createWeightMap();
  addDefsToWeightMap(map3, defs);
  return map3;
}
function addDefToWeightMap(map3, ...defs) {
  return addDefsToWeightMap(map3, defs);
}
function addAdjustment(map3, ...adjustments) {
  for (const adj of adjustments) {
    map3.adjustments.set(adj.id, adj);
  }
  return map3;
}
function addDefsToWeightMap(map3, defs) {
  function addSet(set, def) {
    addSetToTrieCost(map3.insDel, set, def.insDel, def.penalty);
    addSetToTrieTrieCost(map3.replace, set, def.replace, def.penalty);
    addSetToTrieTrieCost(map3.swap, set, def.swap, def.penalty);
  }
  for (const _def of defs) {
    const def = normalizeDef(_def);
    const mapSets = splitMap(def);
    mapSets.forEach((s) => addSet(s, def));
  }
  return map3;
}
function _createWeightMap() {
  return {
    insDel: {},
    replace: {},
    swap: {},
    adjustments: /* @__PURE__ */ new Map
  };
}
function lowest(a, b) {
  if (a === undefined)
    return b;
  if (b === undefined)
    return a;
  return a <= b ? a : b;
}
function highest(a, b) {
  if (a === undefined)
    return b;
  if (b === undefined)
    return a;
  return a >= b ? a : b;
}
function normalize(s) {
  const f = /* @__PURE__ */ new Set([s]);
  f.add(s.normalize("NFC"));
  f.add(s.normalize("NFD"));
  return f;
}
function* splitMapSubstringsIterable(map3) {
  let seq = "";
  let mode = 0;
  for (const char of map3) {
    if (mode && char === ")") {
      yield* normalize(seq);
      mode = 0;
      continue;
    }
    if (mode) {
      seq += char;
      continue;
    }
    if (char === "(") {
      mode = 1;
      seq = "";
      continue;
    }
    yield* normalize(char);
  }
}
function splitMapSubstrings(map3) {
  return [...splitMapSubstringsIterable(map3)];
}
function splitMap(def) {
  const { map: map3 } = def;
  const sets = map3.split("|");
  return sets.map(splitMapSubstrings).filter((s) => s.length > 0);
}
function addToTrieCost(trie, str, cost, penalties) {
  if (!str)
    return;
  let t = trie;
  for (const c of str) {
    const n = t.n = t.n || /* @__PURE__ */ Object.create(null);
    t = n[c] = n[c] || /* @__PURE__ */ Object.create(null);
  }
  t.c = lowest(t.c, cost);
  t.p = highest(t.p, penalties);
}
function addToTrieTrieCost(trie, left, right, cost, penalties) {
  let t = trie;
  for (const c of left) {
    const n = t.n = t.n || /* @__PURE__ */ Object.create(null);
    t = n[c] = n[c] || /* @__PURE__ */ Object.create(null);
  }
  const trieCost = t.t = t.t || /* @__PURE__ */ Object.create(null);
  addToTrieCost(trieCost, right, cost, penalties);
}
function addSetToTrieCost(trie, set, cost, penalties) {
  if (cost === undefined)
    return;
  for (const str of set) {
    addToTrieCost(trie, str, cost, penalties);
  }
}
function addSetToTrieTrieCost(trie, set, cost, penalties) {
  if (cost === undefined)
    return;
  for (const left of set) {
    for (const right of set) {
      if (left === right)
        continue;
      addToTrieTrieCost(trie, left, right, cost, penalties);
    }
  }
}
function* searchTrieNodes(trie, str, i) {
  const len = str.length;
  for (let n = trie.n;i < len && n; ) {
    const t = n[str[i]];
    if (!t)
      return;
    ++i;
    yield { i, t };
    n = t.n;
  }
}
function* findTrieCostPrefixes(trie, str, i) {
  for (const n of searchTrieNodes(trie, str, i)) {
    const { c, p } = n.t;
    if (c !== undefined) {
      yield { i: n.i, c, p: p || 0 };
    }
  }
}
function* findTrieTrieCostPrefixes(trie, str, i) {
  for (const n of searchTrieNodes(trie, str, i)) {
    const t = n.t.t;
    if (t !== undefined) {
      yield { i: n.i, t };
    }
  }
}
function createWeightCostCalculator(weightMap) {
  return new _WeightCostCalculator(weightMap);
}
var _WeightCostCalculator = class {
  constructor(weightMap) {
    this.weightMap = weightMap;
  }
  *calcInsDelCosts(pos) {
    const { a, ai, b, bi, c, p } = pos;
    for (const del of findTrieCostPrefixes(this.weightMap.insDel, a, ai)) {
      yield { a, b, ai: del.i, bi, c: c + del.c, p: p + del.p };
    }
    for (const ins of findTrieCostPrefixes(this.weightMap.insDel, b, bi)) {
      yield { a, b, ai, bi: ins.i, c: c + ins.c, p: p + ins.p };
    }
  }
  *calcReplaceCosts(pos) {
    const { a, ai, b, bi, c, p } = pos;
    for (const del of findTrieTrieCostPrefixes(this.weightMap.replace, a, ai)) {
      for (const ins of findTrieCostPrefixes(del.t, b, bi)) {
        yield { a, b, ai: del.i, bi: ins.i, c: c + ins.c, p: p + ins.p };
      }
    }
  }
  *calcSwapCosts(pos) {
    const { a, ai, b, bi, c, p } = pos;
    const swap = this.weightMap.swap;
    for (const left of findTrieTrieCostPrefixes(swap, a, ai)) {
      for (const right of findTrieCostPrefixes(left.t, a, left.i)) {
        const sw = a.slice(left.i, right.i) + a.slice(ai, left.i);
        if (b.slice(bi).startsWith(sw)) {
          const len = sw.length;
          yield { a, b, ai: ai + len, bi: bi + len, c: c + right.c, p: p + right.p };
        }
      }
    }
  }
  calcAdjustment(word) {
    let penalty = 0;
    for (const adj of this.weightMap.adjustments.values()) {
      if (adj.regexp.global) {
        for (const _m of word.matchAll(adj.regexp)) {
          penalty += adj.penalty;
        }
      } else if (adj.regexp.test(word)) {
        penalty += adj.penalty;
      }
    }
    return penalty;
  }
};
function normalizeDef(def) {
  const { map: map3, ...rest } = def;
  return { ...rest, map: normalizeMap(map3) };
}
function normalizeMap(map3) {
  return map3.replaceAll(matchPossibleWordSeparators, DEFAULT_COMPOUNDED_WORD_SEPARATOR);
}
function distanceAStarWeighted(wordA, wordB, map3, cost = 100) {
  const calc = createWeightCostCalculator(map3);
  const best = _distanceAStarWeightedEx(wordA, wordB, calc, cost);
  const penalty = calc.calcAdjustment(wordB);
  return best.c + best.p + penalty;
}
function _distanceAStarWeightedEx(wordA, wordB, map3, cost = 100) {
  const a = "^" + wordA + "$";
  const b = "^" + wordB + "$";
  const aN = a.length;
  const bN = b.length;
  const candidates = new CandidatePool(aN, bN);
  candidates.add({ ai: 0, bi: 0, c: 0, p: 0, f: undefined });
  function opSub(n) {
    const { ai, bi, c, p } = n;
    if (ai < aN && bi < bN) {
      const cc = a[ai] === b[bi] ? c : c + cost;
      candidates.add({ ai: ai + 1, bi: bi + 1, c: cc, p, f: n });
    }
  }
  function opIns(n) {
    const { ai, bi, c, p } = n;
    if (bi < bN) {
      candidates.add({ ai, bi: bi + 1, c: c + cost, p, f: n });
    }
  }
  function opDel(n) {
    const { ai, bi, c, p } = n;
    if (ai < aN) {
      candidates.add({ ai: ai + 1, bi, c: c + cost, p, f: n });
    }
  }
  function opSwap(n) {
    const { ai, bi, c, p } = n;
    if (a[ai] === b[bi + 1] && a[ai + 1] === b[bi]) {
      candidates.add({ ai: ai + 2, bi: bi + 2, c: c + cost, p, f: n });
    }
  }
  function opMap7(n) {
    const { ai, bi, c, p } = n;
    const pos = { a, b, ai, bi, c, p };
    const costCalculations = [map3.calcInsDelCosts(pos), map3.calcSwapCosts(pos), map3.calcReplaceCosts(pos)];
    costCalculations.forEach((iter) => {
      for (const nn of iter) {
        candidates.add({ ...nn, f: n });
      }
    });
  }
  let best;
  while (best = candidates.next()) {
    if (best.ai === aN && best.bi === bN)
      break;
    opSwap(best);
    opIns(best);
    opDel(best);
    opMap7(best);
    opSub(best);
  }
  assert(best);
  return best;
}
var CandidatePool = class {
  constructor(aN, bN) {
    this.aN = aN;
    this.bN = bN;
  }
  pool = new PairingHeap(compare2);
  grid = [];
  next() {
    let n;
    while (n = this.pool.dequeue()) {
      if (!n.d)
        return n;
    }
    return;
  }
  add(n) {
    const i = idx(n.ai, n.bi, this.bN);
    const g = this.grid[i];
    if (!g) {
      this.grid[i] = n;
      this.pool.add(n);
      return;
    }
    if (g.c <= n.c)
      return;
    g.d = true;
    this.grid[i] = n;
    this.pool.add(n);
  }
};
function idx(r, c, cols) {
  return r * cols + c;
}
function compare2(a, b) {
  return a.c - b.c || b.ai + b.bi - a.ai - a.bi;
}
var initialRow = [...".".repeat(50)].map((_, i) => i);
Object.freeze(initialRow);
var defaultCost = 100;
function editDistanceWeighted(wordA, wordB, weights, editCost = defaultCost) {
  return distanceAStarWeighted(wordA, wordB, weights, editCost);
}
function startTimer() {
  const start = performance.now();
  return () => performance.now() - start;
}
function createPerfTimer() {
  const timer = startTimer();
  const active = /* @__PURE__ */ new Map;
  const events = [{ name: "start", at: 0 }];
  function updateEvent(event, atTime = timer()) {
    const elapsed = atTime - event.at;
    event.elapsed = (event.elapsed || 0) + elapsed;
    return elapsed;
  }
  function start(name) {
    const event = createEvent(name || "start");
    events.push(event);
    name && active.set(name, event);
    return () => updateEvent(event);
  }
  function stop(name) {
    const knownEvent = name && active.get(name);
    if (knownEvent) {
      return updateEvent(knownEvent);
    }
    return mark(name || "stop");
  }
  function createEvent(name) {
    return { name, at: timer() };
  }
  function mark(name) {
    const event = createEvent(name);
    events.push(event);
    return event.at;
  }
  function formatReport() {
    const lineElements = [
      { name: "Event Name", at: "Time", elapsed: "Elapsed" },
      { name: "----------", at: "----", elapsed: "-------" },
      ...mapEvents()
    ];
    function mapEvents() {
      const stack = [];
      return events.map((e) => {
        for (let s = stack.pop();s; s = stack.pop()) {
          if (s >= e.at + (e.elapsed || 0)) {
            stack.push(s);
            break;
          }
        }
        const d = stack.length;
        if (e.elapsed) {
          stack.push(e.at + e.elapsed);
        }
        return {
          name: "| ".repeat(d) + (e.name || "").replaceAll("\t", "  "),
          at: `${t(e.at)}`,
          elapsed: e.elapsed ? `${t(e.elapsed)}` : "--"
        };
      });
    }
    function t(ms) {
      return ms.toFixed(3) + "ms";
    }
    function m(v, s) {
      return Math.max(v, s.length);
    }
    const lengths = lineElements.reduce((a, b) => ({ name: m(a.name, b.name), at: m(a.at, b.at), elapsed: m(a.elapsed, b.elapsed) }), { name: 0, at: 0, elapsed: 0 });
    const lines = lineElements.map((e) => `${e.at.padStart(lengths.at)}  ${e.name.padEnd(lengths.name)}  ${e.elapsed.padStart(lengths.elapsed)}`);
    return lines.join(`
`);
  }
  function measureFn(name, fn) {
    const s = start(name);
    const v = fn();
    s();
    return v;
  }
  async function measureAsyncFn(name, fn) {
    const s = start(name);
    const v = await fn();
    s();
    return v;
  }
  function report(reporter = console.log) {
    reporter(formatReport());
  }
  return {
    start,
    stop,
    mark,
    elapsed: timer,
    report,
    formatReport,
    measureFn,
    measureAsyncFn
  };
}
var globalPerfTimer = undefined;
function getGlobalPerfTimer() {
  const timer = globalPerfTimer || createPerfTimer();
  globalPerfTimer = timer;
  return timer;
}
function isDefined2(a) {
  return a !== undefined;
}
function cleanCopy(t) {
  const r = { ...t };
  return clean(r);
}
function clean(t) {
  for (const prop in t) {
    if (t[prop] === undefined) {
      delete t[prop];
    }
  }
  return t;
}
function unique(a) {
  return [...new Set(a)];
}
function regexQuote(text) {
  return text.replaceAll(/([[\]\-+(){},|*.\\])/g, "\\$1");
}
function replaceAllFactory(match, replaceWithText) {
  const r = RegExp(regexQuote(match), "g");
  return (text) => text.replace(r, replaceWithText);
}
var defaultMaxNumberSuggestions = 10;
var BASE_COST = 100;
var MAX_NUM_CHANGES = 5;
var MAX_COST_SCALE = 0.5;
var MAX_ALLOWED_COST_SCALE = 1.03 * MAX_COST_SCALE;
var collator = new Intl.Collator;
var regexSeparator = new RegExp(`[${regexQuote(WORD_SEPARATOR)}]`, "g");
var wordLengthCost = [0, 50, 25, 5, 0];
var EXTRA_WORD_COST = 5;
var DEFAULT_COLLECTOR_TIMEOUT = 1000;
var symStopProcessing = Symbol("Collector Stop Processing");
function compSuggestionResults(a, b) {
  const aPref = a.isPreferred && -1 || 0;
  const bPref = b.isPreferred && -1 || 0;
  return aPref - bPref || a.cost - b.cost || a.word.length - b.word.length || collator.compare(a.word, b.word);
}
var defaultSuggestionCollectorOptions = Object.freeze({
  numSuggestions: defaultMaxNumberSuggestions,
  filter: () => true,
  changeLimit: MAX_NUM_CHANGES,
  includeTies: false,
  ignoreCase: true,
  timeout: DEFAULT_COLLECTOR_TIMEOUT,
  weightMap: undefined,
  compoundSeparator: "",
  compoundMethod: undefined
});
function suggestionCollector(wordToMatch, options) {
  const {
    filter: filter3 = () => true,
    changeLimit = MAX_NUM_CHANGES,
    includeTies = false,
    ignoreCase = true,
    timeout = DEFAULT_COLLECTOR_TIMEOUT,
    weightMap,
    compoundSeparator = defaultSuggestionCollectorOptions.compoundSeparator
  } = options;
  const numSuggestions = Math.max(options.numSuggestions, 0) || 0;
  const numSugToHold = weightMap ? numSuggestions * 2 : numSuggestions;
  const sugs = /* @__PURE__ */ new Map;
  let maxCost = BASE_COST * Math.min(wordToMatch.length * MAX_ALLOWED_COST_SCALE, changeLimit);
  const useSeparator = compoundSeparator || (weightMap ? DEFAULT_COMPOUNDED_WORD_SEPARATOR : defaultSuggestionCollectorOptions.compoundSeparator);
  const fnCleanWord = !useSeparator || useSeparator === compoundSeparator ? (w) => w : replaceAllFactory(useSeparator, "");
  if (useSeparator && weightMap) {
    addDefToWeightMap(weightMap, { map: useSeparator, insDel: 50 });
  }
  const genSuggestionOptions = clean({
    changeLimit,
    ignoreCase,
    compoundMethod: options.compoundMethod,
    compoundSeparator: useSeparator
  });
  let timeRemaining = timeout;
  function dropMax() {
    if (sugs.size < 2 || !numSuggestions) {
      sugs.clear();
      return;
    }
    const sorted = [...sugs.values()].sort(compSuggestionResults);
    let i = numSugToHold - 1;
    maxCost = sorted[i].cost;
    for (;i < sorted.length && sorted[i].cost <= maxCost; ++i) {
    }
    for (;i < sorted.length; ++i) {
      sugs.delete(sorted[i].word);
    }
  }
  function adjustCost(sug) {
    if (sug.isPreferred)
      return sug;
    const words = sug.word.split(regexSeparator);
    const extraCost = words.map((w) => wordLengthCost[w.length] || 0).reduce((a, b) => a + b, 0) + (words.length - 1) * EXTRA_WORD_COST;
    return { word: sug.word, cost: sug.cost + extraCost };
  }
  function collectSuggestion(suggestion) {
    const { word, cost, isPreferred } = adjustCost(suggestion);
    if (cost <= maxCost && filter3(suggestion.word, cost)) {
      const known = sugs.get(word);
      if (known) {
        known.cost = Math.min(known.cost, cost);
        known.isPreferred = known.isPreferred || isPreferred;
      } else {
        sugs.set(word, { word, cost, isPreferred });
        if (cost < maxCost && sugs.size > numSugToHold) {
          dropMax();
        }
      }
    }
    return maxCost;
  }
  function collect(src, timeout2, filter22) {
    let stop = false;
    timeout2 = timeout2 ?? timeRemaining;
    timeout2 = Math.min(timeout2, timeRemaining);
    if (timeout2 < 0)
      return;
    const timer = startTimer();
    let ir;
    while (!(ir = src.next(stop || maxCost)).done) {
      if (timer() > timeout2) {
        stop = symStopProcessing;
      }
      const { value } = ir;
      if (!value)
        continue;
      if (isSuggestionResult(value)) {
        if (!filter22 || filter22(value.word, value.cost)) {
          collectSuggestion(value);
        }
        continue;
      }
    }
    timeRemaining -= timer();
  }
  function cleanCompoundResult(sr) {
    const { word, cost } = sr;
    const cWord = fnCleanWord(word);
    if (cWord !== word) {
      return {
        word: cWord,
        cost,
        compoundWord: word,
        isPreferred: undefined
      };
    }
    return { ...sr };
  }
  function suggestions() {
    if (numSuggestions < 1 || !sugs.size)
      return [];
    const NF = "NFD";
    const nWordToMatch = wordToMatch.normalize(NF);
    const rawValues = [...sugs.values()];
    const values = weightMap ? rawValues.map(({ word, cost, isPreferred }) => ({
      word,
      cost: isPreferred ? cost : editDistanceWeighted(nWordToMatch, word.normalize(NF), weightMap, 110),
      isPreferred
    })) : rawValues;
    const sorted = values.sort(compSuggestionResults).map(cleanCompoundResult);
    let i = Math.min(sorted.length, numSuggestions) - 1;
    const limit = includeTies ? sorted.length : Math.min(sorted.length, numSuggestions);
    const iCost = sorted[i].cost;
    const maxCost2 = Math.min(iCost, weightMap ? changeLimit * BASE_COST - 1 : iCost);
    for (i = 1;i < limit && sorted[i].cost <= maxCost2; ++i) {
    }
    sorted.length = i;
    return sorted;
  }
  const collector = {
    collect,
    add: function(suggestion) {
      collectSuggestion(suggestion);
      return this;
    },
    get suggestions() {
      return suggestions();
    },
    get maxCost() {
      return maxCost;
    },
    get word() {
      return wordToMatch;
    },
    get maxNumSuggestions() {
      return numSuggestions;
    },
    get changeLimit() {
      return changeLimit;
    },
    includesTies: includeTies,
    ignoreCase,
    symbolStopProcessing: symStopProcessing,
    genSuggestionOptions
  };
  return collector;
}
function impersonateCollector(collector, word) {
  const r = Object.create(collector);
  Object.defineProperty(r, "word", { value: word, writable: false });
  return r;
}
function isSuggestionResult(s) {
  const r = s;
  return !!r && typeof r === "object" && r?.cost !== undefined && r.word != null;
}
function comparePath(a, b) {
  return a.c / (a.i + 1) - b.c / (b.i + 1) + (b.i - a.i);
}
function suggestAStar(trie, word, options = {}) {
  const opts = createSuggestionOptions(options);
  const collector = suggestionCollector(word, opts);
  collector.collect(getSuggestionsAStar(trie, word, opts));
  return collector.suggestions;
}
function* getSuggestionsAStar(trie, srcWord, options = {}) {
  const { compoundMethod, changeLimit, ignoreCase, weightMap } = createSuggestionOptions(options);
  const visMap = visualLetterMaskMap;
  const root = trie.getRoot();
  const rootIgnoreCase = ignoreCase && root.get(root.info.stripCaseAndAccentsPrefix) || undefined;
  const pathHeap = new PairingHeap(comparePath);
  const resultHeap = new PairingHeap(compareSuggestion);
  const rootPNode = { n: root, i: 0, c: 0, s: "", p: undefined, t: createCostTrie() };
  const BC = opCosts.baseCost;
  const VC = opCosts.visuallySimilar;
  const DL = opCosts.duplicateLetterCost;
  const wordSeparator = compoundMethod === 2 ? JOIN_SEPARATOR : WORD_SEPARATOR;
  const sc = specialChars(trie.info);
  const comp = trie.info.compoundCharacter;
  const compRoot = root.get(comp);
  const compRootIgnoreCase = rootIgnoreCase && rootIgnoreCase.get(comp);
  const emitted = /* @__PURE__ */ Object.create(null);
  const srcLetters = [...srcWord];
  let limit = BC * Math.min(srcLetters.length * opCosts.wordLengthCostFactor, changeLimit);
  pathHeap.add(rootPNode);
  if (rootIgnoreCase) {
    pathHeap.add({ n: rootIgnoreCase, i: 0, c: 0, s: "", p: undefined, t: createCostTrie() });
  }
  let best = pathHeap.dequeue();
  let maxSize = pathHeap.size;
  let suggestionsGenerated = 0;
  let nodesProcessed = 0;
  let nodesProcessedLimit = 1000;
  let minGen = 1;
  while (best) {
    if (++nodesProcessed > nodesProcessedLimit) {
      nodesProcessedLimit += 1000;
      if (suggestionsGenerated < minGen) {
        break;
      }
      minGen += suggestionsGenerated;
    }
    if (best.c > limit) {
      best = pathHeap.dequeue();
      maxSize = Math.max(maxSize, pathHeap.size);
      continue;
    }
    processPath(best);
    for (const sug of resultHeap) {
      ++suggestionsGenerated;
      if (sug.cost > limit)
        continue;
      if (sug.word in emitted && emitted[sug.word] <= sug.cost)
        continue;
      const action = yield sug;
      emitted[sug.word] = sug.cost;
      if (typeof action === "number") {
        limit = Math.min(action, limit);
      }
      if (typeof action === "symbol") {
        return;
      }
    }
    best = pathHeap.dequeue();
    maxSize = Math.max(maxSize, pathHeap.size);
  }
  return;
  function compareSuggestion(a, b) {
    const pa = a.isPreferred && 1 || 0;
    const pb = b.isPreferred && 1 || 0;
    return pb - pa || a.cost - b.cost || Math.abs(a.word.charCodeAt(0) - srcWord.charCodeAt(0)) - Math.abs(b.word.charCodeAt(0) - srcWord.charCodeAt(0));
  }
  function processPath(p) {
    const len = srcLetters.length;
    if (p.n.eow && p.i === len) {
      const word = pNodeToWord(p);
      const result = { word, cost: p.c };
      resultHeap.add(result);
    }
    calcEdges(p);
  }
  function calcEdges(p) {
    const { n, i, t } = p;
    const s = srcLetters[i];
    const sg = visMap[s] || 0;
    const cost0 = p.c;
    const cost = cost0 + BC + (i ? 0 : opCosts.firstLetterBias);
    const costVis = cost0 + VC;
    const costLegacyCompound = cost0 + opCosts.wordBreak;
    const costCompound = cost0 + opCosts.compound;
    if (s) {
      const m = n.get(s);
      if (m) {
        storePath(t, m, i + 1, cost0, s, p, "=", s);
      }
      if (weightMap) {
        processWeightMapEdges(p, weightMap);
      }
      const ns = srcLetters[i + 1];
      if (s == ns && m) {
        storePath(t, m, i + 2, cost0 + DL, s, p, "dd", s);
      }
      storePath(t, n, i + 1, cost, "", p, "d", "");
      for (const [ss, node] of n.entries()) {
        if (node.id === m?.id || ss in sc)
          continue;
        const g = visMap[ss] || 0;
        const c = sg & g ? costVis : cost;
        storePath(t, node, i + 1, c, ss, p, "r", ss);
      }
      if (n.eow && i && compoundMethod) {
        storePath(t, root, i, costLegacyCompound, wordSeparator, p, "L", wordSeparator);
      }
      if (ns) {
        const n1 = n.get(ns);
        const n2 = n1?.get(s);
        if (n2) {
          const ss = ns + s;
          storePath(t, n2, i + 2, cost0 + opCosts.swapCost, ss, p, "s", ss);
        }
      }
    }
    if (compRoot && costCompound <= limit && n.get(comp)) {
      if (compRootIgnoreCase) {
        storePath(t, compRootIgnoreCase, i, costCompound, "", p, "~+", "~+");
      }
      storePath(t, compRoot, i, costCompound, "", p, "+", "+");
    }
    if (cost <= limit) {
      for (const [char, node] of n.entries()) {
        if (char in sc)
          continue;
        storePath(t, node, i, cost, char, p, "i", char);
      }
    }
  }
  function processWeightMapEdges(p, weightMap2) {
    delLetters(p, weightMap2, srcLetters, storePath);
    insLetters(p, weightMap2, srcLetters, storePath);
    repLetters(p, weightMap2, srcLetters, storePath);
    return;
  }
  function storePath(t, n, i, c, s, p, a, ss) {
    const tt = getCostTrie(t, ss);
    const curr = tt.c[i];
    if (curr <= c || c > limit)
      return;
    tt.c[i] = c;
    pathHeap.add({ n, i, c, s, p, t: tt, a });
  }
}
function delLetters(pNode, weightMap, letters, storePath) {
  const { t, n } = pNode;
  const trie = weightMap.insDel;
  let ii = pNode.i;
  const cost0 = pNode.c - pNode.i;
  const len = letters.length;
  for (let nn = trie.n;ii < len && nn; ) {
    const tt = nn[letters[ii]];
    if (!tt)
      return;
    ++ii;
    if (tt.c !== undefined) {
      storePath(t, n, ii, cost0 + tt.c, "", pNode, "d", "");
    }
    nn = tt.n;
  }
}
function insLetters(p, weightMap, _letters, storePath) {
  const { t, i, c, n } = p;
  const cost0 = c;
  searchTrieCostNodesMatchingTrie2(weightMap.insDel, n, (s, tc, n2) => {
    if (tc.c !== undefined) {
      storePath(t, n2, i, cost0 + tc.c, s, p, "i", s);
    }
  });
}
function repLetters(pNode, weightMap, letters, storePath) {
  const node = pNode.n;
  const pt = pNode.t;
  const cost0 = pNode.c;
  const len = letters.length;
  const trie = weightMap.replace;
  let i = pNode.i;
  for (let n = trie.n;i < len && n; ) {
    const t = n[letters[i]];
    if (!t)
      return;
    ++i;
    const tInsert = t.t;
    if (tInsert) {
      searchTrieCostNodesMatchingTrie2(tInsert, node, (s, tt, n2) => {
        const c = tt.c;
        if (c === undefined) {
          return;
        }
        storePath(pt, n2, i, cost0 + c + (tt.p || 0), s, pNode, "r", s);
      });
    }
    n = t.n;
  }
}
function createCostTrie() {
  return { c: [], t: /* @__PURE__ */ Object.create(null) };
}
function getCostTrie(t, s) {
  if (s.length == 1) {
    return t.t[s] ??= createCostTrie();
  }
  if (!s) {
    return t;
  }
  let tt = t;
  for (const c of s) {
    tt = tt.t[c] ??= createCostTrie();
  }
  return tt;
}
function pNodeToWord(p) {
  const parts = [];
  let n = p;
  while (n) {
    parts.push(n.s);
    n = n.p;
  }
  parts.reverse();
  return parts.join("");
}
function specialChars(options) {
  const charSet = /* @__PURE__ */ Object.create(null);
  for (const c of Object.values(options)) {
    charSet[c] = true;
  }
  return charSet;
}
function searchTrieCostNodesMatchingTrie2(trie, node, emit, s = "") {
  const n = trie.n;
  if (!n)
    return;
  for (const [key, c] of node.entries()) {
    const t = n[key];
    if (!t)
      continue;
    const pfx = s + key;
    emit(pfx, t, c);
    if (t.n) {
      searchTrieCostNodesMatchingTrie2(t, c, emit, pfx);
    }
  }
}
var COMPOUND_FIX = "+";
var OPTIONAL_COMPOUND_FIX = "*";
var CASE_INSENSITIVE_PREFIX = "~";
var FORBID_PREFIX = "!";
var LINE_COMMENT = "#";
var IDENTITY_PREFIX = "=";
var defaultTrieInfo = Object.freeze({
  compoundCharacter: COMPOUND_FIX,
  forbiddenWordPrefix: FORBID_PREFIX,
  stripCaseAndAccentsPrefix: CASE_INSENSITIVE_PREFIX,
  isCaseAware: true,
  hasForbiddenWords: false,
  hasCompoundWords: false,
  hasNonStrictWords: false
});
function mergeDefaults(value, defaultValue) {
  const result = { ...defaultValue };
  if (value) {
    for (const [k, v] of Object.entries(value)) {
      if (k in result) {
        result[k] = v ?? result[k];
      }
    }
  }
  return result;
}
function mergeOptionalWithDefaults(...options) {
  return options.reduce((acc, opt) => mergeDefaults(opt, acc), defaultTrieInfo);
}
function expandCharacterSet(line, rangeChar = "-") {
  const charSet = /* @__PURE__ */ new Set;
  let mode = 0;
  let prev = "";
  for (const char of line) {
    if (mode) {
      expandRange(prev, char).forEach((a) => charSet.add(a));
      mode = 0;
    }
    if (char === rangeChar && prev) {
      mode = 1;
      continue;
    }
    charSet.add(char);
    prev = char;
  }
  if (mode)
    charSet.add(rangeChar);
  return charSet;
}
function expandRange(a, b) {
  const values = [];
  const end = b.codePointAt(0);
  const begin = a.codePointAt(0);
  if (!(begin && end))
    return values;
  for (let i = begin;i <= end; ++i) {
    values.push(String.fromCodePoint(i));
  }
  return values;
}
function caseForms(letter, locale) {
  const forms2 = /* @__PURE__ */ new Set([letter]);
  function tryCases(s) {
    forms2.add(s.toLocaleLowerCase(locale));
    forms2.add(s.toLocaleUpperCase(locale));
  }
  tryCases(letter);
  [...forms2].forEach(tryCases);
  return [...forms2].filter((a) => !!a);
}
function accentForms(letter) {
  const forms2 = /* @__PURE__ */ new Set([letter, letter.normalize("NFC"), letter.normalize("NFD")]);
  return forms2;
}
function stripAccents(characters) {
  return characters.normalize("NFD").replaceAll(/\p{M}/gu, "");
}
function stripNonAccents(characters) {
  return characters.normalize("NFD").replaceAll(/[^\p{M}]/gu, "");
}
function isValidUtf16Character(char) {
  const len = char.length;
  const code = char.charCodeAt(0) & 64512;
  const valid = len === 1 && (code & 63488) !== 55296 || len === 2 && (code & 64512) === 55296 && (char.charCodeAt(1) & 64512) === 56320;
  return valid;
}
function assertValidUtf16Character(char) {
  if (!isValidUtf16Character(char)) {
    const len = char.length;
    const codes2 = toCharCodes(char.slice(0, 2)).map((c) => "0x" + ("0000" + c.toString(16)).slice(-4));
    let message;
    if (len == 1) {
      message = `Invalid utf16 character, lone surrogate: ${codes2[0]}`;
    } else if (len == 2) {
      message = `Invalid utf16 character, not a valid surrogate pair: [${codes2.join(", ")}]`;
    } else {
      message = `Invalid utf16 character, must be a single character, found: ${len}`;
    }
    throw new Error(message);
  }
}
function toCharCodes(s) {
  const values = [];
  for (let i = 0;i < s.length; ++i) {
    values.push(s.charCodeAt(i));
  }
  return values;
}
function encodeUtf8N_BE(code) {
  if (code < 128) {
    return code;
  }
  if (code < 2048) {
    return 49280 | (code & 1984) << 2 | code & 63;
  }
  if (code < 65536) {
    return 14712960 | (code & 61440) << 4 | (code & 4032) << 2 | code & 63;
  }
  return 4034953344 + ((code & 1835008) << 6 | (code & 258048) << 4 | (code & 4032) << 2 | code & 63);
}
var Utf8Accumulator = class _Utf8Accumulator {
  remaining = 0;
  value = 0;
  decode(byte) {
    let remaining = this.remaining;
    if (byte & ~255)
      return this.reset();
    if ((byte & 128) === 0) {
      if (remaining)
        return this.reset();
      return byte;
    }
    if (remaining) {
      if ((byte & 192) !== 128)
        return this.reset();
      let value = this.value;
      value = value << 6 | byte & 63;
      this.value = value;
      remaining -= 1;
      this.remaining = remaining;
      return remaining ? undefined : value;
    }
    if ((byte & 224) === 192) {
      this.value = byte & 31;
      this.remaining = 1;
      return;
    }
    if ((byte & 240) === 224) {
      this.value = byte & 15;
      this.remaining = 2;
      return;
    }
    if ((byte & 248) === 240) {
      this.value = byte & 7;
      this.remaining = 3;
      return;
    }
    return this.reset();
  }
  reset() {
    this.remaining = 0;
    this.value = 0;
    return 65533;
  }
  clone(into = new _Utf8Accumulator) {
    into.remaining = this.remaining;
    into.value = this.value;
    return into;
  }
  static isMultiByte(v) {
    return (v & 128) !== 0;
  }
  static isSingleByte(v) {
    return (v & 128) === 0;
  }
  static create() {
    return new this;
  }
};
function encodeTextToUtf8Into(text, into, offset = 0) {
  let i = offset;
  const len = text.length;
  for (let j = 0;j < len; j++) {
    let code = text.charCodeAt(j);
    code = (code & 63488) === 55296 ? text.codePointAt(j++) || 0 : code;
    if (code < 128) {
      into[i++] = code;
      continue;
    }
    if (code < 2048) {
      const u2 = 49280 | (code & 1984) << 2 | code & 63;
      into[i++] = u2 >>> 8;
      into[i++] = u2 & 255;
      continue;
    }
    if (code < 65536) {
      const u2 = 14712960 | (code & 61440) << 4 | (code & 4032) << 2 | code & 63;
      into[i++] = u2 >>> 16;
      into[i++] = u2 >>> 8 & 255;
      into[i++] = u2 & 255;
      continue;
    }
    const u = 4034953344 | ((code & 1835008) << 6 | (code & 258048) << 4 | (code & 4032) << 2 | code & 63);
    into[i++] = u >>> 24 & 255;
    into[i++] = u >>> 16 & 255;
    into[i++] = u >>> 8 & 255;
    into[i++] = u & 255;
  }
  return i - offset;
}
function encodeTextToUtf8(text) {
  const array = new Array(text.length);
  const len = encodeTextToUtf8Into(text, array);
  array.length !== len && (array.length = len);
  return array;
}
var emptySeq = [0];
Object.freeze(emptySeq);
var CharIndex = class {
  constructor(charIndex) {
    this.charIndex = charIndex;
    this.#charToUtf8SeqMap = buildCharIndexSequenceMap(charIndex);
    this.#multiByteChars = [...this.#charToUtf8SeqMap.values()].some((c) => c.length > 1);
  }
  #charToUtf8SeqMap;
  #lastWord = "";
  #lastWordSeq = [];
  #multiByteChars;
  getCharUtf8Seq(c) {
    const found = this.#charToUtf8SeqMap.get(c);
    if (found)
      return found;
    const s = encodeTextToUtf8(c);
    this.#charToUtf8SeqMap.set(c, s);
    return s;
  }
  wordToUtf8Seq(word) {
    if (this.#lastWord === word)
      return this.#lastWordSeq;
    const seq = encodeTextToUtf8(word);
    this.#lastWord = word;
    this.#lastWordSeq = seq;
    return seq;
  }
  indexContainsMultiByteChars() {
    return this.#multiByteChars;
  }
  get size() {
    return this.charIndex.length;
  }
  toJSON() {
    return { charIndex: this.charIndex };
  }
};
function buildCharIndexSequenceMap(charIndex) {
  const map3 = /* @__PURE__ */ new Map;
  for (const key of charIndex) {
    map3.set(key, encodeTextToUtf8(key));
  }
  return map3;
}
var CharIndexBuilder = class {
  charIndex = [];
  charIndexMap = /* @__PURE__ */ new Map;
  charIndexSeqMap = /* @__PURE__ */ new Map;
  #mapIdxToSeq = /* @__PURE__ */ new Map;
  constructor() {
    this.getUtf8Value("");
  }
  getUtf8Value(c) {
    const found = this.charIndexMap.get(c);
    if (found !== undefined) {
      return found;
    }
    const nc = c.normalize("NFC");
    this.charIndex.push(nc);
    const utf8 = encodeUtf8N_BE(nc.codePointAt(0) || 0);
    this.charIndexMap.set(c, utf8);
    this.charIndexMap.set(nc, utf8);
    this.charIndexMap.set(c.normalize("NFD"), utf8);
    return utf8;
  }
  utf8ValueToUtf8Seq(idx2) {
    const found = this.#mapIdxToSeq.get(idx2);
    if (found !== undefined) {
      return found;
    }
    const seq = splitUtf8(idx2);
    this.#mapIdxToSeq.set(idx2, seq);
    return seq;
  }
  charToUtf8Seq(c) {
    const idx2 = this.getUtf8Value(c);
    return this.utf8ValueToUtf8Seq(idx2);
  }
  wordToUtf8Seq(word) {
    const seq = new Array(word.length);
    let i = 0;
    for (const c of word) {
      const idx2 = this.getUtf8Value(c);
      const cSep = this.utf8ValueToUtf8Seq(idx2);
      if (typeof cSep === "number") {
        seq[i++] = cSep;
        continue;
      }
      for (const cIdx of cSep) {
        seq[i++] = cIdx;
      }
    }
    if (seq.length !== i)
      seq.length = i;
    return seq;
  }
  get size() {
    return this.charIndex.length;
  }
  build() {
    return new CharIndex(this.charIndex);
  }
};
function splitUtf8(utf8) {
  if (utf8 <= 255)
    return [utf8];
  if (utf8 <= 65535)
    return [utf8 >> 8 & 255, utf8 & 255];
  if (utf8 <= 16777215)
    return [utf8 >> 16 & 255, utf8 >> 8 & 255, utf8 & 255];
  return [utf8 >> 24 & 255, utf8 >> 16 & 255, utf8 >> 8 & 255, utf8 & 255].filter((v) => v);
}
function extractInfo(info) {
  const { NodeMaskEOW, NodeMaskChildCharIndex, NodeChildRefShift } = info;
  return {
    NodeMaskEOW,
    NodeMaskChildCharIndex,
    NodeChildRefShift
  };
}
var FastTrieBlobInternals = class {
  constructor(nodes, charIndex, maskInfo, info) {
    this.nodes = nodes;
    this.charIndex = charIndex;
    const { NodeMaskEOW, NodeMaskChildCharIndex, NodeChildRefShift } = maskInfo;
    this.NodeMaskEOW = NodeMaskEOW;
    this.NodeMaskChildCharIndex = NodeMaskChildCharIndex;
    this.NodeChildRefShift = NodeChildRefShift;
    this.isIndexDecoderNeeded = charIndex.indexContainsMultiByteChars();
    this.info = mergeOptionalWithDefaults(info);
  }
  NodeMaskEOW;
  NodeMaskChildCharIndex;
  NodeChildRefShift;
  isIndexDecoderNeeded;
  info;
};
var FastTrieBlobInternalsAndMethods = class extends FastTrieBlobInternals {
  nodeFindNode;
  nodeFindExact;
  nodeGetChild;
  isForbidden;
  findExact;
  hasForbiddenWords;
  hasCompoundWords;
  hasNonStrictWords;
  constructor(nodes, charIndex, maskInfo, info, trieMethods) {
    super(nodes, charIndex, maskInfo, info);
    this.nodeFindExact = trieMethods.nodeFindExact;
    this.nodeGetChild = trieMethods.nodeGetChild;
    this.isForbidden = trieMethods.isForbidden;
    this.findExact = trieMethods.findExact;
    this.nodeFindNode = trieMethods.nodeFindNode;
    this.hasForbiddenWords = trieMethods.hasForbiddenWords;
    this.hasCompoundWords = trieMethods.hasCompoundWords;
    this.hasNonStrictWords = trieMethods.hasNonStrictWords;
  }
};
function sortNodes(nodes, mask) {
  if (Object.isFrozen(nodes)) {
    assertSorted(nodes, mask);
    return nodes;
  }
  for (let i = 0;i < nodes.length; ++i) {
    let node = nodes[i];
    if (node.length > 2) {
      const isFrozen = Object.isFrozen(node);
      node = isFrozen ? Uint32Array.from(node) : node;
      const nodeInfo = node[0];
      node[0] = 0;
      node.sort((a, b) => !a ? -1 : !b ? 1 : (a & mask) - (b & mask));
      node[0] = nodeInfo;
      if (isFrozen) {
        nodes[i] = node;
        Object.freeze(node);
      }
    }
  }
  Object.freeze(nodes);
  return nodes;
}
function assertSorted(nodes, mask) {
  for (let i = 0;i < nodes.length; ++i) {
    const node = nodes[i];
    if (node.length > 2) {
      let last = -1;
      for (let j = 1;j < node.length; ++j) {
        const n = node[j] & mask;
        if (n < last) {
          throw new Error(`Node ${i} is not sorted. ${last} > ${n}`);
        }
        last = n;
      }
    }
  }
}
var EmptyKeys2 = Object.freeze([]);
var EmptyNodes = Object.freeze([]);
var EmptyEntries2 = Object.freeze([]);
var FastTrieBlobINode = class _FastTrieBlobINode {
  constructor(trie, nodeIdx) {
    this.trie = trie;
    this.nodeIdx = nodeIdx;
    const node = trie.nodes[nodeIdx];
    this.node = node;
    this.eow = !!(node[0] & trie.NodeMaskEOW);
    this._count = node.length - 1;
    this.id = nodeIdx;
    this.findExact = (word) => trie.nodeFindExact(nodeIdx, word);
  }
  id;
  node;
  eow;
  _keys;
  _count;
  _size;
  _chained;
  _nodesEntries;
  _entries;
  _values;
  charToIdx;
  keys() {
    if (this._keys)
      return this._keys;
    if (!this._count)
      return EmptyKeys2;
    this._keys = this.getNodesEntries().map(([key]) => key);
    return this._keys;
  }
  values() {
    if (!this._count)
      return EmptyNodes;
    if (this._values)
      return this._values;
    this._values = this.entries().map(([, value]) => value);
    return this._values;
  }
  entries() {
    if (this._entries)
      return this._entries;
    if (!this._count)
      return EmptyEntries2;
    const entries = this.getNodesEntries();
    this._entries = entries.map(([key, value]) => [key, new _FastTrieBlobINode(this.trie, value)]);
    return this._entries;
  }
  get(char) {
    const idx2 = this.trie.nodeGetChild(this.id, char);
    if (idx2 === undefined)
      return;
    return new _FastTrieBlobINode(this.trie, idx2);
  }
  getNode(chars) {
    const idx2 = this.trie.nodeFindNode(this.id, chars);
    if (idx2 === undefined)
      return;
    return new _FastTrieBlobINode(this.trie, idx2);
  }
  has(char) {
    const idx2 = this.trie.nodeGetChild(this.id, char);
    return idx2 !== undefined;
  }
  hasChildren() {
    return this._count > 0;
  }
  child(keyIdx) {
    if (!this._values && !this.containsChainedIndexes()) {
      const n = this.node[keyIdx + 1];
      const nodeIdx = n >>> this.trie.NodeChildRefShift;
      return new _FastTrieBlobINode(this.trie, nodeIdx);
    }
    return this.values()[keyIdx];
  }
  getCharToIdxMap() {
    const m = this.charToIdx;
    if (m)
      return m;
    const map3 = /* @__PURE__ */ Object.create(null);
    const keys = this.keys();
    for (let i = 0;i < keys.length; ++i) {
      map3[keys[i]] = i;
    }
    this.charToIdx = map3;
    return map3;
  }
  findExact(word) {
    return this.trie.nodeFindExact(this.id, word);
  }
  isForbidden(word) {
    const n = this.trie.nodeGetChild(this.id, this.trie.info.forbiddenWordPrefix);
    if (n === undefined)
      return false;
    return this.trie.nodeFindExact(n, word);
  }
  findCaseInsensitive(word) {
    const n = this.trie.nodeGetChild(this.id, this.trie.info.stripCaseAndAccentsPrefix);
    if (n === undefined)
      return false;
    return this.trie.nodeFindExact(n, word);
  }
  containsChainedIndexes() {
    if (this._chained !== undefined)
      return this._chained;
    if (!this._count || !this.trie.isIndexDecoderNeeded) {
      this._chained = false;
      return false;
    }
    let found = false;
    const NodeMaskChildCharIndex = this.trie.NodeMaskChildCharIndex;
    const len = this._count;
    const node = this.node;
    for (let i = 1;i <= len && !found; ++i) {
      const entry = node[i];
      const codePoint = entry & NodeMaskChildCharIndex;
      found = Utf8Accumulator.isMultiByte(codePoint);
    }
    this._chained = !!found;
    return this._chained;
  }
  getNodesEntries() {
    if (this._nodesEntries)
      return this._nodesEntries;
    if (!this.containsChainedIndexes()) {
      const entries = Array(this._count);
      const nodes = this.node;
      const NodeMaskChildCharIndex = this.trie.NodeMaskChildCharIndex;
      const RefShift = this.trie.NodeChildRefShift;
      for (let i = 0;i < this._count; ++i) {
        const entry = nodes[i + 1];
        const codePoint = entry & NodeMaskChildCharIndex;
        entries[i] = [String.fromCodePoint(codePoint), entry >>> RefShift];
      }
      this._nodesEntries = entries;
      return entries;
    }
    this._nodesEntries = this.walkChainedIndexes();
    return this._nodesEntries;
  }
  walkChainedIndexes() {
    const NodeMaskChildCharIndex = this.trie.NodeMaskChildCharIndex;
    const NodeChildRefShift = this.trie.NodeChildRefShift;
    const nodes = this.trie.nodes;
    const acc = Utf8Accumulator.create();
    const stack = [{ n: this.node, c: 1, acc }];
    let depth = 0;
    const entries = Array(this._count);
    let eIdx = 0;
    while (depth >= 0) {
      const s = stack[depth];
      const { n: node, c: off } = s;
      if (off >= node.length) {
        --depth;
        continue;
      }
      ++s.c;
      const entry = node[off];
      const charIdx = entry & NodeMaskChildCharIndex;
      const acc2 = s.acc.clone();
      const codePoint = acc2.decode(charIdx);
      if (codePoint !== undefined) {
        const char = String.fromCodePoint(codePoint);
        const nodeIdx = entry >>> NodeChildRefShift;
        entries[eIdx++] = [char, nodeIdx];
        continue;
      }
      const idx2 = entry >>> NodeChildRefShift;
      const ss = stack[++depth];
      if (ss) {
        ss.n = nodes[idx2];
        ss.c = 1;
        ss.acc = acc2;
      } else {
        stack[depth] = { n: nodes[idx2], c: 1, acc: acc2 };
      }
    }
    return entries;
  }
  get size() {
    if (this._size === undefined) {
      if (!this.containsChainedIndexes()) {
        this._size = this._count;
        return this._size;
      }
      this._size = this.getNodesEntries().length;
    }
    return this._size;
  }
};
var FastTrieBlobIRoot = class extends FastTrieBlobINode {
  hasForbiddenWords;
  hasCompoundWords;
  hasNonStrictWords;
  constructor(trie, nodeIdx) {
    super(trie, nodeIdx);
    this.hasForbiddenWords = trie.hasForbiddenWords;
    this.hasCompoundWords = trie.hasCompoundWords;
    this.hasNonStrictWords = trie.hasNonStrictWords;
  }
  resolveId(id) {
    return new FastTrieBlobINode(this.trie, id);
  }
  find(word, strict) {
    let found = this.findExact(word);
    if (found) {
      return { found: word, compoundUsed: false, caseMatched: true };
    }
    if (strict)
      return;
    found = this.findCaseInsensitive(word);
    return found ? { found: word, compoundUsed: false, caseMatched: false } : undefined;
  }
  get info() {
    return this.trie.info;
  }
  get forbidPrefix() {
    return this.trie.info.forbiddenWordPrefix;
  }
  get compoundFix() {
    return this.trie.info.compoundCharacter;
  }
  get caseInsensitivePrefix() {
    return this.trie.info.stripCaseAndAccentsPrefix;
  }
};
var TrieBlobInternals = class {
  constructor(nodes, charIndex, maskInfo, methods) {
    this.nodes = nodes;
    this.charIndex = charIndex;
    const { NodeMaskEOW, NodeMaskChildCharIndex, NodeMaskNumChildren, NodeChildRefShift } = maskInfo;
    this.NodeMaskEOW = NodeMaskEOW;
    this.NodeMaskNumChildren = NodeMaskNumChildren;
    this.NodeMaskChildCharIndex = NodeMaskChildCharIndex;
    this.NodeChildRefShift = NodeChildRefShift;
    this.isIndexDecoderNeeded = charIndex.indexContainsMultiByteChars();
    this.nodeFindExact = methods.nodeFindExact;
    this.isForbidden = methods.isForbidden;
    this.findExact = methods.findExact;
    this.nodeGetChild = methods.nodeGetChild;
    this.nodeFindNode = methods.nodeFindNode;
    this.hasForbiddenWords = methods.hasForbiddenWords;
    this.hasCompoundWords = methods.hasCompoundWords;
    this.hasNonStrictWords = methods.hasNonStrictWords;
  }
  NodeMaskEOW;
  NodeMaskNumChildren;
  NodeMaskChildCharIndex;
  NodeChildRefShift;
  isIndexDecoderNeeded;
  nodeFindExact;
  isForbidden;
  findExact;
  nodeGetChild;
  nodeFindNode;
  hasForbiddenWords;
  hasCompoundWords;
  hasNonStrictWords;
};
var EmptyKeys3 = Object.freeze([]);
var EmptyNodes2 = Object.freeze([]);
var EmptyEntries3 = Object.freeze([]);
var TrieBlobINode = class _TrieBlobINode {
  constructor(trie, nodeIdx) {
    this.trie = trie;
    this.nodeIdx = nodeIdx;
    const node = trie.nodes[nodeIdx];
    this.node = node;
    this.eow = !!(node & trie.NodeMaskEOW);
    this._count = node & trie.NodeMaskNumChildren;
    this.id = nodeIdx;
  }
  id;
  node;
  eow;
  _keys;
  _count;
  _size;
  _chained;
  _nodesEntries;
  _entries;
  _values;
  charToIdx;
  keys() {
    if (this._keys)
      return this._keys;
    if (!this._count)
      return EmptyKeys3;
    this._keys = this.getNodesEntries().map(([key]) => key);
    return this._keys;
  }
  values() {
    if (!this._count)
      return EmptyNodes2;
    if (this._values)
      return this._values;
    this._values = this.entries().map(([, value]) => value);
    return this._values;
  }
  entries() {
    if (this._entries)
      return this._entries;
    if (!this._count)
      return EmptyEntries3;
    const entries = this.getNodesEntries();
    this._entries = entries.map(([key, value]) => [key, new _TrieBlobINode(this.trie, value)]);
    return this._entries;
  }
  get(char) {
    return this.#getChildNode(char);
  }
  has(char) {
    return this.trie.nodeGetChild(this.nodeIdx, char) !== undefined;
  }
  hasChildren() {
    return this._count > 0;
  }
  child(keyIdx) {
    if (!this._values && !this.containsChainedIndexes()) {
      const n = this.trie.nodes[this.nodeIdx + keyIdx + 1];
      const nodeIdx = n >>> this.trie.NodeChildRefShift;
      return new _TrieBlobINode(this.trie, nodeIdx);
    }
    return this.values()[keyIdx];
  }
  #getChildNodeIdx(char) {
    return this.trie.nodeGetChild(this.nodeIdx, char);
  }
  #getChildNode(char) {
    if (this.charToIdx) {
      const keyIdx = this.charToIdx[char];
      if (keyIdx === undefined)
        return;
      return this.child(keyIdx);
    }
    const idx2 = this.#getChildNodeIdx(char);
    if (idx2 === undefined)
      return;
    return new _TrieBlobINode(this.trie, idx2);
  }
  getCharToIdxMap() {
    const m = this.charToIdx;
    if (m)
      return m;
    const map3 = /* @__PURE__ */ Object.create(null);
    const keys = this.keys();
    for (let i = 0;i < keys.length; ++i) {
      map3[keys[i]] = i;
    }
    this.charToIdx = map3;
    return map3;
  }
  getNode(word) {
    const n = this.trie.nodeFindNode(this.nodeIdx, word);
    return n === undefined ? undefined : new _TrieBlobINode(this.trie, n);
  }
  findExact(word) {
    return this.trie.nodeFindExact(this.nodeIdx, word);
  }
  containsChainedIndexes() {
    if (this._chained !== undefined)
      return this._chained;
    if (!this._count || !this.trie.isIndexDecoderNeeded) {
      this._chained = false;
      return false;
    }
    let found = false;
    const NodeMaskChildCharIndex = this.trie.NodeMaskChildCharIndex;
    const offset = this.nodeIdx + 1;
    const nodes = this.trie.nodes;
    const len = this._count;
    for (let i = 0;i < len && !found; ++i) {
      const entry = nodes[i + offset];
      const charIdx = entry & NodeMaskChildCharIndex;
      found = Utf8Accumulator.isMultiByte(charIdx);
    }
    this._chained = !!found;
    return this._chained;
  }
  getNodesEntries() {
    if (this._nodesEntries)
      return this._nodesEntries;
    if (!this.containsChainedIndexes()) {
      const entries = Array(this._count);
      const nodes = this.trie.nodes;
      const offset = this.nodeIdx + 1;
      const NodeMaskChildCharIndex = this.trie.NodeMaskChildCharIndex;
      const RefShift = this.trie.NodeChildRefShift;
      for (let i = 0;i < this._count; ++i) {
        const entry = nodes[offset + i];
        const codePoint = entry & NodeMaskChildCharIndex;
        entries[i] = [String.fromCodePoint(codePoint), entry >>> RefShift];
      }
      this._nodesEntries = entries;
      return entries;
    }
    this._nodesEntries = this.walkChainedIndexes();
    return this._nodesEntries;
  }
  walkChainedIndexes() {
    const NodeMaskChildCharIndex = this.trie.NodeMaskChildCharIndex;
    const NodeChildRefShift = this.trie.NodeChildRefShift;
    const NodeMaskNumChildren = this.trie.NodeMaskNumChildren;
    const nodes = this.trie.nodes;
    const acc = Utf8Accumulator.create();
    const stack = [{ nodeIdx: this.nodeIdx + 1, lastIdx: this.nodeIdx + this._count, acc }];
    let depth = 0;
    const entries = Array(this._count);
    let eIdx = 0;
    while (depth >= 0) {
      const s = stack[depth];
      const { nodeIdx, lastIdx } = s;
      if (nodeIdx > lastIdx) {
        --depth;
        continue;
      }
      ++s.nodeIdx;
      const entry = nodes[nodeIdx];
      const charIdx = entry & NodeMaskChildCharIndex;
      const acc2 = s.acc.clone();
      const codePoint = acc2.decode(charIdx);
      if (codePoint !== undefined) {
        const char = String.fromCodePoint(codePoint);
        const nodeIdx2 = entry >>> NodeChildRefShift;
        entries[eIdx++] = [char, nodeIdx2];
        continue;
      }
      const idx2 = entry >>> NodeChildRefShift;
      const lIdx = idx2 + (nodes[idx2] & NodeMaskNumChildren);
      const ss = stack[++depth];
      if (ss) {
        ss.nodeIdx = idx2 + 1;
        ss.lastIdx = lIdx;
        ss.acc = acc2;
      } else {
        stack[depth] = { nodeIdx: idx2 + 1, lastIdx: lIdx, acc: acc2 };
      }
    }
    return entries;
  }
  get size() {
    if (this._size === undefined) {
      if (!this.containsChainedIndexes()) {
        this._size = this._count;
        return this._size;
      }
      this._size = this.getNodesEntries().length;
    }
    return this._size;
  }
};
var TrieBlobIRoot = class extends TrieBlobINode {
  constructor(trie, nodeIdx, info, methods) {
    super(trie, nodeIdx);
    this.info = info;
    this.find = methods.find;
    this.isForbidden = trie.isForbidden;
    this.hasForbiddenWords = trie.hasForbiddenWords;
    this.hasCompoundWords = trie.hasCompoundWords;
    this.hasNonStrictWords = trie.hasNonStrictWords;
  }
  find;
  isForbidden;
  hasForbiddenWords;
  hasCompoundWords;
  hasNonStrictWords;
  resolveId(id) {
    return new TrieBlobINode(this.trie, id);
  }
  get forbidPrefix() {
    return this.info.forbiddenWordPrefix;
  }
  get compoundFix() {
    return this.info.compoundCharacter;
  }
  get caseInsensitivePrefix() {
    return this.info.stripCaseAndAccentsPrefix;
  }
};
var NodeHeaderNumChildrenBits = 8;
var NodeHeaderNumChildrenShift = 0;
var HEADER_SIZE_UINT32 = 8;
var HEADER_SIZE = HEADER_SIZE_UINT32 * 4;
var HEADER_OFFSET = 0;
var HEADER_OFFSET_SIG = HEADER_OFFSET;
var HEADER_OFFSET_ENDIAN = HEADER_OFFSET_SIG + 8;
var HEADER_OFFSET_VERSION = HEADER_OFFSET_ENDIAN + 4;
var HEADER_OFFSET_NODES = HEADER_OFFSET_VERSION + 4;
var HEADER_OFFSET_NODES_LEN = HEADER_OFFSET_NODES + 4;
var HEADER_OFFSET_CHAR_INDEX = HEADER_OFFSET_NODES_LEN + 4;
var HEADER_OFFSET_CHAR_INDEX_LEN = HEADER_OFFSET_CHAR_INDEX + 4;
var HEADER = {
  header: HEADER_OFFSET,
  sig: HEADER_OFFSET_SIG,
  version: HEADER_OFFSET_VERSION,
  endian: HEADER_OFFSET_ENDIAN,
  nodes: HEADER_OFFSET_NODES,
  nodesLen: HEADER_OFFSET_NODES_LEN,
  charIndex: HEADER_OFFSET_CHAR_INDEX,
  charIndexLen: HEADER_OFFSET_CHAR_INDEX_LEN
};
var headerSig = "TrieBlob";
var version = "00.01.00";
var endianSig = 67305985;
var TrieBlob = class _TrieBlob {
  constructor(nodes, charIndex, info) {
    this.nodes = nodes;
    this.charIndex = charIndex;
    trieBlobSort(nodes);
    this.info = mergeOptionalWithDefaults(info);
    this.#nodes8 = new Uint8Array(nodes.buffer, nodes.byteOffset + this.#beAdj);
    this.#forbidIdx = this._lookupNode(0, this.info.forbiddenWordPrefix);
    this.#compoundIdx = this._lookupNode(0, this.info.compoundCharacter);
    this.#nonStrictIdx = this._lookupNode(0, this.info.stripCaseAndAccentsPrefix);
    this.hasForbiddenWords = !!this.#forbidIdx;
    this.hasCompoundWords = !!this.#compoundIdx;
    this.hasNonStrictWords = !!this.#nonStrictIdx;
  }
  info;
  #forbidIdx;
  #compoundIdx;
  #nonStrictIdx;
  #size;
  #iTrieRoot;
  #nodes8;
  #beAdj = endianness() === "BE" ? 3 : 0;
  wordToCharacters = (word) => [...word];
  hasForbiddenWords;
  hasCompoundWords;
  hasNonStrictWords;
  wordToUtf8Seq(word) {
    return this.charIndex.wordToUtf8Seq(word);
  }
  letterToNodeCharIndexSequence(letter) {
    return this.charIndex.getCharUtf8Seq(letter);
  }
  has(word) {
    return this.#hasWord(0, word);
  }
  isForbiddenWord(word) {
    return !!this.#forbidIdx && this.#hasWord(this.#forbidIdx, word);
  }
  find(word, strict) {
    if (!this.hasCompoundWords) {
      const found = this.#hasWord(0, word);
      if (found)
        return { found: word, compoundUsed: false, caseMatched: true };
      if (strict || !this.#nonStrictIdx)
        return { found: false, compoundUsed: false, caseMatched: false };
      return { found: this.#hasWord(this.#nonStrictIdx, word) && word, compoundUsed: false, caseMatched: false };
    }
    return;
  }
  getRoot() {
    return this.#iTrieRoot ??= this._getRoot();
  }
  _getRoot() {
    const trieData = new TrieBlobInternals(this.nodes, this.charIndex, {
      NodeMaskEOW: _TrieBlob.NodeMaskEOW,
      NodeMaskNumChildren: _TrieBlob.NodeMaskNumChildren,
      NodeMaskChildCharIndex: _TrieBlob.NodeMaskChildCharIndex,
      NodeChildRefShift: _TrieBlob.NodeChildRefShift
    }, {
      nodeFindExact: (idx2, word) => this.#hasWord(idx2, word),
      nodeGetChild: (idx2, letter) => this._lookupNode(idx2, letter),
      nodeFindNode: (idx2, word) => this.#findNode(idx2, word),
      isForbidden: (word) => this.isForbiddenWord(word),
      findExact: (word) => this.has(word),
      hasCompoundWords: this.hasCompoundWords,
      hasForbiddenWords: this.hasForbiddenWords,
      hasNonStrictWords: this.hasNonStrictWords
    });
    return new TrieBlobIRoot(trieData, 0, this.info, {
      find: (word, strict) => this.find(word, strict)
    });
  }
  getNode(prefix) {
    return findNode(this.getRoot(), prefix);
  }
  #hasWord(nodeIdx, word) {
    const nodeIdxFound = this.#findNode(nodeIdx, word);
    if (!nodeIdxFound)
      return false;
    const node = this.nodes[nodeIdxFound];
    const m = _TrieBlob.NodeMaskEOW;
    return (node & m) === m;
  }
  #findNode(nodeIdx, word) {
    const wordIndexes = this.wordToUtf8Seq(word);
    return this.#lookupNode(nodeIdx, wordIndexes);
  }
  #lookupNode(nodeIdx, seq) {
    const NodeMaskNumChildren = _TrieBlob.NodeMaskNumChildren;
    const NodeChildRefShift = _TrieBlob.NodeChildRefShift;
    const nodes = this.nodes;
    const nodes8 = this.#nodes8;
    const wordIndexes = seq;
    const len = wordIndexes.length;
    let node = nodes[nodeIdx];
    for (let p = 0;p < len; ++p, node = nodes[nodeIdx]) {
      const letterIdx = wordIndexes[p];
      const count3 = node & NodeMaskNumChildren;
      const idx4 = nodeIdx << 2;
      if (count3 > 15) {
        const pEnd = idx4 + (count3 << 2);
        let i2 = idx4 + 4;
        let j = pEnd;
        while (j - i2 >= 4) {
          const m = i2 + j >> 1 & ~3;
          if (nodes8[m] < letterIdx) {
            i2 = m + 4;
          } else {
            j = m;
          }
        }
        if (i2 > pEnd || nodes8[i2] !== letterIdx)
          return;
        nodeIdx = nodes[i2 >> 2] >>> NodeChildRefShift;
        continue;
      }
      let i = idx4 + count3 * 4;
      for (;i > idx4; i -= 4) {
        if (nodes8[i] === letterIdx) {
          break;
        }
      }
      if (i <= idx4)
        return;
      nodeIdx = nodes[i >> 2] >>> NodeChildRefShift;
    }
    return nodeIdx;
  }
  _lookupNode(nodeIdx, char) {
    const indexSeq = this.letterToNodeCharIndexSequence(char);
    const currNodeIdx = this.#lookupNode(nodeIdx, indexSeq);
    return currNodeIdx;
  }
  *words() {
    const NodeMaskNumChildren = _TrieBlob.NodeMaskNumChildren;
    const NodeMaskEOW = _TrieBlob.NodeMaskEOW;
    const NodeMaskChildCharIndex = _TrieBlob.NodeMaskChildCharIndex;
    const NodeChildRefShift = _TrieBlob.NodeChildRefShift;
    const nodes = this.nodes;
    const stack = [{ nodeIdx: 0, pos: 0, word: "", acc: Utf8Accumulator.create() }];
    let depth = 0;
    while (depth >= 0) {
      const { nodeIdx, pos, word, acc } = stack[depth];
      const node = nodes[nodeIdx];
      if (!pos && node & NodeMaskEOW) {
        yield word;
      }
      const len = node & NodeMaskNumChildren;
      if (pos >= len) {
        --depth;
        continue;
      }
      const nextPos = ++stack[depth].pos;
      const entry = nodes[nodeIdx + nextPos];
      const nAcc = acc.clone();
      const codePoint = nAcc.decode(entry & NodeMaskChildCharIndex);
      const letter = codePoint && String.fromCodePoint(codePoint) || "";
      ++depth;
      stack[depth] = {
        nodeIdx: entry >>> NodeChildRefShift,
        pos: 0,
        word: word + letter,
        acc: nAcc
      };
    }
  }
  get size() {
    if (this.#size)
      return this.#size;
    const NodeMaskNumChildren = _TrieBlob.NodeMaskNumChildren;
    const nodes = this.nodes;
    let p = 0;
    let count3 = 0;
    while (p < nodes.length) {
      ++count3;
      p += (nodes[p] & NodeMaskNumChildren) + 1;
    }
    this.#size = count3;
    return count3;
  }
  toJSON() {
    return {
      options: this.info,
      nodes: nodesToJson(this.nodes),
      charIndex: this.charIndex
    };
  }
  encodeBin() {
    const charIndex = Buffer.from(this.charIndex.charIndex.join(`
`));
    const charIndexLen = charIndex.byteLength + 3 & ~3;
    const nodeOffset = HEADER_SIZE + charIndexLen;
    const size = nodeOffset + this.nodes.length * 4;
    const useLittle = isLittleEndian();
    const buffer2 = Buffer.alloc(size);
    const header = new DataView(buffer2.buffer);
    const nodeData = new Uint8Array(this.nodes.buffer);
    buffer2.write(headerSig, HEADER.sig, "utf8");
    buffer2.write(version, HEADER.version, "utf8");
    header.setUint32(HEADER.endian, endianSig, useLittle);
    header.setUint32(HEADER.nodes, nodeOffset, useLittle);
    header.setUint32(HEADER.nodesLen, this.nodes.length, useLittle);
    header.setUint32(HEADER.charIndex, HEADER_SIZE, useLittle);
    header.setUint32(HEADER.charIndexLen, charIndex.length, useLittle);
    buffer2.set(charIndex, HEADER_SIZE);
    buffer2.set(nodeData, nodeOffset);
    return buffer2;
  }
  static decodeBin(blob) {
    if (!checkSig(blob)) {
      throw new ErrorDecodeTrieBlob("Invalid TrieBlob Header");
    }
    const header = new DataView(blob.buffer);
    const useLittle = isLittleEndian();
    if (header.getUint32(HEADER.endian, useLittle) !== endianSig) {
      throw new ErrorDecodeTrieBlob("Invalid TrieBlob Header");
    }
    const offsetNodes = header.getUint32(HEADER.nodes, useLittle);
    const lenNodes = header.getUint32(HEADER.nodesLen, useLittle);
    const offsetCharIndex = header.getUint32(HEADER.charIndex, useLittle);
    const lenCharIndex = header.getUint32(HEADER.charIndexLen, useLittle);
    const charIndex = Buffer.from(blob.subarray(offsetCharIndex, offsetCharIndex + lenCharIndex)).toString("utf8").split(`
`);
    const nodes = new Uint32Array(blob.buffer, offsetNodes, lenNodes);
    const trieBlob = new _TrieBlob(nodes, new CharIndex(charIndex), defaultTrieInfo);
    return trieBlob;
  }
  static NodeMaskEOW = 256 & 65535;
  static NodeMaskNumChildren = (1 << NodeHeaderNumChildrenBits) - 1 & 65535;
  static NodeMaskNumChildrenShift = NodeHeaderNumChildrenShift;
  static NodeChildRefShift = 8;
  static NodeMaskChildCharIndex = 255;
  static nodesView(trie) {
    return new Uint32Array(trie.nodes);
  }
};
function isLittleEndian() {
  const buf = new Uint8Array([1, 2, 3, 4]);
  const view = new DataView(buf.buffer);
  return view.getUint32(0, true) === 67305985;
}
function checkSig(blob) {
  if (blob.length < HEADER_SIZE) {
    return false;
  }
  const buf = Buffer.from(blob, 0, headerSig.length);
  if (buf.toString("utf8", 0, headerSig.length) !== headerSig) {
    return false;
  }
  return true;
}
var ErrorDecodeTrieBlob = class extends Error {
  constructor(message) {
    super(message);
  }
};
function nodesToJson(nodes) {
  function nodeElement(offset2) {
    const node = nodes[offset2];
    const numChildren = node & TrieBlob.NodeMaskNumChildren;
    const eow = !!(node & TrieBlob.NodeMaskEOW);
    const children = [];
    for (let i = 1;i <= numChildren; ++i) {
      children.push({
        c: ("00" + (nodes[offset2 + i] & TrieBlob.NodeMaskChildCharIndex).toString(16)).slice(-2),
        o: nodes[offset2 + i] >>> TrieBlob.NodeChildRefShift
      });
    }
    return { id: offset2, eow, n: offset2 + numChildren + 1, c: children };
  }
  const elements = [];
  let offset = 0;
  while (offset < nodes.length) {
    const e = nodeElement(offset);
    elements.push(e);
    offset = e.n;
  }
  return elements;
}
function trieBlobSort(data) {
  const MaskNumChildren = TrieBlob.NodeMaskNumChildren;
  const MaskChildCharIndex = TrieBlob.NodeMaskChildCharIndex;
  const limit = data.length;
  let idx2 = 0;
  let node = data[0];
  let nc = node & MaskNumChildren;
  for (;idx2 < limit; idx2 += nc + 1, node = data[idx2], nc = node & MaskNumChildren) {
    if (!nc)
      continue;
    const start = idx2 + 1;
    const end = start + nc;
    let last = 0;
    let i = start;
    for (;i < end; ++i) {
      const cIdx = data[i] & MaskChildCharIndex;
      if (last >= cIdx)
        break;
      last = cIdx;
    }
    if (i === end)
      continue;
    const sorted = data.slice(start, end).sort((a, b) => (a & MaskChildCharIndex) - (b & MaskChildCharIndex));
    sorted.forEach((v, i2) => data[start + i2] = v);
  }
}
var checkSorted = false;
var FastTrieBlob = class _FastTrieBlob {
  constructor(nodes, _charIndex, bitMasksInfo, info) {
    this.nodes = nodes;
    this._charIndex = _charIndex;
    this.bitMasksInfo = bitMasksInfo;
    this.info = info;
    this.wordToCharacters = (word) => [...word];
    this.#forbidIdx = this.#searchNodeForChar(0, this.info.forbiddenWordPrefix) || 0;
    this.#compoundIdx = this.#searchNodeForChar(0, this.info.compoundCharacter) || 0;
    this.#nonStrictIdx = this.#searchNodeForChar(0, this.info.stripCaseAndAccentsPrefix) || 0;
    this.hasForbiddenWords = !!this.#forbidIdx;
    this.hasCompoundWords = !!this.#compoundIdx;
    this.hasNonStrictWords = !!this.#nonStrictIdx;
    if (checkSorted) {
      assertSorted(this.nodes, bitMasksInfo.NodeMaskChildCharIndex);
    }
  }
  _readonly = false;
  #forbidIdx;
  #compoundIdx;
  #nonStrictIdx;
  _iTrieRoot;
  wordToCharacters;
  hasForbiddenWords;
  hasCompoundWords;
  hasNonStrictWords;
  wordToUtf8Seq(word) {
    return this._charIndex.wordToUtf8Seq(word);
  }
  letterToUtf8Seq(letter) {
    return this._charIndex.getCharUtf8Seq(letter);
  }
  has(word) {
    return this.#has(0, word);
  }
  hasCaseInsensitive(word) {
    if (!this.#nonStrictIdx)
      return false;
    return this.#has(this.#nonStrictIdx, word);
  }
  #has(nodeIdx, word) {
    return this.#hasSorted(nodeIdx, word);
  }
  #hasSorted(nodeIdx, word) {
    const charIndexes = this.wordToUtf8Seq(word);
    const found = this.#lookupNode(nodeIdx, charIndexes);
    if (found === undefined)
      return false;
    const node = this.nodes[found];
    return !!(node[0] & this.bitMasksInfo.NodeMaskEOW);
  }
  #lookupNode(nodeIdx, seq) {
    const NodeMaskChildCharIndex = this.bitMasksInfo.NodeMaskChildCharIndex;
    const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
    const nodes = this.nodes;
    const len = seq.length;
    let node = nodes[nodeIdx];
    for (let p = 0;p < len; ++p, node = nodes[nodeIdx]) {
      const letterIdx = seq[p];
      const count3 = node.length;
      if (count3 < 2)
        return;
      let i = 1;
      let j = count3 - 1;
      let c = -1;
      while (i < j) {
        const m = i + j >> 1;
        c = node[m] & NodeMaskChildCharIndex;
        if (c < letterIdx) {
          i = m + 1;
        } else {
          j = m;
        }
      }
      if (i >= count3 || (node[i] & NodeMaskChildCharIndex) !== letterIdx)
        return;
      nodeIdx = node[i] >>> NodeChildRefShift;
      if (!nodeIdx)
        return;
    }
    return nodeIdx;
  }
  *words() {
    const NodeMaskChildCharIndex = this.bitMasksInfo.NodeMaskChildCharIndex;
    const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
    const NodeMaskEOW = this.bitMasksInfo.NodeMaskEOW;
    const nodes = this.nodes;
    const accumulator = Utf8Accumulator.create();
    const stack = [{ nodeIdx: 0, pos: 0, word: "", accumulator }];
    let depth = 0;
    while (depth >= 0) {
      const { nodeIdx, pos, word, accumulator: accumulator2 } = stack[depth];
      const node = nodes[nodeIdx];
      if (!pos && node[0] & NodeMaskEOW) {
        yield word;
      }
      if (pos >= node.length - 1) {
        --depth;
        continue;
      }
      const nextPos = ++stack[depth].pos;
      const entry = node[nextPos];
      const charIdx = entry & NodeMaskChildCharIndex;
      const acc = accumulator2.clone();
      const codePoint = acc.decode(charIdx);
      const letter = codePoint && String.fromCodePoint(codePoint) || "";
      ++depth;
      stack[depth] = {
        nodeIdx: entry >>> NodeChildRefShift,
        pos: 0,
        word: word + letter,
        accumulator: acc
      };
    }
  }
  toTrieBlob() {
    const NodeMaskChildCharIndex = this.bitMasksInfo.NodeMaskChildCharIndex;
    const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
    const nodes = this.nodes;
    function calcNodeToIndex(nodes2) {
      let offset2 = 0;
      const idx2 = Array(nodes2.length + 1);
      for (let i = 0;i < nodes2.length; ++i) {
        idx2[i] = offset2;
        offset2 += nodes2[i].length;
      }
      idx2[nodes2.length] = offset2;
      return idx2;
    }
    const nodeToIndex = calcNodeToIndex(nodes);
    const nodeElementCount = nodeToIndex[nodeToIndex.length - 1];
    const binNodes = new Uint32Array(nodeElementCount);
    const lenShift = TrieBlob.NodeMaskNumChildrenShift;
    const refShift = TrieBlob.NodeChildRefShift;
    let offset = 0;
    for (let i = 0;i < nodes.length; ++i) {
      const node = nodes[i];
      binNodes[offset++] = node.length - 1 << lenShift | node[0];
      for (let j = 1;j < node.length; ++j) {
        const v = node[j];
        const nodeRef = v >>> NodeChildRefShift;
        const charIndex = v & NodeMaskChildCharIndex;
        binNodes[offset++] = nodeToIndex[nodeRef] << refShift | charIndex;
      }
    }
    return new TrieBlob(binNodes, this._charIndex, this.info);
  }
  isReadonly() {
    return this._readonly;
  }
  freeze() {
    this._readonly = true;
    return this;
  }
  toJSON() {
    return {
      info: this.info,
      nodes: nodesToJSON(this.nodes)
    };
  }
  static create(data) {
    return new _FastTrieBlob(data.nodes, data.charIndex, extractInfo(data), data.info);
  }
  static toITrieNodeRoot(trie) {
    return new FastTrieBlobIRoot(new FastTrieBlobInternalsAndMethods(trie.nodes, trie._charIndex, trie.bitMasksInfo, trie.info, {
      nodeFindNode: (idx2, word) => trie.#lookupNode(idx2, trie.wordToUtf8Seq(word)),
      nodeFindExact: (idx2, word) => trie.#has(idx2, word),
      nodeGetChild: (idx2, letter) => trie.#searchNodeForChar(idx2, letter),
      isForbidden: (word) => trie.isForbiddenWord(word),
      findExact: (word) => trie.has(word),
      hasForbiddenWords: trie.hasForbiddenWords,
      hasCompoundWords: trie.hasCompoundWords,
      hasNonStrictWords: trie.hasNonStrictWords
    }), 0);
  }
  static NodeMaskEOW = TrieBlob.NodeMaskEOW;
  static NodeChildRefShift = TrieBlob.NodeChildRefShift;
  static NodeMaskChildCharIndex = TrieBlob.NodeMaskChildCharIndex;
  static DefaultBitMaskInfo = {
    NodeMaskEOW: _FastTrieBlob.NodeMaskEOW,
    NodeMaskChildCharIndex: _FastTrieBlob.NodeMaskChildCharIndex,
    NodeChildRefShift: _FastTrieBlob.NodeChildRefShift
  };
  get iTrieRoot() {
    return this._iTrieRoot ??= _FastTrieBlob.toITrieNodeRoot(this);
  }
  getRoot() {
    return this.iTrieRoot;
  }
  getNode(prefix) {
    return findNode(this.getRoot(), prefix);
  }
  isForbiddenWord(word) {
    return !!this.#forbidIdx && this.#has(this.#forbidIdx, word);
  }
  nodeInfo(nodeIndex, accumulator) {
    const acc = accumulator ?? Utf8Accumulator.create();
    const n = this.nodes[nodeIndex];
    const eow = !!(n[0] & this.bitMasksInfo.NodeMaskEOW);
    const children = [];
    children.length = n.length - 1;
    for (let p = 1;p < n.length; ++p) {
      const v = n[p];
      const cIdx = v & this.bitMasksInfo.NodeMaskChildCharIndex;
      const a = acc.clone();
      const codePoint = a.decode(cIdx);
      const c = codePoint !== undefined ? String.fromCodePoint(codePoint) : "";
      const i = v >>> this.bitMasksInfo.NodeChildRefShift;
      children[p] = { c, i, cIdx };
    }
    return { eow, children };
  }
  get size() {
    return this.nodes.length;
  }
  #searchNodeForChar(nodeIdx, char) {
    const charIndexes = this.letterToUtf8Seq(char);
    return this.#lookupNode(nodeIdx, charIndexes);
  }
  get charIndex() {
    return [...this._charIndex.charIndex];
  }
  static fromTrieBlob(trie) {
    const bitMasksInfo = {
      NodeMaskEOW: TrieBlob.NodeMaskEOW,
      NodeMaskChildCharIndex: TrieBlob.NodeMaskChildCharIndex,
      NodeChildRefShift: TrieBlob.NodeChildRefShift
    };
    const trieNodesBin = TrieBlob.nodesView(trie);
    const nodeOffsets = [];
    for (let offset = 0;offset < trieNodesBin.length; offset += (trieNodesBin[offset] & TrieBlob.NodeMaskNumChildren) + 1) {
      nodeOffsets.push(offset);
    }
    const offsetToNodeIndex = new Map(nodeOffsets.map((offset, i) => [offset, i]));
    const nodes = Array.from({ length: nodeOffsets.length });
    for (let i = 0;i < nodes.length; ++i) {
      const offset = nodeOffsets[i];
      const n = trieNodesBin[offset];
      const eow = n & TrieBlob.NodeMaskEOW;
      const count3 = n & TrieBlob.NodeMaskNumChildren;
      const node = new Uint32Array(count3 + 1);
      node[0] = eow;
      nodes[i] = node;
      for (let j = 1;j <= count3; ++j) {
        const n2 = trieNodesBin[offset + j];
        const charIndex = n2 & TrieBlob.NodeMaskChildCharIndex;
        const nodeIndex = n2 >>> TrieBlob.NodeChildRefShift;
        const idx2 = offsetToNodeIndex.get(nodeIndex);
        if (idx2 === undefined) {
          throw new Error(`Invalid node index ${nodeIndex}`);
        }
        node[j] = idx2 << TrieBlob.NodeChildRefShift | charIndex;
      }
    }
    return new _FastTrieBlob(sortNodes(nodes, TrieBlob.NodeMaskChildCharIndex), trie.charIndex, bitMasksInfo, trie.info);
  }
  static isFastTrieBlob(obj) {
    return obj instanceof _FastTrieBlob;
  }
};
function nodesToJSON(nodes) {
  const mapNodeToAcc = /* @__PURE__ */ new Map;
  function mapNode(node, i) {
    if (node.length === 1) {
      return {
        i,
        w: !!(node[0] & TrieBlob.NodeMaskEOW) && 1 || 0
      };
    }
    const acc = mapNodeToAcc.get(node) || Utf8Accumulator.create();
    function mapChild(n) {
      const index = n >>> TrieBlob.NodeChildRefShift;
      const seq = n & TrieBlob.NodeMaskChildCharIndex;
      const cAcc = acc.clone();
      const codePoint = cAcc.decode(seq);
      if (codePoint === undefined) {
        mapNodeToAcc.set(nodes[index], cAcc);
      }
      return {
        i: index,
        c: codePoint && String.fromCodePoint(codePoint),
        s: seq.toString(16).padStart(2, "0")
      };
    }
    return {
      i,
      w: !!(node[0] & TrieBlob.NodeMaskEOW) && 1 || 0,
      c: [...node.slice(1)].map(mapChild)
    };
  }
  return nodes.map((n, i) => mapNode(n, i));
}
function resolveMap(map3, key, resolve) {
  const r = map3.get(key);
  if (r !== undefined)
    return r;
  const v = resolve(key);
  map3.set(key, v);
  return v;
}
var FastTrieBlobBuilder = class _FastTrieBlobBuilder {
  charIndex = new CharIndexBuilder;
  nodes;
  _readonly = false;
  IdxEOW;
  _cursor;
  _options;
  wordToCharacters = (word) => [...word];
  bitMasksInfo;
  constructor(options, bitMasksInfo = _FastTrieBlobBuilder.DefaultBitMaskInfo) {
    this._options = mergeOptionalWithDefaults(options);
    this.bitMasksInfo = bitMasksInfo;
    this.nodes = [[0], Object.freeze([_FastTrieBlobBuilder.NodeMaskEOW])];
    this.IdxEOW = 1;
  }
  setOptions(options) {
    this._options = mergeOptionalWithDefaults(this.options, options);
    return this.options;
  }
  get options() {
    return this._options;
  }
  wordToUtf8Seq(word) {
    return this.charIndex.wordToUtf8Seq(word);
  }
  letterToUtf8Seq(letter) {
    return this.charIndex.charToUtf8Seq(letter);
  }
  insert(word) {
    this.#assertNotReadonly();
    if (typeof word === "string") {
      return this._insert(word);
    }
    const words = word;
    for (const w of words) {
      this._insert(w);
    }
    return this;
  }
  getCursor() {
    this.#assertNotReadonly();
    this._cursor ??= this.createCursor();
    return this._cursor;
  }
  createCursor() {
    const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
    const NodeMaskEOW = this.bitMasksInfo.NodeMaskEOW;
    const LetterMask = this.bitMasksInfo.NodeMaskChildCharIndex;
    const refNodes = [0, 1];
    function childPos(node, letterIdx) {
      for (let i = 1;i < node.length; ++i) {
        if ((node[i] & LetterMask) === letterIdx) {
          return i;
        }
      }
      return 0;
    }
    assert2(this.nodes.length === 2);
    const eow = 1;
    const eowShifted = eow << NodeChildRefShift;
    const nodes = this.nodes;
    const stack = [{ nodeIdx: 0, pos: 0, pDepth: -1 }];
    let nodeIdx = 0;
    let depth = 0;
    const insertChar = (char) => {
      if (!nodes[nodeIdx]) {
        refNodes.push(nodeIdx);
      }
      const pDepth = depth;
      const utf8Seq = this.letterToUtf8Seq(char);
      for (let i = 0;i < utf8Seq.length; ++i) {
        insertCharIndexes(utf8Seq[i], pDepth);
      }
    };
    const insertCharIndexes = (seq, pDepth) => {
      if (nodes[nodeIdx] && Object.isFrozen(nodes[nodeIdx])) {
        nodeIdx = nodes.push([...nodes[nodeIdx]]) - 1;
        const { pos: pos2, nodeIdx: pNodeIdx } = stack[depth];
        const pNode = nodes[pNodeIdx];
        pNode[pos2] = pNode[pos2] & LetterMask | nodeIdx << NodeChildRefShift;
      }
      const node = nodes[nodeIdx] || [0];
      nodes[nodeIdx] = node;
      const hasIdx = childPos(node, seq);
      const childIdx = hasIdx ? node[hasIdx] >>> NodeChildRefShift : nodes.length;
      const pos = hasIdx || node.push(childIdx << NodeChildRefShift | seq) - 1;
      ++depth;
      const s = stack[depth];
      if (s) {
        s.nodeIdx = nodeIdx;
        s.pos = pos;
        s.pDepth = pDepth;
      } else {
        stack[depth] = { nodeIdx, pos, pDepth };
      }
      nodeIdx = childIdx;
    };
    const markEOW = () => {
      if (nodeIdx === eow)
        return;
      const node = nodes[nodeIdx];
      if (!node) {
        const { pos, nodeIdx: pNodeIdx } = stack[depth];
        const pNode = nodes[pNodeIdx];
        pNode[pos] = pNode[pos] & LetterMask | eowShifted;
      } else {
        nodes[nodeIdx] = node;
        node[0] |= NodeMaskEOW;
      }
      nodeIdx = eow;
    };
    const reference = (refId) => {
      const refNodeIdx = refNodes[refId];
      assert2(refNodeIdx !== undefined);
      assert2(nodes[nodeIdx] === undefined);
      assert2(nodes[refNodeIdx]);
      Object.freeze(nodes[refNodeIdx]);
      const s = stack[depth];
      nodeIdx = s.nodeIdx;
      const pos = s.pos;
      const node = nodes[nodeIdx];
      node[pos] = refNodeIdx << NodeChildRefShift | node[pos] & LetterMask;
    };
    const backStep = (num) => {
      if (!num)
        return;
      assert2(num <= depth && num > 0);
      for (let n = num;n > 0; --n) {
        depth = stack[depth].pDepth;
      }
      nodeIdx = stack[depth + 1].nodeIdx;
    };
    const c = {
      insertChar,
      markEOW,
      reference,
      backStep
    };
    return c;
  }
  _insert(word) {
    word = word.trim();
    if (!word)
      return this;
    const NodeMaskChildCharIndex = this.bitMasksInfo.NodeMaskChildCharIndex;
    const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
    const NodeMaskEOW = this.bitMasksInfo.NodeMaskEOW;
    const IdxEOW = this.IdxEOW;
    const nodes = this.nodes;
    const utf8Seq = this.wordToUtf8Seq(word);
    const len = utf8Seq.length;
    let nodeIdx = 0;
    for (let p = 0;p < len; ++p) {
      const seq = utf8Seq[p];
      const node = nodes[nodeIdx];
      const count3 = node.length;
      let i = count3 - 1;
      for (;i > 0; --i) {
        if ((node[i] & NodeMaskChildCharIndex) === seq) {
          break;
        }
      }
      if (i > 0) {
        nodeIdx = node[i] >>> NodeChildRefShift;
        if (nodeIdx === 1 && p < len - 1) {
          nodeIdx = this.nodes.push([NodeMaskEOW]) - 1;
          node[i] = nodeIdx << NodeChildRefShift | seq;
        }
        continue;
      }
      nodeIdx = p < len - 1 ? this.nodes.push([0]) - 1 : IdxEOW;
      node.push(nodeIdx << NodeChildRefShift | seq);
    }
    if (nodeIdx > 1) {
      const node = nodes[nodeIdx];
      node[0] |= NodeMaskEOW;
    }
    return this;
  }
  has(word) {
    const NodeMaskChildCharIndex = this.bitMasksInfo.NodeMaskChildCharIndex;
    const NodeChildRefShift = this.bitMasksInfo.NodeChildRefShift;
    const NodeMaskEOW = this.bitMasksInfo.NodeMaskEOW;
    const nodes = this.nodes;
    const charIndexes = this.wordToUtf8Seq(word);
    const len = charIndexes.length;
    let nodeIdx = 0;
    let node = nodes[nodeIdx];
    for (let p = 0;p < len; ++p, node = nodes[nodeIdx]) {
      const letterIdx = charIndexes[p];
      const count3 = node.length;
      let i = count3 - 1;
      for (;i > 0; --i) {
        if ((node[i] & NodeMaskChildCharIndex) === letterIdx) {
          break;
        }
      }
      if (i < 1)
        return false;
      nodeIdx = node[i] >>> NodeChildRefShift;
    }
    return !!(node[0] & NodeMaskEOW);
  }
  isReadonly() {
    return this._readonly;
  }
  freeze() {
    this._readonly = true;
    return this;
  }
  build() {
    this._cursor = undefined;
    this._readonly = true;
    this.freeze();
    return FastTrieBlob.create(new FastTrieBlobInternals(sortNodes(this.nodes.map((n) => Uint32Array.from(n)), this.bitMasksInfo.NodeMaskChildCharIndex), this.charIndex.build(), this.bitMasksInfo, this.options));
  }
  toJSON() {
    return {
      options: this.options,
      nodes: nodesToJSON(this.nodes.map((n) => Uint32Array.from(n)))
    };
  }
  #assertNotReadonly() {
    assert2(!this.isReadonly(), "FastTrieBlobBuilder is readonly");
  }
  static fromWordList(words, options) {
    const ft = new _FastTrieBlobBuilder(options);
    return ft.insert(words).build();
  }
  static fromTrieRoot(root) {
    const bitMasksInfo = _FastTrieBlobBuilder.DefaultBitMaskInfo;
    const NodeChildRefShift = bitMasksInfo.NodeChildRefShift;
    const NodeCharIndexMask = bitMasksInfo.NodeMaskChildCharIndex;
    const NodeMaskEOW = bitMasksInfo.NodeMaskEOW;
    const tf = new _FastTrieBlobBuilder(undefined, bitMasksInfo);
    const IdxEOW = tf.IdxEOW;
    const known = /* @__PURE__ */ new Map([[root, 0]]);
    function resolveNode(n) {
      if (n.f && !n.c)
        return IdxEOW;
      const node = [n.f ? NodeMaskEOW : 0];
      return tf.nodes.push(node) - 1;
    }
    function walk4(n) {
      const found = known.get(n);
      if (found)
        return found;
      const nodeIdx = resolveMap(known, n, resolveNode);
      const node = tf.nodes[nodeIdx];
      if (!n.c)
        return nodeIdx;
      const children = Object.entries(n.c);
      for (let p = 0;p < children.length; ++p) {
        const [char, childNode] = children[p];
        addCharToNode(node, char, childNode);
      }
      return nodeIdx;
    }
    function resolveChild(node, charIndex) {
      let i = 1;
      for (i = 1;i < node.length && (node[i] & NodeCharIndexMask) !== charIndex; ++i) {
      }
      return i;
    }
    function addCharToNode(node, char, n) {
      const indexSeq = tf.letterToUtf8Seq(char);
      assertValidUtf16Character(char);
      for (const idx2 of indexSeq.slice(0, -1)) {
        const pos = resolveChild(node, idx2);
        if (pos < node.length) {
          node = tf.nodes[node[pos] >>> NodeChildRefShift];
        } else {
          const next = [0];
          const nodeIdx = tf.nodes.push(next) - 1;
          node[pos] = nodeIdx << NodeChildRefShift | idx2;
          node = next;
        }
      }
      const letterIdx = indexSeq[indexSeq.length - 1];
      const i = node.push(letterIdx) - 1;
      node[i] = walk4(n) << NodeChildRefShift | letterIdx;
    }
    walk4(root);
    return tf.build();
  }
  static NodeMaskEOW = TrieBlob.NodeMaskEOW;
  static NodeChildRefShift = TrieBlob.NodeChildRefShift;
  static NodeMaskChildCharIndex = TrieBlob.NodeMaskChildCharIndex;
  static DefaultBitMaskInfo = {
    NodeMaskEOW: _FastTrieBlobBuilder.NodeMaskEOW,
    NodeMaskChildCharIndex: _FastTrieBlobBuilder.NodeMaskChildCharIndex,
    NodeChildRefShift: _FastTrieBlobBuilder.NodeChildRefShift
  };
};
function clean2(t) {
  const copy = { ...t };
  for (const key of Object.keys(copy)) {
    if (copy[key] === undefined) {
      delete copy[key];
    }
  }
  return copy;
}
var defaultLegacyMinCompoundLength2 = 3;
var ITrieImpl = class _ITrieImpl {
  constructor(data, numNodes) {
    this.data = data;
    this.numNodes = numNodes;
    this.root = data.getRoot();
    this._info = mergeOptionalWithDefaults(data.info);
    this.hasForbiddenWords = data.hasForbiddenWords;
    this.hasCompoundWords = data.hasCompoundWords;
    this.hasNonStrictWords = data.hasNonStrictWords;
  }
  _info;
  root;
  count;
  weightMap;
  #optionsCompound = this.createFindOptions({ compoundMode: "compound" });
  hasForbiddenWords;
  hasCompoundWords;
  hasNonStrictWords;
  numWords() {
    this.count ??= countWords(this.root);
    return this.count;
  }
  isNumWordsKnown() {
    return this.count !== undefined;
  }
  get size() {
    return this.data.size;
  }
  get info() {
    return this._info;
  }
  get isCaseAware() {
    return this.info.isCaseAware ?? true;
  }
  find(text) {
    return findWordNode(this.data.getRoot(), text, this.#optionsCompound).node;
  }
  has(word, minLegacyCompoundLength) {
    if (this.hasWord(word, false))
      return true;
    if (minLegacyCompoundLength) {
      const f = this.findWord(word, { useLegacyWordCompounds: minLegacyCompoundLength });
      return !!f.found;
    }
    return false;
  }
  hasWord(word, caseSensitive) {
    const f = this.findWord(word, { caseSensitive, checkForbidden: false });
    return !!f.found;
  }
  findWord(word, options) {
    if (options?.useLegacyWordCompounds) {
      const len = options.useLegacyWordCompounds !== true ? options.useLegacyWordCompounds : defaultLegacyMinCompoundLength2;
      const findOptions = this.createFindOptions({
        legacyMinCompoundLength: len,
        matchCase: options.caseSensitive || false
      });
      return findLegacyCompound(this.root, word, findOptions);
    }
    return findWord(this.root, word, {
      matchCase: options?.caseSensitive,
      checkForbidden: options?.checkForbidden
    });
  }
  isForbiddenWord(word) {
    return this.hasForbiddenWords && isForbiddenWord(this.root, word, this.info.forbiddenWordPrefix);
  }
  completeWord(text) {
    const n = this.find(text);
    const compoundChar = this.info.compoundCharacter;
    const subNodes = pipeSync(n ? iteratorTrieWords(n) : [], opFilterSync((w) => w[w.length - 1] !== compoundChar), opMapSync((suffix) => text + suffix));
    return pipeSync(n && n.eow ? [text] : [], opAppendSync(subNodes));
  }
  suggest(text, options) {
    return this.suggestWithCost(text, options).map((a) => a.word);
  }
  suggestWithCost(text, options) {
    const sep = options.compoundSeparator;
    const weightMap = options.weightMap || this.weightMap;
    const adjWord = sep ? replaceAllFactory(sep, "") : (a) => a;
    const optFilter = options.filter;
    const filter3 = optFilter ? (word, cost) => {
      const w = adjWord(word);
      return !this.isForbiddenWord(w) && optFilter(w, cost);
    } : (word) => !this.isForbiddenWord(adjWord(word));
    const opts = { ...options, filter: filter3, weightMap };
    return suggestAStar(this.data, text, opts);
  }
  genSuggestions(collector, compoundMethod) {
    const filter3 = (word) => !this.isForbiddenWord(word);
    const options = createSuggestionOptions(clean2({ compoundMethod, ...collector.genSuggestionOptions }));
    const suggestions = getSuggestionsAStar(this.data, collector.word, options);
    collector.collect(suggestions, undefined, filter3);
  }
  words() {
    return iteratorTrieWords(this.root);
  }
  iterate() {
    return walker(this.root);
  }
  static create(words, info) {
    const builder = new FastTrieBlobBuilder(info);
    builder.insert(words);
    const root = builder.build();
    return new _ITrieImpl(root, undefined);
  }
  createFindOptions(options) {
    const findOptions = createFindOptions(options);
    return findOptions;
  }
};
function buildITrieFromWords(words, info = {}) {
  const builder = new FastTrieBlobBuilder(info);
  builder.insert(words);
  const ft = builder.build();
  return new ITrieImpl(ft.size > 1000 ? ft.toTrieBlob() : ft);
}
function isValidChar(char) {
  return isValidUtf16Character(char);
}
function assertIsValidChar(char, message) {
  if (!isValidChar(char)) {
    assert3(false, `${message} "${char}" ${formatCharCodes(char)}`);
  }
}
function formatCharCodes(char) {
  return char.split("").map((c) => "0x" + c.charCodeAt(0).toString(16).padStart(4, "0").toUpperCase()).join(":");
}
var FLAG_WORD = 1;
function insert2(word, root = {}) {
  const text = [...word];
  let node = root;
  for (let i = 0;i < text.length; ++i) {
    const head = text[i];
    const c = node.c || /* @__PURE__ */ Object.create(null);
    node.c = c;
    node = c[head] || {};
    c[head] = node;
  }
  node.f = (node.f || 0) | FLAG_WORD;
  return root;
}
function isWordTerminationNode(node) {
  return ((node.f || 0) & FLAG_WORD) === FLAG_WORD;
}
function orderTrie(node) {
  if (!node.c)
    return;
  const nodes = Object.entries(node.c).sort(([a], [b]) => a < b ? -1 : 1);
  node.c = Object.fromEntries(nodes);
  for (const n of nodes) {
    orderTrie(n[1]);
  }
}
function iteratorTrieWords2(node) {
  return walkerWords2(node);
}
function createTrieRoot(options) {
  const fullOptions = mergeOptionalWithDefaults(options);
  return {
    ...fullOptions,
    c: /* @__PURE__ */ Object.create(null)
  };
}
function createTrieRootFromList(words, options) {
  const root = createTrieRoot(options);
  for (const word of words) {
    if (word.length) {
      insert2(word, root);
    }
  }
  return root;
}
function countNodes(root) {
  const seen = /* @__PURE__ */ new Set;
  function walk4(n) {
    if (seen.has(n))
      return;
    seen.add(n);
    if (n.c) {
      Object.values(n.c).forEach((n2) => walk4(n2));
    }
  }
  walk4(root);
  return seen.size;
}
function countWords2(root) {
  const visited = /* @__PURE__ */ new Map;
  function walk4(n) {
    if (visited.has(n)) {
      return visited.get(n);
    }
    let cnt = n.f ? 1 : 0;
    visited.set(n, cnt);
    if (!n.c) {
      return cnt;
    }
    for (const c of Object.values(n.c)) {
      cnt += walk4(c);
    }
    visited.set(n, cnt);
    return cnt;
  }
  return walk4(root);
}
function checkCircular(root) {
  const seen = /* @__PURE__ */ new Set;
  const inStack = /* @__PURE__ */ new Set;
  function walk4(n) {
    if (seen.has(n))
      return { isCircular: false, allSeen: true };
    if (inStack.has(n)) {
      const stack = [...inStack, n];
      const word = trieStackToWord(stack);
      const pos = stack.indexOf(n);
      return { isCircular: true, allSeen: false, ref: { stack, word, pos } };
    }
    inStack.add(n);
    let r = { isCircular: false, allSeen: true };
    if (n.c) {
      r = Object.values(n.c).reduce((acc, n2) => {
        if (acc.isCircular)
          return acc;
        const r2 = walk4(n2);
        r2.allSeen = r2.allSeen && acc.allSeen;
        return r2;
      }, r);
    }
    if (r.allSeen) {
      seen.add(n);
    }
    inStack.delete(n);
    return r;
  }
  return walk4(root);
}
function reverseMapTrieNode(node) {
  return node.c && new Map(Object.entries(node.c).map(([c, n]) => [n, c]));
}
function trieStackToWord(stack) {
  let word = "";
  let lastMap = reverseMapTrieNode(stack[0]);
  for (let i = 1;i < stack.length; ++i) {
    const n = stack[i];
    const char = lastMap?.get(n);
    if (char) {
      word += char;
    }
    lastMap = reverseMapTrieNode(n);
  }
  return word;
}
function isCircular(root) {
  return checkCircular(root).isCircular;
}
function trieNodeToRoot(node, options) {
  const newOptions = mergeOptionalWithDefaults(options);
  return {
    ...newOptions,
    c: node.c || /* @__PURE__ */ Object.create(null)
  };
}
function consolidate(root) {
  let count3 = 0;
  const signatures = /* @__PURE__ */ new Map;
  const cached = /* @__PURE__ */ new Map;
  const knownMap = /* @__PURE__ */ new Map;
  if (isCircular(root)) {
    throw new Error("Trie is circular.");
  }
  function signature2(n) {
    const isWord = n.f ? "*" : "";
    const ref = n.c ? JSON.stringify(Object.entries(n.c).map(([k, n2]) => [k, cached.get(n2)])) : "";
    return isWord + ref;
  }
  function findEow(n) {
    if (n.f && !n.c)
      return n;
    let r;
    if (n.c) {
      for (const c of Object.values(n.c)) {
        r = findEow(c);
        if (r)
          break;
      }
    }
    return r;
  }
  function compareMaps(a, b) {
    for (const e of a) {
      if (b[e[0]] !== e[1])
        return false;
    }
    return a.length === b.size;
  }
  function deepCopy(n) {
    const k = knownMap.get(n);
    if (k) {
      return k;
    }
    const orig = n;
    if (n.c) {
      const children = Object.entries(n.c).map((c) => [c[0], deepCopy(c[1])]);
      if (!compareMaps(children, n.c)) {
        n = { f: n.f, c: Object.fromEntries(children) };
      }
    }
    const sig = signature2(n);
    const ref = signatures.get(sig);
    if (ref) {
      knownMap.set(orig, ref);
      return ref;
    }
    Object.freeze(n);
    signatures.set(sig, n);
    cached.set(n, count3++);
    knownMap.set(orig, n);
    return n;
  }
  function process2(n) {
    if (cached.has(n)) {
      return n;
    }
    if (Object.isFrozen(n)) {
      return knownMap.get(n) || deepCopy(n);
    }
    if (n.c) {
      const children = Object.entries(n.c).sort((a, b) => a[0] < b[0] ? -1 : 1).map(([k, n2]) => [k, process2(n2)]);
      n.c = Object.fromEntries(children);
    }
    const sig = signature2(n);
    const ref = signatures.get(sig);
    if (ref) {
      return ref;
    }
    signatures.set(sig, n);
    cached.set(n, count3++);
    return n;
  }
  const eow = findEow(root) || { f: FLAG_WORD, c: undefined };
  signatures.set(signature2(eow), eow);
  cached.set(eow, count3++);
  return trieNodeToRoot(process2(root), root);
}
var defaultLegacyMinCompoundLength3 = 3;
var _defaultFindOptions2 = {
  matchCase: false,
  compoundMode: "compound",
  forbidPrefix: FORBID_PREFIX,
  compoundFix: COMPOUND_FIX,
  caseInsensitivePrefix: CASE_INSENSITIVE_PREFIX,
  legacyMinCompoundLength: defaultLegacyMinCompoundLength3
};
var arrayCompoundModes2 = ["none", "compound", "legacy"];
var knownCompoundModes2 = new Map(arrayCompoundModes2.map((a) => [a, a]));
function findWord2(root, word, options) {
  return _findWord(root, word, createFindOptions2(options));
}
function findWordNode2(root, word, options) {
  return _findWordNode2(root, word, createFindOptions2(options));
}
function _findWord(root, word, options) {
  const { node: _, ...result } = _findWordNode2(root, word, options);
  return result;
}
function _findWordNode2(root, word, options) {
  const compoundMode = knownCompoundModes2.get(options.compoundMode) || _defaultFindOptions2.compoundMode;
  const compoundPrefix = options.compoundMode === "compound" ? root.compoundCharacter ?? options.compoundFix : "";
  const ignoreCasePrefix = options.matchCase ? "" : root.stripCaseAndAccentsPrefix ?? options.caseInsensitivePrefix;
  function __findCompound() {
    const f = findCompoundWord2(root, word, compoundPrefix, ignoreCasePrefix);
    const result = { ...f };
    if (f.found !== false && f.compoundUsed) {
      const r = !f.caseMatched ? walk3(root, options.caseInsensitivePrefix) : root;
      result.forbidden = isForbiddenWord2(r, word, options.forbidPrefix);
    }
    return result;
  }
  function __findExact() {
    const n = walk3(root, word);
    const isFound = isEndOfWordNode2(n);
    const result = {
      found: isFound && word,
      compoundUsed: false,
      forbidden: isForbiddenWord2(root, word, options.forbidPrefix),
      node: n,
      caseMatched: true
    };
    return result;
  }
  switch (compoundMode) {
    case "none": {
      return options.matchCase ? __findExact() : __findCompound();
    }
    case "compound": {
      return __findCompound();
    }
    case "legacy": {
      return findLegacyCompound2(root, word, options);
    }
  }
}
function findLegacyCompound2(root, word, options) {
  const roots = [root];
  if (!options.matchCase) {
    roots.push(walk3(root, options.caseInsensitivePrefix));
  }
  return findLegacyCompoundNode2(roots, word, options.legacyMinCompoundLength);
}
function findCompoundNode2(root, word, compoundCharacter, ignoreCasePrefix) {
  const stack = [
    { n: root, compoundPrefix: ignoreCasePrefix, cr: undefined, caseMatched: true }
  ];
  const compoundPrefix = compoundCharacter || ignoreCasePrefix;
  const possibleCompoundPrefix = ignoreCasePrefix && compoundCharacter ? ignoreCasePrefix + compoundCharacter : "";
  const nw = word.normalize();
  const w = [...nw];
  function determineRoot(s) {
    const prefix = s.compoundPrefix;
    let r = root;
    let i2;
    for (i2 = 0;i2 < prefix.length && r; ++i2) {
      r = r.c?.[prefix[i2]];
    }
    const caseMatched2 = s.caseMatched && prefix[0] !== ignoreCasePrefix;
    return {
      n: s.n,
      compoundPrefix: prefix === compoundPrefix ? possibleCompoundPrefix : "",
      cr: r,
      caseMatched: caseMatched2
    };
  }
  let compoundUsed = false;
  let caseMatched = true;
  let i = 0;
  let node;
  while (true) {
    const s = stack[i];
    const h = w[i++];
    const n = s.cr || s.n;
    const c = n?.c?.[h];
    if (c && i < word.length) {
      caseMatched = s.caseMatched;
      stack[i] = { n: c, compoundPrefix, cr: undefined, caseMatched };
    } else if (!c || !c.f) {
      node = node || c;
      while (--i > 0) {
        const s2 = stack[i];
        if (!s2.compoundPrefix || !s2.n?.c)
          continue;
        if (compoundCharacter in s2.n.c)
          break;
      }
      if (i >= 0 && stack[i].compoundPrefix) {
        compoundUsed = i > 0;
        const r = determineRoot(stack[i]);
        stack[i] = r;
        if (!r.cr) {
          break;
        }
        if (!i && !r.caseMatched && nw !== nw.toLowerCase()) {
          break;
        }
      } else {
        break;
      }
    } else {
      node = c;
      caseMatched = s.caseMatched;
      break;
    }
  }
  const found = i && i === word.length && word || false;
  const result = { found, compoundUsed, node, forbidden: undefined, caseMatched };
  return result;
}
function findCompoundWord2(root, word, compoundCharacter, ignoreCasePrefix) {
  const { found, compoundUsed, node, caseMatched } = findCompoundNode2(root, word, compoundCharacter, ignoreCasePrefix);
  if (!node || !node.f) {
    return { found: false, compoundUsed, node, forbidden: undefined, caseMatched };
  }
  return { found, compoundUsed, node, forbidden: undefined, caseMatched };
}
function findWordExact2(root, word) {
  return isEndOfWordNode2(walk3(root, word));
}
function isEndOfWordNode2(n) {
  return n?.f === FLAG_WORD;
}
function walk3(root, word) {
  const w = [...word];
  let n = root;
  let i = 0;
  while (n && i < w.length) {
    const h = w[i++];
    n = n.c?.[h];
  }
  return n;
}
function findLegacyCompoundNode2(roots, word, minCompoundLength) {
  const root = roots[0];
  const numRoots = roots.length;
  const stack = [
    { n: root, usedRoots: 1, subLength: 0, isCompound: false, cr: undefined, caseMatched: true }
  ];
  const w = word;
  const wLen = w.length;
  let compoundUsed = false;
  let caseMatched = true;
  let i = 0;
  let node;
  while (true) {
    const s = stack[i];
    const h = w[i++];
    const n = s.cr || s.n;
    const c = n?.c?.[h];
    if (c && i < wLen) {
      stack[i] = {
        n: c,
        usedRoots: 0,
        subLength: s.subLength + 1,
        isCompound: s.isCompound,
        cr: undefined,
        caseMatched: s.caseMatched
      };
    } else if (!c || !c.f || c.f && s.subLength < minCompoundLength - 1) {
      while (--i > 0) {
        const s2 = stack[i];
        if (s2.usedRoots < numRoots && s2.n?.f && (s2.subLength >= minCompoundLength || !s2.subLength) && wLen - i >= minCompoundLength) {
          break;
        }
      }
      if (i > 0 || stack[i].usedRoots < numRoots) {
        compoundUsed = i > 0;
        const s2 = stack[i];
        s2.cr = roots[s2.usedRoots++];
        s2.subLength = 0;
        s2.isCompound = compoundUsed;
        s2.caseMatched = s2.caseMatched && s2.usedRoots <= 1;
      } else {
        break;
      }
    } else {
      node = c;
      caseMatched = s.caseMatched;
      break;
    }
  }
  function extractWord() {
    if (!word || i < word.length)
      return false;
    const letters = [];
    let subLen = 0;
    for (let j = 0;j < i; ++j) {
      const { subLength } = stack[j];
      if (subLength < subLen) {
        letters.push("+");
      }
      letters.push(word[j]);
      subLen = subLength;
    }
    return letters.join("");
  }
  const found = extractWord();
  const result = { found, compoundUsed, node, forbidden: undefined, caseMatched };
  return result;
}
function isForbiddenWord2(root, word, forbiddenPrefix) {
  return findWordExact2(root?.c?.[forbiddenPrefix], word);
}
var createFindOptions2 = memorizeLastCall(_createFindOptions2);
function _createFindOptions2(options) {
  return mergeDefaults(options, _defaultFindOptions2);
}
var TrieNodeTrie = class _TrieNodeTrie {
  constructor(root) {
    this.root = root;
    this.info = mergeOptionalWithDefaults(root);
    this.hasForbiddenWords = !!root.c[root.forbiddenWordPrefix];
    this.hasCompoundWords = !!root.c[root.compoundCharacter];
    this.hasNonStrictWords = !!root.c[root.stripCaseAndAccentsPrefix];
  }
  _iTrieRoot;
  info;
  _size;
  hasForbiddenWords;
  hasCompoundWords;
  hasNonStrictWords;
  wordToCharacters = (word) => [...word];
  get iTrieRoot() {
    return this._iTrieRoot || (this._iTrieRoot = trieRootToITrieRoot(this.root));
  }
  getRoot() {
    return this.iTrieRoot;
  }
  getNode(prefix) {
    return findNode(this.getRoot(), prefix);
  }
  words() {
    return iteratorTrieWords2(this.root);
  }
  has(word) {
    return findWordExact2(this.root, word);
  }
  isForbiddenWord(word) {
    return findWordExact2(this.root.c[this.root.forbiddenWordPrefix], word);
  }
  get size() {
    return this._size ??= countNodes(this.root);
  }
  static createFromWords(words, options) {
    const root = createTrieRootFromList(words, options);
    return new _TrieNodeTrie(root);
  }
  static createFromWordsAndConsolidate(words, options) {
    const root = createTrieRootFromList(words, options);
    return new _TrieNodeTrie(consolidate(root));
  }
};
var EOW = "*";
var DATA = EOW;
function* toIterableIterator2(iter) {
  yield* iter;
}
function importTrie(linesX) {
  let radix = 16;
  const comment = /^\s*#/;
  const iter = toIterableIterator2(linesX);
  function parseHeaderRows(headerRows) {
    const header = headerRows.slice(0, 2).join(`
`);
    const headerReg3 = /^TrieXv1\nbase=(\d+)$/;
    if (!headerReg3.test(header))
      throw new Error("Unknown file format");
    radix = Number.parseInt(header.replace(headerReg3, "$1"), 10);
  }
  function readHeader(iter2) {
    const headerRows = [];
    while (true) {
      const next = iter2.next();
      if (next.done) {
        break;
      }
      const line = next.value.trim();
      if (!line || comment.test(line)) {
        continue;
      }
      if (line === DATA) {
        break;
      }
      headerRows.push(line);
    }
    parseHeaderRows(headerRows);
  }
  const regNotEscapedCommas = /(^|[^\\]),/g;
  const regUnescapeCommas = /__COMMA__/g;
  const regUnescape = /[\\](.)/g;
  const flagsWord = { f: FLAG_WORD };
  function splitLine2(line) {
    const pattern = "$1__COMMA__";
    return line.replaceAll(regNotEscapedCommas, pattern).split(regUnescapeCommas).map((a) => a.replaceAll(regUnescape, "$1"));
  }
  function decodeLine2(line, nodes) {
    const isWord = line[0] === EOW;
    line = isWord ? line.slice(1) : line;
    const flags = isWord ? flagsWord : {};
    const children = splitLine2(line).filter((a) => !!a).map((a) => [a[0], Number.parseInt(a.slice(1) || "0", radix)]).map(([k, i]) => [k, nodes[i]]);
    const cNode = children.length ? { c: Object.fromEntries(children) } : {};
    return { ...cNode, ...flags };
  }
  readHeader(iter);
  const n = genSequence([DATA]).concat(iter).map((a) => a.replace(/\r?\n/, "")).filter((a) => !!a).reduce((acc, line) => {
    const { lines, nodes } = acc;
    const root = decodeLine2(line, nodes);
    nodes[lines] = root;
    return { lines: lines + 1, root, nodes };
  }, { lines: 0, nodes: [], root: {} });
  return trieNodeToRoot(n.root, { isCaseAware: false });
}
var EOW2 = "*";
var DATA2 = "__DATA__";
function* toIterableIterator22(iter) {
  yield* iter;
}
function importTrie2(linesX) {
  let radix = 16;
  const comment = /^\s*#/;
  const iter = toIterableIterator22(linesX);
  function parseHeaderRows(headerRows) {
    const header = headerRows.slice(0, 2).join(`
`);
    const headerReg3 = /^TrieXv2\nbase=(\d+)$/;
    if (!headerReg3.test(header))
      throw new Error("Unknown file format");
    radix = Number.parseInt(header.replace(headerReg3, "$1"), 10);
  }
  function readHeader(iter2) {
    const headerRows = [];
    while (true) {
      const next = iter2.next();
      if (next.done) {
        break;
      }
      const line = next.value.trim();
      if (!line || comment.test(line)) {
        continue;
      }
      if (line === DATA2) {
        break;
      }
      headerRows.push(line);
    }
    parseHeaderRows(headerRows);
  }
  function parseLine(line, base) {
    const isWord = line[1] === EOW2;
    const refOffset = isWord ? 2 : 1;
    const refs = line.slice(refOffset).split(",").filter((a) => !!a).map((r) => Number.parseInt(r, base));
    return {
      letter: line[0],
      isWord,
      refs
    };
  }
  const flagsWord = { f: FLAG_WORD };
  function decodeLine2(line, nodes) {
    const { letter, isWord, refs } = parseLine(line, radix);
    const flags = isWord ? flagsWord : {};
    const children = refs.map((r) => nodes[r]).sort((a, b) => a.s < b.s ? -1 : 1).map((n2) => [n2.s, n2]);
    const cNode = children.length ? { c: Object.fromEntries(children) } : {};
    return { s: letter, ...cNode, ...flags };
  }
  readHeader(iter);
  const n = genSequence(iter).map((a) => a.replace(/\r?\n/, "")).filter((a) => !!a).reduce((acc, line) => {
    const { nodes } = acc;
    const root = decodeLine2(line, nodes);
    nodes.push(root);
    return { root, nodes };
  }, { nodes: [], root: { s: "", c: /* @__PURE__ */ Object.create(null) } });
  return trieNodeToRoot(n.root, { isCaseAware: false });
}
var EOW3 = "$";
var BACK = "<";
var EOL = `
`;
var LF = "\r";
var REF = "#";
var REF_REL = "@";
var EOR = ";";
var ESCAPE = "\\";
var REF_INDEX_BEGIN = "[";
var REF_INDEX_END = "]";
var INLINE_DATA_COMMENT_LINE = "/";
var specialCharacters = stringToCharSet([
  EOW3,
  BACK,
  EOL,
  REF,
  REF_REL,
  EOR,
  ESCAPE,
  LF,
  REF_INDEX_BEGIN,
  REF_INDEX_END,
  INLINE_DATA_COMMENT_LINE,
  ..."0123456789",
  ..."`~!@#$%^&*()_-+=[]{};:'\"<>,./?\\|"
].join(""));
var SPECIAL_CHARACTERS_MAP = [
  [`
`, "\\n"],
  ["\r", "\\r"],
  ["\\", "\\\\"]
];
var specialCharacterMap = stringToCharMap(SPECIAL_CHARACTERS_MAP);
var characterMap = stringToCharMap(SPECIAL_CHARACTERS_MAP.map((a) => [a[1], a[0]]));
var specialPrefix = stringToCharSet("~!");
var DATA3 = "__DATA__";
function importTrie3(linesX) {
  linesX = typeof linesX === "string" ? linesX.split(/^/m) : linesX;
  let radix = 10;
  const comment = /^\s*#/;
  const iter = tapIterable(pipeSync(linesX, opConcatMapSync((a) => a.split(/^/m))));
  function parseHeaderRows(headerRows) {
    const header = headerRows.slice(0, 2).join(`
`);
    const headerReg3 = /^TrieXv[34]\nbase=(\d+)$/;
    if (!headerReg3.test(header))
      throw new Error("Unknown file format");
    radix = Number.parseInt(header.replace(headerReg3, "$1"), 10);
  }
  function readHeader(iter2) {
    const headerRows = [];
    for (const value of iter2) {
      const line = value.trim();
      if (!line || comment.test(line))
        continue;
      if (line === DATA3)
        break;
      headerRows.push(line);
    }
    parseHeaderRows(headerRows);
  }
  readHeader(iter);
  const root = parseStream(radix, iter);
  return root;
}
var numbersSet = stringToCharSet("0123456789");
function parseStream(radix, iter) {
  const eow = Object.freeze({ f: 1 });
  let refIndex = [];
  const root = trieNodeToRoot({}, {});
  function parseReference(acc, s) {
    const isIndexRef = s === REF_REL;
    let ref = "";
    function parser(acc2, s2) {
      if (s2 === EOR || radix === 10 && !(s2 in numbersSet)) {
        const { root: root2, nodes: nodes2, stack } = acc2;
        const r = Number.parseInt(ref, radix);
        const top = stack[stack.length - 1];
        const p = stack[stack.length - 2].node;
        const n = isIndexRef ? refIndex[r] : r;
        p.c && (p.c[top.s] = nodes2[n]);
        const rr = { root: root2, nodes: nodes2, stack, parser: undefined };
        return s2 === EOR ? rr : parserMain(rr, s2);
      }
      ref = ref + s2;
      return acc2;
    }
    const { nodes } = acc;
    nodes.pop();
    return { ...acc, nodes, parser };
  }
  function parseEscapeCharacter(acc, _) {
    let prev = "";
    const parser = function(acc2, s) {
      if (prev) {
        s = characterMap[prev + s] || s;
        return parseCharacter({ ...acc2, parser: undefined }, s);
      }
      if (s === ESCAPE) {
        prev = s;
        return acc2;
      }
      return parseCharacter({ ...acc2, parser: undefined }, s);
    };
    return { ...acc, parser };
  }
  function parseComment(acc, s) {
    const endOfComment = s;
    let isEscaped = false;
    function parser(acc2, s2) {
      if (isEscaped) {
        isEscaped = false;
        return acc2;
      }
      if (s2 === ESCAPE) {
        isEscaped = true;
        return acc2;
      }
      if (s2 === endOfComment) {
        return { ...acc2, parser: undefined };
      }
      return acc2;
    }
    return { ...acc, parser };
  }
  function parseCharacter(acc, s) {
    const parser = undefined;
    const { root: root2, nodes, stack } = acc;
    const top = stack[stack.length - 1];
    const node = top.node;
    const c = node.c ?? /* @__PURE__ */ Object.create(null);
    const n = { f: undefined, c: undefined, n: nodes.length };
    c[s] = n;
    node.c = c;
    stack.push({ node: n, s });
    nodes.push(n);
    return { root: root2, nodes, stack, parser };
  }
  function parseEOW(acc, _) {
    const parser = parseBack;
    const { root: root2, nodes, stack } = acc;
    const top = stack[stack.length - 1];
    const node = top.node;
    node.f = FLAG_WORD;
    if (!node.c) {
      top.node = eow;
      const p = stack[stack.length - 2].node;
      p.c && (p.c[top.s] = eow);
      nodes.pop();
    }
    stack.pop();
    return { root: root2, nodes, stack, parser };
  }
  const charactersBack = stringToCharSet(BACK + "23456789");
  function parseBack(acc, s) {
    if (!(s in charactersBack)) {
      return parserMain({ ...acc, parser: undefined }, s);
    }
    let n = s === BACK ? 1 : Number.parseInt(s, 10) - 1;
    const { stack } = acc;
    while (n-- > 0) {
      stack.pop();
    }
    return { ...acc, parser: parseBack };
  }
  function parseIgnore(acc, _) {
    return acc;
  }
  const parsers = createStringLookupMap([
    [EOW3, parseEOW],
    [BACK, parseBack],
    [REF, parseReference],
    [REF_REL, parseReference],
    [ESCAPE, parseEscapeCharacter],
    [EOL, parseIgnore],
    [LF, parseIgnore],
    [INLINE_DATA_COMMENT_LINE, parseComment]
  ]);
  function parserMain(acc, s) {
    const parser = acc.parser ?? parsers[s] ?? parseCharacter;
    return parser(acc, s);
  }
  const charsetSpaces = stringToCharSet(` \r
\t`);
  function parseReferenceIndex(acc, s) {
    let json = "";
    function parserStart(acc2, s2) {
      if (s2 === REF_INDEX_BEGIN) {
        json = json + s2;
        return { ...acc2, parser };
      }
      if (s2 in charsetSpaces) {
        return acc2;
      }
      return parserMain({ ...acc2, parser: undefined }, s2);
    }
    function parser(acc2, s2) {
      json = json + s2;
      if (s2 === REF_INDEX_END) {
        refIndex = json.replaceAll(/[\s[\]]/g, "").split(",").map((n) => Number.parseInt(n, radix));
        return { ...acc2, parser: undefined };
      }
      return acc2;
    }
    return parserStart({ ...acc, parser: parserStart }, s);
  }
  reduceSync(pipeSync(iter, opConcatMapSync((a) => [...a])), parserMain, {
    nodes: [root],
    root,
    stack: [{ node: root, s: "" }],
    parser: parseReferenceIndex
  });
  return root;
}
function stringToCharSet(values) {
  const set = /* @__PURE__ */ Object.create(null);
  const len = values.length;
  for (let i = 0;i < len; ++i) {
    set[values[i]] = true;
  }
  return set;
}
function stringToCharMap(values) {
  return createStringLookupMap(values);
}
function createStringLookupMap(values) {
  const map3 = /* @__PURE__ */ Object.create(null);
  const len = values.length;
  for (let i = 0;i < len; ++i) {
    map3[values[i][0]] = values[i][1];
  }
  return map3;
}
function tapIterable(iterable) {
  let lastValue;
  let iter;
  function getNext() {
    if (lastValue && lastValue.done) {
      return { ...lastValue };
    }
    iter = iter || iterable[Symbol.iterator]();
    lastValue = iter.next();
    return lastValue;
  }
  function* iterableFn() {
    let next;
    while (!(next = getNext()).done) {
      yield next.value;
    }
  }
  return {
    [Symbol.iterator]: iterableFn
  };
}
function assert4(condition, message = "Assert Failed") {
  if (condition)
    return;
  throw new Error(message);
}
var EOW4 = Object.freeze({ f: 1, k: true });
var compare3 = new Intl.Collator().compare;
var TrieNodeBuilder = class {
  _cursor;
  root = { ...defaultTrieInfo, c: /* @__PURE__ */ Object.create(null) };
  shouldSort = false;
  wordToCharacters = (word) => [...word];
  setOptions(options) {
    const opts = mergeOptionalWithDefaults(options, this.root);
    Object.assign(this.root, opts);
    return opts;
  }
  build() {
    return new TrieNodeTrie(this.root);
  }
  getCursor() {
    this._cursor ??= this.createCursor();
    return this._cursor;
  }
  setCharacterSet(_characters) {
    this.shouldSort = true;
  }
  createCursor() {
    const nodes = [this.root, EOW4];
    const eow = EOW4;
    assert4(Object.keys(this.root.c).length === 0, "The Trie MUST be empty for cursors to work.");
    const stack = [{ n: this.root, c: "" }];
    let currNode = this.root;
    let depth = 0;
    const insertChar = (char) => {
      assertIsValidChar(char);
      if (currNode.k) {
        const s2 = stack[depth];
        const { k: _, c: c3, ...copy } = currNode;
        currNode = s2.n.c[s2.c] = copy;
        if (c3) {
          currNode.c = Object.assign(/* @__PURE__ */ Object.create(null), c3);
        }
        nodes.push(currNode);
      }
      const c2 = currNode.c || /* @__PURE__ */ Object.create(null);
      currNode.c = c2;
      const n = currNode;
      const next = c2[char] = c2[char] || {};
      nodes.push(next);
      ++depth;
      const s = stack[depth];
      if (s) {
        s.n = n;
        s.c = char;
      } else {
        stack.push({ n, c: char });
      }
      currNode = next;
    };
    const markEOW = () => {
      if (!currNode.c) {
        const s = stack[depth];
        s.n.c[s.c] = eow;
        if (nodes[nodes.length - 1] === currNode) {
          nodes.pop();
        }
        currNode = eow;
      } else {
        currNode.f = 1;
      }
    };
    const reference = (nodeId) => {
      const s = stack[depth];
      s.n.c[s.c] = nodes[nodeId];
      nodes.pop();
    };
    const backStep = (num) => {
      if (!num)
        return;
      assert4(num <= depth && num > 0);
      depth -= num;
      currNode = stack[depth + 1].n;
    };
    const c = {
      insertChar,
      markEOW,
      reference,
      backStep
    };
    return c;
  }
  sortChildren(node) {
    const entries = Object.entries(node.c).sort((a, b) => compare3(a[0], b[0]));
    node.c = Object.fromEntries(entries);
    for (const c of Object.values(node.c)) {
      if (c.c) {
        this.sortChildren(c);
      }
    }
  }
  sortNodes() {
    if (this.shouldSort) {
      this.sortChildren(this.root);
    }
  }
};
var specialCharacterMap2 = /* @__PURE__ */ new Map([
  [`
`, "\\n"],
  ["\r", "\\r"],
  ["\\", "\\\\"]
]);
var characterMap2 = new Map([...specialCharacterMap2].map((a) => [a[1], a[0]]));
var DATA4 = "__DATA__";
function importTrieV3WithBuilder(builder, srcLines) {
  const timer = getGlobalPerfTimer();
  const timerStart = timer.start("importTrieV3");
  const dataLines = typeof srcLines === "string" ? srcLines.split(`
`) : Array.isArray(srcLines) ? srcLines : [...srcLines];
  let radix = 16;
  const comment = /^\s*#/;
  function parseHeaderRows(headerRows) {
    const header = headerRows.slice(0, 2).join(`
`);
    const headerReg3 = /^TrieXv3\nbase=(\d+)$/;
    if (!headerReg3.test(header))
      throw new Error("Unknown file format");
    radix = Number.parseInt(header.replace(headerReg3, "$1"), 10);
  }
  function findStartOfData(data) {
    for (let i = 0;i < data.length; ++i) {
      const line = data[i];
      if (line.includes(DATA4)) {
        return i;
      }
    }
    return -1;
  }
  function readHeader(data) {
    const headerRows = [];
    for (const hLine of data) {
      const line = hLine.trim();
      if (!line || comment.test(line)) {
        continue;
      }
      if (line === DATA4) {
        break;
      }
      headerRows.push(line);
    }
    parseHeaderRows(headerRows);
  }
  const startOfData = findStartOfData(dataLines);
  if (startOfData < 0) {
    throw new Error("Unknown file format");
  }
  readHeader(dataLines.slice(0, startOfData));
  const cursor = builder.getCursor();
  let node = {
    cursor,
    parser: undefined
  };
  const parser = parseStream2(radix);
  const timerParse = timer.start("importTrieV3.parse");
  for (let i = startOfData + 1;i < dataLines.length; ++i) {
    const line = dataLines[i];
    for (const c of line) {
      node = parser(node, c);
    }
  }
  timerParse();
  timerStart();
  return builder.build();
}
function parseStream2(radix) {
  function parseReference(acc, _) {
    let ref = "";
    function parser(acc2, s) {
      if (s === EOR) {
        const { cursor } = acc2;
        const r = Number.parseInt(ref, radix);
        cursor.reference(r + 1);
        acc2.parser = undefined;
        return acc2;
      }
      ref = ref + s;
      return acc2;
    }
    acc.parser = parser;
    return acc;
  }
  function parseEscapeCharacter(acc, _) {
    let prev = "";
    const parser = function(acc2, s) {
      if (prev) {
        s = characterMap2.get(prev + s) || s;
        acc2.parser = undefined;
        return parseCharacter(acc2, s);
      }
      if (s === ESCAPE) {
        prev = s;
        return acc2;
      }
      acc2.parser = undefined;
      return parseCharacter(acc2, s);
    };
    acc.parser = parser;
    return acc;
  }
  function parseCharacter(acc, s) {
    acc.cursor.insertChar(s);
    acc.parser = undefined;
    return acc;
  }
  function parseEOW(acc, _) {
    acc.parser = parseBack;
    acc.cursor.markEOW();
    acc.cursor.backStep(1);
    return acc;
  }
  const charactersBack = stringToCharSet2(BACK + "23456789");
  function parseBack(acc, s) {
    if (!(s in charactersBack)) {
      acc.parser = undefined;
      return parserMain(acc, s);
    }
    const n = s === BACK ? 1 : Number.parseInt(s, 10) - 1;
    acc.cursor.backStep(n);
    acc.parser = parseBack;
    return acc;
  }
  function parseIgnore(acc, _) {
    return acc;
  }
  const parsers = /* @__PURE__ */ new Map([
    [EOW3, parseEOW],
    [BACK, parseBack],
    [REF, parseReference],
    [ESCAPE, parseEscapeCharacter],
    [EOL, parseIgnore],
    [LF, parseIgnore]
  ]);
  function parserMain(acc, s) {
    const parser = acc.parser ?? parsers.get(s) ?? parseCharacter;
    return parser(acc, s);
  }
  return parserMain;
}
function stringToCharSet2(values) {
  const set = /* @__PURE__ */ Object.create(null);
  const len = values.length;
  for (let i = 0;i < len; ++i) {
    set[values[i]] = true;
  }
  return set;
}
function importTrieV3AsFastTrieBlob(srcLines) {
  return importTrieV3WithBuilder(new FastTrieBlobBuilder, srcLines);
}
function decodeTrieData(raw) {
  return decodeStringFormat(typeof raw === "string" ? raw : raw.toString("utf8"));
}
function decodeStringFormat(data) {
  return importTrie4(data);
}
var deserializers = [
  (data) => new TrieNodeTrie(importTrie(data)),
  (data) => new TrieNodeTrie(importTrie(data)),
  (data) => new TrieNodeTrie(importTrie2(data)),
  (data) => importTrieV3AsFastTrieBlob(data),
  (data) => new TrieNodeTrie(importTrie3(data))
];
var headerReg = /^\s*TrieXv(\d+)/m;
function importTrie4(input) {
  const lines = Array.isArray(input) ? input : typeof input === "string" ? input.split(`
`) : [...input];
  function parseHeaderRows(headerRows) {
    for (let i = 0;i < headerRows.length; ++i) {
      const match = headerRows[i].match(headerReg);
      if (match) {
        return Number.parseInt(match[1], 10);
      }
    }
    throw new Error("Unknown file format");
  }
  function readHeader(iter) {
    const headerRows = [];
    for (const entry of iter) {
      const line = entry.trim();
      headerRows.push(line);
      if (line === DATA || line === DATA2) {
        break;
      }
    }
    return headerRows;
  }
  const headerLines = readHeader(lines);
  const version2 = parseHeaderRows(headerLines);
  const method = deserializers[version2];
  if (!method) {
    throw new Error(`Unsupported version: ${version2}`);
  }
  return method(lines);
}
function decodeTrie(raw) {
  const data = decodeTrieData(raw);
  return new ITrieImpl(data);
}
var specialCharacters2 = stringToCharSet3([EOW3, BACK, EOL, REF, EOR, ESCAPE, LF, "0123456789", "`~!@#$%^&*()_-+=[]{};:'\"<>,./?\\|"].join(""));
var specialPrefix2 = stringToCharSet3("~!");
function stringToCharSet3(values) {
  const set = /* @__PURE__ */ Object.create(null);
  const len = values.length;
  for (let i = 0;i < len; ++i) {
    set[values[i]] = true;
  }
  return set;
}
var codes = [
  ["af", "Afrikaans"],
  ["af-NA", "Afrikaans", "Namibia"],
  ["af-ZA", "Afrikaans", "South Africa"],
  ["ak", "Akan"],
  ["ak-GH", "Akan", "Ghana"],
  ["am", "Amharic"],
  ["am-ET", "Amharic", "Ethiopia"],
  ["ar", "Arabic"],
  ["ar-1", "Arabic"],
  ["ar-AE", "Arabic", "United Arab Emirates"],
  ["ar-BH", "Arabic", "Bahrain"],
  ["ar-DJ", "Arabic", "Djibouti"],
  ["ar-DZ", "Arabic", "Algeria"],
  ["ar-EG", "Arabic", "Egypt"],
  ["ar-EH", "Arabic"],
  ["ar-ER", "Arabic", "Eritrea"],
  ["ar-IL", "Arabic", "Israel"],
  ["ar-IQ", "Arabic", "Iraq"],
  ["ar-JO", "Arabic", "Jordan"],
  ["ar-KM", "Arabic", "Comoros"],
  ["ar-KW", "Arabic", "Kuwait"],
  ["ar-LB", "Arabic", "Lebanon"],
  ["ar-LY", "Arabic", "Libya"],
  ["ar-MA", "Arabic", "Morocco"],
  ["ar-MR", "Arabic", "Mauritania"],
  ["ar-OM", "Arabic", "Oman"],
  ["ar-PS", "Arabic"],
  ["ar-QA", "Arabic", "Qatar"],
  ["ar-SA", "Arabic", "Saudi Arabia"],
  ["ar-SD", "Arabic", "Sudan"],
  ["ar-SO", "Arabic", "Somalia"],
  ["ar-SS", "Arabic"],
  ["ar-SY", "Arabic", "Syria"],
  ["ar-TD", "Arabic", "Chad"],
  ["ar-TN", "Arabic", "Tunisia"],
  ["ar-YE", "Arabic", "Yemen"],
  ["as", "Assamese"],
  ["as-IN", "Assamese", "India"],
  ["az", "Azerbaijani"],
  ["az-AZ", "Azerbaijani", "Azerbaijan"],
  ["be", "Belarusian"],
  ["be-BY", "Belarusian", "Belarus"],
  ["bg", "Bulgarian"],
  ["bg-BG", "Bulgarian", "Bulgaria"],
  ["bm", "Bambara"],
  ["bm-ML", "Bambara", "Mali"],
  ["bn", "Bengali"],
  ["bn-BD", "Bengali", "Bangladesh"],
  ["bn-IN", "Bengali", "India"],
  ["bo", "Tibetan"],
  ["bo-CN", "Tibetan", "China"],
  ["bo-IN", "Tibetan", "India"],
  ["br", "Breton"],
  ["br-FR", "Breton", "France"],
  ["bs", "Bosnian"],
  ["bs-BA", "Bosnian", "Bosnia and Herzegovina"],
  ["ca", "Catalan"],
  ["ca-AD", "Catalan", "Andorra"],
  ["ca-ES", "Catalan", "Spain"],
  ["ca-FR", "Catalan", "France"],
  ["ca-IT", "Catalan", "Italy"],
  ["ce", "Chechen"],
  ["ce-RU", "Chechen", "Russia"],
  ["cs", "Czech"],
  ["cs-CZ", "Czech", "Czech Republic"],
  ["cu", "Old Slavonic"],
  ["cu-RU", "Old Slavonic", "Russia"],
  ["cy", "Welsh"],
  ["cy-GB", "Welsh", "United Kingdom"],
  ["da", "Danish"],
  ["da-DK", "Danish", "Denmark"],
  ["da-GL", "Danish", "Greenland"],
  ["de", "German"],
  ["de-AT", "German", "Austria"],
  ["de-BE", "German", "Belgium"],
  ["de-CH", "German", "Switzerland"],
  ["de-DE", "German", "Germany"],
  ["de-IT", "German", "Italy"],
  ["de-LI", "German", "Liechtenstein"],
  ["de-LU", "German", "Luxembourg"],
  ["dz", "Dzongkha"],
  ["dz-BT", "Dzongkha", "Bhutan"],
  ["ee", "Ewe"],
  ["ee-GH", "Ewe", "Ghana"],
  ["ee-TG", "Ewe", "Togo"],
  ["el", "Greek", "Modern (1453-)"],
  ["el-CY", "Greek", "Cyprus"],
  ["el-GR", "Greek", "Greece"],
  ["en", "English"],
  ["en-AG", "English", "Antigua and Barbuda"],
  ["en-AI", "English", "Anguilla"],
  ["en-AS", "English", "American Samoa"],
  ["en-AT", "English", "Austria"],
  ["en-AU", "English", "Australia"],
  ["en-BB", "English", "Barbados"],
  ["en-BE", "English", "Belgium"],
  ["en-BI", "English", "Burundi"],
  ["en-BM", "English", "Bermuda"],
  ["en-BS", "English", "Bahamas"],
  ["en-BW", "English", "Botswana"],
  ["en-BZ", "English", "Belize"],
  ["en-CA", "English", "Canada"],
  ["en-CC", "English", "Cocos (Keeling) Islands"],
  ["en-CH", "English", "Switzerland"],
  ["en-CK", "English", "Cook Islands"],
  ["en-CM", "English", "Cameroon"],
  ["en-CX", "English", "Christmas Island"],
  ["en-CY", "English", "Cyprus"],
  ["en-DE", "English", "Germany"],
  ["en-DG", "English"],
  ["en-DK", "English", "Denmark"],
  ["en-DM", "English", "Dominica"],
  ["en-ER", "English", "Eritrea"],
  ["en-FI", "English", "Finland"],
  ["en-FJ", "English", "Fiji"],
  ["en-FK", "English", "Falkland Islands (Islas Malvinas)"],
  ["en-FM", "English", "Micronesia"],
  ["en-GB", "English", "United Kingdom"],
  ["en-GD", "English", "Grenada"],
  ["en-GG", "English", "Guernsey"],
  ["en-GH", "English", "Ghana"],
  ["en-GI", "English", "Gibraltar"],
  ["en-GM", "English", "Gambia"],
  ["en-GU", "English", "Guam"],
  ["en-GY", "English", "Guyana"],
  ["en-HK", "English", "Hong Kong"],
  ["en-IE", "English", "Ireland"],
  ["en-IL", "English", "Israel"],
  ["en-IM", "English", "Isle of Man"],
  ["en-IN", "English", "India"],
  ["en-IO", "English", "British Indian Ocean Territory"],
  ["en-JE", "English", "Jersey"],
  ["en-JM", "English", "Jamaica"],
  ["en-KE", "English", "Kenya"],
  ["en-KI", "English", "Kiribati"],
  ["en-KN", "English", "Saint Kitts and Nevis"],
  ["en-KY", "English", "Cayman Islands"],
  ["en-LC", "English", "Saint Lucia"],
  ["en-LR", "English", "Liberia"],
  ["en-LS", "English", "Lesotho"],
  ["en-MG", "English", "Madagascar"],
  ["en-MH", "English", "Marshall Islands"],
  ["en-MO", "English", "Macau"],
  ["en-MP", "English", "Northern Mariana Islands"],
  ["en-MS", "English", "Montserrat"],
  ["en-MT", "English", "Malta"],
  ["en-MU", "English", "Mauritius"],
  ["en-MW", "English", "Malawi"],
  ["en-MY", "English", "Malaysia"],
  ["en-NA", "English", "Namibia"],
  ["en-NF", "English", "Norfolk Island"],
  ["en-NG", "English", "Nigeria"],
  ["en-NL", "English", "Netherlands"],
  ["en-NR", "English", "Nauru"],
  ["en-NU", "English", "Niue"],
  ["en-NZ", "English", "New Zealand"],
  ["en-PG", "English", "Papua New Guinea"],
  ["en-PH", "English", "Philippines"],
  ["en-PK", "English", "Pakistan"],
  ["en-PN", "English", "Pitcairn Islands"],
  ["en-PR", "English", "Puerto Rico"],
  ["en-PW", "English", "Palau"],
  ["en-RW", "English", "Rwanda"],
  ["en-SB", "English", "Solomon Islands"],
  ["en-SC", "English", "Seychelles"],
  ["en-SD", "English", "Sudan"],
  ["en-SE", "English", "Sweden"],
  ["en-SG", "English", "Singapore"],
  ["en-SH", "English", "Saint Helena"],
  ["en-SI", "English", "Slovenia"],
  ["en-SL", "English", "Sierra Leone"],
  ["en-SS", "English"],
  ["en-SX", "English"],
  ["en-SZ", "English", "Swaziland"],
  ["en-TC", "English", "Turks and Caicos Islands"],
  ["en-TK", "English", "Tokelau"],
  ["en-TO", "English", "Tonga"],
  ["en-TT", "English", "Trinidad and Tobago"],
  ["en-TV", "English", "Tuvalu"],
  ["en-TZ", "English", "Tanzania"],
  ["en-UG", "English", "Uganda"],
  ["en-UM", "English", "Baker Island"],
  ["en-US", "English", "United States"],
  ["en-VC", "English", "Saint Vincent and the Grenadines"],
  ["en-VG", "English", "British Virgin Islands"],
  ["en-VI", "English", "U.S. Virgin Islands"],
  ["en-VU", "English", "Vanuatu"],
  ["en-WS", "English", "Samoa"],
  ["en-ZA", "English", "South Africa"],
  ["en-ZM", "English", "Zambia"],
  ["en-ZW", "English", "Zimbabwe"],
  ["eo", "Esperanto"],
  ["es", "Spanish"],
  ["es-AR", "Spanish", "Argentina"],
  ["es-BO", "Spanish", "Bolivia"],
  ["es-BR", "Spanish", "Brazil"],
  ["es-BZ", "Spanish", "Belize"],
  ["es-CL", "Spanish", "Chile"],
  ["es-CO", "Spanish", "Colombia"],
  ["es-CR", "Spanish", "Costa Rica"],
  ["es-CU", "Spanish", "Cuba"],
  ["es-DO", "Spanish", "Dominican Republic"],
  ["es-EA", "Spanish"],
  ["es-EC", "Spanish", "Ecuador"],
  ["es-ES", "Spanish", "Spain"],
  ["es-GQ", "Spanish", "Equatorial Guinea"],
  ["es-GT", "Spanish", "Guatemala"],
  ["es-HN", "Spanish", "Honduras"],
  ["es-IC", "Spanish"],
  ["es-MX", "Spanish", "Mexico"],
  ["es-NI", "Spanish", "Nicaragua"],
  ["es-PA", "Spanish", "Panama"],
  ["es-PE", "Spanish", "Peru"],
  ["es-PH", "Spanish", "Philippines"],
  ["es-PR", "Spanish", "Puerto Rico"],
  ["es-PY", "Spanish", "Paraguay"],
  ["es-SV", "Spanish", "El Salvador"],
  ["es-US", "Spanish", "United States"],
  ["es-UY", "Spanish", "Uruguay"],
  ["es-VE", "Spanish", "Venezuela"],
  ["et", "Estonian"],
  ["et-EE", "Estonian", "Estonia"],
  ["eu", "Basque"],
  ["eu-ES", "Basque", "Spain"],
  ["fa", "Persian"],
  ["fa-AF", "Persian", "Afghanistan"],
  ["fa-IR", "Persian", "Iran"],
  ["ff", "Fulah"],
  ["ff-CM", "Fulah", "Cameroon"],
  ["ff-GN", "Fulah", "Guinea"],
  ["ff-MR", "Fulah", "Mauritania"],
  ["ff-SN", "Fulah", "Senegal"],
  ["fi", "Finnish"],
  ["fi-FI", "Finnish", "Finland"],
  ["fo", "Faroese"],
  ["fo-DK", "Faroese", "Denmark"],
  ["fo-FO", "Faroese", "Faroe Islands"],
  ["fr", "French"],
  ["fr-BE", "French", "Belgium"],
  ["fr-BF", "French", "Burkina Faso"],
  ["fr-BI", "French", "Burundi"],
  ["fr-BJ", "French", "Benin"],
  ["fr-BL", "French"],
  ["fr-CA", "French", "Canada"],
  ["fr-CD", "French", "Congo"],
  ["fr-CF", "French", "Central African Republic"],
  ["fr-CG", "French", "Congo"],
  ["fr-CH", "French", "Switzerland"],
  ["fr-CI", "French, Cote d'Ivoire (Ivory Coast)"],
  ["fr-CM", "French", "Cameroon"],
  ["fr-DJ", "French", "Djibouti"],
  ["fr-DZ", "French", "Algeria"],
  ["fr-FR", "French", "France"],
  ["fr-GA", "French", "Gabon"],
  ["fr-GF", "French", "French Guiana"],
  ["fr-GN", "French", "Guinea"],
  ["fr-GP", "French", "Saint Barthelemy"],
  ["fr-GQ", "French", "Equatorial Guinea"],
  ["fr-HT", "French", "Haiti"],
  ["fr-KM", "French", "Comoros"],
  ["fr-LU", "French", "Luxembourg"],
  ["fr-MA", "French", "Morocco"],
  ["fr-MC", "French", "Monaco"],
  ["fr-MF", "French"],
  ["fr-MG", "French", "Madagascar"],
  ["fr-ML", "French", "Mali"],
  ["fr-MQ", "French", "Martinique"],
  ["fr-MR", "French", "Mauritania"],
  ["fr-MU", "French", "Mauritius"],
  ["fr-NC", "French", "New Caledonia"],
  ["fr-NE", "French", "Niger"],
  ["fr-PF", "French", "French Polynesia"],
  ["fr-PM", "French", "Saint Pierre and Miquelon"],
  ["fr-RE", "French", "Reunion"],
  ["fr-RW", "French", "Rwanda"],
  ["fr-SC", "French", "Seychelles"],
  ["fr-SN", "French", "Senegal"],
  ["fr-SY", "French", "Syria"],
  ["fr-TD", "French", "Chad"],
  ["fr-TG", "French", "Togo"],
  ["fr-TN", "French", "Tunisia"],
  ["fr-VU", "French", "Vanuatu"],
  ["fr-WF", "French", "Wallis and Futuna"],
  ["fr-YT", "French", "Mayotte"],
  ["fy", "Western Frisian"],
  ["fy-NL", "Western Frisian", "Netherlands"],
  ["ga", "Irish"],
  ["ga-IE", "Irish", "Ireland"],
  ["gd", "Gaelic"],
  ["gd-GB", "Gaelic", "United Kingdom"],
  ["gl", "Galician"],
  ["gl-ES", "Galician", "Spain"],
  ["gu", "Gujarati"],
  ["gu-IN", "Gujarati", "India"],
  ["gv", "Manx"],
  ["gv-IM", "Manx", "Isle of Man"],
  ["ha", "Hausa"],
  ["ha-GH", "Hausa", "Ghana"],
  ["ha-NE", "Hausa", "Niger"],
  ["ha-NG", "Hausa", "Nigeria"],
  ["he", "Hebrew"],
  ["he-IL", "Hebrew", "Israel"],
  ["hi", "Hindi"],
  ["hi-IN", "Hindi", "India"],
  ["hr", "Croatian"],
  ["hr-BA", "Croatian", "Bosnia and Herzegovina"],
  ["hr-HR", "Croatian", "Croatia"],
  ["hu", "Hungarian"],
  ["hu-HU", "Hungarian", "Hungary"],
  ["hy", "Armenian"],
  ["hy-AM", "Armenian", "Armenia"],
  ["id", "Indonesian"],
  ["id-ID", "Indonesian", "Indonesia"],
  ["ig", "Igbo"],
  ["ig-NG", "Igbo", "Nigeria"],
  ["ii", "Sichuan Yi"],
  ["ii-CN", "Sichuan Yi", "China"],
  ["is", "Icelandic"],
  ["is-IS", "Icelandic", "Iceland"],
  ["it", "Italian"],
  ["it-CH", "Italian", "Switzerland"],
  ["it-IT", "Italian", "Italy"],
  ["it-SM", "Italian", "San Marino"],
  ["it-VA", "Italian", "Vatican City"],
  ["ja", "Japanese"],
  ["ja-JP", "Japanese", "Japan"],
  ["ka", "Georgian"],
  ["ka-GE", "Georgian", "Georgia"],
  ["ki", "Kikuyu"],
  ["ki-KE", "Kikuyu", "Kenya"],
  ["kk", "Kazakh"],
  ["kk-KZ", "Kazakh", "Kazakhstan"],
  ["kl", "Kalaallisut"],
  ["kl-GL", "Kalaallisut", "Greenland"],
  ["km", "Central Khmer"],
  ["km-KH", "Central Khmer", "Cambodia"],
  ["kn", "Kannada"],
  ["kn-IN", "Kannada", "India"],
  ["ko", "Korean"],
  ["ko-KP", "Korean", "Korea"],
  ["ko-KR", "Korean", "Korea"],
  ["ks", "Kashmiri"],
  ["ks-IN", "Kashmiri", "India"],
  ["kw", "Cornish"],
  ["kw-GB", "Cornish", "United Kingdom"],
  ["ky", "Kirghiz"],
  ["ky-KG", "Kirghiz", "Kyrgyzstan"],
  ["lb", "Luxembourgish"],
  ["lb-LU", "Luxembourgish", "Luxembourg"],
  ["lg", "Ganda"],
  ["lg-UG", "Ganda", "Uganda"],
  ["ln", "Lingala"],
  ["ln-AO", "Lingala", "Angola"],
  ["ln-CD", "Lingala", "Congo"],
  ["ln-CF", "Lingala", "Central African Republic"],
  ["ln-CG", "Lingala", "Congo"],
  ["lo", "Lao"],
  ["lo-LA", "Lao", "Laos"],
  ["lt", "Lithuanian"],
  ["lt-LT", "Lithuanian", "Lithuania"],
  ["lu", "Luba-Katanga"],
  ["lu-CD", "Luba-Katanga", "Congo"],
  ["lv", "Latvian"],
  ["lv-LV", "Latvian", "Latvia"],
  ["mg", "Malagasy"],
  ["mg-MG", "Malagasy", "Madagascar"],
  ["mk", "Macedonian"],
  ["mk-MK", "Macedonian", "Macedonia"],
  ["ml", "Malayalam"],
  ["ml-IN", "Malayalam", "India"],
  ["mn", "Mongolian"],
  ["mn-MN", "Mongolian", "Mongolia"],
  ["mr", "Marathi"],
  ["mr-IN", "Marathi", "India"],
  ["ms", "Malay"],
  ["ms-BN", "Malay", "Brunei"],
  ["ms-MY", "Malay", "Malaysia"],
  ["ms-SG", "Malay", "Singapore"],
  ["mt", "Maltese"],
  ["mt-MT", "Maltese", "Malta"],
  ["my", "Burmese"],
  ["my-MM", "Burmese", "Myanmar (Burma)"],
  ["nb", "Bokml Norwegian"],
  ["nb-NO", "Bokml Norwegian", "Norway"],
  ["nb-SJ", "Bokml Norwegian", "Svalbard"],
  ["nd", "Ndebele, North"],
  ["nd-ZW", "Ndebele, North", "Zimbabwe"],
  ["ne", "Nepali"],
  ["ne-IN", "Nepali", "India"],
  ["ne-NP", "Nepali", "Nepal"],
  ["nl", "Dutch"],
  ["nl-AW", "Dutch", "Aruba"],
  ["nl-BE", "Dutch", "Belgium"],
  ["nl-BQ", "Dutch"],
  ["nl-CW", "Dutch"],
  ["nl-NL", "Dutch", "Netherlands"],
  ["nl-SR", "Dutch", "Suriname"],
  ["nl-SX", "Dutch"],
  ["nn", "Norwegian Nynorsk"],
  ["nn-NO", "Norwegian Nynorsk", "Norway"],
  ["om", "Oromo"],
  ["om-ET", "Oromo", "Ethiopia"],
  ["om-KE", "Oromo", "Kenya"],
  ["or", "Oriya"],
  ["or-IN", "Oriya", "India"],
  ["os", "Ossetian"],
  ["os-GE", "Ossetian", "Georgia"],
  ["os-RU", "Ossetian", "Russia"],
  ["pa", "Panjabi"],
  ["pa-IN", "Panjabi", "India"],
  ["pa-PK", "Panjabi", "Pakistan"],
  ["pl", "Polish"],
  ["pl-PL", "Polish", "Poland"],
  ["ps", "Pushto"],
  ["ps-AF", "Pushto", "Afghanistan"],
  ["pt", "Portuguese"],
  ["pt-AO", "Portuguese", "Angola"],
  ["pt-BR", "Portuguese", "Brazil"],
  ["pt-CH", "Portuguese", "Switzerland"],
  ["pt-CV", "Portuguese", "Cape Verde"],
  ["pt-GQ", "Portuguese", "Equatorial Guinea"],
  ["pt-GW", "Portuguese", "Guinea-Bissau"],
  ["pt-LU", "Portuguese", "Luxembourg"],
  ["pt-MO", "Portuguese", "Macau"],
  ["pt-MZ", "Portuguese", "Mozambique"],
  ["pt-PT", "Portuguese", "Portugal"],
  ["pt-ST", "Portuguese", "Sao Tome and Principe"],
  ["pt-TL", "Portuguese", "Timor-Leste (East Timor)"],
  ["qu", "Quechua"],
  ["qu-BO", "Quechua", "Bolivia"],
  ["qu-EC", "Quechua", "Ecuador"],
  ["qu-PE", "Quechua", "Peru"],
  ["rm", "Romansh"],
  ["rm-CH", "Romansh", "Switzerland"],
  ["rn", "Rundi"],
  ["rn-BI", "Rundi", "Burundi"],
  ["ro", "Romanian"],
  ["ro-MD", "Romanian", "Moldova"],
  ["ro-RO", "Romanian", "Romania"],
  ["ru", "Russian"],
  ["ru-BY", "Russian", "Belarus"],
  ["ru-KG", "Russian", "Kyrgyzstan"],
  ["ru-KZ", "Russian", "Kazakhstan"],
  ["ru-MD", "Russian", "Moldova"],
  ["ru-RU", "Russian", "Russia"],
  ["ru-UA", "Russian", "Ukraine"],
  ["rw", "Kinyarwanda"],
  ["rw-RW", "Kinyarwanda", "Rwanda"],
  ["se", "Northern Sami"],
  ["se-FI", "Northern Sami", "Finland"],
  ["se-NO", "Northern Sami", "Norway"],
  ["se-SE", "Northern Sami", "Sweden"],
  ["sg", "Sango"],
  ["sg-CF", "Sango", "Central African Republic"],
  ["si", "Sinhala"],
  ["si-LK", "Sinhala", "Sri Lanka"],
  ["sk", "Slovak"],
  ["sk-SK", "Slovak", "Slovakia"],
  ["sl", "Slovenian"],
  ["sl-SI", "Slovenian", "Slovenia"],
  ["sn", "Shona"],
  ["sn-ZW", "Shona", "Zimbabwe"],
  ["so", "Somali"],
  ["so-DJ", "Somali", "Djibouti"],
  ["so-ET", "Somali", "Ethiopia"],
  ["so-KE", "Somali", "Kenya"],
  ["so-SO", "Somali", "Somalia"],
  ["sq", "Albanian"],
  ["sq-AL", "Albanian", "Albania"],
  ["sq-MK", "Albanian", "Macedonia"],
  ["sq-XK", "Albanian"],
  ["sr", "Serbian"],
  ["sr-BA", "Serbian", "Bosnia and Herzegovina"],
  ["sr-ME", "Serbian", "Montenegro"],
  ["sr-RS", "Serbian", "Serbia"],
  ["sr-XK", "Serbian"],
  ["sv", "Swedish"],
  ["sv-AX", "Swedish", "Aland"],
  ["sv-FI", "Swedish", "Finland"],
  ["sv-SE", "Swedish", "Sweden"],
  ["sw", "Swahili"],
  ["sw-CD", "Swahili", "Congo"],
  ["sw-KE", "Swahili", "Kenya"],
  ["sw-TZ", "Swahili", "Tanzania"],
  ["sw-UG", "Swahili", "Uganda"],
  ["ta", "Tamil"],
  ["ta-IN", "Tamil", "India"],
  ["ta-LK", "Tamil", "Sri Lanka"],
  ["ta-MY", "Tamil", "Malaysia"],
  ["ta-SG", "Tamil", "Singapore"],
  ["te", "Telugu"],
  ["te-IN", "Telugu", "India"],
  ["th", "Thai"],
  ["th-TH", "Thai", "Thailand"],
  ["ti", "Tigrinya"],
  ["ti-ER", "Tigrinya", "Eritrea"],
  ["ti-ET", "Tigrinya", "Ethiopia"],
  ["tk", "Turkmen"],
  ["tk-TM", "Turkmen", "Turkmenistan"],
  ["to", "Tonga (Tonga Islands)"],
  ["to-TO", "Tonga (Tonga Islands)", "Tonga"],
  ["tr", "Turkish"],
  ["tr-CY", "Turkish", "Cyprus"],
  ["tr-TR", "Turkish", "Turkey"],
  ["ug", "Uighur"],
  ["ug-CN", "Uighur", "China"],
  ["uk", "Ukrainian"],
  ["uk-UA", "Ukrainian", "Ukraine"],
  ["ur", "Urdu"],
  ["ur-IN", "Urdu", "India"],
  ["ur-PK", "Urdu", "Pakistan"],
  ["uz", "Uzbek"],
  ["uz-AF", "Uzbek", "Afghanistan"],
  ["uz-UZ", "Uzbek", "Uzbekistan"],
  ["vi", "Vietnamese"],
  ["vi-VN", "Vietnamese", "Vietnam"],
  ["vo", "Volapk"],
  ["yi", "Yiddish"],
  ["yi-1", "Yiddish"],
  ["yo", "Yoruba"],
  ["yo-BJ", "Yoruba", "Benin"],
  ["yo-NG", "Yoruba", "Nigeria"],
  ["zh", "Chinese"],
  ["zh-CN", "Chinese", "China"],
  ["zh-HK", "Chinese", "Hong Kong"],
  ["zh-MO", "Chinese", "Macau"],
  ["zh-SG", "Chinese", "Singapore"],
  ["zh-TW", "Chinese", "China"],
  ["zu", "Zulu"],
  ["zu-ZA", "Zulu", "South Africa"]
];
var codesByLocale;
var Locale = class {
  _raw;
  _locale;
  constructor(locale) {
    this._raw = locale;
    this._locale = normalizeLocale(locale);
  }
  get locale() {
    return this._locale;
  }
  localInfo() {
    return lookupLocaleInfo(this._locale);
  }
  isValid() {
    return isStandardLocale(this._locale);
  }
  toJSON() {
    return this.locale;
  }
  toString() {
    return this.locale;
  }
};
var regExTwoLetter = /^[a-z]{2}$/i;
var regExLocaleWithCountry = /^([a-z]{2})[_-]?([a-z]{2,3})$/i;
var regExValidLocale = /^([a-z]{2})(?:-([A-Z]{2,3}))?$/;
function normalizeLocale(locale) {
  locale = locale.trim();
  if (regExTwoLetter.test(locale))
    return locale.toLowerCase();
  const m = locale.match(regExLocaleWithCountry);
  if (!m)
    return locale;
  const lang = m[1].toLowerCase();
  const variant = m[2].toUpperCase();
  return `${lang}-${variant}`;
}
function isStandardLocale(locale) {
  return regExValidLocale.test(locale);
}
function lookupLocaleInfo(locale) {
  codesByLocale = codesByLocale || buildLocaleLookup();
  return codesByLocale.get(locale);
}
function buildLocaleLookup() {
  const info = codes.map(([locale, language, country]) => ({ locale, language, country }));
  return new Map(info.map((i) => [i.locale, i]));
}
function createLocale(locale) {
  return new Locale(locale);
}
function parseLocale(locales) {
  locales = typeof locales === "string" ? locales.split(",") : locales;
  return locales.map(createLocale);
}
var defaultEditCosts = {
  accentCosts: 1,
  baseCost: 100,
  capsCosts: 1,
  firstLetterPenalty: 4,
  nonAlphabetCosts: 110
};
var defaultHunspellCosts = {
  ...defaultEditCosts,
  ioConvertCost: 30,
  keyboardCost: 99,
  mapCost: 25,
  replaceCosts: 75,
  tryCharCost: 100
};
function mapHunspellCosts(costs = {}) {
  return { ...defaultHunspellCosts, ...cleanCopy(costs) };
}
function mapEditCosts(costs = {}) {
  return { ...defaultEditCosts, ...cleanCopy(costs) };
}
function joinLetters(letters) {
  const v = [...letters];
  return v.map((a) => a.length > 1 || !a.length ? `(${a})` : a).join("");
}
function parseAlphabet(cs, locale, editCost) {
  const { cost, penalty } = cs;
  const characters = expandCharacterSet(cs.characters);
  const charForms = [
    ...pipeSync(characters, opMapSync((c) => caseForms(c, locale).sort()))
  ];
  const alphabet = joinLetters([
    ...pipeSync(charForms, opFlattenSync(), opMapSync((letter) => accentForms(letter)), opFlattenSync(), opUniqueSync())
  ].sort());
  const sugAlpha = clean({
    map: alphabet,
    replace: cost,
    insDel: cost,
    swap: cost,
    penalty
  });
  return [
    sugAlpha,
    parseAlphabetCaps(cs.characters, locale, editCost),
    ...calcCostsForAccentedLetters(alphabet, locale, editCost)
  ];
}
function parseAlphabetCaps(alphabet, locale, editCost) {
  const characters = expandCharacterSet(alphabet);
  const charForms = [
    ...pipeSync(characters, opMapSync((c) => caseForms(c, locale).sort()))
  ];
  const caps = charForms.map((a) => joinLetters(a)).join("|");
  const sugCaps = {
    map: caps,
    replace: editCost.capsCosts
  };
  return sugCaps;
}
function calcFirstCharacterReplaceDefs(alphabets, editCost) {
  return alphabets.map((cs) => calcFirstCharacterReplace(cs, editCost));
}
function calcFirstCharacterReplace(cs, editCost) {
  const mapOfFirstLetters = [
    ...pipeSync(expandCharacterSet(cs.characters), opUniqueSync(), opMapSync((letter) => `(^${letter})`))
  ].sort().join("") + "(^)";
  const penalty = editCost.firstLetterPenalty;
  const cost = cs.cost - penalty;
  return {
    map: mapOfFirstLetters,
    replace: cost,
    penalty: penalty * 2
  };
}
function parseAccents(cs, _editCost) {
  const { cost, penalty } = cs;
  const accents = joinLetters([
    ...pipeSync(expandCharacterSet(cs.characters), opMapSync((char) => stripNonAccents(char)))
  ]);
  if (!accents)
    return;
  return clean({
    map: accents,
    replace: cost,
    insDel: cost,
    penalty
  });
}
function calcCostsForAccentedLetters(simpleMap, locale, costs) {
  const charactersWithAccents = [
    ...pipeSync(splitMap2(simpleMap), opMapSync((char) => caseForms(char, locale)), opFlattenSync(), opMapSync((char) => [...accentForms(char)]), opFilterSync((forms2) => forms2.length > 1))
  ];
  const characters = pipeSync(charactersWithAccents, opMapSync((forms2) => /* @__PURE__ */ new Set([...forms2, ...forms2.map((char) => stripAccents(char))])), opMapSync((forms2) => [...forms2].sort()), opFilterSync((forms2) => forms2.length > 1), opMapSync(joinLetters), opUniqueSync());
  const replaceAccentMap = [...characters].join("|");
  const cost = costs.accentCosts;
  const costToReplaceAccent = !replaceAccentMap ? [] : [{ map: replaceAccentMap, replace: cost }];
  const normalizeMap2 = charactersWithAccents.map((a) => a.sort()).map(joinLetters).join("|");
  const costToNormalizeAccent = !normalizeMap2 ? [] : [{ map: normalizeMap2, replace: 0 }];
  return [...costToReplaceAccent, ...costToNormalizeAccent];
}
function* splitMap2(map3) {
  let seq = "";
  let mode = 0;
  for (const char of map3) {
    if (mode && char === ")") {
      yield seq;
      mode = 0;
      continue;
    }
    if (mode) {
      seq += char;
      continue;
    }
    if (char === "(") {
      mode = 1;
      seq = "";
      continue;
    }
    yield char;
  }
}
function hunspellInformationToSuggestionCostDef(hunInfo, locales) {
  const costs = calcCosts(hunInfo.costs, locales);
  const operations = [
    affKey,
    affKeyCaps,
    affMap,
    affMapAccents,
    affMapCaps,
    affNoTry,
    affRepConv,
    affTry,
    affTryAccents,
    affTryFirstCharacterReplace
  ];
  function parseAff(aff, costs2) {
    const regSupportedAff = /^(?:MAP|KEY|TRY|NO-TRY|ICONV|OCONV|REP)\s/;
    const rejectAff = /^(?:MAP|KEY|TRY|ICONV|OCONV|REP)\s+\d+$/;
    const lines = aff.split(`
`).map((a) => a.replace(/#.*/, "")).map((a) => a.trim()).filter((a) => regSupportedAff.test(a)).filter((a) => !rejectAff.test(a));
    const defs = pipeSync(lines, opMapSync((line) => pipeSync(operations, opMapSync((fn) => fn(line, costs2)), opMapSync(asArrayOf), opFlattenSync())), opFlattenSync(), opFilterSync(isDefined2));
    return [...defs];
  }
  return parseAff(hunInfo.aff, costs);
}
function calcCosts(costs = {}, locale) {
  const useLocale = locale?.length ? locale.map((loc) => loc.locale) : undefined;
  const hunCosts = mapHunspellCosts(costs);
  const c = {
    ...hunCosts,
    locale: useLocale
  };
  return c;
}
var regExpMap = /^(?:MAP)\s+(\S+)$/;
function affMap(line, costs) {
  const m = line.match(regExpMap);
  if (!m)
    return;
  const map3 = m[1];
  const cost = costs.mapCost;
  return {
    map: map3,
    replace: cost,
    swap: cost
  };
}
var regExpTry = /^(?:TRY)\s+(\S+)$/;
function affTry(line, costs) {
  const m = line.match(regExpTry);
  if (!m)
    return;
  const cost = costs.tryCharCost;
  const tryChars = m[1];
  const characters = tryChars;
  return parseAlphabet({
    characters,
    cost
  }, costs.locale, costs);
}
function affTryFirstCharacterReplace(line, costs) {
  const m = line.match(regExpTry);
  if (!m)
    return;
  const characters = m[1];
  const cost = costs.tryCharCost;
  return calcFirstCharacterReplace({
    characters,
    cost
  }, costs);
}
var regExpNoTry = /^NO-TRY\s+(\S+)$/;
function affNoTry(line, costs) {
  const m = line.match(regExpNoTry);
  if (!m)
    return;
  const map3 = m[1];
  return {
    map: map3,
    insDel: Math.max(costs.nonAlphabetCosts - costs.tryCharCost, 0),
    penalty: costs.nonAlphabetCosts + costs.tryCharCost
  };
}
var regExpRepConv = /^(?:REP|(?:I|O)CONV)\s+(\S+)\s+(\S+)$/;
function affRepConv(line, costs) {
  const m = line.match(regExpRepConv);
  if (!m)
    return;
  const cost = line.startsWith("REP") ? costs.replaceCosts : costs.ioConvertCost;
  const from = m[1];
  let into = m[2];
  into = into.replace(/^0$/, "");
  if (from.startsWith("^") && !into.startsWith("^")) {
    into = "^" + into;
  }
  if (from.endsWith("$") && !into.endsWith("$")) {
    into = into + "$";
  }
  return {
    map: joinLetters([from, into]),
    replace: cost
  };
}
var regExpKey = /^(?:KEY)\s+(\S+)$/;
function affKey(line, costs) {
  const m = line.match(regExpKey);
  if (!m)
    return;
  const kbd = m[1];
  const pairs = [...splitMap2(kbd)].map(reducer((p, v) => ({ a: p.b, b: v }), { a: "|", b: "|" })).filter((ab) => ab.a !== "|" && ab.b !== "|").map(({ a, b }) => joinLetters([a, b]));
  const pairsUpper = pairs.map((p) => p.toLocaleUpperCase(costs.locale));
  const map3 = unique([...pairs, ...pairsUpper]).join("|");
  const cost = costs.keyboardCost;
  return {
    map: map3,
    replace: cost,
    swap: cost
  };
}
function affKeyCaps(line, costs) {
  const m = line.match(regExpKey);
  if (!m)
    return;
  return parseCaps(m[1], costs);
}
function affMapCaps(line, costs) {
  const m = line.match(regExpMap);
  if (!m)
    return;
  return parseCaps(m[1], costs);
}
function affTryAccents(line, costs) {
  const m = line.match(regExpTry);
  if (!m)
    return;
  return calcCostsForAccentedLetters(m[1], costs.locale, costs);
}
function affMapAccents(line, costs) {
  const m = line.match(regExpMap);
  if (!m)
    return;
  return calcCostsForAccentedLetters(m[1], costs.locale, costs);
}
function parseCaps(value, costs) {
  const locale = costs.locale;
  const letters = [...splitMap2(value)].filter((a) => a !== "|");
  const withCases = letters.map((s) => caseForms(s, locale)).filter((forms2) => forms2.length > 1).map(joinLetters);
  const map3 = unique(withCases).join("|");
  const cost = costs.capsCosts;
  if (!map3)
    return;
  return {
    map: map3,
    replace: cost
  };
}
function reducer(fn, initialVal) {
  let acc = initialVal;
  return (val, i) => acc = fn(acc, val, i);
}
function asArrayOf(v) {
  return Array.isArray(v) ? v : [v];
}
function mapDictionaryInformation(dictInfo) {
  const _locale = dictInfo.locale;
  const locale = _locale ? parseLocale(_locale).filter((loc) => loc.isValid()) : undefined;
  const locales = locale?.map((loc) => loc.locale);
  const costs = mapEditCosts(dictInfo.costs);
  const defsEC = dictInfo.suggestionEditCosts || [];
  const defsHI = dictInfo.hunspellInformation ? hunspellInformationToSuggestionCostDef(dictInfo.hunspellInformation, locale) : [];
  return [
    ...defsEC,
    ...processAlphabet(dictInfo.alphabet, locales, costs),
    ...processAccents(dictInfo.accents, costs),
    ...defsHI
  ];
}
function processAlphabet(alphabet, locale, editCost) {
  const csAlphabet = toCharSets(alphabet, "a-zA-Z", editCost.baseCost);
  return [
    ...pipeSync(csAlphabet, opMapSync((cs) => parseAlphabet(cs, locale, editCost)), opFlattenSync()),
    ...calcFirstCharacterReplaceDefs(csAlphabet, editCost)
  ];
}
function toCharSets(cs, defaultValue, cost, penalty) {
  cs = cs ?? defaultValue;
  if (!cs)
    return [];
  if (typeof cs === "string") {
    cs = [
      {
        characters: cs,
        cost
      }
    ];
  }
  if (penalty !== undefined) {
    cs.forEach((cs2) => cs2.penalty = penalty);
  }
  return cs;
}
function processAccents(accents, editCost) {
  const cs = toCharSets(accents, "-", editCost.accentCosts);
  return cs.map((cs2) => parseAccents(cs2, editCost)).filter(isDefined2);
}
function mapDictionaryInformationToAdjustment(dictInfo) {
  if (!dictInfo.adjustments)
    return [];
  return dictInfo.adjustments.map(mapAdjustment);
}
function mapAdjustment(adj) {
  const { id, regexp, penalty } = adj;
  return {
    id,
    regexp: new RegExp(regexp),
    penalty
  };
}
var defaultDefs = [
  {
    map: "1234567890-.",
    insDel: 1,
    penalty: 200
  }
];
var defaultAdjustments = [
  {
    id: "compound-case-change",
    regexp: /\p{Ll}\p{Lu}/gu,
    penalty: 1000
  },
  {
    id: "short-compounds-1",
    regexp: /^[^]{0,2}(?=)|[^]{0,2}(?=|$)/gm,
    penalty: 100
  },
  {
    id: "short-compounds-3",
    regexp: /^[^]{3}(?=)|[^]{3}(?=|$)/gm,
    penalty: 50
  }
];
function mapDictionaryInformationToWeightMap(dictInfo) {
  const defs = [...mapDictionaryInformation(dictInfo), ...defaultDefs];
  const adjustments = mapDictionaryInformationToAdjustment(dictInfo);
  const map3 = createWeightMap(...defs);
  addAdjustment(map3, ...defaultAdjustments, ...adjustments);
  return map3;
}
var baseCost = opCosts.baseCost;
var swapCost = opCosts.swapCost;
var postSwapCost = swapCost - baseCost;
var insertSpaceCost = -1;
var mapSubCost = opCosts.visuallySimilar;
var maxCostScale = opCosts.wordLengthCostFactor;
var discourageInsertCost = baseCost;
var setOfSeparators = /* @__PURE__ */ new Set([JOIN_SEPARATOR, WORD_SEPARATOR]);
function suggest(root, word, options = {}) {
  const opts = createSuggestionOptions(options);
  const collectorOpts = clean2(opts);
  const collector = suggestionCollector(word, collectorOpts);
  collector.collect(genSuggestions(root, word, { ...opts, ...collector.genSuggestionOptions }));
  return collector.suggestions;
}
function* genSuggestions(root, word, options = {}) {
  const roots = Array.isArray(root) ? root : [root];
  for (const r of roots) {
    yield* genCompoundableSuggestions(r, word, options);
  }
  return;
}
function* genCompoundableSuggestions(root, word, options = {}) {
  const { compoundMethod = 0, changeLimit, ignoreCase } = createSuggestionOptions(options);
  const history = [];
  const historyTags = /* @__PURE__ */ new Map;
  const bc = baseCost;
  const psc = postSwapCost;
  const matrix = [[]];
  const stack = [];
  const x = " " + word;
  const mx = x.length - 1;
  const specialInsCosts = Object.assign(/* @__PURE__ */ Object.create(null), {
    [WORD_SEPARATOR]: insertSpaceCost,
    [JOIN_SEPARATOR]: insertSpaceCost
  });
  const specialSubCosts = Object.assign(/* @__PURE__ */ Object.create(null), {
    "-": discourageInsertCost
  });
  let stopNow = false;
  let costLimit = bc * Math.min(word.length * maxCostScale, changeLimit);
  function updateCostLimit(maxCost) {
    switch (typeof maxCost) {
      case "number": {
        costLimit = maxCost;
        break;
      }
      case "symbol": {
        stopNow = true;
        break;
      }
    }
  }
  const a = 0;
  let b = 0;
  for (let i = 0, c = 0;i <= mx && c <= costLimit; ++i) {
    c = i * baseCost;
    matrix[0][i] = c;
    b = i;
  }
  stack[0] = { a, b };
  const hint = word;
  const iWalk = hintedWalker(root, ignoreCase, hint, compoundMethod, options.compoundSeparator);
  let goDeeper = true;
  for (let r = iWalk.next({ goDeeper });!stopNow && !r.done; r = iWalk.next({ goDeeper })) {
    const { text, node, depth } = r.value;
    let { a: a2, b: b2 } = stack[depth];
    const w = text.slice(-1);
    const wG = visualLetterMaskMap[w] || 0;
    if (setOfSeparators.has(w)) {
      const mxRange = matrix[depth].slice(a2, b2 + 1);
      const mxMin = Math.min(...mxRange);
      const tag = [a2, ...mxRange.map((c2) => c2 - mxMin)].join(",");
      const ht = historyTags.get(tag);
      if (ht && ht.m <= mxMin) {
        goDeeper = false;
        const { i: i2, w: w2, m } = ht;
        if (i2 >= history.length) {
          continue;
        }
        const r2 = history[i2];
        if (r2.word.slice(0, w2.length) !== w2) {
          continue;
        }
        const dc = mxMin - m;
        for (let p = i2;p < history.length; ++p) {
          const { word: word2, cost: hCost } = history[p];
          const fix = word2.slice(0, w2.length);
          if (fix !== w2) {
            break;
          }
          const cost2 = hCost + dc;
          if (cost2 <= costLimit) {
            const suffix = word2.slice(w2.length);
            const emit = text + suffix;
            updateCostLimit(yield { word: emit, cost: cost2 });
          }
        }
        continue;
      } else {
        historyTags.set(tag, { w: text, i: history.length, m: mxMin });
      }
    }
    const d = depth + 1;
    const lastSugLetter = d > 1 ? text[d - 2] : "";
    const c = bc - d + (specialSubCosts[w] || 0);
    const ci = c + (specialInsCosts[w] || 0);
    matrix[d] = matrix[d] || [];
    matrix[d][a2] = matrix[d - 1][a2] + ci + d - a2;
    let lastLetter = x[a2];
    let min3 = matrix[d][a2];
    let i;
    for (i = a2 + 1;i <= b2; ++i) {
      const curLetter = x[i];
      const cG = visualLetterMaskMap[curLetter] || 0;
      const subCost = w === curLetter ? 0 : wG & cG ? mapSubCost : curLetter === lastSugLetter ? w === lastLetter ? psc : c : c;
      const e = Math.min(matrix[d - 1][i - 1] + subCost, matrix[d - 1][i] + ci, matrix[d][i - 1] + c);
      min3 = Math.min(min3, e);
      matrix[d][i] = e;
      lastLetter = curLetter;
    }
    const { b: bb } = stack[d - 1];
    while (b2 < mx) {
      b2 += 1;
      i = b2;
      const curLetter = x[i];
      const cG = visualLetterMaskMap[curLetter] || 0;
      const subCost = w === curLetter ? 0 : wG & cG ? mapSubCost : curLetter === lastSugLetter ? w === lastLetter ? psc : c : c;
      const j = Math.min(bb, i - 1);
      const e = Math.min(matrix[d - 1][j] + subCost, matrix[d][i - 1] + c);
      min3 = Math.min(min3, e);
      matrix[d][i] = e;
      lastLetter = curLetter;
      if (e > costLimit)
        break;
    }
    for (;b2 > a2 && matrix[d][b2] > costLimit; b2 -= 1) {
    }
    for (;a2 < b2 && matrix[d][a2] > costLimit; a2 += 1) {
    }
    b2 = Math.min(b2 + 1, mx);
    stack[d] = { a: a2, b: b2 };
    const cost = matrix[d][b2];
    if (node.f && isWordTerminationNode(node) && cost <= costLimit) {
      const r2 = { word: text, cost };
      history.push(r2);
      updateCostLimit(yield r2);
    } else {
      updateCostLimit(yield undefined);
    }
    goDeeper = min3 <= costLimit;
  }
  return;
}
var defaultLegacyMinCompoundLength4 = 3;
var Trie = class _Trie {
  constructor(root, count3) {
    this.root = root;
    this.count = count3;
    this._options = mergeOptionalWithDefaults(root);
    this.isLegacy = this.calcIsLegacy();
    this.hasForbidden = !!root.c[root.forbiddenWordPrefix];
    this._findOptionsDefaults = {
      caseInsensitivePrefix: this._options.stripCaseAndAccentsPrefix,
      compoundFix: this._options.compoundCharacter,
      forbidPrefix: this._options.forbiddenWordPrefix
    };
    this._findOptionsExact = this.createFindOptions({ compoundMode: "none" });
  }
  _options;
  _findOptionsDefaults;
  _findOptionsExact;
  isLegacy;
  hasForbidden;
  size() {
    this.count = this.count ?? countWords2(this.root);
    return this.count;
  }
  isSizeKnown() {
    return this.count !== undefined;
  }
  get options() {
    return this._options;
  }
  find(text, minCompoundLength = false) {
    const minLength = !minCompoundLength ? undefined : minCompoundLength === true ? defaultLegacyMinCompoundLength4 : minCompoundLength;
    const options = this.createFindOptions({
      compoundMode: minLength ? "legacy" : "compound",
      legacyMinCompoundLength: minLength
    });
    return findWordNode2(this.root, text, options).node;
  }
  has(word, minLegacyCompoundLength) {
    if (this.hasWord(word, false))
      return true;
    if (minLegacyCompoundLength) {
      const f = this.findWord(word, { useLegacyWordCompounds: minLegacyCompoundLength });
      return !!f.found;
    }
    return false;
  }
  hasWord(word, caseSensitive) {
    const f = this.findWord(word, { caseSensitive });
    return !!f.found && !f.forbidden;
  }
  findWord(word, options) {
    if (options?.useLegacyWordCompounds) {
      const len = options.useLegacyWordCompounds !== true ? options.useLegacyWordCompounds : defaultLegacyMinCompoundLength4;
      const findOptions2 = this.createFindOptions({
        legacyMinCompoundLength: len,
        matchCase: options.caseSensitive
      });
      return findLegacyCompound2(this.root, word, findOptions2);
    }
    const findOptions = this.createFindOptionsMatchCase(options?.caseSensitive);
    return findWord2(this.root, word, findOptions);
  }
  isForbiddenWord(word) {
    return this.hasForbidden && isForbiddenWord2(this.root, word, this.options.forbiddenWordPrefix);
  }
  completeWord(text) {
    const n = this.find(text);
    const compoundChar = this.options.compoundCharacter;
    const subNodes = pipeSync(iteratorTrieWords2(n || {}), opFilterSync((w) => w[w.length - 1] !== compoundChar), opMapSync((suffix) => text + suffix));
    return pipeSync(n && isWordTerminationNode(n) ? [text] : [], opAppendSync(subNodes));
  }
  suggest(text, options) {
    return this.suggestWithCost(text, options).map((a) => a.word);
  }
  suggestWithCost(text, options) {
    const sep = options.compoundSeparator;
    const adjWord = sep ? replaceAllFactory(sep, "") : (a) => a;
    const optFilter = options.filter;
    const filter3 = optFilter ? (word, cost) => {
      const w = adjWord(word);
      return !this.isForbiddenWord(w) && optFilter(w, cost);
    } : (word) => !this.isForbiddenWord(adjWord(word));
    const opts = { ...options, filter: filter3 };
    return suggest(this.root, text, opts);
  }
  genSuggestions(collector, compoundMethod) {
    const filter3 = (word) => !this.isForbiddenWord(word);
    const options = clean2({ compoundMethod, ...collector.genSuggestionOptions });
    const suggestions = genSuggestions(this.root, collector.word, options);
    collector.collect(suggestions, undefined, filter3);
  }
  words() {
    return iteratorTrieWords2(this.root);
  }
  iterate() {
    return walker2(this.root);
  }
  insert(word) {
    insert2(word, this.root);
    return this;
  }
  calcIsLegacy() {
    const c = this.root.c;
    return !(c && c[this._options.compoundCharacter] || c[this._options.stripCaseAndAccentsPrefix] || c[this._options.forbiddenWordPrefix]);
  }
  static create(words, options) {
    const root = createTrieRootFromList(words, options);
    orderTrie(root);
    return new _Trie(root, undefined);
  }
  createFindOptions(options = {}) {
    const findOptions = createFindOptions2({
      ...this._findOptionsDefaults,
      ...options
    });
    return findOptions;
  }
  lastCreateFindOptionsMatchCaseMap = /* @__PURE__ */ new Map;
  createFindOptionsMatchCase(matchCase) {
    const f = this.lastCreateFindOptionsMatchCaseMap.get(matchCase);
    if (f !== undefined)
      return f;
    const findOptions = this.createFindOptions({ matchCase });
    this.lastCreateFindOptionsMatchCaseMap.set(matchCase, findOptions);
    return findOptions;
  }
};
var SecondChanceCache = class {
  constructor(maxL0Size) {
    this.maxL0Size = maxL0Size;
  }
  map0 = /* @__PURE__ */ new Map;
  map1 = /* @__PURE__ */ new Map;
  has(key) {
    if (this.map0.has(key))
      return true;
    if (this.map1.has(key)) {
      this.set(key, this.get1(key));
      return true;
    }
    return false;
  }
  get(key) {
    return this.map0.get(key) ?? this.get1(key);
  }
  set(key, value) {
    if (this.map0.size >= this.maxL0Size && !this.map0.has(key)) {
      this.map1 = this.map0;
      this.map0 = /* @__PURE__ */ new Map;
    }
    this.map0.set(key, value);
    return this;
  }
  get size() {
    return this.map0.size + this.map1.size;
  }
  get size0() {
    return this.map0.size;
  }
  get size1() {
    return this.map1.size;
  }
  clear() {
    this.map0.clear();
    this.map1.clear();
    return this;
  }
  get1(key) {
    if (this.map1.has(key)) {
      const v = this.map1.get(key);
      this.map1.delete(key);
      this.map0.set(key, v);
      return v;
    }
    return;
  }
  toArray() {
    return [...this.map1, ...this.map0];
  }
};
var SymbolFrozenNode = Symbol();
var MAX_NUM_SIGS = 1e5;
var MAX_TRANSFORMS = 1e6;
var MAX_CACHE_SIZE = 1e6;
var TrieBuilder = class {
  count = 0;
  signatures = new SecondChanceCache(MAX_NUM_SIGS);
  cached = new SecondChanceCache(MAX_CACHE_SIZE);
  transforms = new SecondChanceCache(MAX_TRANSFORMS);
  _eow;
  lastPath = [{ s: "", n: { id: 0, f: undefined, c: undefined } }];
  tails = /* @__PURE__ */ new Map;
  trieOptions;
  numWords = 0;
  _debug_lastWordsInserted = [];
  _debug_mode = false;
  constructor(words, trieOptions) {
    this._eow = this.createNodeFrozen(1);
    this.tails.set("", this._eow);
    this._canBeCached(this._eow);
    this.signatures.set(this.signature(this._eow), this._eow);
    this.cached.set(this._eow, this._eow.id ?? ++this.count);
    this.trieOptions = Object.freeze(mergeOptionalWithDefaults(trieOptions));
    if (words) {
      this.insert(words);
    }
  }
  get _root() {
    return trieNodeToRoot(this.lastPath[0].n, this.trieOptions);
  }
  signature(n) {
    const isWord = n.f ? "*" : "";
    const entries = n.c ? Object.entries(n.c) : undefined;
    const c = entries ? entries.map(([k, n2]) => [k, this.cached.get(n2)]) : undefined;
    const ref = c ? JSON.stringify(c) : "";
    const sig = isWord + ref;
    return sig;
  }
  _canBeCached(n) {
    if (!n.c)
      return true;
    for (const v of Object.values(n.c)) {
      if (!this.cached.has(v))
        return false;
    }
    return true;
  }
  tryCacheFrozen(n) {
    assertFrozen(n);
    if (this.cached.has(n)) {
      return n;
    }
    this.cached.set(n, n.id ?? ++this.count);
    return n;
  }
  freeze(n) {
    if (Object.isFrozen(n))
      return n;
    if (n.c) {
      const c = Object.entries(n.c).sort((a, b) => a[0] < b[0] ? -1 : 1).map(([k, n2]) => [k, this.freeze(n2)]);
      n.c = Object.fromEntries(c);
      Object.freeze(n.c);
    }
    return Object.freeze(n);
  }
  tryToCache(n) {
    if (!this._canBeCached(n)) {
      return n;
    }
    const sig = this.signature(n);
    const ref = this.signatures.get(sig);
    if (ref !== undefined) {
      return this.tryCacheFrozen(ref);
    }
    this.signatures.set(sig, this.freeze(n));
    return n;
  }
  storeTransform(src, s, result) {
    if (!Object.isFrozen(result) || !Object.isFrozen(src))
      return;
    this.logDebug("storeTransform", () => ({ s, src: this.debNodeInfo(src), result: this.debNodeInfo(result) }));
    const t = this.transforms.get(src) ?? /* @__PURE__ */ new Map;
    t.set(s, result);
    this.transforms.set(src, t);
  }
  addChild(node, head, child) {
    if (node.c?.[head] !== child) {
      let c = node.c || /* @__PURE__ */ Object.create(null);
      if (Object.isFrozen(c)) {
        c = Object.assign(/* @__PURE__ */ Object.create(null), c);
      }
      c[head] = child;
      if (Object.isFrozen(node)) {
        node = this.createNode(node.f, c);
      } else {
        node.c = c;
      }
    }
    return Object.isFrozen(child) ? this.tryToCache(node) : node;
  }
  buildTail(s) {
    const ss = s.join("");
    const v = this.tails.get(ss);
    if (v)
      return v;
    const head = s[0];
    const tail = s.slice(1);
    const t = this.tails.get(tail.join(""));
    const c = t || this.buildTail(tail);
    const n = this.addChild(this.createNode(), head, c);
    if (!t) {
      return n;
    }
    const cachedNode = this.tryCacheFrozen(this.freeze(n));
    this.tails.set(ss, cachedNode);
    return cachedNode;
  }
  _insert(node, s, d) {
    this.logDebug("_insert", () => ({
      n: this.debNodeInfo(node),
      s,
      d,
      w: this.lastPath.map((a) => a.s).join("")
    }));
    const orig = node;
    if (Object.isFrozen(node)) {
      const n = this.transforms.get(node)?.get(s.join(""));
      if (n) {
        return this.tryCacheFrozen(n);
      }
    }
    if (!s.length) {
      if (!node.c) {
        return this._eow;
      } else {
        node = this.copyIfFrozen(node);
        node.f = this._eow.f;
        return node;
      }
    }
    const head = s[0];
    const tail = s.slice(1);
    const cNode = node.c?.[head];
    const child = cNode ? this._insert(cNode, tail, d + 1) : this.buildTail(tail);
    node = this.addChild(node, head, child);
    this.storeTransform(orig, s.join(""), node);
    this.lastPath[d] = { s: head, n: child };
    return node;
  }
  insertWord(word) {
    this.logDebug("insertWord", word);
    this._debug_lastWordsInserted[this.numWords & 15] = word;
    this.numWords++;
    const chars = [...word];
    let d = 1;
    for (const s of chars) {
      const p = this.lastPath[d];
      if (p?.s !== s)
        break;
      d++;
    }
    if (chars.length < d) {
      d = chars.length;
    }
    this.lastPath.length = d;
    d -= 1;
    const { n } = this.lastPath[d];
    const tail = chars.slice(d);
    this.lastPath[d].n = this._insert(n, tail, d + 1);
    while (d > 0) {
      const { s, n: n2 } = this.lastPath[d];
      d -= 1;
      const parent = this.lastPath[d];
      const pn = parent.n;
      parent.n = this.addChild(pn, s, n2);
      if (pn === parent.n)
        break;
      const tail2 = chars.slice(d);
      this.storeTransform(pn, tail2.join(""), parent.n);
    }
  }
  insert(words) {
    for (const w of words) {
      w && this.insertWord(w);
    }
  }
  reset() {
    this.lastPath = [{ s: "", n: { id: 0, f: undefined, c: undefined } }];
    this.cached.clear();
    this.signatures.clear();
    this.signatures.set(this.signature(this._eow), this._eow);
    this.count = 0;
    this.cached.set(this._eow, this._eow.id ?? ++this.count);
  }
  build(consolidateSuffixes = false) {
    const root = this._root;
    this.reset();
    const check = checkCircular(this._root);
    if (check.isCircular) {
      const { word, pos } = check.ref;
      console.error("Circular Reference %o", { word, pos });
      throw new Error("Trie: Circular Reference");
    }
    return new Trie(consolidateSuffixes ? consolidate(root) : root);
  }
  debugStack(stack) {
    return stack.map((n) => this.debNodeInfo(n));
  }
  debNodeInfo(node) {
    const id = node.id ?? "?";
    const cid = this.cached.get(node) ?? "?";
    const f = node.f || 0;
    const c = node.c ? Object.fromEntries(Object.entries(node.c).map(([k, n]) => [k, { id: n.id, r: this.cached.get(n) }])) : undefined;
    const L = Object.isFrozen(node);
    return { id, cid, f, c, L };
  }
  logDebug(methodName, contentOrFunction) {
    this.runDebug(() => {
      const content = typeof contentOrFunction === "function" ? contentOrFunction() : contentOrFunction;
      console.warn("%s: %o", methodName, content);
    });
  }
  runDebug(method) {
    if (this._debug_mode) {
      method();
    }
  }
  copyIfFrozen(n) {
    if (!Object.isFrozen(n))
      return n;
    const c = n.c ? Object.assign(/* @__PURE__ */ Object.create(null), n.c) : undefined;
    return this.createNode(n.f, c);
  }
  createNodeFrozen(f, c) {
    return this.freeze(this.createNode(f, c));
  }
  createNode(f, c) {
    return { id: ++this.count, f, c };
  }
};
function assertFrozen(n) {
  if (!("id" in n)) {
    console.warn("%o", n);
  }
  if (!Object.isFrozen(n) || !("id" in n))
    throw new Error("Must be TrieNodeExFrozen");
}
var normalizeWord = (text) => text.normalize();
var normalizeWordForCaseInsensitive = (text) => {
  const t = text.toLowerCase();
  return [t, t.normalize("NFD").replaceAll(/\p{M}/gu, "")];
};
var RegExpSplit = /[\s,;]/g;
var _defaultOptions = {
  commentCharacter: LINE_COMMENT,
  optionalCompoundCharacter: OPTIONAL_COMPOUND_FIX,
  compoundCharacter: COMPOUND_FIX,
  forbiddenPrefix: FORBID_PREFIX,
  caseInsensitivePrefix: CASE_INSENSITIVE_PREFIX,
  keepExactPrefix: IDENTITY_PREFIX,
  stripCaseAndAccents: true,
  stripCaseAndAccentsKeepDuplicate: false,
  stripCaseAndAccentsOnForbidden: false,
  split: false,
  splitKeepBoth: false,
  splitSeparator: RegExpSplit,
  keepOptionalCompoundCharacter: false
};
var defaultParseDictionaryOptions = Object.freeze(_defaultOptions);
var cSpellToolDirective = "cspell-dictionary:";
function createDictionaryLineParserMapper(options) {
  const _options = options || _defaultOptions;
  const {
    commentCharacter = _defaultOptions.commentCharacter,
    optionalCompoundCharacter: optionalCompound = _defaultOptions.optionalCompoundCharacter,
    compoundCharacter: compound = _defaultOptions.compoundCharacter,
    caseInsensitivePrefix: ignoreCase = _defaultOptions.caseInsensitivePrefix,
    forbiddenPrefix: forbidden = _defaultOptions.forbiddenPrefix,
    keepExactPrefix: keepCase = _defaultOptions.keepExactPrefix,
    splitSeparator = _defaultOptions.splitSeparator,
    splitKeepBoth = _defaultOptions.splitKeepBoth,
    stripCaseAndAccentsKeepDuplicate = _defaultOptions.stripCaseAndAccentsKeepDuplicate,
    stripCaseAndAccentsOnForbidden = _defaultOptions.stripCaseAndAccentsOnForbidden,
    keepOptionalCompoundCharacter = _defaultOptions.keepOptionalCompoundCharacter
  } = _options;
  let { stripCaseAndAccents = _defaultOptions.stripCaseAndAccents, split = _defaultOptions.split } = _options;
  function isString(line) {
    return typeof line === "string";
  }
  function trim(line) {
    return line.trim();
  }
  function removeComments(line) {
    const idx2 = line.indexOf(commentCharacter);
    if (idx2 < 0)
      return line;
    const idxDirective = line.indexOf(cSpellToolDirective, idx2);
    if (idxDirective >= 0) {
      const flags = line.slice(idxDirective).split(/[\s,;]/g).map((s) => s.trim()).filter((a) => !!a);
      for (const flag of flags) {
        switch (flag) {
          case "split": {
            split = true;
            break;
          }
          case "no-split": {
            split = false;
            break;
          }
          case "no-generate-alternatives": {
            stripCaseAndAccents = false;
            break;
          }
          case "generate-alternatives": {
            stripCaseAndAccents = true;
            break;
          }
        }
      }
    }
    return line.slice(0, idx2).trim();
  }
  function filterEmptyLines(line) {
    return !!line;
  }
  function* mapOptionalPrefix(line) {
    if (line[0] === optionalCompound) {
      const t = line.slice(1);
      yield t;
      yield compound + t;
    } else {
      yield line;
    }
  }
  function* mapOptionalSuffix(line) {
    if (line.slice(-1) === optionalCompound) {
      const t = line.slice(0, -1);
      yield t;
      yield t + compound;
    } else {
      yield line;
    }
  }
  const doNotNormalizePrefix = /* @__PURE__ */ Object.create(null);
  [ignoreCase, keepCase, '"'].forEach((prefix) => doNotNormalizePrefix[prefix] = true);
  if (!stripCaseAndAccentsOnForbidden) {
    doNotNormalizePrefix[forbidden] = true;
  }
  function removeDoublePrefix(w) {
    return w.startsWith(ignoreCase + ignoreCase) ? w.slice(1) : w;
  }
  function stripKeepCasePrefixAndQuotes(word) {
    word = word.replaceAll(/"(.*?)"/g, "$1");
    return word[0] === keepCase ? word.slice(1) : word;
  }
  function _normalize(word) {
    return normalizeWord(stripKeepCasePrefixAndQuotes(word));
  }
  function* mapNormalize(word) {
    const nWord = _normalize(word);
    const forms2 = /* @__PURE__ */ new Set;
    forms2.add(nWord);
    if (stripCaseAndAccents && !(word[0] in doNotNormalizePrefix)) {
      for (const n of normalizeWordForCaseInsensitive(nWord)) {
        (stripCaseAndAccentsKeepDuplicate || n !== nWord) && forms2.add(ignoreCase + n);
      }
    }
    yield* forms2;
  }
  function* splitWords(lines) {
    for (const line of lines) {
      if (split) {
        const lineEscaped = line.includes('"') ? line.replaceAll(/".*?"/g, (quoted) => " " + quoted.replaceAll(/(\s)/g, "\\$1") + " ") : line;
        const words = splitLine(lineEscaped, splitSeparator);
        yield* words.map((escaped) => escaped.replaceAll("\\", ""));
        if (!splitKeepBoth)
          continue;
      }
      yield line;
    }
  }
  function* splitLines(paragraphs) {
    for (const paragraph of paragraphs) {
      yield* paragraph.split(`
`);
    }
  }
  const mapCompounds = keepOptionalCompoundCharacter ? [] : [opConcatMapSync(mapOptionalPrefix), opConcatMapSync(mapOptionalSuffix)];
  const processLines = opCombineSync(opFilterSync(isString), splitLines, opMapSync(removeComments), splitWords, opMapSync(trim), opFilterSync(filterEmptyLines), ...mapCompounds, opConcatMapSync(mapNormalize), opMapSync(removeDoublePrefix));
  return processLines;
}
function parseDictionaryLines(lines, options) {
  return createDictionaryLineParserMapper(options)(typeof lines === "string" ? [lines] : lines);
}
var RegExpToEncode = /\\([\s,;])/g;
var RegExpDecode = /<<(%[\da-f]{2})>>/gi;
function encodeLine(line) {
  return line.replaceAll(RegExpToEncode, (_, v) => "<<" + encodeURIComponent(v) + ">>");
}
function decodeLine(line) {
  return line.replaceAll(RegExpDecode, (_, v) => "\\" + decodeURIComponent(v));
}
function splitLine(line, regExp) {
  return encodeLine(line).split(regExp).map((line2) => decodeLine(line2));
}

// node_modules/cspell-dictionary/dist/util/text.js
var regExAllUpper = /^(?:\p{Lu}\p{M}?)+$/u;
var regExAccents = /\p{M}/gu;
function isUpperCase(word) {
  return !!regExAllUpper.test(word);
}
function ucFirst(word) {
  return word.slice(0, 1).toUpperCase() + word.slice(1);
}
function removeAccents(text) {
  return text.normalize("NFD").replaceAll(regExAccents, "");
}
function removeUnboundAccents(text) {
  return text.replaceAll(regExAccents, "");
}

// node_modules/cspell-dictionary/dist/SpellingDictionary/SpellingDictionaryMethods.js
var defaultNumSuggestions = 10;
function wordSearchForms(word, isDictionaryCaseSensitive, ignoreCase) {
  const forms2 = new Set;
  word = word.normalize("NFC");
  const wordLc = word.toLowerCase();
  if (ignoreCase) {
    if (isDictionaryCaseSensitive) {
      forms2.add(wordLc);
    } else {
      forms2.add(wordLc);
      forms2.add(removeUnboundAccents(wordLc));
    }
  } else {
    if (isDictionaryCaseSensitive) {
      forms2.add(word);
      forms2.add(wordLc);
      if (isUpperCase(word)) {
        forms2.add(ucFirst(wordLc));
      }
    } else {
      forms2.add(wordLc);
      forms2.add(removeUnboundAccents(wordLc));
    }
  }
  return forms2;
}
function wordSuggestFormsArray(word) {
  return [...wordSuggestForms(word)];
}
function wordSuggestForms(word) {
  word = word.normalize("NFC");
  const forms2 = new Set([word]);
  const wordLc = word.toLowerCase();
  forms2.add(wordLc);
  return forms2;
}
var DEFAULT_HAS_OPTIONS = Object.freeze({});
function hasOptionToSearchOption(opt) {
  return canonicalSearchOptions(!opt ? DEFAULT_HAS_OPTIONS : opt);
}
var canonicalSearchOptionsMap = new Map;
var knownCanonicalOptions = new WeakMap;
function canonicalSearchOptions(opt) {
  const known = knownCanonicalOptions.get(opt);
  if (known)
    return known;
  const { ignoreCase, useCompounds } = opt;
  const foundLevel1Map = canonicalSearchOptionsMap.get(ignoreCase);
  const useLevel1Map = foundLevel1Map || new Map;
  if (!foundLevel1Map) {
    canonicalSearchOptionsMap.set(ignoreCase, useLevel1Map);
  }
  const foundCanOpts = useLevel1Map.get(useCompounds);
  const canOpts = foundCanOpts || Object.freeze({ ignoreCase, useCompounds });
  if (!foundCanOpts) {
    useLevel1Map.set(useCompounds, canOpts);
  }
  knownCanonicalOptions.set(opt, canOpts);
  return canOpts;
}
function createWeightMapFromDictionaryInformation(di) {
  return di ? mapDictionaryInformationToWeightMap(di) : undefined;
}

// node_modules/cspell-dictionary/dist/SpellingDictionary/CachingDictionary.js
var dictionaryCounter = 0;
var DefaultAutoCacheSize = 1000;
var logRequests = false;
var log = [];
var startTime = performance.now();

class CachedDict {
  dict;
  options;
  name;
  id = ++dictionaryCounter;
  constructor(dict, options) {
    this.dict = dict;
    this.options = options;
    this.name = dict.name;
  }
  #has = autoCache((word) => this.dict.has(word, this.options), DefaultAutoCacheSize);
  has = logRequests ? (word) => {
    const time = performance.now() - startTime;
    const value = this.#has(word);
    log.push({ time, method: "has", word, value });
    return value;
  } : this.#has;
  isNoSuggestWord = autoCache((word) => this.dict.isNoSuggestWord(word, this.options), DefaultAutoCacheSize);
  isForbidden = autoCache((word) => this.dict.isForbidden(word), DefaultAutoCacheSize);
  getPreferredSuggestions = autoCache((word) => this.dict.getPreferredSuggestions?.(word), DefaultAutoCacheSize);
  stats() {
    return {
      name: this.name,
      id: this.id,
      has: extractStats(this.#has),
      isNoSuggestWord: extractStats(this.isNoSuggestWord),
      isForbidden: extractStats(this.isForbidden),
      getPreferredSuggestions: extractStats(this.getPreferredSuggestions)
    };
  }
}
var knownDicts = new Map;
function createCachingDictionary(dict, options) {
  options = canonicalSearchOptions(options);
  let knownOptions = knownDicts.get(options);
  if (!knownOptions) {
    knownOptions = new WeakMap;
    knownDicts.set(options, knownOptions);
  }
  const known = knownOptions.get(dict);
  if (known)
    return known;
  const cached = new CachedDict(dict, options);
  knownOptions.set(dict, cached);
  return cached;
}
// node_modules/cspell-dictionary/dist/util/AutoResolve.js
function autoResolve(map3, key, resolve) {
  const found = map3.get(key);
  if (found !== undefined || map3.has(key))
    return found;
  const value = resolve(key);
  map3.set(key, value);
  return value;
}

class AutoResolveCache {
  map = new Map;
  get(k, resolve) {
    return resolve ? autoResolve(this.map, k, resolve) : this.map.get(k);
  }
  has(k) {
    return this.map.has(k);
  }
  set(k, v) {
    this.map.set(k, v);
    return this;
  }
}
function autoResolveWeak(map3, key, resolve) {
  const found = map3.get(key);
  if (found !== undefined || map3.has(key))
    return found;
  const value = resolve(key);
  map3.set(key, value);
  return value;
}

class AutoResolveWeakCache {
  map = new WeakMap;
  get(k, resolve) {
    return resolve ? autoResolveWeak(this.map, k, resolve) : this.map.get(k);
  }
  has(k) {
    return this.map.has(k);
  }
  set(k, v) {
    this.map.set(k, v);
    return this;
  }
}
function createAutoResolveWeakCache() {
  return new AutoResolveWeakCache;
}

// node_modules/cspell-dictionary/dist/util/util.js
function isDefined3(v) {
  return v !== undefined;
}

// node_modules/cspell-dictionary/dist/SpellingDictionary/createSpellingDictionary.js
import { fileURLToPath } from "node:url";

// node_modules/fast-equals/dist/esm/index.mjs
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
function combineComparators(comparatorA, comparatorB) {
  return function isEqual(a, b, state) {
    return comparatorA(a, b, state) && comparatorB(a, b, state);
  };
}
function createIsCircular(areItemsEqual) {
  return function isCircular(a, b, state) {
    if (!a || !b || typeof a !== "object" || typeof b !== "object") {
      return areItemsEqual(a, b, state);
    }
    var cache = state.cache;
    var cachedA = cache.get(a);
    var cachedB = cache.get(b);
    if (cachedA && cachedB) {
      return cachedA === b && cachedB === a;
    }
    cache.set(a, b);
    cache.set(b, a);
    var result = areItemsEqual(a, b, state);
    cache.delete(a);
    cache.delete(b);
    return result;
  };
}
function getStrictProperties(object) {
  return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));
}
var hasOwn = Object.hasOwn || function(object, property) {
  return hasOwnProperty.call(object, property);
};
function sameValueZeroEqual(a, b) {
  return a === b || !a && !b && a !== a && b !== b;
}
var PREACT_VNODE = "__v";
var PREACT_OWNER = "__o";
var REACT_OWNER = "_owner";
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var keys = Object.keys;
function areArraysEqual(a, b, state) {
  var index = a.length;
  if (b.length !== index) {
    return false;
  }
  while (index-- > 0) {
    if (!state.equals(a[index], b[index], index, index, a, b, state)) {
      return false;
    }
  }
  return true;
}
function areDatesEqual(a, b) {
  return sameValueZeroEqual(a.getTime(), b.getTime());
}
function areErrorsEqual(a, b) {
  return a.name === b.name && a.message === b.message && a.cause === b.cause && a.stack === b.stack;
}
function areFunctionsEqual(a, b) {
  return a === b;
}
function areMapsEqual(a, b, state) {
  var size = a.size;
  if (size !== b.size) {
    return false;
  }
  if (!size) {
    return true;
  }
  var matchedIndices = new Array(size);
  var aIterable = a.entries();
  var aResult;
  var bResult;
  var index = 0;
  while (aResult = aIterable.next()) {
    if (aResult.done) {
      break;
    }
    var bIterable = b.entries();
    var hasMatch = false;
    var matchIndex = 0;
    while (bResult = bIterable.next()) {
      if (bResult.done) {
        break;
      }
      if (matchedIndices[matchIndex]) {
        matchIndex++;
        continue;
      }
      var aEntry = aResult.value;
      var bEntry = bResult.value;
      if (state.equals(aEntry[0], bEntry[0], index, matchIndex, a, b, state) && state.equals(aEntry[1], bEntry[1], aEntry[0], bEntry[0], a, b, state)) {
        hasMatch = matchedIndices[matchIndex] = true;
        break;
      }
      matchIndex++;
    }
    if (!hasMatch) {
      return false;
    }
    index++;
  }
  return true;
}
var areNumbersEqual = sameValueZeroEqual;
function areObjectsEqual(a, b, state) {
  var properties = keys(a);
  var index = properties.length;
  if (keys(b).length !== index) {
    return false;
  }
  while (index-- > 0) {
    if (!isPropertyEqual(a, b, state, properties[index])) {
      return false;
    }
  }
  return true;
}
function areObjectsEqualStrict(a, b, state) {
  var properties = getStrictProperties(a);
  var index = properties.length;
  if (getStrictProperties(b).length !== index) {
    return false;
  }
  var property;
  var descriptorA;
  var descriptorB;
  while (index-- > 0) {
    property = properties[index];
    if (!isPropertyEqual(a, b, state, property)) {
      return false;
    }
    descriptorA = getOwnPropertyDescriptor(a, property);
    descriptorB = getOwnPropertyDescriptor(b, property);
    if ((descriptorA || descriptorB) && (!descriptorA || !descriptorB || descriptorA.configurable !== descriptorB.configurable || descriptorA.enumerable !== descriptorB.enumerable || descriptorA.writable !== descriptorB.writable)) {
      return false;
    }
  }
  return true;
}
function arePrimitiveWrappersEqual(a, b) {
  return sameValueZeroEqual(a.valueOf(), b.valueOf());
}
function areRegExpsEqual(a, b) {
  return a.source === b.source && a.flags === b.flags;
}
function areSetsEqual(a, b, state) {
  var size = a.size;
  if (size !== b.size) {
    return false;
  }
  if (!size) {
    return true;
  }
  var matchedIndices = new Array(size);
  var aIterable = a.values();
  var aResult;
  var bResult;
  while (aResult = aIterable.next()) {
    if (aResult.done) {
      break;
    }
    var bIterable = b.values();
    var hasMatch = false;
    var matchIndex = 0;
    while (bResult = bIterable.next()) {
      if (bResult.done) {
        break;
      }
      if (!matchedIndices[matchIndex] && state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a, b, state)) {
        hasMatch = matchedIndices[matchIndex] = true;
        break;
      }
      matchIndex++;
    }
    if (!hasMatch) {
      return false;
    }
  }
  return true;
}
function areTypedArraysEqual(a, b) {
  var index = a.length;
  if (b.length !== index) {
    return false;
  }
  while (index-- > 0) {
    if (a[index] !== b[index]) {
      return false;
    }
  }
  return true;
}
function areUrlsEqual(a, b) {
  return a.hostname === b.hostname && a.pathname === b.pathname && a.protocol === b.protocol && a.port === b.port && a.hash === b.hash && a.username === b.username && a.password === b.password;
}
function isPropertyEqual(a, b, state, property) {
  if ((property === REACT_OWNER || property === PREACT_OWNER || property === PREACT_VNODE) && (a.$$typeof || b.$$typeof)) {
    return true;
  }
  return hasOwn(b, property) && state.equals(a[property], b[property], property, property, a, b, state);
}
var ARGUMENTS_TAG = "[object Arguments]";
var BOOLEAN_TAG = "[object Boolean]";
var DATE_TAG = "[object Date]";
var ERROR_TAG = "[object Error]";
var MAP_TAG = "[object Map]";
var NUMBER_TAG = "[object Number]";
var OBJECT_TAG = "[object Object]";
var REG_EXP_TAG = "[object RegExp]";
var SET_TAG = "[object Set]";
var STRING_TAG = "[object String]";
var URL_TAG = "[object URL]";
var isArray = Array.isArray;
var isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView ? ArrayBuffer.isView : null;
var assign2 = Object.assign;
var getTag = Object.prototype.toString.call.bind(Object.prototype.toString);
function createEqualityComparator(_a) {
  var { areArraysEqual: areArraysEqual2, areDatesEqual: areDatesEqual2, areErrorsEqual: areErrorsEqual2, areFunctionsEqual: areFunctionsEqual2, areMapsEqual: areMapsEqual2, areNumbersEqual: areNumbersEqual2, areObjectsEqual: areObjectsEqual2, arePrimitiveWrappersEqual: arePrimitiveWrappersEqual2, areRegExpsEqual: areRegExpsEqual2, areSetsEqual: areSetsEqual2, areTypedArraysEqual: areTypedArraysEqual2, areUrlsEqual: areUrlsEqual2 } = _a;
  return function comparator(a, b, state) {
    if (a === b) {
      return true;
    }
    if (a == null || b == null) {
      return false;
    }
    var type = typeof a;
    if (type !== typeof b) {
      return false;
    }
    if (type !== "object") {
      if (type === "number") {
        return areNumbersEqual2(a, b, state);
      }
      if (type === "function") {
        return areFunctionsEqual2(a, b, state);
      }
      return false;
    }
    var constructor = a.constructor;
    if (constructor !== b.constructor) {
      return false;
    }
    if (constructor === Object) {
      return areObjectsEqual2(a, b, state);
    }
    if (isArray(a)) {
      return areArraysEqual2(a, b, state);
    }
    if (isTypedArray != null && isTypedArray(a)) {
      return areTypedArraysEqual2(a, b, state);
    }
    if (constructor === Date) {
      return areDatesEqual2(a, b, state);
    }
    if (constructor === RegExp) {
      return areRegExpsEqual2(a, b, state);
    }
    if (constructor === Map) {
      return areMapsEqual2(a, b, state);
    }
    if (constructor === Set) {
      return areSetsEqual2(a, b, state);
    }
    var tag = getTag(a);
    if (tag === DATE_TAG) {
      return areDatesEqual2(a, b, state);
    }
    if (tag === REG_EXP_TAG) {
      return areRegExpsEqual2(a, b, state);
    }
    if (tag === MAP_TAG) {
      return areMapsEqual2(a, b, state);
    }
    if (tag === SET_TAG) {
      return areSetsEqual2(a, b, state);
    }
    if (tag === OBJECT_TAG) {
      return typeof a.then !== "function" && typeof b.then !== "function" && areObjectsEqual2(a, b, state);
    }
    if (tag === URL_TAG) {
      return areUrlsEqual2(a, b, state);
    }
    if (tag === ERROR_TAG) {
      return areErrorsEqual2(a, b, state);
    }
    if (tag === ARGUMENTS_TAG) {
      return areObjectsEqual2(a, b, state);
    }
    if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {
      return arePrimitiveWrappersEqual2(a, b, state);
    }
    return false;
  };
}
function createEqualityComparatorConfig(_a) {
  var { circular, createCustomConfig, strict } = _a;
  var config = {
    areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,
    areDatesEqual,
    areErrorsEqual,
    areFunctionsEqual,
    areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,
    areNumbersEqual,
    areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,
    arePrimitiveWrappersEqual,
    areRegExpsEqual,
    areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,
    areTypedArraysEqual: strict ? areObjectsEqualStrict : areTypedArraysEqual,
    areUrlsEqual
  };
  if (createCustomConfig) {
    config = assign2({}, config, createCustomConfig(config));
  }
  if (circular) {
    var areArraysEqual$1 = createIsCircular(config.areArraysEqual);
    var areMapsEqual$1 = createIsCircular(config.areMapsEqual);
    var areObjectsEqual$1 = createIsCircular(config.areObjectsEqual);
    var areSetsEqual$1 = createIsCircular(config.areSetsEqual);
    config = assign2({}, config, {
      areArraysEqual: areArraysEqual$1,
      areMapsEqual: areMapsEqual$1,
      areObjectsEqual: areObjectsEqual$1,
      areSetsEqual: areSetsEqual$1
    });
  }
  return config;
}
function createInternalEqualityComparator(compare4) {
  return function(a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {
    return compare4(a, b, state);
  };
}
function createIsEqual(_a) {
  var { circular, comparator, createState, equals, strict } = _a;
  if (createState) {
    return function isEqual(a, b) {
      var _a2 = createState(), _b = _a2.cache, cache = _b === undefined ? circular ? new WeakMap : undefined : _b, meta = _a2.meta;
      return comparator(a, b, {
        cache,
        equals,
        meta,
        strict
      });
    };
  }
  if (circular) {
    return function isEqual(a, b) {
      return comparator(a, b, {
        cache: new WeakMap,
        equals,
        meta: undefined,
        strict
      });
    };
  }
  var state = {
    cache: undefined,
    equals,
    meta: undefined,
    strict
  };
  return function isEqual(a, b) {
    return comparator(a, b, state);
  };
}
var deepEqual = createCustomEqual();
var strictDeepEqual = createCustomEqual({ strict: true });
var circularDeepEqual = createCustomEqual({ circular: true });
var strictCircularDeepEqual = createCustomEqual({
  circular: true,
  strict: true
});
var shallowEqual = createCustomEqual({
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
var strictShallowEqual = createCustomEqual({
  strict: true,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
var circularShallowEqual = createCustomEqual({
  circular: true,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
var strictCircularShallowEqual = createCustomEqual({
  circular: true,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  },
  strict: true
});
function createCustomEqual(options) {
  if (options === undefined) {
    options = {};
  }
  var _a = options.circular, circular = _a === undefined ? false : _a, createCustomInternalComparator = options.createInternalComparator, createState = options.createState, _b = options.strict, strict = _b === undefined ? false : _b;
  var config = createEqualityComparatorConfig(options);
  var comparator = createEqualityComparator(config);
  var equals = createCustomInternalComparator ? createCustomInternalComparator(comparator) : createInternalEqualityComparator(comparator);
  return createIsEqual({ circular, comparator, createState, equals, strict });
}

// node_modules/cspell-dictionary/dist/util/simpleCache.js
class SimpleWeakCache {
  size;
  L0 = new WeakMap;
  L1 = new WeakMap;
  L2 = new WeakMap;
  sizeL0 = 0;
  constructor(size) {
    this.size = size;
  }
  has(key) {
    for (const c of this.caches()) {
      if (c.has(key))
        return true;
    }
    return false;
  }
  get(key) {
    for (const c of this.caches()) {
      const entry = c.get(key);
      if (entry) {
        if (c !== this.L0) {
          this._set(key, entry);
        }
        return entry.v;
      }
    }
    return;
  }
  set(key, value) {
    this._set(key, { v: value });
  }
  _set(key, entry) {
    if (this.L0.has(key)) {
      this.L0.set(key, entry);
      return this;
    }
    if (this.sizeL0 >= this.size) {
      this.rotate();
    }
    this.sizeL0 += 1;
    this.L0.set(key, entry);
  }
  caches() {
    return [this.L0, this.L1, this.L2];
  }
  rotate() {
    this.L2 = this.L1;
    this.L1 = this.L0;
    this.L0 = new WeakMap;
    this.sizeL0 = 0;
  }
}

class AutoWeakCache extends SimpleWeakCache {
  factory;
  constructor(factory, size) {
    super(size);
    this.factory = factory;
  }
  get(key) {
    const v = super.get(key);
    if (v !== undefined)
      return v;
    const val = this.factory(key);
    this.set(key, val);
    return val;
  }
}

class SimpleCache {
  size;
  L0 = new Map;
  L1 = new Map;
  L2 = new Map;
  constructor(size) {
    this.size = size;
  }
  has(key) {
    for (const c of this.caches()) {
      if (c.has(key))
        return true;
    }
    return false;
  }
  get(key) {
    for (const c of this.caches()) {
      const entry = c.get(key);
      if (entry) {
        if (c !== this.L0) {
          this._set(key, entry);
        }
        return entry.v;
      }
    }
    return;
  }
  set(key, value) {
    this._set(key, { v: value });
  }
  _set(key, entry) {
    if (this.L0.has(key)) {
      this.L0.set(key, entry);
      return this;
    }
    if (this.L0.size >= this.size) {
      this.rotate();
    }
    this.L0.set(key, entry);
  }
  caches() {
    return [this.L0, this.L1, this.L2];
  }
  rotate() {
    this.L2 = this.L1;
    this.L1 = this.L0;
    this.L0 = new Map;
  }
}

// node_modules/cspell-dictionary/dist/SpellingDictionary/SpellingDictionary.js
var defaultOptions = Object.freeze({
  weightMap: undefined
});

// node_modules/cspell-dictionary/dist/util/clean.js
function clean3(src) {
  const r = src;
  for (const key of Object.keys(r)) {
    if (r[key] === undefined) {
      delete r[key];
    }
  }
  return r;
}

// node_modules/cspell-dictionary/dist/util/regexHelper.js
function escapeRegEx(s) {
  return s.replaceAll(/[|\\{}()[\]^$+*?.]/g, "\\$&").replaceAll("-", "\\x2d");
}

// node_modules/cspell-dictionary/dist/util/repMap.js
function createMapper(repMap, ignoreCharset) {
  if (!repMap && !ignoreCharset)
    return (a) => a;
  repMap = repMap || [];
  const charsetMap = charsetToRepMapRegEx(ignoreCharset);
  if (charsetMap) {
    repMap = [...repMap, ...charsetMap];
  }
  const filteredMap = repMap.filter(([match, _]) => !!match);
  if (!filteredMap.length) {
    return (a) => a;
  }
  const regEx = createMapperRegExp(repMap);
  const values = repMap.filter(([match, _]) => !!match).map(([_, into]) => into);
  function resolve(m, ...matches) {
    const index = matches.findIndex((a) => !!a);
    return 0 <= index && index < values.length ? values[index] : m;
  }
  return function(s) {
    return s.replace(regEx, resolve);
  };
}
function charsetToRepMapRegEx(charset, replaceWith = "") {
  if (!charset)
    return;
  return charset.split("|").map((chars) => `[${chars.replaceAll(/[\][\\]/g, "\\$&")}]`).map((map3) => [map3, replaceWith]);
}
function charsetToRepMap(charset, replaceWith = "") {
  if (!charset)
    return;
  return charset.split("|").flatMap((chars) => [...expandCharacterSet(chars)]).map((char) => [char, replaceWith]);
}
function expandReplaceMap(repMap) {
  return repMap.flatMap(([from, replaceWith]) => from.split("|").map((w) => [w, replaceWith]));
}
function createMapperRegExp(repMap) {
  const filteredMap = repMap.filter(([match, _]) => !!match);
  if (!filteredMap.length) {
    return /$^/;
  }
  const regExStr = filteredMap.map(([from, _]) => from).map((s) => {
    try {
      const r = /\(/.test(s) ? s.replaceAll(/\((?=.*\))/g, "(?:").replaceAll("(?:?", "(?") : s;
      new RegExp(r);
      s = r;
    } catch {
      return escapeRegEx(s);
    }
    return s;
  }).map((s) => `(${s})`).join("|");
  const regEx = new RegExp(regExStr, "g");
  return regEx;
}
function createRepMapper(repMap, ignoreCharset) {
  if (!repMap && !ignoreCharset)
    return (word) => [word];
  const trie = createTrie(repMap, ignoreCharset);
  return (word) => {
    const edits = calcAllEdits(trie, word);
    return applyEdits(word, edits);
  };
}
function applyEdits(word, edits) {
  if (!edits.length)
    return [word];
  const letterEdits = [];
  for (let i = 0;i < word.length; ++i) {
    letterEdits[i] = { edits: [{ b: i, e: i + 1, r: word[i] }], suffixes: [] };
  }
  letterEdits[word.length] = { edits: [], suffixes: [""] };
  for (const edit of edits) {
    const le = letterEdits[edit.b];
    le.edits.push(edit);
  }
  for (let i = word.length - 1;i >= 0; --i) {
    const le = letterEdits[i];
    const sfx = le.suffixes;
    for (const edit of le.edits) {
      const pfx = edit.r;
      const nSfx = letterEdits[edit.e].suffixes;
      for (const s of nSfx) {
        sfx.push(pfx + s);
      }
    }
  }
  const results = new Set(letterEdits[0].suffixes);
  return [...results];
}
function calcAllEdits(root, word) {
  const edits = [];
  function walk2(node, b, e) {
    if (node.rep) {
      node.rep.forEach((r) => edits.push({ b, e, r }));
    }
    if (e === word.length || !node.children)
      return;
    const n = node.children[word[e]];
    if (!n)
      return;
    walk2(n, b, e + 1);
  }
  for (let i = 0;i < word.length; ++i) {
    walk2(root, i, i);
  }
  return edits;
}
function createTrie(repMap, ignoreCharset) {
  const combined = [repMap, charsetToRepMap(ignoreCharset)].filter(isDefined3).flat();
  const expanded = expandReplaceMap(combined);
  const trieRoot = Object.create(null);
  expanded.forEach(([match, replaceWith]) => addToTrie(trieRoot, match, replaceWith));
  return trieRoot;
}
function addToTrie(node, match, replaceWith) {
  while (match) {
    const children = node.children || (node.children = Object.create(null));
    const k = match[0];
    const childNode = children[k] || (children[k] = Object.create(null));
    node = childNode;
    match = match.slice(1);
  }
  const s = new Set(node.rep || []);
  s.add(replaceWith);
  node.rep = [...s];
}

// node_modules/cspell-dictionary/dist/SpellingDictionary/defaults.js
var ignoreCase = true;
var isForbiddenIgnoreCaseAndAccents = false;

// node_modules/cspell-dictionary/dist/SpellingDictionary/SpellingDictionaryFromTrie.js
var findWordOptionsCaseSensitive = Object.freeze({ caseSensitive: true });
var findWordOptionsNotCaseSensitive = Object.freeze({ caseSensitive: false });

class SpellingDictionaryFromTrie {
  trie;
  name;
  options;
  source;
  _size = 0;
  knownWords = new Set;
  unknownWords = new Set;
  mapWord;
  remapWord;
  type = "SpellingDictionaryFromTrie";
  isDictionaryCaseSensitive;
  containsNoSuggestWords;
  weightMap;
  constructor(trie, name, options, source = "from trie", size) {
    this.trie = trie;
    this.name = name;
    this.options = options;
    this.source = source;
    this.mapWord = createMapper(options.repMap, options.dictionaryInformation?.ignore);
    this.remapWord = createRepMapper(options.repMap, options.dictionaryInformation?.ignore);
    this.isDictionaryCaseSensitive = options.caseSensitive ?? trie.isCaseAware;
    this.containsNoSuggestWords = options.noSuggest || false;
    this._size = size || 0;
    this.weightMap = options.weightMap || createWeightMapFromDictionaryInformation(options.dictionaryInformation);
  }
  get size() {
    if (!this._size) {
      const i = this.trie.iterate();
      let deeper = true;
      let size = 0;
      for (let r = i.next();!r.done; r = i.next(deeper)) {
        size += 1;
        deeper = r.value.text.length < 5;
      }
      this._size = size;
    }
    return this._size;
  }
  has(word, hasOptions) {
    const { useCompounds, ignoreCase: ignoreCase2 } = this.resolveOptions(hasOptions);
    const r = this._find(word, useCompounds, ignoreCase2);
    return !!r && !r.forbidden && !!r.found;
  }
  find(word, hasOptions) {
    const { useCompounds, ignoreCase: ignoreCase2 } = this.resolveOptions(hasOptions);
    const r = this._find(word, useCompounds, ignoreCase2);
    const { forbidden = this.isForbidden(word) } = r || {};
    if (!r && !forbidden)
      return;
    const { found = forbidden ? word : false } = r || {};
    const noSuggest = found !== false && this.containsNoSuggestWords;
    return { found, forbidden, noSuggest };
  }
  resolveOptions(hasOptions) {
    const { useCompounds = this.options.useCompounds, ignoreCase: ignoreCase2 = ignoreCase } = hasOptionToSearchOption(hasOptions);
    return { useCompounds, ignoreCase: ignoreCase2 };
  }
  _find = (word, useCompounds, ignoreCase2) => this.findAnyForm(word, useCompounds, ignoreCase2);
  findAnyForm(word, useCompounds, ignoreCase2) {
    const outerForms = outerWordForms(word, this.remapWord || ((word2) => [this.mapWord(word2)]));
    for (const form of outerForms) {
      const r = this._findAnyForm(form, useCompounds, ignoreCase2);
      if (r)
        return r;
    }
    return;
  }
  _findAnyForm(mWord, useCompounds, ignoreCase2) {
    const opts = ignoreCase2 ? findWordOptionsNotCaseSensitive : findWordOptionsCaseSensitive;
    const findResult = this.trie.findWord(mWord, opts);
    if (findResult.found !== false) {
      return findResult;
    }
    const forms2 = wordSearchForms(mWord, this.isDictionaryCaseSensitive, ignoreCase2);
    for (const w of forms2) {
      const findResult2 = this.trie.findWord(w, opts);
      if (findResult2.found !== false) {
        return findResult2;
      }
    }
    if (useCompounds) {
      const optsUseCompounds = { ...opts, useLegacyWordCompounds: useCompounds };
      for (const w of forms2) {
        const findResult2 = this.trie.findWord(w, optsUseCompounds);
        if (findResult2.found !== false) {
          return findResult2;
        }
      }
    }
    return;
  }
  isNoSuggestWord(word, options) {
    return this.containsNoSuggestWords ? this.has(word, options) : false;
  }
  isForbidden(word, _ignoreCaseAndAccents) {
    return this.trie.isForbiddenWord(word);
  }
  suggest(word, suggestOptions = {}) {
    return this._suggest(word, suggestOptions);
  }
  _suggest(word, suggestOptions) {
    const { numSuggestions = defaultNumSuggestions, numChanges, includeTies, ignoreCase: ignoreCase2, timeout } = suggestOptions;
    function filter3(_word) {
      return true;
    }
    const collector = suggestionCollector(word, clean3({
      numSuggestions,
      filter: filter3,
      changeLimit: numChanges,
      includeTies,
      ignoreCase: ignoreCase2,
      timeout,
      weightMap: this.weightMap
    }));
    this.genSuggestions(collector, suggestOptions);
    return collector.suggestions.map((r) => ({ ...r, word: r.word }));
  }
  genSuggestions(collector, suggestOptions) {
    if (this.options.noSuggest)
      return;
    const _compoundMethod = suggestOptions.compoundMethod ?? (this.options.useCompounds ? CompoundWordsMethod.JOIN_WORDS : CompoundWordsMethod.NONE);
    wordSuggestFormsArray(collector.word).forEach((w) => this.trie.genSuggestions(impersonateCollector(collector, w), _compoundMethod));
  }
  getErrors() {
    return [];
  }
}
function createSpellingDictionaryFromTrieFile(data, name, source, options) {
  const trie = decodeTrie(data);
  return new SpellingDictionaryFromTrie(trie, name, options, source);
}
function* outerWordForms(word, mapWord) {
  const sent = new Set;
  let w = word;
  const ww = w;
  yield w;
  sent.add(w);
  w = word.normalize("NFC");
  if (w !== ww) {
    yield w;
    sent.add(w);
  }
  w = word.normalize("NFD");
  if (w !== ww && !sent.has(w)) {
    yield w;
    sent.add(w);
  }
  for (const f of sent) {
    for (const m of mapWord(f)) {
      if (m !== ww && !sent.has(m)) {
        yield m;
        sent.add(m);
      }
    }
  }
  return;
}

// node_modules/cspell-dictionary/dist/SpellingDictionary/createSpellingDictionary.js
var cachedDictionaries = new AutoWeakCache(_createSpellingDictionary, 64);
var maxSetSize = 3;
var cachedParamsByWordList = new SimpleCache(64);
function createSpellingDictionary(wordList, name, source, options) {
  const params = [wordList, name, source.toString(), options];
  if (!Array.isArray(wordList)) {
    return _createSpellingDictionary(params);
  }
  const cached = cachedParamsByWordList.get(name) || new Set;
  for (const cachedParams of cached) {
    if (deepEqual(params, cachedParams)) {
      return cachedDictionaries.get(cachedParams);
    }
  }
  if (cached.size > maxSetSize)
    cached.clear();
  cached.add(params);
  cachedParamsByWordList.set(name, cached);
  return cachedDictionaries.get(params);
}
function _createSpellingDictionary(params) {
  const [wordList, name, source, options] = params;
  const parseOptions = { stripCaseAndAccents: options?.supportNonStrictSearches ?? true };
  const words = parseDictionaryLines(wordList, parseOptions);
  const trie = buildITrieFromWords(words);
  const opts = { ...options || defaultOptions };
  if (opts.weightMap === undefined && opts.dictionaryInformation) {
    opts.weightMap = createWeightMapFromDictionaryInformation(opts.dictionaryInformation);
  }
  return new SpellingDictionaryFromTrie(trie, name, opts, source);
}
function createFailedToLoadDictionary(name, sourceUrl, error, options) {
  const sourceHref = typeof sourceUrl === "string" ? sourceUrl : sourceUrl.href;
  const source = sourceHref.startsWith("file:") ? fileURLToPath(sourceUrl) : sourceHref;
  options = options || {};
  return {
    name,
    source,
    type: "error",
    containsNoSuggestWords: false,
    has: () => false,
    find: () => {
      return;
    },
    isNoSuggestWord: () => false,
    isForbidden: () => false,
    suggest: () => [],
    mapWord: (a) => a,
    genSuggestions: () => {
      return;
    },
    size: 0,
    options,
    isDictionaryCaseSensitive: false,
    getErrors: () => [error]
  };
}

// node_modules/cspell-dictionary/dist/util/textMappers.js
function* mapperRemoveCaseAndAccents(words) {
  for (const word of words) {
    const lc = word.toLowerCase();
    yield lc;
    const woAccents = removeAccents(lc);
    if (lc !== woAccents)
      yield woAccents;
  }
}

// node_modules/cspell-dictionary/dist/SpellingDictionary/Typos/typosParser.js
import assert5 from "node:assert";

// node_modules/cspell-dictionary/dist/SpellingDictionary/Typos/util.js
function normalizeTyposDefValue(value) {
  if (!value)
    return false;
  if (typeof value === "string")
    return value;
  const unique2 = [...new Set(value)];
  return unique2.length > 1 ? unique2 : unique2.length === 1 ? unique2[0] : false;
}
function mergeDefEntry(targetDef, key, value) {
  const curValue = targetDef[key];
  if (!curValue) {
    targetDef[key] = normalizeTyposDefValue(value);
    return targetDef;
  }
  if (!value)
    return targetDef;
  const newValue = Array.isArray(curValue) ? curValue : [curValue];
  if (Array.isArray(value)) {
    newValue.push(...value);
  } else {
    newValue.push(value);
  }
  targetDef[key] = normalizeTyposDefValue(newValue);
  return targetDef;
}
function mergeDef(targetDef, fromDef) {
  for (const key of Object.keys(fromDef)) {
    mergeDefEntry(targetDef, key, fromDef[key]);
  }
  return targetDef;
}
function appendToDef(def, entry) {
  if (!entry)
    return def;
  if (typeof entry === "string") {
    if (!def[entry]) {
      def[entry] = false;
    }
    return def;
  }
  if (Array.isArray(entry)) {
    const [key, ...sugs] = entry.map((s2) => s2.trim());
    if (!key)
      return def;
    const s = sugs.map((s2) => s2.trim()).filter((s2) => !!s2);
    return mergeDefEntry(def, key, s);
  }
  return mergeDef(def, entry);
}
function createTyposDef(entries) {
  const def = Object.create(null);
  if (!entries)
    return def;
  for (const [key, value] of entries) {
    def[key] = isDefined5(value) ? value : false;
  }
  return def;
}
function extractAllSuggestions(typosDef) {
  const allSugs = pipeSync(Object.values(typosDef), opFilterSync(hasSuggestions), opConcatMapSync((v) => Array.isArray(v) ? v : [v]));
  return new Set(allSugs);
}
function extractIgnoreValues(typosDef, ignorePrefix) {
  const pfxLen = ignorePrefix.length;
  return new Set(Object.keys(typosDef).filter((k) => k.startsWith(ignorePrefix)).map((k) => k.slice(pfxLen)));
}
function isDefined5(v) {
  return v !== undefined && v !== null;
}
function isString(v) {
  return typeof v === "string";
}
function isArray2(v) {
  return Array.isArray(v);
}
function hasSuggestions(v) {
  return isString(v) || isArray2(v);
}

// node_modules/cspell-dictionary/dist/SpellingDictionary/Typos/typosParser.js
function assertString(v) {
  assert5(typeof v === "string", "A string was expected.");
  return true;
}
var suggestionsSeparator = /[,]/;
var typoSuggestionsSeparator = /:|->/;
var typoEntrySeparator = /[\n;]/;
function normalize2(s) {
  return s.normalize();
}
function trimAndFilter(lines) {
  return lines.map((s) => s.trim()).filter((s) => !!s).map(normalize2);
}
function cleanSugs(rawSugs) {
  const sugs = trimAndFilter(rawSugs);
  return sugs.length === 1 ? sugs[0] : sugs.length ? sugs : false;
}
function splitSuggestionsValue(value) {
  return cleanSugs(value.split(suggestionsSeparator));
}
function sanitizeIntoTypoDef(dirtyDef) {
  if (!dirtyDef || typeof dirtyDef !== "object")
    return;
  const def = createTyposDef();
  for (const [rawKey, value] of Object.entries(dirtyDef)) {
    const key = normalize2(rawKey.trim());
    if (!key)
      continue;
    if (typeof value === "string") {
      def[key] = splitSuggestionsValue(value);
      continue;
    }
    if (Array.isArray(value)) {
      const sugs = cleanSugs(value.filter(assertString));
      def[key] = sugs;
      continue;
    }
    assert5(value === false, "Unexpected suggestion type.");
    def[key] = false;
  }
  return def;
}
function processEntriesToTyposDef(entries) {
  const def = isIterable2(entries) ? reduceToTyposDef(entries) : entries;
  const result = sanitizeIntoTypoDef(def);
  assert5(result);
  return result;
}
function reduceToTyposDef(entries) {
  const def = createTyposDef();
  for (const entry of entries) {
    appendToDef(def, parseTyposLine(entry));
  }
  return def;
}
function parseTyposLine(line) {
  if (!line)
    return;
  if (typeof line === "string") {
    const def = createTyposDef();
    for (const subEntry of splitIntoLines(line)) {
      const [left, right] = splitEntry(subEntry);
      const typo = left.trim();
      if (!right)
        return typo;
      const sugs = splitSuggestionsValue(right);
      def[typo] = sugs;
    }
    return def;
  }
  if (Array.isArray(line)) {
    const [key, ...sugs] = line.filter(assertString).map((s) => s.trim());
    if (!key)
      return;
    return [key, ...sugs];
  }
  return sanitizeIntoTypoDef(line);
}
function splitIntoLines(content) {
  return trimAndFilter(normalize2(content).split(typoEntrySeparator));
}
function splitEntry(line) {
  return line.split(typoSuggestionsSeparator, 2);
}
function isIterable2(v) {
  return Symbol.iterator in v;
}
// node_modules/cspell-dictionary/dist/SpellingDictionary/TyposDictionary.js
class TyposDictionaryImpl {
  name;
  source;
  typosDef;
  containsNoSuggestWords;
  options = {};
  type = "typos";
  size;
  ignoreWords;
  suggestions;
  suggestionsLower;
  explicitIgnoreWords;
  constructor(name, source, typosDef, ignoreList) {
    this.name = name;
    this.source = source;
    this.typosDef = typosDef;
    this.size = Object.keys(typosDef).length;
    this.explicitIgnoreWords = extractIgnoreValues(typosDef, "!");
    this.suggestions = extractAllSuggestions(typosDef);
    this.ignoreWords = new Set(pipeSync(this.explicitIgnoreWords, opAppendSync(ignoreList || [])));
    this.suggestionsLower = new Set(pipeSync(this.suggestions, mapperRemoveCaseAndAccents));
    this.containsNoSuggestWords = this.ignoreWords.size > 0;
  }
  has(_word, _options) {
    return false;
  }
  find(word, options) {
    const result = this._findForms(word, options?.ignoreCase ?? ignoreCase);
    if (result === false)
      return;
    const { found, ignore } = result;
    return { found, forbidden: !ignore, noSuggest: ignore };
  }
  _findForms(word, ignoreCaseAndAccents) {
    const lcWord = word.toLowerCase();
    if (this.ignoreWords.has(word)) {
      return { found: word, ignore: true };
    }
    if (this.suggestions.has(word)) {
      return false;
    }
    if (ignoreCaseAndAccents) {
      if (this.suggestionsLower.has(lcWord)) {
        return false;
      }
      if (this.ignoreWords.has(lcWord)) {
        return { found: lcWord, ignore: true };
      }
    }
    if (word in this.typosDef)
      return { found: word, ignore: false };
    if (lcWord in this.typosDef)
      return { found: lcWord, ignore: false };
    return false;
  }
  isForbidden(word, ignoreCaseAndAccents = isForbiddenIgnoreCaseAndAccents) {
    const found = this._findForms(word, ignoreCaseAndAccents);
    return found !== false && !found.ignore;
  }
  isNoSuggestWord(word, options) {
    const result = this.find(word, options);
    return result?.noSuggest ?? false;
  }
  isSuggestedWord(word, ignoreCaseAndAccents = isForbiddenIgnoreCaseAndAccents) {
    if (this.suggestions.has(word))
      return true;
    const lcWord = word.toLowerCase();
    return ignoreCaseAndAccents && (this.suggestions.has(lcWord) || this.suggestionsLower.has(lcWord));
  }
  suggest(word) {
    return this.getPreferredSuggestions(word);
  }
  _suggest(word) {
    if (this.ignoreWords.has(word))
      return [];
    if (!(word in this.typosDef))
      return;
    const sug = this.typosDef[word];
    const isPreferred = true;
    if (!sug)
      return [];
    if (typeof sug === "string") {
      return [
        {
          word: sug,
          cost: 1,
          isPreferred
        }
      ];
    }
    return sug.map((word2, index) => ({ word: word2, cost: index + 1, isPreferred }));
  }
  genSuggestions(collector) {
    const sugs = this.suggest(collector.word);
    sugs.forEach((result) => collector.add(result));
  }
  getPreferredSuggestions(word) {
    return this._suggest(word) || this._suggest(word.toLowerCase()) || [];
  }
  mapWord(word) {
    return word;
  }
  isDictionaryCaseSensitive = true;
  getErrors() {
    return [];
  }
}
var createCache = createAutoResolveWeakCache();
function createTyposDictionary(entries, name, source) {
  return createCache.get(entries, () => {
    const def = processEntriesToTyposDef(entries);
    return new TyposDictionaryImpl(name, source, def);
  });
}

// node_modules/cspell-dictionary/dist/SpellingDictionary/FlagWordsDictionary.js
class FlagWordsDictionaryTrie extends SpellingDictionaryFromTrie {
  name;
  source;
  containsNoSuggestWords = false;
  options = {};
  constructor(trie, name, source) {
    super(trie, name, defaultOptions, source);
    this.name = name;
    this.source = source;
  }
  has(_word, _options) {
    return false;
  }
  find(word, hasOptions) {
    const f = super.find(word, hasOptions);
    if (!f || !f.forbidden)
      return;
    return f;
  }
  suggest() {
    return [];
  }
  genSuggestions() {
    return;
  }
  isDictionaryCaseSensitive = true;
}

class FlagWordsDictionary {
  name;
  source;
  dictTypos;
  dictTrie;
  containsNoSuggestWords = false;
  options = {};
  type = "flag-words";
  constructor(name, source, dictTypos, dictTrie) {
    this.name = name;
    this.source = source;
    this.dictTypos = dictTypos;
    this.dictTrie = dictTrie;
  }
  has(word, options) {
    return this.dictTypos.has(word, options) || this.dictTrie?.has(word, options) || false;
  }
  find(word, options) {
    const findTypos = this.dictTypos.find(word, options);
    if (findTypos)
      return findTypos;
    const ignoreCase2 = options?.ignoreCase ?? ignoreCase;
    if (this.dictTypos.isSuggestedWord(word, ignoreCase2))
      return;
    return this.dictTrie?.find(word, options);
  }
  isForbidden(word, ignoreCaseAndAccents = isForbiddenIgnoreCaseAndAccents) {
    const findResult = this.find(word, { ignoreCase: ignoreCaseAndAccents });
    return findResult?.forbidden || false;
  }
  isNoSuggestWord(word, options) {
    return this.dictTrie?.isNoSuggestWord(word, options) || this.dictTypos.isNoSuggestWord(word, options);
  }
  suggest(word, suggestOptions = {}) {
    return this.dictTypos.suggest(word, suggestOptions);
  }
  getPreferredSuggestions(word) {
    return this.dictTypos.getPreferredSuggestions(word);
  }
  genSuggestions() {
    return;
  }
  mapWord(word) {
    return word;
  }
  get size() {
    return this.dictTypos.size + (this.dictTrie?.size || 0);
  }
  isDictionaryCaseSensitive = true;
  getErrors() {
    return [];
  }
}
var createCache2 = createAutoResolveWeakCache();
function createFlagWordsDictionary(wordList, name, source) {
  return createCache2.get(wordList, () => {
    const testSpecialCharacters = /[~*+]/;
    const { t: specialWords, f: typoWords } = bisect(parseDictionaryLines(wordList, { stripCaseAndAccents: false }), (line) => testSpecialCharacters.test(line));
    const trieDict = specialWords.size ? buildTrieDict(specialWords, name, source) : undefined;
    const typosDict = createTyposDictionary(typoWords, name, source);
    if (!trieDict)
      return typosDict;
    return new FlagWordsDictionary(name, source, typosDict, trieDict);
  });
}
var regExpCleanIgnore = /^(!!)+/;
function buildTrieDict(words, name, source) {
  const trie = buildITrieFromWords(pipeSync(words, opMapSync((w) => "!" + w), opMapSync((w) => w.replace(regExpCleanIgnore, ""))));
  return new FlagWordsDictionaryTrie(trie, name, source);
}
function bisect(values, predicate) {
  const t = new Set;
  const f = new Set;
  for (const v of values) {
    if (predicate(v)) {
      t.add(v);
    } else {
      f.add(v);
    }
  }
  return { t, f };
}

// node_modules/cspell-dictionary/dist/SpellingDictionary/IgnoreWordsDictionary.js
var NormalizeForm = "NFC";

class IgnoreWordsDictionary {
  name;
  source;
  dict;
  dictNonStrict;
  containsNoSuggestWords = true;
  options = {};
  type = "ignore";
  constructor(name, source, words) {
    this.name = name;
    this.source = source;
    this.dict = new Set(words);
    this.dictNonStrict = new Set(pipeSync(this.dict, opFilterSync((w) => w.startsWith("~")), opMapSync((w) => w.slice(1))));
  }
  has(word, options) {
    const nWord = word.normalize(NormalizeForm);
    if (this.dict.has(nWord))
      return true;
    const lcWord = nWord.toLowerCase();
    if (this.dict.has(lcWord))
      return true;
    const ignoreCase2 = options?.ignoreCase ?? ignoreCase;
    return ignoreCase2 && (this.dictNonStrict.has(nWord) || this.dictNonStrict.has(lcWord));
  }
  find(word, options) {
    const nWord = word.normalize(NormalizeForm);
    if (this.dict.has(nWord))
      return { found: nWord, forbidden: false, noSuggest: true };
    const lcWord = nWord.toLowerCase();
    if (this.dict.has(lcWord))
      return { found: lcWord, forbidden: false, noSuggest: true };
    const ignoreCase2 = options?.ignoreCase ?? ignoreCase;
    if (!ignoreCase2)
      return;
    if (this.dictNonStrict.has(nWord))
      return { found: nWord, forbidden: false, noSuggest: true };
    return this.dictNonStrict.has(lcWord) && { found: lcWord, forbidden: false, noSuggest: true } || undefined;
  }
  isForbidden(_word, _ignoreCase) {
    return false;
  }
  isNoSuggestWord(word, options) {
    return this.has(word, options);
  }
  suggest() {
    return [];
  }
  genSuggestions() {
    return;
  }
  mapWord(word) {
    return word;
  }
  get size() {
    return this.dict.size;
  }
  isDictionaryCaseSensitive = true;
  getErrors() {
    return [];
  }
}
var createCache3 = createAutoResolveWeakCache();
function createIgnoreWordsDictionary(wordList, name, source) {
  return createCache3.get(wordList, () => {
    const testSpecialCharacters = /[*+]/;
    const words = [...parseDictionaryLines(wordList, { stripCaseAndAccents: true })].map((w) => w.normalize(NormalizeForm));
    const hasSpecial = words.some((word) => testSpecialCharacters.test(word));
    if (hasSpecial) {
      return createSpellingDictionary(words, name, source, {
        caseSensitive: true,
        noSuggest: true,
        weightMap: undefined,
        supportNonStrictSearches: true
      });
    }
    return new IgnoreWordsDictionary(name, source, words);
  });
}

// node_modules/cspell-dictionary/dist/SpellingDictionary/SpellingDictionaryCollection.js
function identityString(w) {
  return w;
}

class SpellingDictionaryCollectionImpl {
  dictionaries;
  name;
  options = { weightMap: undefined };
  mapWord = identityString;
  type = "SpellingDictionaryCollection";
  source;
  isDictionaryCaseSensitive;
  containsNoSuggestWords;
  constructor(dictionaries, name, source) {
    this.dictionaries = dictionaries;
    this.name = name;
    this.dictionaries = this.dictionaries.sort((a, b) => b.size - a.size);
    this.source = source || dictionaries.map((d) => d.name).join(", ");
    this.isDictionaryCaseSensitive = this.dictionaries.reduce((a, b) => a || b.isDictionaryCaseSensitive, false);
    this.containsNoSuggestWords = this.dictionaries.reduce((a, b) => a || b.containsNoSuggestWords, false);
  }
  has(word, hasOptions) {
    const options = hasOptionToSearchOption(hasOptions);
    return !!isWordInAnyDictionary(this.dictionaries, word, options) && !this.isForbidden(word);
  }
  find(word, hasOptions) {
    const options = hasOptionToSearchOption(hasOptions);
    return findInAnyDictionary(this.dictionaries, word, options);
  }
  isNoSuggestWord(word, options) {
    return this._isNoSuggestWord(word, options);
  }
  isForbidden(word, ignoreCaseAndAccents) {
    const ignoreCase2 = ignoreCaseAndAccents ?? isForbiddenIgnoreCaseAndAccents;
    return !!this._isForbiddenInDict(word, ignoreCase2) && !this.isNoSuggestWord(word, { ignoreCase: ignoreCase2 });
  }
  suggest(word, suggestOptions = {}) {
    return this._suggest(word, suggestOptions);
  }
  _suggest(word, suggestOptions) {
    const { numSuggestions = defaultNumSuggestions, numChanges, ignoreCase: ignoreCase2, includeTies, timeout } = suggestOptions;
    const prefixNoCase = CASE_INSENSITIVE_PREFIX;
    const filter3 = (word2, _cost) => {
      return (ignoreCase2 || word2[0] !== prefixNoCase) && !this.isForbidden(word2) && !this.isNoSuggestWord(word2, suggestOptions);
    };
    const collectorOptions = {
      numSuggestions,
      filter: filter3,
      changeLimit: numChanges,
      includeTies,
      ignoreCase: ignoreCase2,
      timeout
    };
    const collector = suggestionCollector(word, collectorOptions);
    this.genSuggestions(collector, suggestOptions);
    return collector.suggestions;
  }
  get size() {
    return this.dictionaries.reduce((a, b) => a + b.size, 0);
  }
  getPreferredSuggestions(word) {
    const sugs = this.dictionaries.flatMap((dict) => dict.getPreferredSuggestions?.(word)).filter(isDefined3);
    if (sugs.length <= 1)
      return sugs;
    const unique2 = new Set;
    return sugs.filter((sug) => {
      if (unique2.has(sug.word))
        return false;
      unique2.add(sug.word);
      return true;
    });
  }
  genSuggestions(collector, suggestOptions) {
    const _suggestOptions = { ...suggestOptions };
    const { compoundMethod = CompoundWordsMethod.SEPARATE_WORDS } = suggestOptions;
    _suggestOptions.compoundMethod = this.options.useCompounds ? CompoundWordsMethod.JOIN_WORDS : compoundMethod;
    this.dictionaries.forEach((dict) => dict.genSuggestions(collector, _suggestOptions));
  }
  getErrors() {
    return this.dictionaries.reduce((errors, dict) => [...errors, ...dict.getErrors?.() || []], []);
  }
  _isForbiddenInDict(word, ignoreCase2) {
    return isWordForbiddenInAnyDictionary(this.dictionaries, word, ignoreCase2);
  }
  _isNoSuggestWord = (word, options) => {
    if (!this.containsNoSuggestWords)
      return false;
    return !!isNoSuggestWordInAnyDictionary(this.dictionaries, word, options || {});
  };
}
function createCollection(dictionaries, name, source) {
  return new SpellingDictionaryCollectionImpl(dictionaries, name, source);
}
function isWordInAnyDictionary(dicts, word, options) {
  return dicts.find((dict) => dict.has(word, options));
}
function findInAnyDictionary(dicts, word, options) {
  const found = dicts.map((dict) => dict.find(word, options)).filter(isDefined3);
  if (!found.length)
    return;
  return found.reduce((a, b) => ({
    found: a.forbidden ? a.found : b.forbidden ? b.found : a.found || b.found,
    forbidden: a.forbidden || b.forbidden,
    noSuggest: a.noSuggest || b.noSuggest
  }));
}
function isNoSuggestWordInAnyDictionary(dicts, word, options) {
  return dicts.find((dict) => dict.isNoSuggestWord(word, options));
}
function isWordForbiddenInAnyDictionary(dicts, word, ignoreCase2) {
  return dicts.find((dict) => dict.isForbidden(word, ignoreCase2));
}

// node_modules/cspell-dictionary/dist/SpellingDictionary/SuggestDictionary.js
class SuggestDictionaryImpl {
  name;
  source;
  typosDef;
  containsNoSuggestWords = false;
  options = {};
  type = "suggest";
  size;
  suggestions;
  suggestionsLower;
  constructor(name, source, typosDef) {
    this.name = name;
    this.source = source;
    this.typosDef = typosDef;
    this.size = Object.keys(typosDef).length;
    this.suggestions = extractAllSuggestions(typosDef);
    this.suggestionsLower = new Set(pipeSync(this.suggestions, mapperRemoveCaseAndAccents));
  }
  has(_word, _options) {
    return false;
  }
  find(_word, _options) {
    return;
  }
  isForbidden(_word, _ignoreCaseAndAccents) {
    return false;
  }
  isNoSuggestWord(_word, _options) {
    return false;
  }
  isSuggestedWord(word, ignoreCaseAndAccents = isForbiddenIgnoreCaseAndAccents) {
    if (this.suggestions.has(word))
      return true;
    const lcWord = word.toLowerCase();
    return ignoreCaseAndAccents && (this.suggestions.has(lcWord) || this.suggestionsLower.has(lcWord));
  }
  suggest(word) {
    return this.getPreferredSuggestions(word);
  }
  _suggest(word) {
    if (!(word in this.typosDef))
      return;
    const sug = this.typosDef[word];
    const isPreferred = true;
    if (!sug)
      return [];
    if (typeof sug === "string") {
      return [
        {
          word: sug,
          cost: 1,
          isPreferred
        }
      ];
    }
    return sug.map((word2, index) => ({ word: word2, cost: index + 1, isPreferred }));
  }
  getPreferredSuggestions(word) {
    return this._suggest(word) || this._suggest(word.toLowerCase()) || [];
  }
  genSuggestions(collector) {
    const sugs = this.suggest(collector.word);
    sugs.forEach((result) => collector.add(result));
  }
  mapWord(word) {
    return word;
  }
  isDictionaryCaseSensitive = true;
  getErrors() {
    return [];
  }
}
var createCache4 = createAutoResolveWeakCache();
function createSuggestDictionary(entries, name, source) {
  return createCache4.get(entries, () => {
    const def = processEntriesToTyposDef(entries);
    return new SuggestDictionaryImpl(name, source, def);
  });
}

// node_modules/cspell-dictionary/dist/SpellingDictionary/createInlineSpellingDictionary.js
var cache = createAutoResolveWeakCache();
function createInlineSpellingDictionary(inlineDict, source) {
  return cache.get(inlineDict, () => {
    const { words, flagWords, ignoreWords, suggestWords, name } = inlineDict;
    const dictSources = [
      words && createSpellingDictionary(words, name + "-words", source, inlineDict),
      flagWords && createFlagWordsDictionary(flagWords, name + "-flag-words", source),
      ignoreWords && createIgnoreWordsDictionary(ignoreWords, name + "-ignore-words", source),
      suggestWords && createSuggestDictionary(suggestWords, name + "-suggest", source)
    ].filter(isDefined3);
    return createCollection(dictSources, name, source);
  });
}
// node_modules/cspell-lib/dist/lib/Settings/DictionarySettings.js
import * as path5 from "node:path";

// node_modules/cspell-lib/dist/lib/util/util.js
var uniqueFn = uniqueFilterFnGenerator;
function uniqueFilterFnGenerator(extractFn) {
  const values = new Set;
  const extractor = extractFn || ((a) => a);
  return (v) => {
    const vv = extractor(v);
    const ret = !values.has(vv);
    values.add(vv);
    return ret;
  };
}
function clean5(src) {
  const r = src;
  for (const key of Object.keys(r)) {
    if (r[key] === undefined || r[key] === null) {
      delete r[key];
    }
  }
  return r;
}
function scanMap(accFn, init) {
  let acc = init;
  let first3 = true;
  return function(value) {
    if (first3 && acc === undefined) {
      first3 = false;
      acc = value;
      return acc;
    }
    acc = accFn(acc, value);
    return acc;
  };
}
function isDefined6(v) {
  return v !== undefined;
}
function isArrayEqual(a, b) {
  if (a === b)
    return true;
  let isMatch = a.length === b.length;
  for (let i = 0;i < a.length && isMatch; ++i) {
    isMatch = a[i] === b[i];
  }
  return isMatch;
}
function doSetsIntersect(a, b) {
  function compare4(a2, b2) {
    for (const item of a2) {
      if (b2.has(item))
        return true;
    }
    return false;
  }
  return a.size <= b.size ? compare4(a, b) : compare4(b, a);
}

// node_modules/cspell-lib/dist/lib/Models/CSpellSettingsInternalDef.js
var SymbolCSpellSettingsInternal = Symbol("CSpellSettingsInternal");
function cleanCSpellSettingsInternal(parts) {
  return parts ? Object.assign(clean5(parts), { [SymbolCSpellSettingsInternal]: true }) : { [SymbolCSpellSettingsInternal]: true };
}
function createCSpellSettingsInternal(parts) {
  return cleanCSpellSettingsInternal({ ...parts });
}
function isCSpellSettingsInternal(cs) {
  return !!cs[SymbolCSpellSettingsInternal];
}
function isDictionaryDefinitionInlineInternal(def) {
  if (def.path)
    return false;
  const defInline = def;
  return !!(defInline.words || defInline.flagWords || defInline.ignoreWords || defInline.suggestWords);
}

// node_modules/cspell-lib/dist/lib/util/AutoResolve.js
function autoResolve2(map3, key, resolve) {
  const found = map3.get(key);
  if (found !== undefined || map3.has(key))
    return found;
  const value = resolve(key);
  map3.set(key, value);
  return value;
}

class CacheStatsTracker {
  hits = 0;
  misses = 0;
  resolved = 0;
  deletes = 0;
  sets = 0;
  clears = 0;
  disposals = 0;
  stats() {
    return {
      hits: this.hits,
      misses: this.misses,
      resolved: this.resolved,
      deletes: this.deletes,
      sets: this.sets,
      clears: this.clears,
      disposals: this.disposals
    };
  }
  clear() {
    this.hits = 0;
    this.misses = 0;
    this.resolved = 0;
    this.deletes = 0;
    this.sets = 0;
    ++this.clears;
  }
}

class AutoResolveCache2 {
  map = new Map;
  get(k, resolve) {
    return resolve ? autoResolve2(this.map, k, resolve) : this.map.get(k);
  }
  has(k) {
    return this.map.has(k);
  }
  set(k, v) {
    this.map.set(k, v);
    return this;
  }
  delete(k) {
    return this.map.delete(k);
  }
  clear() {
    this.map.clear();
  }
  dispose() {
    this.clear();
  }
}
function createAutoResolveCache() {
  return new AutoResolveCache2;
}
function autoResolveWeak2(map3, key, resolve) {
  const found = map3.get(key);
  if (found !== undefined || map3.has(key))
    return found;
  const value = resolve(key);
  map3.set(key, value);
  return value;
}

class AutoResolveWeakCache2 {
  _map = new WeakMap;
  _stats = new CacheStatsTracker;
  get(k, resolve) {
    const map3 = this._map;
    const found = map3.get(k);
    if (found !== undefined || map3.has(k)) {
      ++this._stats.hits;
      return found;
    }
    ++this._stats.misses;
    if (!resolve) {
      return;
    }
    ++this._stats.resolved;
    const value = resolve(k);
    map3.set(k, value);
    return value;
  }
  get map() {
    return this._map;
  }
  has(k) {
    return this._map.has(k);
  }
  set(k, v) {
    ++this._stats.sets;
    this._map.set(k, v);
    return this;
  }
  clear() {
    this._stats.clear();
    this._map = new WeakMap;
  }
  delete(k) {
    ++this._stats.deletes;
    return this._map.delete(k);
  }
  dispose() {
    ++this._stats.disposals;
    this.clear();
  }
  stats() {
    return this._stats.stats();
  }
}
function createAutoResolveWeakCache2() {
  return new AutoResolveWeakCache2;
}

class AutoResolveWeakWeakCache {
  _map = new WeakMap;
  _stats = new CacheStatsTracker;
  get(k, resolve) {
    const map3 = this._map;
    const found = map3.get(k);
    const foundValue = found?.deref();
    if (found !== undefined && foundValue) {
      ++this._stats.hits;
      return foundValue;
    }
    ++this._stats.misses;
    if (!resolve) {
      if (found) {
        map3.delete(k);
      }
      return;
    }
    ++this._stats.resolved;
    const value = resolve(k);
    map3.set(k, new WeakRef(value));
    return value;
  }
  get map() {
    return this._map;
  }
  has(k) {
    return !!this._map.get(k)?.deref();
  }
  set(k, v) {
    ++this._stats.sets;
    this._map.set(k, new WeakRef(v));
    return this;
  }
  clear() {
    this._stats.clear();
    this._map = new WeakMap;
  }
  delete(k) {
    ++this._stats.deletes;
    return this._map.delete(k);
  }
  dispose() {
    ++this._stats.disposals;
    this.clear();
  }
  stats() {
    return this._stats.stats();
  }
}
function createAutoResolveWeakWeakCache() {
  return new AutoResolveWeakWeakCache;
}

// node_modules/cspell-lib/dist/lib/util/resolveFile.js
import { createRequire as createRequire2 } from "node:module";
import * as os2 from "node:os";
import * as path4 from "node:path";
import { fileURLToPath as fileURLToPath8 } from "node:url";

// node_modules/global-directory/index.js
var import_ini = __toESM(require_ini(), 1);
import process2 from "node:process";
import path from "node:path";
import os from "node:os";
import fs from "node:fs";
var isWindows = process2.platform === "win32";
var readRc = (filePath) => {
  try {
    return import_ini.default.parse(fs.readFileSync(filePath, "utf8")).prefix;
  } catch {
  }
};
var getEnvNpmPrefix = () => Object.keys(process2.env).reduce((prefix, name) => /^npm_config_prefix$/i.test(name) ? process2.env[name] : prefix, undefined);
var getGlobalNpmrc = () => {
  if (isWindows && process2.env.APPDATA) {
    return path.join(process2.env.APPDATA, "/npm/etc/npmrc");
  }
  if (process2.execPath.includes("/Cellar/node")) {
    const homebrewPrefix = process2.execPath.slice(0, process2.execPath.indexOf("/Cellar/node"));
    return path.join(homebrewPrefix, "/lib/node_modules/npm/npmrc");
  }
  if (process2.execPath.endsWith("/bin/node")) {
    const installDir = path.dirname(path.dirname(process2.execPath));
    return path.join(installDir, "/etc/npmrc");
  }
};
var getDefaultNpmPrefix = () => {
  if (isWindows) {
    const { APPDATA } = process2.env;
    return APPDATA ? path.join(APPDATA, "npm") : path.dirname(process2.execPath);
  }
  return path.dirname(path.dirname(process2.execPath));
};
var getNpmPrefix = () => {
  const envPrefix = getEnvNpmPrefix();
  if (envPrefix) {
    return envPrefix;
  }
  const homePrefix = readRc(path.join(os.homedir(), ".npmrc"));
  if (homePrefix) {
    return homePrefix;
  }
  if (process2.env.PREFIX) {
    return process2.env.PREFIX;
  }
  const globalPrefix = readRc(getGlobalNpmrc());
  if (globalPrefix) {
    return globalPrefix;
  }
  return getDefaultNpmPrefix();
};
var npmPrefix = path.resolve(getNpmPrefix());
var getYarnWindowsDirectory = () => {
  if (isWindows && process2.env.LOCALAPPDATA) {
    const dir = path.join(process2.env.LOCALAPPDATA, "Yarn");
    if (fs.existsSync(dir)) {
      return dir;
    }
  }
  return false;
};
var getYarnPrefix = () => {
  if (process2.env.PREFIX) {
    return process2.env.PREFIX;
  }
  const windowsPrefix = getYarnWindowsDirectory();
  if (windowsPrefix) {
    return windowsPrefix;
  }
  const configPrefix = path.join(os.homedir(), ".config/yarn");
  if (fs.existsSync(configPrefix)) {
    return configPrefix;
  }
  const homePrefix = path.join(os.homedir(), ".yarn-config");
  if (fs.existsSync(homePrefix)) {
    return homePrefix;
  }
  return npmPrefix;
};
var globalDirectory = {};
globalDirectory.npm = {};
globalDirectory.npm.prefix = npmPrefix;
globalDirectory.npm.packages = path.join(npmPrefix, isWindows ? "node_modules" : "lib/node_modules");
globalDirectory.npm.binaries = isWindows ? npmPrefix : path.join(npmPrefix, "bin");
var yarnPrefix = path.resolve(getYarnPrefix());
globalDirectory.yarn = {};
globalDirectory.yarn.prefix = yarnPrefix;
globalDirectory.yarn.packages = path.join(yarnPrefix, getYarnWindowsDirectory() ? "Data/global/node_modules" : "global/node_modules");
globalDirectory.yarn.binaries = path.join(globalDirectory.yarn.packages, ".bin");
var global_directory_default = globalDirectory;

// node_modules/@cspell/cspell-resolver/dist/resolveGlobal.mjs
var import_requireResolve = __toESM(require_requireResolve(), 1);
function resolveGlobal(modulesName) {
  const paths = [global_directory_default.npm.packages, global_directory_default.yarn.packages];
  return import_requireResolve.requireResolve(modulesName, paths);
}
// node_modules/@cspell/dynamic-import/dist/esm/dynamicImport.mjs
import { statSync as statSync2 } from "node:fs";
import { resolve as resolvePath } from "node:path";

// node_modules/@cspell/url/dist/index.js
import assert7 from "node:assert";
import Path from "node:path";
import { pathToFileURL as pathToFileURL2 } from "node:url";
import { fileURLToPath as fileURLToPath2, pathToFileURL } from "node:url";
var isURLRegEx = /^(\w[\w-]{1,63}:\/|data:|stdin:)/i;
function toURL(url, relativeTo) {
  return normalizeWindowsUrl(url instanceof URL ? url : new URL(url, relativeTo));
}
function urlParent(url) {
  url = toURL(url);
  if (url.protocol === "data:") {
    return url;
  }
  const hasTrailingSlash = url.pathname.endsWith("/");
  if (!url.pathname.startsWith("/")) {
    const parts = url.pathname.split("/").slice(0, hasTrailingSlash ? -2 : -1);
    let pathname = parts.join("/");
    pathname = pathname && pathname + "/" || "";
    return new URL(url.protocol + (url.host ? "//" + url.host : "") + pathname + url.search + url.hash);
  }
  return new URL(hasTrailingSlash ? ".." : ".", url);
}
function basenameOfUrlPathname(path2) {
  const adj = path2.endsWith("/") ? 2 : 0;
  const idx2 = path2.lastIndexOf("/", path2.length - adj);
  return idx2 >= 0 ? path2.slice(idx2 + 1) : path2;
}
function isUrlLike(filename) {
  return filename instanceof URL || isURLRegEx.test(filename);
}
function hasProtocol(url, protocol) {
  protocol = protocol.endsWith(":") ? protocol : protocol + ":";
  return typeof url === "string" ? url.startsWith(protocol) : url.protocol === protocol;
}
function addTrailingSlash(url) {
  if (url.pathname.endsWith("/"))
    return url;
  const urlWithSlash = new URL(url.href);
  urlWithSlash.pathname += "/";
  return urlWithSlash;
}
function urlToUrlRelative(urlFrom, urlTo) {
  let pFrom = urlFrom.pathname;
  const pTo = urlTo.pathname;
  if (pFrom === pTo)
    return "";
  pFrom = pFrom.endsWith("/") ? pFrom : new URL("./", urlFrom).pathname;
  if (pTo.startsWith(pFrom))
    return decodeURIComponent(pTo.slice(pFrom.length));
  const p0 = pFrom;
  const p1 = pTo;
  if (p1.startsWith(p0)) {
    return decodeURIComponent(p0 === p1 ? "" : p1.slice(p0.lastIndexOf("/") + 1));
  }
  const p0Parts = p0.split("/").slice(0, -1);
  const p1Parts = p1.split("/");
  let i = 0;
  for (i = 0;i < p0Parts.length && i < p1Parts.length - 1 && p0Parts[i] === p1Parts[i]; ++i) {
  }
  const rel = "../".repeat(p0Parts.length - i) + p1Parts.slice(i).join("/");
  return decodeURIComponent(rel.length < p1.length ? rel : p1);
}
var regExpWindowsPath = /^[\\/]([a-zA-Z]:[\\/])/;
var badUncLocalhostUrl = /^(\/+[a-zA-Z])\$/;
function normalizeWindowsUrl(url) {
  url = typeof url === "string" ? new URL(url) : url;
  if (url.protocol === "file:") {
    let pathname = url.pathname.replaceAll("%3A", ":").replaceAll("%3a", ":").replaceAll("%24", "$");
    if (!url.host) {
      pathname = pathname.replace(badUncLocalhostUrl, "$1:");
    }
    pathname = pathname.replace(regExpWindowsPath, (d) => d.toUpperCase());
    if (pathname !== url.pathname) {
      url = new URL(url);
      url.pathname = pathname;
      return fixUncUrl(url);
    }
  }
  return fixUncUrl(url);
}
function fixUncUrl(url) {
  if (url.href.startsWith("file:////")) {
    return new URL(url.href.replace(/^file:\/{4}/, "file://"));
  }
  return url;
}
var regMatchFilename = /filename=([^;,]*)/;
function urlBasename(url) {
  function guessDataUrlName(header) {
    const filenameMatch = header.match(regMatchFilename);
    if (filenameMatch)
      return filenameMatch[1];
    const mime = header.split(";", 1)[0];
    return mime.replaceAll(/\W/g, ".");
  }
  url = toURL(url);
  if (url.protocol === "data:") {
    return guessDataUrlName(url.pathname.split(",", 1)[0]);
  }
  return basenameOfUrlPathname(url.pathname);
}
function isDataURL(url) {
  return hasProtocol(url, "data:");
}
var isWindows2 = process.platform === "win32";
var windowsUrlPathRegExp = /^\/[a-zA-Z]:\//;
function isWindowsPathnameWithDriveLatter(pathname) {
  return windowsUrlPathRegExp.test(pathname);
}
function isFileURL(url) {
  return hasProtocol(url, "file:");
}
function toFilePathOrHref(url) {
  return isFileURL(url) && url.toString().startsWith("file:///") ? toFilePath(url) : url.toString();
}
function toFilePath(url) {
  try {
    if (isWindows2) {
      const u = new URL(url);
      if (!isWindowsPathnameWithDriveLatter(u.pathname)) {
        const cwdUrl = pathToFileURL(process.cwd());
        if (cwdUrl.hostname) {
          return fileURLToPath2(new URL(u.pathname, cwdUrl));
        }
        const drive = cwdUrl.pathname.split("/")[1];
        u.pathname = `/${drive}${u.pathname}`;
        return fileURLToPath2(u);
      }
    }
    return pathWindowsDriveLetterToUpper(fileURLToPath2(url));
  } catch {
    return url.toString();
  }
}
var regExpWindowsPathDriveLetter = /^([a-zA-Z]):[\\/]/;
function pathWindowsDriveLetterToUpper(absoluteFilePath) {
  return absoluteFilePath.replace(regExpWindowsPathDriveLetter, (s) => s.toUpperCase());
}
var regExpWindowsFileUrl = /^file:\/\/\/[a-zA-Z]:\//;
function isWindowsFileUrl(url) {
  return regExpWindowsFileUrl.test(url.toString());
}
var isWindowsPathRegEx = regExpWindowsPathDriveLetter;
var isWindowsPathname = regExpWindowsPath;
var percentRegEx = /%/g;
var backslashRegEx = /\\/g;
var newlineRegEx = /\n/g;
var carriageReturnRegEx = /\r/g;
var tabRegEx = /\t/g;
var questionRegex = /\?/g;
var hashRegex = /#/g;
var ProtocolFile = "file:";
var FileUrlBuilder = class {
  windows;
  path;
  cwd;
  constructor(options = {}) {
    const sep = options.path?.sep;
    this.windows = options.windows ?? (sep ? sep === "\\" : undefined) ?? isWindows2;
    this.path = options.path ?? (this.windows ? Path.win32 : Path.posix);
    this.cwd = options.cwd ?? this.pathToFileURL(this.path.resolve() + "/", this.rootFileURL());
    assert7(this.path.sep === (this.windows ? "\\" : "/"), `Path separator should match OS type Windows: ${this.windows === true ? "true" : (this.windows ?? "undefined") || "false"}, sep: ${this.path.sep}, options: ` + JSON.stringify({
      isWindows: isWindows2,
      sep: `${sep}`,
      windows: options.windows,
      pathSep: options.path?.sep,
      n: options.path?.normalize("path/file.txt"),
      cwd: options.cwd?.href,
      win32: this.path === Path.win32,
      posix: this.path === Path.posix,
      "win32.normalize": this.path.normalize === Path.win32.normalize,
      "posix.normalize": this.path.normalize === Path.posix.normalize
    }));
  }
  encodePathChars(filepath) {
    filepath = filepath.replaceAll(percentRegEx, "%25");
    if (!this.windows && !isWindows2 && filepath.includes("\\")) {
      filepath = filepath.replaceAll(backslashRegEx, "%5C");
    }
    filepath = filepath.replaceAll(newlineRegEx, "%0A");
    filepath = filepath.replaceAll(carriageReturnRegEx, "%0D");
    filepath = filepath.replaceAll(tabRegEx, "%09");
    return filepath;
  }
  normalizeFilePathForUrl(filePath) {
    filePath = this.encodePathChars(filePath);
    filePath = filePath.replaceAll(questionRegex, "%3F");
    filePath = filePath.replaceAll(hashRegex, "%23");
    const pathname = filePath.replaceAll("\\", "/");
    return pathname.replace(isWindowsPathRegEx, (drive) => `/${drive}`.toUpperCase());
  }
  toFileURL(filenameOrUrl, relativeTo) {
    return normalizeWindowsUrl(this.#toFileURL(filenameOrUrl, relativeTo));
  }
  #toFileURL(filenameOrUrl, relativeTo) {
    if (typeof filenameOrUrl !== "string")
      return filenameOrUrl;
    if (isUrlLike(filenameOrUrl))
      return normalizeWindowsUrl(new URL(filenameOrUrl));
    relativeTo ??= this.cwd;
    isWindows2 && (filenameOrUrl = filenameOrUrl.replaceAll("\\", "/"));
    if (this.isAbsolute(filenameOrUrl) && isFileURL(relativeTo)) {
      const pathname2 = this.normalizeFilePathForUrl(filenameOrUrl);
      if (isWindowsFileUrl(relativeTo) && !isWindowsPathnameWithDriveLatter(pathname2)) {
        const relFilePrefix = relativeTo.toString().slice(0, 10);
        return normalizeWindowsUrl(new URL(relFilePrefix + pathname2));
      }
      return normalizeWindowsUrl(new URL("file://" + pathname2));
    }
    if (isUrlLike(relativeTo)) {
      const pathname2 = this.normalizeFilePathForUrl(filenameOrUrl);
      return normalizeWindowsUrl(new URL(pathname2, relativeTo));
    }
    const appendSlash = filenameOrUrl.endsWith("/") ? "/" : "";
    const pathname = this.normalizeFilePathForUrl(this.path.resolve(relativeTo.toString(), filenameOrUrl)) + appendSlash;
    return normalizeWindowsUrl(new URL("file://" + pathname));
  }
  toFileDirURL(dirOrUrl, relativeTo) {
    return addTrailingSlash(this.toFileURL(dirOrUrl, relativeTo));
  }
  urlToFilePathOrHref(url) {
    url = this.toFileURL(url);
    return this.#urlToFilePathOrHref(url);
  }
  #urlToFilePathOrHref(url) {
    if (url.protocol !== ProtocolFile || url.hostname)
      return url.href;
    const p = this.path === Path ? toFilePathOrHref(url) : decodeURIComponent(url.pathname.split("/").join(this.path.sep));
    return pathWindowsDriveLetterToUpper(p.replace(isWindowsPathname, "$1"));
  }
  relative(urlFrom, urlTo) {
    if (urlFrom.protocol === urlTo.protocol && urlFrom.protocol === ProtocolFile) {
      if (urlFrom.href === urlTo.href)
        return "";
      urlFrom = urlFrom.pathname.endsWith("/") ? urlFrom : new URL("./", urlFrom);
      const fromPath = urlFrom.pathname;
      const toPath = urlTo.pathname;
      if (toPath.startsWith(fromPath))
        return decodeURIComponent(toPath.slice(fromPath.length));
      const pFrom = this.#urlToFilePathOrHref(urlFrom);
      const pTo = this.#urlToFilePathOrHref(urlTo);
      const toIsDir = urlTo.pathname.endsWith("/");
      let pathname = this.normalizeFilePathForUrl(this.path.relative(pFrom, pTo));
      if (toIsDir && !pathname.endsWith("/"))
        pathname += "/";
      return decodeURIComponent(pathname);
    }
    return decodeURIComponent(urlToUrlRelative(urlFrom, urlTo));
  }
  urlDirname(url) {
    return urlParent(this.toFileURL(url));
  }
  pathToFileURL(pathname, relativeToURL) {
    return new URL(this.normalizeFilePathForUrl(pathname), relativeToURL || this.cwd);
  }
  rootFileURL(filePath) {
    const path2 = this.path;
    const p = path2.parse(path2.normalize(path2.resolve(filePath ?? ".")));
    return new URL(this.normalizeFilePathForUrl(p.root), this.#getFsRootURL());
  }
  #getFsRootURL() {
    if (this.path === Path)
      return pathToFileURL2("/");
    const p = this.path.resolve("/");
    return new URL(this.normalizeFilePathForUrl(p), "file:///");
  }
  isAbsolute(filePath) {
    return isUrlLike(filePath) || this.path.isAbsolute(filePath);
  }
  isUrlLike(url) {
    return isUrlLike(url);
  }
};
var fileUrlBuilder = new FileUrlBuilder;
function toFileURL(filenameOrUrl, relativeTo) {
  return fileUrlBuilder.toFileURL(filenameOrUrl, relativeTo);
}
function toFileDirURL(dir) {
  return fileUrlBuilder.toFileDirURL(dir);
}

// node_modules/import-meta-resolve/lib/resolve.js
import assert9 from "node:assert";
import { statSync, realpathSync } from "node:fs";
import process3 from "node:process";
import { URL as URL2, fileURLToPath as fileURLToPath5, pathToFileURL as pathToFileURL3 } from "node:url";
import path3 from "node:path";
import { builtinModules } from "node:module";

// node_modules/import-meta-resolve/lib/get-format.js
import { fileURLToPath as fileURLToPath4 } from "node:url";

// node_modules/import-meta-resolve/lib/package-json-reader.js
import fs2 from "node:fs";
import path2 from "node:path";
import { fileURLToPath as fileURLToPath3 } from "node:url";

// node_modules/import-meta-resolve/lib/errors.js
import v8 from "node:v8";
import assert8 from "node:assert";
import { format as format2, inspect } from "node:util";
var own = {}.hasOwnProperty;
var classRegExp = /^([A-Z][a-z\d]*)+$/;
var kTypes = new Set([
  "string",
  "function",
  "number",
  "object",
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
]);
var codes2 = {};
function formatList(array, type = "and") {
  return array.length < 3 ? array.join(` ${type} `) : `${array.slice(0, -1).join(", ")}, ${type} ${array[array.length - 1]}`;
}
var messages = new Map;
var nodeInternalPrefix = "__node_internal_";
var userStackTraceLimit;
codes2.ERR_INVALID_ARG_TYPE = createError("ERR_INVALID_ARG_TYPE", (name, expected, actual) => {
  assert8(typeof name === "string", "'name' must be a string");
  if (!Array.isArray(expected)) {
    expected = [expected];
  }
  let message = "The ";
  if (name.endsWith(" argument")) {
    message += `${name} `;
  } else {
    const type = name.includes(".") ? "property" : "argument";
    message += `"${name}" ${type} `;
  }
  message += "must be ";
  const types = [];
  const instances = [];
  const other = [];
  for (const value of expected) {
    assert8(typeof value === "string", "All expected entries have to be of type string");
    if (kTypes.has(value)) {
      types.push(value.toLowerCase());
    } else if (classRegExp.exec(value) === null) {
      assert8(value !== "object", 'The value "object" should be written as "Object"');
      other.push(value);
    } else {
      instances.push(value);
    }
  }
  if (instances.length > 0) {
    const pos = types.indexOf("object");
    if (pos !== -1) {
      types.slice(pos, 1);
      instances.push("Object");
    }
  }
  if (types.length > 0) {
    message += `${types.length > 1 ? "one of type" : "of type"} ${formatList(types, "or")}`;
    if (instances.length > 0 || other.length > 0)
      message += " or ";
  }
  if (instances.length > 0) {
    message += `an instance of ${formatList(instances, "or")}`;
    if (other.length > 0)
      message += " or ";
  }
  if (other.length > 0) {
    if (other.length > 1) {
      message += `one of ${formatList(other, "or")}`;
    } else {
      if (other[0].toLowerCase() !== other[0])
        message += "an ";
      message += `${other[0]}`;
    }
  }
  message += `. Received ${determineSpecificType(actual)}`;
  return message;
}, TypeError);
codes2.ERR_INVALID_MODULE_SPECIFIER = createError("ERR_INVALID_MODULE_SPECIFIER", (request, reason, base = undefined) => {
  return `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`;
}, TypeError);
codes2.ERR_INVALID_PACKAGE_CONFIG = createError("ERR_INVALID_PACKAGE_CONFIG", (path2, base, message) => {
  return `Invalid package config ${path2}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`;
}, Error);
codes2.ERR_INVALID_PACKAGE_TARGET = createError("ERR_INVALID_PACKAGE_TARGET", (packagePath, key, target, isImport = false, base = undefined) => {
  const relatedError = typeof target === "string" && !isImport && target.length > 0 && !target.startsWith("./");
  if (key === ".") {
    assert8(isImport === false);
    return `Invalid "exports" main target ${JSON.stringify(target)} defined ` + `in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
  }
  return `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(target)} defined for '${key}' in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
}, Error);
codes2.ERR_MODULE_NOT_FOUND = createError("ERR_MODULE_NOT_FOUND", (path2, base, exactUrl = false) => {
  return `Cannot find ${exactUrl ? "module" : "package"} '${path2}' imported from ${base}`;
}, Error);
codes2.ERR_NETWORK_IMPORT_DISALLOWED = createError("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error);
codes2.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError("ERR_PACKAGE_IMPORT_NOT_DEFINED", (specifier, packagePath, base) => {
  return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`;
}, TypeError);
codes2.ERR_PACKAGE_PATH_NOT_EXPORTED = createError("ERR_PACKAGE_PATH_NOT_EXPORTED", (packagePath, subpath, base = undefined) => {
  if (subpath === ".")
    return `No "exports" main defined in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
  return `Package subpath '${subpath}' is not defined by "exports" in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
}, Error);
codes2.ERR_UNSUPPORTED_DIR_IMPORT = createError("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported " + "resolving ES modules imported from %s", Error);
codes2.ERR_UNSUPPORTED_RESOLVE_REQUEST = createError("ERR_UNSUPPORTED_RESOLVE_REQUEST", 'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.', TypeError);
codes2.ERR_UNKNOWN_FILE_EXTENSION = createError("ERR_UNKNOWN_FILE_EXTENSION", (extension, path2) => {
  return `Unknown file extension "${extension}" for ${path2}`;
}, TypeError);
codes2.ERR_INVALID_ARG_VALUE = createError("ERR_INVALID_ARG_VALUE", (name, value, reason = "is invalid") => {
  let inspected = inspect(value);
  if (inspected.length > 128) {
    inspected = `${inspected.slice(0, 128)}...`;
  }
  const type = name.includes(".") ? "property" : "argument";
  return `The ${type} '${name}' ${reason}. Received ${inspected}`;
}, TypeError);
function createError(sym, value, constructor) {
  messages.set(sym, value);
  return makeNodeErrorWithCode(constructor, sym);
}
function makeNodeErrorWithCode(Base, key) {
  return NodeError;
  function NodeError(...parameters) {
    const limit = Error.stackTraceLimit;
    if (isErrorStackTraceLimitWritable())
      Error.stackTraceLimit = 0;
    const error = new Base;
    if (isErrorStackTraceLimitWritable())
      Error.stackTraceLimit = limit;
    const message = getMessage(key, parameters, error);
    Object.defineProperties(error, {
      message: {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true
      },
      toString: {
        value() {
          return `${this.name} [${key}]: ${this.message}`;
        },
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    captureLargerStackTrace(error);
    error.code = key;
    return error;
  }
}
function isErrorStackTraceLimitWritable() {
  try {
    if (v8.startupSnapshot.isBuildingSnapshot()) {
      return false;
    }
  } catch {
  }
  const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
  if (desc === undefined) {
    return Object.isExtensible(Error);
  }
  return own.call(desc, "writable") && desc.writable !== undefined ? desc.writable : desc.set !== undefined;
}
function hideStackFrames(wrappedFunction) {
  const hidden = nodeInternalPrefix + wrappedFunction.name;
  Object.defineProperty(wrappedFunction, "name", { value: hidden });
  return wrappedFunction;
}
var captureLargerStackTrace = hideStackFrames(function(error) {
  const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
  if (stackTraceLimitIsWritable) {
    userStackTraceLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = Number.POSITIVE_INFINITY;
  }
  Error.captureStackTrace(error);
  if (stackTraceLimitIsWritable)
    Error.stackTraceLimit = userStackTraceLimit;
  return error;
});
function getMessage(key, parameters, self) {
  const message = messages.get(key);
  assert8(message !== undefined, "expected `message` to be found");
  if (typeof message === "function") {
    assert8(message.length <= parameters.length, `Code: ${key}; The provided arguments length (${parameters.length}) does not ` + `match the required ones (${message.length}).`);
    return Reflect.apply(message, self, parameters);
  }
  const regex = /%[dfijoOs]/g;
  let expectedLength = 0;
  while (regex.exec(message) !== null)
    expectedLength++;
  assert8(expectedLength === parameters.length, `Code: ${key}; The provided arguments length (${parameters.length}) does not ` + `match the required ones (${expectedLength}).`);
  if (parameters.length === 0)
    return message;
  parameters.unshift(message);
  return Reflect.apply(format2, null, parameters);
}
function determineSpecificType(value) {
  if (value === null || value === undefined) {
    return String(value);
  }
  if (typeof value === "function" && value.name) {
    return `function ${value.name}`;
  }
  if (typeof value === "object") {
    if (value.constructor && value.constructor.name) {
      return `an instance of ${value.constructor.name}`;
    }
    return `${inspect(value, { depth: -1 })}`;
  }
  let inspected = inspect(value, { colors: false });
  if (inspected.length > 28) {
    inspected = `${inspected.slice(0, 25)}...`;
  }
  return `type ${typeof value} (${inspected})`;
}

// node_modules/import-meta-resolve/lib/package-json-reader.js
var hasOwnProperty2 = {}.hasOwnProperty;
var { ERR_INVALID_PACKAGE_CONFIG } = codes2;
var cache2 = new Map;
function read(jsonPath, { base, specifier }) {
  const existing = cache2.get(jsonPath);
  if (existing) {
    return existing;
  }
  let string;
  try {
    string = fs2.readFileSync(path2.toNamespacedPath(jsonPath), "utf8");
  } catch (error) {
    const exception = error;
    if (exception.code !== "ENOENT") {
      throw exception;
    }
  }
  const result = {
    exists: false,
    pjsonPath: jsonPath,
    main: undefined,
    name: undefined,
    type: "none",
    exports: undefined,
    imports: undefined
  };
  if (string !== undefined) {
    let parsed;
    try {
      parsed = JSON.parse(string);
    } catch (error_) {
      const cause = error_;
      const error = new ERR_INVALID_PACKAGE_CONFIG(jsonPath, (base ? `"${specifier}" from ` : "") + fileURLToPath3(base || specifier), cause.message);
      error.cause = cause;
      throw error;
    }
    result.exists = true;
    if (hasOwnProperty2.call(parsed, "name") && typeof parsed.name === "string") {
      result.name = parsed.name;
    }
    if (hasOwnProperty2.call(parsed, "main") && typeof parsed.main === "string") {
      result.main = parsed.main;
    }
    if (hasOwnProperty2.call(parsed, "exports")) {
      result.exports = parsed.exports;
    }
    if (hasOwnProperty2.call(parsed, "imports")) {
      result.imports = parsed.imports;
    }
    if (hasOwnProperty2.call(parsed, "type") && (parsed.type === "commonjs" || parsed.type === "module")) {
      result.type = parsed.type;
    }
  }
  cache2.set(jsonPath, result);
  return result;
}
function getPackageScopeConfig(resolved) {
  let packageJSONUrl = new URL("package.json", resolved);
  while (true) {
    const packageJSONPath2 = packageJSONUrl.pathname;
    if (packageJSONPath2.endsWith("node_modules/package.json")) {
      break;
    }
    const packageConfig = read(fileURLToPath3(packageJSONUrl), {
      specifier: resolved
    });
    if (packageConfig.exists) {
      return packageConfig;
    }
    const lastPackageJSONUrl = packageJSONUrl;
    packageJSONUrl = new URL("../package.json", packageJSONUrl);
    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) {
      break;
    }
  }
  const packageJSONPath = fileURLToPath3(packageJSONUrl);
  return {
    pjsonPath: packageJSONPath,
    exists: false,
    type: "none"
  };
}
function getPackageType(url) {
  return getPackageScopeConfig(url).type;
}

// node_modules/import-meta-resolve/lib/get-format.js
var { ERR_UNKNOWN_FILE_EXTENSION } = codes2;
var hasOwnProperty3 = {}.hasOwnProperty;
var extensionFormatMap = {
  __proto__: null,
  ".cjs": "commonjs",
  ".js": "module",
  ".json": "json",
  ".mjs": "module"
};
function mimeToFormat(mime) {
  if (mime && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime))
    return "module";
  if (mime === "application/json")
    return "json";
  return null;
}
var protocolHandlers = {
  __proto__: null,
  "data:": getDataProtocolModuleFormat,
  "file:": getFileProtocolModuleFormat,
  "http:": getHttpProtocolModuleFormat,
  "https:": getHttpProtocolModuleFormat,
  "node:"() {
    return "builtin";
  }
};
function getDataProtocolModuleFormat(parsed) {
  const { 1: mime } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(parsed.pathname) || [null, null, null];
  return mimeToFormat(mime);
}
function extname(url) {
  const pathname = url.pathname;
  let index = pathname.length;
  while (index--) {
    const code = pathname.codePointAt(index);
    if (code === 47) {
      return "";
    }
    if (code === 46) {
      return pathname.codePointAt(index - 1) === 47 ? "" : pathname.slice(index);
    }
  }
  return "";
}
function getFileProtocolModuleFormat(url, _context, ignoreErrors) {
  const value = extname(url);
  if (value === ".js") {
    const packageType = getPackageType(url);
    if (packageType !== "none") {
      return packageType;
    }
    return "commonjs";
  }
  if (value === "") {
    const packageType = getPackageType(url);
    if (packageType === "none" || packageType === "commonjs") {
      return "commonjs";
    }
    return "module";
  }
  const format3 = extensionFormatMap[value];
  if (format3)
    return format3;
  if (ignoreErrors) {
    return;
  }
  const filepath = fileURLToPath4(url);
  throw new ERR_UNKNOWN_FILE_EXTENSION(value, filepath);
}
function getHttpProtocolModuleFormat() {
}
function defaultGetFormatWithoutErrors(url, context) {
  const protocol = url.protocol;
  if (!hasOwnProperty3.call(protocolHandlers, protocol)) {
    return null;
  }
  return protocolHandlers[protocol](url, context, true) || null;
}

// node_modules/import-meta-resolve/lib/utils.js
var { ERR_INVALID_ARG_VALUE } = codes2;
var DEFAULT_CONDITIONS = Object.freeze(["node", "import"]);
var DEFAULT_CONDITIONS_SET = new Set(DEFAULT_CONDITIONS);
function getDefaultConditions() {
  return DEFAULT_CONDITIONS;
}
function getDefaultConditionsSet() {
  return DEFAULT_CONDITIONS_SET;
}
function getConditionsSet(conditions) {
  if (conditions !== undefined && conditions !== getDefaultConditions()) {
    if (!Array.isArray(conditions)) {
      throw new ERR_INVALID_ARG_VALUE("conditions", conditions, "expected an array");
    }
    return new Set(conditions);
  }
  return getDefaultConditionsSet();
}

// node_modules/import-meta-resolve/lib/resolve.js
var RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace];
var {
  ERR_NETWORK_IMPORT_DISALLOWED,
  ERR_INVALID_MODULE_SPECIFIER,
  ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG2,
  ERR_INVALID_PACKAGE_TARGET,
  ERR_MODULE_NOT_FOUND,
  ERR_PACKAGE_IMPORT_NOT_DEFINED,
  ERR_PACKAGE_PATH_NOT_EXPORTED,
  ERR_UNSUPPORTED_DIR_IMPORT,
  ERR_UNSUPPORTED_RESOLVE_REQUEST
} = codes2;
var own2 = {}.hasOwnProperty;
var invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i;
var deprecatedInvalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
var invalidPackageNameRegEx = /^\.|%|\\/;
var patternRegEx = /\*/g;
var encodedSeparatorRegEx = /%2f|%5c/i;
var emittedPackageWarnings = new Set;
var doubleSlashRegEx = /[/\\]{2}/;
function emitInvalidSegmentDeprecation(target, request, match, packageJsonUrl, internal, base, isTarget) {
  if (process3.noDeprecation) {
    return;
  }
  const pjsonPath = fileURLToPath5(packageJsonUrl);
  const double = doubleSlashRegEx.exec(isTarget ? target : request) !== null;
  process3.emitWarning(`Use of deprecated ${double ? "double slash" : "leading or trailing slash matching"} resolving "${target}" for module ` + `request "${request}" ${request === match ? "" : `matched to "${match}" `}in the "${internal ? "imports" : "exports"}" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${fileURLToPath5(base)}` : ""}.`, "DeprecationWarning", "DEP0166");
}
function emitLegacyIndexDeprecation(url, packageJsonUrl, base, main) {
  if (process3.noDeprecation) {
    return;
  }
  const format3 = defaultGetFormatWithoutErrors(url, { parentURL: base.href });
  if (format3 !== "module")
    return;
  const urlPath = fileURLToPath5(url.href);
  const packagePath = fileURLToPath5(new URL2(".", packageJsonUrl));
  const basePath = fileURLToPath5(base);
  if (!main) {
    process3.emitWarning(`No "main" or "exports" field defined in the package.json for ${packagePath} resolving the main entry point "${urlPath.slice(packagePath.length)}", imported from ${basePath}.
Default "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
  } else if (path3.resolve(packagePath, main) !== urlPath) {
    process3.emitWarning(`Package ${packagePath} has a "main" field set to "${main}", ` + `excluding the full filename and extension to the resolved file at "${urlPath.slice(packagePath.length)}", imported from ${basePath}.
 Automatic extension resolution of the "main" field is ` + "deprecated for ES modules.", "DeprecationWarning", "DEP0151");
  }
}
function tryStatSync(path4) {
  try {
    return statSync(path4);
  } catch {
  }
}
function fileExists(url) {
  const stats = statSync(url, { throwIfNoEntry: false });
  const isFile = stats ? stats.isFile() : undefined;
  return isFile === null || isFile === undefined ? false : isFile;
}
function legacyMainResolve(packageJsonUrl, packageConfig, base) {
  let guess;
  if (packageConfig.main !== undefined) {
    guess = new URL2(packageConfig.main, packageJsonUrl);
    if (fileExists(guess))
      return guess;
    const tries2 = [
      `./${packageConfig.main}.js`,
      `./${packageConfig.main}.json`,
      `./${packageConfig.main}.node`,
      `./${packageConfig.main}/index.js`,
      `./${packageConfig.main}/index.json`,
      `./${packageConfig.main}/index.node`
    ];
    let i2 = -1;
    while (++i2 < tries2.length) {
      guess = new URL2(tries2[i2], packageJsonUrl);
      if (fileExists(guess))
        break;
      guess = undefined;
    }
    if (guess) {
      emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
      return guess;
    }
  }
  const tries = ["./index.js", "./index.json", "./index.node"];
  let i = -1;
  while (++i < tries.length) {
    guess = new URL2(tries[i], packageJsonUrl);
    if (fileExists(guess))
      break;
    guess = undefined;
  }
  if (guess) {
    emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
    return guess;
  }
  throw new ERR_MODULE_NOT_FOUND(fileURLToPath5(new URL2(".", packageJsonUrl)), fileURLToPath5(base));
}
function finalizeResolution(resolved, base, preserveSymlinks) {
  if (encodedSeparatorRegEx.exec(resolved.pathname) !== null) {
    throw new ERR_INVALID_MODULE_SPECIFIER(resolved.pathname, 'must not include encoded "/" or "\\" characters', fileURLToPath5(base));
  }
  let filePath;
  try {
    filePath = fileURLToPath5(resolved);
  } catch (error) {
    const cause = error;
    Object.defineProperty(cause, "input", { value: String(resolved) });
    Object.defineProperty(cause, "module", { value: String(base) });
    throw cause;
  }
  const stats = tryStatSync(filePath.endsWith("/") ? filePath.slice(-1) : filePath);
  if (stats && stats.isDirectory()) {
    const error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, fileURLToPath5(base));
    error.url = String(resolved);
    throw error;
  }
  if (!stats || !stats.isFile()) {
    const error = new ERR_MODULE_NOT_FOUND(filePath || resolved.pathname, base && fileURLToPath5(base), true);
    error.url = String(resolved);
    throw error;
  }
  if (!preserveSymlinks) {
    const real = realpathSync(filePath);
    const { search, hash } = resolved;
    resolved = pathToFileURL3(real + (filePath.endsWith(path3.sep) ? "/" : ""));
    resolved.search = search;
    resolved.hash = hash;
  }
  return resolved;
}
function importNotDefined(specifier, packageJsonUrl, base) {
  return new ERR_PACKAGE_IMPORT_NOT_DEFINED(specifier, packageJsonUrl && fileURLToPath5(new URL2(".", packageJsonUrl)), fileURLToPath5(base));
}
function exportsNotFound(subpath, packageJsonUrl, base) {
  return new ERR_PACKAGE_PATH_NOT_EXPORTED(fileURLToPath5(new URL2(".", packageJsonUrl)), subpath, base && fileURLToPath5(base));
}
function throwInvalidSubpath(request, match, packageJsonUrl, internal, base) {
  const reason = `request is not a valid match in pattern "${match}" for the "${internal ? "imports" : "exports"}" resolution of ${fileURLToPath5(packageJsonUrl)}`;
  throw new ERR_INVALID_MODULE_SPECIFIER(request, reason, base && fileURLToPath5(base));
}
function invalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {
  target = typeof target === "object" && target !== null ? JSON.stringify(target, null, "") : `${target}`;
  return new ERR_INVALID_PACKAGE_TARGET(fileURLToPath5(new URL2(".", packageJsonUrl)), subpath, target, internal, base && fileURLToPath5(base));
}
function resolvePackageTargetString(target, subpath, match, packageJsonUrl, base, pattern, internal, isPathMap, conditions) {
  if (subpath !== "" && !pattern && target[target.length - 1] !== "/")
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  if (!target.startsWith("./")) {
    if (internal && !target.startsWith("../") && !target.startsWith("/")) {
      let isURL = false;
      try {
        new URL2(target);
        isURL = true;
      } catch {
      }
      if (!isURL) {
        const exportTarget = pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, () => subpath) : target + subpath;
        return packageResolve(exportTarget, packageJsonUrl, conditions);
      }
    }
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  }
  if (invalidSegmentRegEx.exec(target.slice(2)) !== null) {
    if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) === null) {
      if (!isPathMap) {
        const request = pattern ? match.replace("*", () => subpath) : match + subpath;
        const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, () => subpath) : target;
        emitInvalidSegmentDeprecation(resolvedTarget, request, match, packageJsonUrl, internal, base, true);
      }
    } else {
      throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
    }
  }
  const resolved = new URL2(target, packageJsonUrl);
  const resolvedPath = resolved.pathname;
  const packagePath = new URL2(".", packageJsonUrl).pathname;
  if (!resolvedPath.startsWith(packagePath))
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  if (subpath === "")
    return resolved;
  if (invalidSegmentRegEx.exec(subpath) !== null) {
    const request = pattern ? match.replace("*", () => subpath) : match + subpath;
    if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {
      if (!isPathMap) {
        const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, () => subpath) : target;
        emitInvalidSegmentDeprecation(resolvedTarget, request, match, packageJsonUrl, internal, base, false);
      }
    } else {
      throwInvalidSubpath(request, match, packageJsonUrl, internal, base);
    }
  }
  if (pattern) {
    return new URL2(RegExpPrototypeSymbolReplace.call(patternRegEx, resolved.href, () => subpath));
  }
  return new URL2(subpath, resolved);
}
function isArrayIndex(key) {
  const keyNumber = Number(key);
  if (`${keyNumber}` !== key)
    return false;
  return keyNumber >= 0 && keyNumber < 4294967295;
}
function resolvePackageTarget(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions) {
  if (typeof target === "string") {
    return resolvePackageTargetString(target, subpath, packageSubpath, packageJsonUrl, base, pattern, internal, isPathMap, conditions);
  }
  if (Array.isArray(target)) {
    const targetList = target;
    if (targetList.length === 0)
      return null;
    let lastException;
    let i = -1;
    while (++i < targetList.length) {
      const targetItem = targetList[i];
      let resolveResult;
      try {
        resolveResult = resolvePackageTarget(packageJsonUrl, targetItem, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions);
      } catch (error) {
        const exception = error;
        lastException = exception;
        if (exception.code === "ERR_INVALID_PACKAGE_TARGET")
          continue;
        throw error;
      }
      if (resolveResult === undefined)
        continue;
      if (resolveResult === null) {
        lastException = null;
        continue;
      }
      return resolveResult;
    }
    if (lastException === undefined || lastException === null) {
      return null;
    }
    throw lastException;
  }
  if (typeof target === "object" && target !== null) {
    const keys2 = Object.getOwnPropertyNames(target);
    let i = -1;
    while (++i < keys2.length) {
      const key = keys2[i];
      if (isArrayIndex(key)) {
        throw new ERR_INVALID_PACKAGE_CONFIG2(fileURLToPath5(packageJsonUrl), base, '"exports" cannot contain numeric property keys.');
      }
    }
    i = -1;
    while (++i < keys2.length) {
      const key = keys2[i];
      if (key === "default" || conditions && conditions.has(key)) {
        const conditionalTarget = target[key];
        const resolveResult = resolvePackageTarget(packageJsonUrl, conditionalTarget, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions);
        if (resolveResult === undefined)
          continue;
        return resolveResult;
      }
    }
    return null;
  }
  if (target === null) {
    return null;
  }
  throw invalidPackageTarget(packageSubpath, target, packageJsonUrl, internal, base);
}
function isConditionalExportsMainSugar(exports, packageJsonUrl, base) {
  if (typeof exports === "string" || Array.isArray(exports))
    return true;
  if (typeof exports !== "object" || exports === null)
    return false;
  const keys2 = Object.getOwnPropertyNames(exports);
  let isConditionalSugar = false;
  let i = 0;
  let keyIndex = -1;
  while (++keyIndex < keys2.length) {
    const key = keys2[keyIndex];
    const currentIsConditionalSugar = key === "" || key[0] !== ".";
    if (i++ === 0) {
      isConditionalSugar = currentIsConditionalSugar;
    } else if (isConditionalSugar !== currentIsConditionalSugar) {
      throw new ERR_INVALID_PACKAGE_CONFIG2(fileURLToPath5(packageJsonUrl), base, `"exports" cannot contain some keys starting with '.' and some not.` + " The exports object must either be an object of package subpath keys" + " or an object of main entry condition name keys only.");
    }
  }
  return isConditionalSugar;
}
function emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {
  if (process3.noDeprecation) {
    return;
  }
  const pjsonPath = fileURLToPath5(pjsonUrl);
  if (emittedPackageWarnings.has(pjsonPath + "|" + match))
    return;
  emittedPackageWarnings.add(pjsonPath + "|" + match);
  process3.emitWarning(`Use of deprecated trailing slash pattern mapping "${match}" in the ` + `"exports" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${fileURLToPath5(base)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`, "DeprecationWarning", "DEP0155");
}
function packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
  let exports = packageConfig.exports;
  if (isConditionalExportsMainSugar(exports, packageJsonUrl, base)) {
    exports = { ".": exports };
  }
  if (own2.call(exports, packageSubpath) && !packageSubpath.includes("*") && !packageSubpath.endsWith("/")) {
    const target = exports[packageSubpath];
    const resolveResult = resolvePackageTarget(packageJsonUrl, target, "", packageSubpath, base, false, false, false, conditions);
    if (resolveResult === null || resolveResult === undefined) {
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    }
    return resolveResult;
  }
  let bestMatch = "";
  let bestMatchSubpath = "";
  const keys2 = Object.getOwnPropertyNames(exports);
  let i = -1;
  while (++i < keys2.length) {
    const key = keys2[i];
    const patternIndex = key.indexOf("*");
    if (patternIndex !== -1 && packageSubpath.startsWith(key.slice(0, patternIndex))) {
      if (packageSubpath.endsWith("/")) {
        emitTrailingSlashPatternDeprecation(packageSubpath, packageJsonUrl, base);
      }
      const patternTrailer = key.slice(patternIndex + 1);
      if (packageSubpath.length >= key.length && packageSubpath.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
        bestMatch = key;
        bestMatchSubpath = packageSubpath.slice(patternIndex, packageSubpath.length - patternTrailer.length);
      }
    }
  }
  if (bestMatch) {
    const target = exports[bestMatch];
    const resolveResult = resolvePackageTarget(packageJsonUrl, target, bestMatchSubpath, bestMatch, base, true, false, packageSubpath.endsWith("/"), conditions);
    if (resolveResult === null || resolveResult === undefined) {
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    }
    return resolveResult;
  }
  throw exportsNotFound(packageSubpath, packageJsonUrl, base);
}
function patternKeyCompare(a, b) {
  const aPatternIndex = a.indexOf("*");
  const bPatternIndex = b.indexOf("*");
  const baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
  const baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
  if (baseLengthA > baseLengthB)
    return -1;
  if (baseLengthB > baseLengthA)
    return 1;
  if (aPatternIndex === -1)
    return 1;
  if (bPatternIndex === -1)
    return -1;
  if (a.length > b.length)
    return -1;
  if (b.length > a.length)
    return 1;
  return 0;
}
function packageImportsResolve(name, base, conditions) {
  if (name === "#" || name.startsWith("#/") || name.endsWith("/")) {
    const reason = "is not a valid internal imports specifier name";
    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, fileURLToPath5(base));
  }
  let packageJsonUrl;
  const packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    packageJsonUrl = pathToFileURL3(packageConfig.pjsonPath);
    const imports = packageConfig.imports;
    if (imports) {
      if (own2.call(imports, name) && !name.includes("*")) {
        const resolveResult = resolvePackageTarget(packageJsonUrl, imports[name], "", name, base, false, true, false, conditions);
        if (resolveResult !== null && resolveResult !== undefined) {
          return resolveResult;
        }
      } else {
        let bestMatch = "";
        let bestMatchSubpath = "";
        const keys2 = Object.getOwnPropertyNames(imports);
        let i = -1;
        while (++i < keys2.length) {
          const key = keys2[i];
          const patternIndex = key.indexOf("*");
          if (patternIndex !== -1 && name.startsWith(key.slice(0, -1))) {
            const patternTrailer = key.slice(patternIndex + 1);
            if (name.length >= key.length && name.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
              bestMatch = key;
              bestMatchSubpath = name.slice(patternIndex, name.length - patternTrailer.length);
            }
          }
        }
        if (bestMatch) {
          const target = imports[bestMatch];
          const resolveResult = resolvePackageTarget(packageJsonUrl, target, bestMatchSubpath, bestMatch, base, true, true, false, conditions);
          if (resolveResult !== null && resolveResult !== undefined) {
            return resolveResult;
          }
        }
      }
    }
  }
  throw importNotDefined(name, packageJsonUrl, base);
}
function parsePackageName(specifier, base) {
  let separatorIndex = specifier.indexOf("/");
  let validPackageName = true;
  let isScoped = false;
  if (specifier[0] === "@") {
    isScoped = true;
    if (separatorIndex === -1 || specifier.length === 0) {
      validPackageName = false;
    } else {
      separatorIndex = specifier.indexOf("/", separatorIndex + 1);
    }
  }
  const packageName = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
  if (invalidPackageNameRegEx.exec(packageName) !== null) {
    validPackageName = false;
  }
  if (!validPackageName) {
    throw new ERR_INVALID_MODULE_SPECIFIER(specifier, "is not a valid package name", fileURLToPath5(base));
  }
  const packageSubpath = "." + (separatorIndex === -1 ? "" : specifier.slice(separatorIndex));
  return { packageName, packageSubpath, isScoped };
}
function packageResolve(specifier, base, conditions) {
  if (builtinModules.includes(specifier)) {
    return new URL2("node:" + specifier);
  }
  const { packageName, packageSubpath, isScoped } = parsePackageName(specifier, base);
  const packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    const packageJsonUrl2 = pathToFileURL3(packageConfig.pjsonPath);
    if (packageConfig.name === packageName && packageConfig.exports !== undefined && packageConfig.exports !== null) {
      return packageExportsResolve(packageJsonUrl2, packageSubpath, packageConfig, base, conditions);
    }
  }
  let packageJsonUrl = new URL2("./node_modules/" + packageName + "/package.json", base);
  let packageJsonPath = fileURLToPath5(packageJsonUrl);
  let lastPath;
  do {
    const stat = tryStatSync(packageJsonPath.slice(0, -13));
    if (!stat || !stat.isDirectory()) {
      lastPath = packageJsonPath;
      packageJsonUrl = new URL2((isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName + "/package.json", packageJsonUrl);
      packageJsonPath = fileURLToPath5(packageJsonUrl);
      continue;
    }
    const packageConfig2 = read(packageJsonPath, { base, specifier });
    if (packageConfig2.exports !== undefined && packageConfig2.exports !== null) {
      return packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig2, base, conditions);
    }
    if (packageSubpath === ".") {
      return legacyMainResolve(packageJsonUrl, packageConfig2, base);
    }
    return new URL2(packageSubpath, packageJsonUrl);
  } while (packageJsonPath.length !== lastPath.length);
  throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath5(base), false);
}
function isRelativeSpecifier(specifier) {
  if (specifier[0] === ".") {
    if (specifier.length === 1 || specifier[1] === "/")
      return true;
    if (specifier[1] === "." && (specifier.length === 2 || specifier[2] === "/")) {
      return true;
    }
  }
  return false;
}
function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
  if (specifier === "")
    return false;
  if (specifier[0] === "/")
    return true;
  return isRelativeSpecifier(specifier);
}
function moduleResolve(specifier, base, conditions, preserveSymlinks) {
  const protocol = base.protocol;
  const isData = protocol === "data:";
  const isRemote = isData || protocol === "http:" || protocol === "https:";
  let resolved;
  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
    try {
      resolved = new URL2(specifier, base);
    } catch (error_) {
      const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
      error.cause = error_;
      throw error;
    }
  } else if (protocol === "file:" && specifier[0] === "#") {
    resolved = packageImportsResolve(specifier, base, conditions);
  } else {
    try {
      resolved = new URL2(specifier);
    } catch (error_) {
      if (isRemote && !builtinModules.includes(specifier)) {
        const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
        error.cause = error_;
        throw error;
      }
      resolved = packageResolve(specifier, base, conditions);
    }
  }
  assert9(resolved !== undefined, "expected to be defined");
  if (resolved.protocol !== "file:") {
    return resolved;
  }
  return finalizeResolution(resolved, base, preserveSymlinks);
}
function checkIfDisallowedImport(specifier, parsed, parsedParentURL) {
  if (parsedParentURL) {
    const parentProtocol = parsedParentURL.protocol;
    if (parentProtocol === "http:" || parentProtocol === "https:") {
      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
        const parsedProtocol = parsed?.protocol;
        if (parsedProtocol && parsedProtocol !== "https:" && parsedProtocol !== "http:") {
          throw new ERR_NETWORK_IMPORT_DISALLOWED(specifier, parsedParentURL, "remote imports cannot import from a local location.");
        }
        return { url: parsed?.href || "" };
      }
      if (builtinModules.includes(specifier)) {
        throw new ERR_NETWORK_IMPORT_DISALLOWED(specifier, parsedParentURL, "remote imports cannot import from a local location.");
      }
      throw new ERR_NETWORK_IMPORT_DISALLOWED(specifier, parsedParentURL, "only relative and absolute specifiers are supported.");
    }
  }
}
function isURL(self) {
  return Boolean(self && typeof self === "object" && "href" in self && typeof self.href === "string" && "protocol" in self && typeof self.protocol === "string" && self.href && self.protocol);
}
function throwIfInvalidParentURL(parentURL) {
  if (parentURL === undefined) {
    return;
  }
  if (typeof parentURL !== "string" && !isURL(parentURL)) {
    throw new codes2.ERR_INVALID_ARG_TYPE("parentURL", ["string", "URL"], parentURL);
  }
}
function defaultResolve(specifier, context = {}) {
  const { parentURL } = context;
  assert9(parentURL !== undefined, "expected `parentURL` to be defined");
  throwIfInvalidParentURL(parentURL);
  let parsedParentURL;
  if (parentURL) {
    try {
      parsedParentURL = new URL2(parentURL);
    } catch {
    }
  }
  let parsed;
  let protocol;
  try {
    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier) ? new URL2(specifier, parsedParentURL) : new URL2(specifier);
    protocol = parsed.protocol;
    if (protocol === "data:") {
      return { url: parsed.href, format: null };
    }
  } catch {
  }
  const maybeReturn = checkIfDisallowedImport(specifier, parsed, parsedParentURL);
  if (maybeReturn)
    return maybeReturn;
  if (protocol === undefined && parsed) {
    protocol = parsed.protocol;
  }
  if (protocol === "node:") {
    return { url: specifier };
  }
  if (parsed && parsed.protocol === "node:")
    return { url: specifier };
  const conditions = getConditionsSet(context.conditions);
  const url = moduleResolve(specifier, new URL2(parentURL), conditions, false);
  return {
    url: url.href,
    format: defaultGetFormatWithoutErrors(url, { parentURL })
  };
}

// node_modules/import-meta-resolve/index.js
function resolve(specifier, parent) {
  if (!parent) {
    throw new Error("Please pass `parent`: `import-meta-resolve` cannot ponyfill that");
  }
  try {
    return defaultResolve(specifier, { parentURL: parent }).url;
  } catch (error) {
    const exception = error;
    if ((exception.code === "ERR_UNSUPPORTED_DIR_IMPORT" || exception.code === "ERR_MODULE_NOT_FOUND") && typeof exception.url === "string") {
      return exception.url;
    }
    throw error;
  }
}

// node_modules/@cspell/dynamic-import/dist/esm/dynamicImport.mjs
var isWindowsPath = /^[a-z]:\\/i;
function importResolveModuleName(moduleName, paths) {
  const modulesNameToImport = normalizeModuleName(moduleName);
  let lastError = undefined;
  for (const parent of paths) {
    try {
      const url = typeof parent === "string" ? parent.startsWith("file://") ? new URL(parent) : dirToUrl(parent) : parent;
      const resolvedURL = new URL(resolve(modulesNameToImport.toString(), url.toString()));
      try {
        const s = statSync2(resolvedURL);
        if (s.isFile()) {
          return resolvedURL;
        }
      } catch {
        const error = new Error(`Cannot find module ${moduleName}`);
        error.code = "ERR_MODULE_NOT_FOUND";
        lastError = error;
      }
    } catch (err) {
      lastError = err;
    }
  }
  throw lastError;
}
function normalizeModuleName(moduleName) {
  return typeof moduleName === "string" && isWindowsPath.test(moduleName) ? toFileURL(moduleName) : moduleName;
}
function dirToUrl(dir) {
  const abs = resolvePath(dir);
  return toFileDirURL(abs);
}
// node_modules/cspell-lib/dist/lib/util/resolveFile.js
var import_resolve_from = __toESM(require_resolve_from(), 1);

// node_modules/cspell-io/dist/index.js
import { gunzipSync } from "node:zlib";

// node_modules/@cspell/cspell-service-bus/dist/esm/errors.js
class ErrorUnhandledRequest extends Error {
  request;
  constructor(request) {
    super(`Unhandled Request: ${request.type}`);
    this.request = request;
  }
}

class ErrorServiceRequestDepthExceeded extends Error {
  request;
  depth;
  constructor(request, depth) {
    super(`Service Request Depth ${depth} Exceeded: ${request.type}`);
    this.request = request;
    this.depth = depth;
  }
}

class UnhandledHandlerError extends Error {
  handlerName;
  handlerDescription;
  cause;
  constructor(handlerName, handlerDescription, cause) {
    super(`Unhandled Error in Handler: ${handlerName}`);
    this.handlerName = handlerName;
    this.handlerDescription = handlerDescription;
    this.cause = cause;
  }
}

// node_modules/@cspell/cspell-service-bus/dist/esm/request.js
class BaseServiceRequest {
  type;
  params;
  __r;
  constructor(type, params) {
    this.type = type;
    this.params = params;
  }
}

class ServiceRequestCls extends BaseServiceRequest {
  constructor(type, params) {
    super(type, params);
  }
}
function createResponse(value, _req) {
  return { value };
}
function createResponseFail(_request, error) {
  return { error };
}
function isServiceResponseSuccess(res) {
  return "value" in res && res.error === undefined;
}

// node_modules/@cspell/cspell-service-bus/dist/esm/bus.js
var MAX_DEPTH = 10;

class ServiceBus {
  handlers = [];
  constructor(handlers = []) {
    handlers.forEach((h) => this.addHandler(h));
  }
  addHandler(handler, name = "anonymous", description) {
    const h = typeof handler === "function" ? { fn: handler, name, description } : handler;
    const { fn, name: _name, description: _description } = h;
    this.handlers.push({ fn, name: _name, description: _description });
    return this;
  }
  dispatch(request) {
    let depth = 0;
    const dispatcher = { dispatch };
    const handler = this.reduceHandlers(this.handlers, request, dispatcher, this.defaultHandler);
    function dispatch(request2) {
      ++depth;
      if (depth >= MAX_DEPTH) {
        return createResponseFail(request2, new ErrorServiceRequestDepthExceeded(request2, depth));
      }
      const response = handler(request2);
      --depth;
      return response;
    }
    return dispatch(request);
  }
  defaultHandler(request) {
    return createResponseFail(request, new ErrorUnhandledRequest(request));
  }
  reduceHandlers(handlers, request, dispatcher, defaultHandler) {
    const _handlers = handlers.map((m) => ({ ...m, fn: m.fn(dispatcher) }));
    const handler = _handlers.reduce((next, h) => {
      const fn = h.fn(next);
      return (req) => {
        try {
          return fn(req);
        } catch (e) {
          return createResponseFail(request, new UnhandledHandlerError(h.name, h.description, e));
        }
      };
    }, defaultHandler);
    return handler;
  }
}
// node_modules/@cspell/cspell-service-bus/dist/esm/createRequestHandler.js
function createRequestHandler(requestDef, fn, name, description) {
  return createIsRequestHandler(requestDef.is, fn, name ?? requestDef.type, description);
}
function createIsRequestHandlerFn(isA, fn) {
  return (dispatcher) => (next) => (request) => isA(request) ? fn(request, next, dispatcher) : next(request);
}
function createIsRequestHandler(isA, fn, name, description) {
  return {
    fn: createIsRequestHandlerFn(isA, fn),
    name,
    description
  };
}
// node_modules/@cspell/cspell-service-bus/dist/esm/requestFactory.js
function requestFactory(requestType) {
  class RequestClass extends ServiceRequestCls {
    static type = requestType;
    constructor(params) {
      super(requestType, params);
    }
    static is(req) {
      return req instanceof RequestClass && req.type === requestType;
    }
    static create(params) {
      return new RequestClass(params);
    }
    static createRequestHandler(fn, name, description) {
      return createRequestHandler(RequestClass, fn, name, description);
    }
    static __request;
  }
  return RequestClass;
}
// node_modules/cspell-io/dist/index.js
import { promises as fs3, readFileSync, statSync as statSync22 } from "node:fs";
import { fileURLToPath as fileURLToPath6 } from "node:url";
import { promisify } from "node:util";
import { gunzipSync as gunzipSync2, gzip } from "node:zlib";
import * as Stream from "node:stream";
import { promisify as promisify2 } from "node:util";
var CFileReference = class _CFileReference {
  constructor(url, encoding, baseFilename, gz) {
    this.url = url;
    this.encoding = encoding;
    this.baseFilename = baseFilename;
    this.gz = gz ?? (baseFilename?.endsWith(".gz") || undefined) ?? (url.pathname.endsWith(".gz") || undefined);
  }
  _;
  gz;
  static isCFileReference(obj) {
    return obj instanceof _CFileReference;
  }
  static from(fileReference, encoding, baseFilename, gz) {
    if (_CFileReference.isCFileReference(fileReference))
      return fileReference;
    if (fileReference instanceof URL)
      return new _CFileReference(fileReference, encoding, baseFilename, gz);
    return new _CFileReference(fileReference.url, fileReference.encoding, fileReference.baseFilename, fileReference.gz);
  }
  toJson() {
    return {
      url: this.url.href,
      encoding: this.encoding,
      baseFilename: this.baseFilename,
      gz: this.gz
    };
  }
};
function toFileReference(file, encoding, baseFilename, gz) {
  const fileReference = typeof file === "string" ? toFileURL(file) : file;
  if (fileReference instanceof URL)
    return new CFileReference(fileReference, encoding, baseFilename, gz);
  return CFileReference.from(fileReference);
}
function isFileReference(ref) {
  return CFileReference.isCFileReference(ref) || !(ref instanceof URL) && typeof ref !== "string";
}
function toFileResourceRequest(file, encoding, signal) {
  const fileReference = typeof file === "string" ? toFileURL(file) : file;
  if (fileReference instanceof URL)
    return { url: fileReference, encoding, signal };
  return { url: fileReference.url, encoding: encoding ?? fileReference.encoding, signal };
}
var ErrorNotImplemented = class extends Error {
  constructor(method, options) {
    super(`Method ${method} is not supported.`, options);
    this.method = method;
  }
};
var AssertionError = class extends Error {
  constructor(message, options) {
    super(message, options);
    this.message = message;
  }
};
function assert10(value, message) {
  if (!value) {
    throw new AssertionError(message ?? "Assertion failed");
  }
}
function asUint8Array(data) {
  return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
}
function arrayBufferViewToBuffer(data) {
  if (data instanceof Buffer) {
    return data;
  }
  const buf = Buffer.from(data.buffer);
  if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
    return buf;
  }
  return buf.subarray(data.byteOffset, data.byteOffset + data.byteLength);
}
function copyArrayBufferView(data) {
  return new Uint8Array(data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength));
}
function swap16Poly(data) {
  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  for (let i = 0;i < view.byteLength; i += 2) {
    view.setUint16(i, view.getUint16(i, false), true);
  }
  return data;
}
function swap16(data) {
  if (typeof Buffer !== "undefined") {
    return arrayBufferViewToBuffer(data).swap16();
  }
  return swap16Poly(data);
}
function swapBytes(data) {
  const buf = copyArrayBufferView(data);
  return swap16(buf);
}
var BOM_BE = 65279;
var BOM_LE = 65534;
var decoderUTF8 = new TextDecoder("utf8");
var decoderUTF16LE = new TextDecoder("utf-16le");
var decoderUTF16BE = createTextDecoderUtf16BE();
var encoderUTF8 = new TextEncoder;
function decodeUtf16LE(data) {
  const buf = asUint8Array(data);
  const bom = buf[0] << 8 | buf[1];
  return decoderUTF16LE.decode(bom === BOM_LE ? buf.subarray(2) : buf);
}
function decodeUtf16BE(data) {
  const buf = asUint8Array(data);
  const bom = buf[0] << 8 | buf[1];
  return decoderUTF16BE.decode(bom === BOM_BE ? buf.subarray(2) : buf);
}
function decodeToString(data, encoding) {
  if (isGZipped(data)) {
    return decodeToString(decompressBuffer(data), encoding);
  }
  const buf = asUint8Array(data);
  const bom = buf[0] << 8 | buf[1];
  if (bom === BOM_BE || buf[0] === 0 && buf[1] !== 0)
    return decodeUtf16BE(buf);
  if (bom === BOM_LE || buf[0] !== 0 && buf[1] === 0)
    return decodeUtf16LE(buf);
  if (!encoding)
    return decoderUTF8.decode(buf);
  switch (encoding) {
    case "utf-16be":
    case "utf16be": {
      return decodeUtf16BE(buf);
    }
    case "utf-16le":
    case "utf16le": {
      return decodeUtf16LE(buf);
    }
    case "utf-8":
    case "utf8": {
      return decoderUTF8.decode(buf);
    }
  }
  throw new UnsupportedEncodingError(encoding);
}
function decode(data, encoding) {
  switch (encoding) {
    case "base64":
    case "base64url":
    case "hex": {
      return arrayBufferViewToBuffer(data).toString(encoding);
    }
  }
  const result = decodeToString(data, encoding);
  return result;
}
function encodeString(str, encoding, bom) {
  switch (encoding) {
    case undefined:
    case "utf-8":
    case "utf8": {
      return encoderUTF8.encode(str);
    }
    case "utf-16be":
    case "utf16be": {
      return encodeUtf16BE(str, bom);
    }
    case "utf-16le":
    case "utf16le": {
      return encodeUtf16LE(str, bom);
    }
  }
  return Buffer.from(str, encoding);
}
function encodeUtf16LE(str, bom = true) {
  const buf = Buffer.from(str, "utf16le");
  if (bom) {
    const target = Buffer.alloc(buf.length + 2);
    target.writeUint16LE(BOM_BE);
    buf.copy(target, 2);
    return target;
  }
  return buf;
}
function encodeUtf16BE(str, bom = true) {
  return swap16(encodeUtf16LE(str, bom));
}
function createTextDecoderUtf16BE() {
  try {
    const decoder = new TextDecoder("utf-16be");
    return decoder;
  } catch {
    return {
      encoding: "utf-16be",
      fatal: false,
      ignoreBOM: false,
      decode: (input) => decoderUTF16LE.decode(swapBytes(input))
    };
  }
}
var UnsupportedEncodingError = class extends Error {
  constructor(encoding) {
    super(`Unsupported encoding: ${encoding}`);
  }
};
function isGZipped(data) {
  if (typeof data === "string")
    return false;
  const buf = asUint8Array(data);
  return buf[0] === 31 && buf[1] === 139;
}
function decompressBuffer(data) {
  if (!isGZipped(data))
    return data;
  const buf = arrayBufferViewToBuffer(data);
  return gunzipSync(buf);
}
var CFileResource = class _CFileResource {
  constructor(url, content, encoding, baseFilename, gz) {
    this.url = url;
    this.content = content;
    this.encoding = encoding;
    this.baseFilename = baseFilename ?? (url.protocol !== "data:" && url.pathname.split("/").pop() || undefined);
    this._gz = gz;
  }
  _text;
  baseFilename;
  _gz;
  get gz() {
    if (this._gz !== undefined)
      return this._gz;
    if (this.url.pathname.endsWith(".gz"))
      return true;
    if (typeof this.content === "string")
      return false;
    return isGZipped(this.content);
  }
  getText(encoding) {
    if (this._text !== undefined)
      return this._text;
    const text = typeof this.content === "string" ? this.content : decode(this.content, encoding ?? this.encoding);
    this._text = text;
    return text;
  }
  getBytes() {
    const arrayBufferview = typeof this.content === "string" ? encodeString(this.content, this.encoding) : this.content;
    return arrayBufferview instanceof Uint8Array ? arrayBufferview : new Uint8Array(arrayBufferview.buffer, arrayBufferview.byteOffset, arrayBufferview.byteLength);
  }
  toJson() {
    return {
      url: this.url.href,
      content: this.getText(),
      encoding: this.encoding,
      baseFilename: this.baseFilename,
      gz: this.gz
    };
  }
  static isCFileResource(obj) {
    return obj instanceof _CFileResource;
  }
  static from(urlOrFileResource, content, encoding, baseFilename, gz) {
    if (_CFileResource.isCFileResource(urlOrFileResource)) {
      if (content) {
        const { url, encoding: encoding2, baseFilename: baseFilename2, gz: gz2 } = urlOrFileResource;
        return new _CFileResource(url, content, encoding2, baseFilename2, gz2);
      }
      return urlOrFileResource;
    }
    if (urlOrFileResource instanceof URL) {
      assert10(content !== undefined);
      return new _CFileResource(urlOrFileResource, content, encoding, baseFilename, gz);
    }
    if (content !== undefined) {
      const fileRef = urlOrFileResource;
      return new _CFileResource(fileRef.url, content, fileRef.encoding, fileRef.baseFilename, fileRef.gz);
    }
    assert10("content" in urlOrFileResource && urlOrFileResource.content !== undefined);
    const fileResource = urlOrFileResource;
    return new _CFileResource(fileResource.url, fileResource.content, fileResource.encoding, fileResource.baseFilename, fileResource.gz);
  }
};
function fromFileResource(fileResource, encoding) {
  return CFileResource.from(encoding ? { ...fileResource, encoding } : fileResource);
}
function compareStats(left, right) {
  if (left === right)
    return 0;
  if (left.eTag || right.eTag)
    return left.eTag === right.eTag ? 0 : (left.eTag || "") < (right.eTag || "") ? -1 : 1;
  const diff = left.size - right.size || left.mtimeMs - right.mtimeMs;
  return diff < 0 ? -1 : diff > 0 ? 1 : 0;
}
function urlOrReferenceToUrl(urlOrReference) {
  return urlOrReference instanceof URL ? urlOrReference : urlOrReference.url;
}
function toReadFileOptions(options) {
  if (!options)
    return options;
  if (typeof options === "string") {
    return { encoding: options };
  }
  return options;
}
function toError2(e) {
  if (e instanceof Error)
    return e;
  if (typeof e === "object" && e && "message" in e && typeof e.message === "string") {
    return new Error(e.message, { cause: e });
  }
  return new Error(e && e.toString());
}
function encodeDataUrl(data, mediaType, attributes) {
  if (typeof data === "string")
    return encodeString2(data, mediaType, attributes);
  const attribs = encodeAttributes(attributes || []);
  const buf = arrayBufferViewToBuffer(data);
  return `data:${mediaType}${attribs};base64,${buf.toString("base64url")}`;
}
function toDataUrl(data, mediaType, attributes) {
  return new URL(encodeDataUrl(data, mediaType, attributes));
}
function encodeString2(data, mediaType, attributes) {
  mediaType = mediaType || "text/plain";
  attributes = attributes || [];
  const asUrlComp = encodeURIComponent(data);
  const asBase64 = Buffer.from(data).toString("base64url");
  const useBase64 = asBase64.length < asUrlComp.length - 7;
  const encoded = useBase64 ? asBase64 : asUrlComp;
  const attribMap = new Map([["charset", "utf-8"], ...attributes]);
  attribMap.set("charset", "utf-8");
  const attribs = encodeAttributes(attribMap);
  return `data:${mediaType}${attribs}${useBase64 ? ";base64" : ""},${encoded}`;
}
function encodeAttributes(attributes) {
  return [...attributes].map(([key, value]) => `;${key}=${encodeURIComponent(value)}`).join("");
}
var dataUrlRegExHead = /^data:(?<mediaType>[^;,]*)(?<attributes>(?:;[^=]+=[^;,]*)*)(?<base64>;base64)?$/;
function decodeDataUrl(url) {
  url = url.toString();
  const [head, encodedData] = url.split(",", 2);
  if (!head || encodedData === undefined)
    throw new Error("Not a data url");
  const match = head.match(dataUrlRegExHead);
  if (!match || !match.groups)
    throw new Error("Not a data url");
  const mediaType = match.groups["mediaType"] || "";
  const rawAttributes = (match.groups["attributes"] || "").split(";").filter((a) => !!a).map((entry) => entry.split("=", 2)).map(([key, value]) => [key, decodeURIComponent(value)]);
  const attributes = new Map(rawAttributes);
  const encoding = attributes.get("charset");
  const isBase64 = !!match.groups["base64"];
  const data = isBase64 ? Buffer.from(encodedData, "base64url") : Buffer.from(decodeURIComponent(encodedData));
  return { mediaType, data, encoding, attributes };
}
function guessMimeType(filename) {
  if (filename.endsWith(".trie"))
    return { mimeType: "application/vnd.cspell.dictionary+trie", encoding: "utf-8" };
  if (filename.endsWith(".trie.gz"))
    return { mimeType: "application/vnd.cspell.dictionary+trie.gz" };
  if (filename.endsWith(".txt"))
    return { mimeType: "text/plain", encoding: "utf-8" };
  if (filename.endsWith(".txt.gz"))
    return { mimeType: "application/gzip" };
  if (filename.endsWith(".gz"))
    return { mimeType: "application/gzip" };
  if (filename.endsWith(".json"))
    return { mimeType: "application/json", encoding: "utf-8" };
  if (filename.endsWith(".yaml") || filename.endsWith(".yml"))
    return { mimeType: "application/x-yaml", encoding: "utf-8" };
  return;
}
var _fetch = global.fetch;
var FetchUrlError = class _FetchUrlError extends Error {
  constructor(message, code, status, url) {
    super(message);
    this.code = code;
    this.status = status;
    this.url = url;
    this.name = "FetchUrlError";
  }
  static create(url, status, message) {
    if (status === 404)
      return new _FetchUrlError(message || "URL not found.", "ENOENT", status, url);
    if (status >= 400 && status < 500)
      return new _FetchUrlError(message || "Permission denied.", "EACCES", status, url);
    return new _FetchUrlError(message || "Fatal Error", "ECONNREFUSED", status, url);
  }
  static fromError(url, e) {
    const cause = getCause(e);
    if (cause) {
      return new _FetchUrlError(cause.message, cause.code, undefined, url);
    }
    if (isNodeError(e)) {
      return new _FetchUrlError(e.message, e.code, undefined, url);
    }
    return new _FetchUrlError(e.message, undefined, undefined, url);
  }
};
function isNodeError(e) {
  if (e instanceof Error && "code" in e && typeof e.code === "string")
    return true;
  if (e && typeof e === "object" && "code" in e && typeof e.code === "string")
    return true;
  return false;
}
function isError2(e) {
  return e instanceof Error;
}
function isErrorWithOptionalCause(e) {
  return isError2(e) && (!("cause" in e) || isNodeError(e.cause) || isNodeError(e));
}
function getCause(e) {
  return isErrorWithOptionalCause(e) ? e.cause : undefined;
}
function toFetchUrlError(err, url) {
  return err instanceof FetchUrlError ? err : FetchUrlError.fromError(url, toError22(err));
}
function toError22(err) {
  return err instanceof Error ? err : new Error("Unknown Error", { cause: err });
}
async function fetchHead(request) {
  const url = toURL2(request);
  try {
    const r = await _fetch(url, { method: "HEAD" });
    if (!r.ok) {
      throw FetchUrlError.create(url, r.status);
    }
    return r.headers;
  } catch (e) {
    throw toFetchUrlError(e, url);
  }
}
async function fetchURL(url, signal) {
  try {
    const request = signal ? new Request(url, { signal }) : url;
    const response = await _fetch(request);
    if (!response.ok) {
      throw FetchUrlError.create(url, response.status);
    }
    return Buffer.from(await response.arrayBuffer());
  } catch (e) {
    throw toFetchUrlError(e, url);
  }
}
function toURL2(url) {
  return typeof url === "string" ? new URL(url) : url;
}
async function getStatHttp(url) {
  const headers = await fetchHead(url);
  const eTag = headers.get("etag") || undefined;
  const guessSize = Number.parseInt(headers.get("content-length") || "0", 10);
  return {
    size: eTag ? -1 : guessSize,
    mtimeMs: 0,
    eTag
  };
}
var RequestType = "fs:readFile";
var RequestFsReadFile = requestFactory(RequestType);
var RequestType2 = "fs:readFileSync";
var RequestFsReadFileTextSync = requestFactory(RequestType2);
var RequestTypeStat = "fs:stat";
var RequestFsStat = requestFactory(RequestTypeStat);
var RequestTypeStatSync = "fs:statSync";
var RequestFsStatSync = requestFactory(RequestTypeStatSync);
var RequestType3 = "fs:writeFile";
var RequestFsWriteFile = requestFactory(RequestType3);
var RequestType4 = "zlib:inflate";
var RequestZlibInflate = requestFactory(RequestType4);
var RequestType5 = "fs:readDir";
var RequestFsReadDirectory = requestFactory(RequestType5);
var isGzFileRegExp = /\.gz($|[?#])/;
function isGzFile(url) {
  return isGzFileRegExp.test(typeof url === "string" ? url : url.pathname);
}
var pGzip = promisify(gzip);
var handleRequestFsReadFile = RequestFsReadFile.createRequestHandler(({ params }) => {
  const baseFilename = urlBasename(params.url);
  return createResponse(fs3.readFile(fileURLToPath6(params.url)).then((content) => CFileResource.from(params.url, content, params.encoding, baseFilename)));
}, undefined, "Node: Read Binary File.");
var handleRequestFsReadFileSync = RequestFsReadFileTextSync.createRequestHandler(({ params }) => createResponse(CFileResource.from({ ...params, content: readFileSync(fileURLToPath6(params.url)) })), undefined, "Node: Sync Read Binary File.");
var handleRequestFsReadDirectory = RequestFsReadDirectory.createRequestHandler(({ params }) => {
  return createResponse(fs3.readdir(fileURLToPath6(params.url), { withFileTypes: true }).then((entries) => direntToDirEntries(params.url, entries)));
}, undefined, "Node: Read Directory.");
var handleRequestZlibInflate = RequestZlibInflate.createRequestHandler(({ params }) => createResponse(gunzipSync2(arrayBufferViewToBuffer(params.data))), undefined, "Node: gz deflate.");
var supportedFetchProtocols = { "http:": true, "https:": true };
var handleRequestFsReadFileHttp = RequestFsReadFile.createRequestHandler((req, next) => {
  const { url, signal, encoding } = req.params;
  if (!(url.protocol in supportedFetchProtocols))
    return next(req);
  return createResponse(fetchURL(url, signal).then((content) => CFileResource.from({ url, encoding, content })));
}, undefined, "Node: Read Http(s) file.");
var handleRequestFsReadFileSyncData = RequestFsReadFileTextSync.createRequestHandler((req, next) => {
  const { url, encoding } = req.params;
  if (url.protocol !== "data:")
    return next(req);
  const data = decodeDataUrl(url);
  return createResponse(CFileResource.from({ url, content: data.data, encoding, baseFilename: data.attributes.get("filename") }));
}, undefined, "Node: Read data: urls.");
var handleRequestFsReadFileData = RequestFsReadFile.createRequestHandler((req, next, dispatcher) => {
  const { url } = req.params;
  if (url.protocol !== "data:")
    return next(req);
  const res = dispatcher.dispatch(RequestFsReadFileTextSync.create(req.params));
  if (!isServiceResponseSuccess(res))
    return res;
  return createResponse(Promise.resolve(res.value));
}, undefined, "Node: Read data: urls.");
var handleRequestFsStat = RequestFsStat.createRequestHandler(({ params }) => createResponse(toPromiseStats(fs3.stat(fileURLToPath6(params.url)))), undefined, "Node: fs.stat.");
function toStats(stat) {
  return {
    size: stat.size,
    mtimeMs: stat.mtimeMs,
    fileType: toFileType(stat)
  };
}
function toPromiseStats(pStat) {
  return pStat.then(toStats);
}
var handleRequestFsStatSync = RequestFsStatSync.createRequestHandler((req) => {
  const { params } = req;
  try {
    return createResponse(statSync22(fileURLToPath6(params.url)));
  } catch (e) {
    return createResponseFail(req, toError2(e));
  }
}, undefined, "Node: fs.stat.");
var handleRequestFsStatHttp = RequestFsStat.createRequestHandler((req, next) => {
  const { url } = req.params;
  if (!(url.protocol in supportedFetchProtocols))
    return next(req);
  return createResponse(getStatHttp(url));
}, undefined, "Node: http get stat");
var handleRequestFsWriteFile = RequestFsWriteFile.createRequestHandler(({ params }) => createResponse(writeFile(params, params.content)), undefined, "Node: fs.writeFile");
async function writeFile(fileRef, content) {
  const gz = isGZipped(content);
  const { url, encoding, baseFilename } = fileRef;
  const resultRef = { url, encoding, baseFilename, gz };
  await fs3.writeFile(fileURLToPath6(fileRef.url), encodeContent(fileRef, content));
  return resultRef;
}
var handleRequestFsWriteFileDataUrl = RequestFsWriteFile.createRequestHandler((req, next) => {
  const fileResource = req.params;
  const { url } = req.params;
  if (url.protocol !== "data:")
    return next(req);
  const gz = isGZipped(fileResource.content);
  const baseFilename = fileResource.baseFilename || "file.txt" + (gz ? ".gz" : "");
  const mt = guessMimeType(baseFilename);
  const mediaType = mt?.mimeType || "text/plain";
  const dataUrl = toDataUrl(fileResource.content, mediaType, [["filename", baseFilename]]);
  return createResponse(Promise.resolve({ url: dataUrl, baseFilename, gz, encoding: mt?.encoding }));
}, undefined, "Node: fs.writeFile DataUrl");
var handleRequestFsWriteFileGz = RequestFsWriteFile.createRequestHandler((req, next, dispatcher) => {
  const fileResource = req.params;
  if (!fileResource.gz && !isGzFile(fileResource.url) && (!fileResource.baseFilename || !isGzFile(fileResource.baseFilename))) {
    return next(req);
  }
  if (typeof fileResource.content !== "string" && isGZipped(fileResource.content)) {
    return next(req);
  }
  return createResponse(compressAndChainWriteRequest(dispatcher, fileResource, fileResource.content));
}, undefined, "Node: fs.writeFile compressed");
async function compressAndChainWriteRequest(dispatcher, fileRef, content) {
  const buf = await pGzip(encodeContent(fileRef, content));
  const res = dispatcher.dispatch(RequestFsWriteFile.create({ ...fileRef, content: buf }));
  assert10(isServiceResponseSuccess(res));
  return res.value;
}
function registerHandlers(serviceBus) {
  const handlers = [
    handleRequestFsReadFile,
    handleRequestFsReadFileSync,
    handleRequestFsWriteFile,
    handleRequestFsWriteFileDataUrl,
    handleRequestFsWriteFileGz,
    handleRequestFsReadFileHttp,
    handleRequestFsReadFileData,
    handleRequestFsReadFileSyncData,
    handleRequestFsReadDirectory,
    handleRequestZlibInflate,
    handleRequestFsStatSync,
    handleRequestFsStat,
    handleRequestFsStatHttp
  ];
  handlers.forEach((handler) => serviceBus.addHandler(handler));
}
function encodeContent(ref, content) {
  if (typeof content === "string") {
    if ([undefined, "utf8", "utf-8"].includes(ref.encoding))
      return content;
    return arrayBufferViewToBuffer(encodeString(content, ref.encoding));
  }
  return arrayBufferViewToBuffer(content);
}
function mapperDirentToDirEntry(dir) {
  return (dirent) => direntToDirEntry(dir, dirent);
}
function direntToDirEntries(dir, dirent) {
  return dirent.map(mapperDirentToDirEntry(dir));
}
function direntToDirEntry(dir, dirent) {
  return {
    name: dirent.name,
    dir,
    fileType: toFileType(dirent)
  };
}
function toFileType(statLike) {
  const t = statLike.isFile() ? 1 : statLike.isDirectory() ? 2 : 0;
  return statLike.isSymbolicLink() ? t | 64 : t;
}
var defaultCSpellIONode = undefined;
var CSpellIONode = class {
  constructor(serviceBus = new ServiceBus) {
    this.serviceBus = serviceBus;
    registerHandlers(serviceBus);
  }
  readFile(urlOrFilename, options) {
    const readOptions = toReadFileOptions(options);
    const ref = toFileResourceRequest(urlOrFilename, readOptions?.encoding, readOptions?.signal);
    const res = this.serviceBus.dispatch(RequestFsReadFile.create(ref));
    if (!isServiceResponseSuccess(res)) {
      throw genError(res.error, "readFile");
    }
    return res.value;
  }
  readDirectory(urlOrFilename) {
    const ref = toFileReference(urlOrFilename);
    const res = this.serviceBus.dispatch(RequestFsReadDirectory.create(ref));
    if (!isServiceResponseSuccess(res)) {
      throw genError(res.error, "readDirectory");
    }
    return res.value;
  }
  readFileSync(urlOrFilename, encoding) {
    const ref = toFileReference(urlOrFilename, encoding);
    const res = this.serviceBus.dispatch(RequestFsReadFileTextSync.create(ref));
    if (!isServiceResponseSuccess(res)) {
      throw genError(res.error, "readFileSync");
    }
    return res.value;
  }
  writeFile(urlOrFilename, content) {
    const ref = toFileReference(urlOrFilename);
    const fileResource = CFileResource.from(ref, content);
    const res = this.serviceBus.dispatch(RequestFsWriteFile.create(fileResource));
    if (!isServiceResponseSuccess(res)) {
      throw genError(res.error, "writeFile");
    }
    return res.value;
  }
  getStat(urlOrFilename) {
    const ref = toFileReference(urlOrFilename);
    const res = this.serviceBus.dispatch(RequestFsStat.create(ref));
    if (!isServiceResponseSuccess(res)) {
      throw genError(res.error, "getStat");
    }
    return res.value;
  }
  getStatSync(urlOrFilename) {
    const ref = toFileReference(urlOrFilename);
    const res = this.serviceBus.dispatch(RequestFsStatSync.create(ref));
    if (!isServiceResponseSuccess(res)) {
      throw genError(res.error, "getStatSync");
    }
    return res.value;
  }
  compareStats(left, right) {
    return compareStats(left, right);
  }
  toURL(urlOrFilename, relativeTo) {
    if (isFileReference(urlOrFilename))
      return urlOrFilename.url;
    return toURL(urlOrFilename, relativeTo);
  }
  toFileURL(urlOrFilename, relativeTo) {
    if (isFileReference(urlOrFilename))
      return urlOrFilename.url;
    return toFileURL(urlOrFilename, relativeTo);
  }
  urlBasename(urlOrFilename) {
    return urlBasename(this.toURL(urlOrFilename));
  }
  urlDirname(urlOrFilename) {
    return urlParent(this.toURL(urlOrFilename));
  }
};
function genError(err, alt) {
  return err || new ErrorNotImplemented(alt);
}
function getDefaultCSpellIO() {
  if (defaultCSpellIONode)
    return defaultCSpellIONode;
  const cspellIO = new CSpellIONode;
  defaultCSpellIONode = cspellIO;
  return cspellIO;
}
var debug = false;
async function findUpFromUrl(name, from, options) {
  const { type: entryType = "file", stopAt, fs: fs5 } = options;
  let dir = new URL(".", from);
  const root = new URL("/", dir);
  const predicate = makePredicate(fs5, name, entryType);
  const stopAtDir = stopAt || root;
  let last = "";
  while (dir.href !== last) {
    const found = await predicate(dir);
    if (found !== undefined)
      return found;
    last = dir.href;
    if (dir.href === root.href || dir.href === stopAtDir.href)
      break;
    dir = new URL("..", dir);
  }
  return;
}
function makePredicate(fs5, name, entryType) {
  if (typeof name === "function")
    return name;
  const checkStat = entryType === "file" || entryType === "!file" ? "isFile" : "isDirectory";
  const checkValue = entryType.startsWith("!") ? false : true;
  function checkName(dir, name2) {
    const f = new URL(name2, dir);
    return fs5.stat(f).then((stats) => (stats.isUnknown() || stats[checkStat]() === checkValue) && f || undefined).catch(() => {
      return;
    });
  }
  if (!Array.isArray(name))
    return (dir) => checkName(dir, name);
  return async (dir) => {
    const pending = name.map((n) => checkName(dir, n));
    for (const p of pending) {
      const found = await p;
      if (found)
        return found;
    }
    return;
  };
}
var CVFileSystem = class {
  #core;
  readFile;
  writeFile;
  stat;
  readDirectory;
  getCapabilities;
  constructor(core) {
    this.#core = core;
    this.readFile = this.#core.readFile.bind(this.#core);
    this.writeFile = this.#core.writeFile.bind(this.#core);
    this.stat = this.#core.stat.bind(this.#core);
    this.readDirectory = this.#core.readDirectory.bind(this.#core);
    this.getCapabilities = this.#core.getCapabilities.bind(this.#core);
  }
  get providerInfo() {
    return this.#core.providerInfo;
  }
  get hasProvider() {
    return this.#core.hasProvider;
  }
  findUp(name, from, options = {}) {
    const opts = { ...options, fs: this.#core };
    return findUpFromUrl(name, from, opts);
  }
};
function cspellIOToFsProvider(cspellIO) {
  const capabilities = 1 | 6 | 8;
  const capabilitiesHttp = capabilities & ~4 & ~8;
  const capMap = {
    "file:": capabilities,
    "http:": capabilitiesHttp,
    "https:": capabilitiesHttp
  };
  const name = "CSpellIO";
  const supportedProtocols = /* @__PURE__ */ new Set(["file:", "http:", "https:"]);
  const fs5 = {
    providerInfo: { name },
    stat: (url) => cspellIO.getStat(url),
    readFile: (url, options) => cspellIO.readFile(url, options),
    readDirectory: (url) => cspellIO.readDirectory(url),
    writeFile: (file) => cspellIO.writeFile(file.url, file.content),
    dispose: () => {
      return;
    },
    capabilities,
    getCapabilities(url) {
      return fsCapabilities(capMap[url.protocol] || 0);
    }
  };
  return {
    name,
    getFileSystem: (url, _next) => {
      return supportedProtocols.has(url.protocol) ? fs5 : undefined;
    }
  };
}
function wrapError(e) {
  if (e instanceof VFSError)
    return e;
  return e;
}
var VFSError = class extends Error {
  constructor(message, options) {
    super(message, options);
  }
};
var VFSErrorUnsupportedRequest = class extends VFSError {
  constructor(request, url, parameters) {
    super(`Unsupported request: ${request}`);
    this.request = request;
    this.parameters = parameters;
    this.url = url?.toString();
  }
  url;
};
var CFsCapabilities = class {
  constructor(flags) {
    this.flags = flags;
  }
  get readFile() {
    return !!(this.flags & 2);
  }
  get writeFile() {
    return !!(this.flags & 4);
  }
  get readDirectory() {
    return !!(this.flags & 8);
  }
  get writeDirectory() {
    return !!(this.flags & 16);
  }
  get stat() {
    return !!(this.flags & 1);
  }
};
function fsCapabilities(flags) {
  return new CFsCapabilities(flags);
}
var WrappedProviderFs = class _WrappedProviderFs {
  constructor(fs5, eventLogger) {
    this.fs = fs5;
    this.eventLogger = eventLogger;
    this.hasProvider = !!fs5;
    this.capabilities = fs5?.capabilities || 0;
    this._capabilities = fsCapabilities(this.capabilities);
    this.providerInfo = fs5?.providerInfo || { name: "unknown" };
  }
  hasProvider;
  capabilities;
  providerInfo;
  _capabilities;
  logEvent(method, event, traceID, url, message) {
    this.eventLogger({ method, event, url, traceID, ts: performance.now(), message });
  }
  getCapabilities(url) {
    if (this.fs?.getCapabilities)
      return this.fs.getCapabilities(url);
    return this._capabilities;
  }
  async stat(urlRef) {
    const traceID = performance.now();
    const url = urlOrReferenceToUrl(urlRef);
    this.logEvent("stat", "start", traceID, url);
    try {
      checkCapabilityOrThrow(this.fs, this.capabilities, 1, "stat", url);
      return new CVfsStat(await this.fs.stat(urlRef));
    } catch (e) {
      this.logEvent("stat", "error", traceID, url, e instanceof Error ? e.message : "");
      throw wrapError(e);
    } finally {
      this.logEvent("stat", "end", traceID, url);
    }
  }
  async readFile(urlRef, optionsOrEncoding) {
    const traceID = performance.now();
    const url = urlOrReferenceToUrl(urlRef);
    this.logEvent("readFile", "start", traceID, url);
    try {
      checkCapabilityOrThrow(this.fs, this.capabilities, 2, "readFile", url);
      const readOptions = toOptions(optionsOrEncoding);
      return fromFileResource(await this.fs.readFile(urlRef, readOptions), readOptions?.encoding);
    } catch (e) {
      this.logEvent("readFile", "error", traceID, url, e instanceof Error ? e.message : "");
      throw wrapError(e);
    } finally {
      this.logEvent("readFile", "end", traceID, url);
    }
  }
  async readDirectory(url) {
    const traceID = performance.now();
    this.logEvent("readDir", "start", traceID, url);
    try {
      checkCapabilityOrThrow(this.fs, this.capabilities, 8, "readDirectory", url);
      return (await this.fs.readDirectory(url)).map((e) => new CVfsDirEntry(e));
    } catch (e) {
      this.logEvent("readDir", "error", traceID, url, e instanceof Error ? e.message : "");
      throw wrapError(e);
    } finally {
      this.logEvent("readDir", "end", traceID, url);
    }
  }
  async writeFile(file) {
    const traceID = performance.now();
    const url = file.url;
    this.logEvent("writeFile", "start", traceID, url);
    try {
      checkCapabilityOrThrow(this.fs, this.capabilities, 4, "writeFile", file.url);
      return await this.fs.writeFile(file);
    } catch (e) {
      this.logEvent("writeFile", "error", traceID, url, e instanceof Error ? e.message : "");
      throw wrapError(e);
    } finally {
      this.logEvent("writeFile", "end", traceID, url);
    }
  }
  static disposeOf(fs5) {
    fs5 instanceof _WrappedProviderFs && fs5.fs?.dispose();
  }
};
function checkCapabilityOrThrow(fs5, capabilities, flag, name, url) {
  if (!(capabilities & flag)) {
    throw new VFSErrorUnsupportedRequest(name, url);
  }
}
var CFileType = class {
  constructor(fileType) {
    this.fileType = fileType;
  }
  isFile() {
    return this.fileType === 1;
  }
  isDirectory() {
    return this.fileType === 2;
  }
  isUnknown() {
    return !this.fileType;
  }
  isSymbolicLink() {
    return !!(this.fileType & 64);
  }
};
var CVfsStat = class extends CFileType {
  constructor(stat) {
    super(stat.fileType || 0);
    this.stat = stat;
  }
  get size() {
    return this.stat.size;
  }
  get mtimeMs() {
    return this.stat.mtimeMs;
  }
  get eTag() {
    return this.stat.eTag;
  }
};
var CVfsDirEntry = class extends CFileType {
  constructor(entry) {
    super(entry.fileType);
    this.entry = entry;
  }
  _url;
  get name() {
    return this.entry.name;
  }
  get dir() {
    return this.entry.dir;
  }
  get url() {
    if (this._url)
      return this._url;
    this._url = new URL(this.entry.name, this.entry.dir);
    return this._url;
  }
  toJSON() {
    return {
      name: this.name,
      dir: this.dir,
      fileType: this.fileType
    };
  }
};
function chopUrl(url) {
  if (!url)
    return "";
  const href = url.href;
  const parts = href.split("/");
  const n = parts.indexOf("node_modules");
  if (n > 0) {
    const tail = parts.slice(Math.max(parts.length - 3, n + 1));
    return parts.slice(0, n + 1).join("/") + "//" + tail.join("/");
  }
  return href;
}
function rPad(str, len, ch = " ") {
  return str.padEnd(len, ch);
}
function toOptions(val) {
  return typeof val === "string" ? { encoding: val } : val;
}
var CVirtualFS = class {
  providers = /* @__PURE__ */ new Set;
  cachedFs = /* @__PURE__ */ new Map;
  revCacheFs = /* @__PURE__ */ new Map;
  fsc;
  fs;
  loggingEnabled = debug;
  constructor() {
    this.fsc = fsPassThroughCore((url) => this._getFS(url));
    this.fs = new CVFileSystem(this.fsc);
  }
  enableLogging(value) {
    this.loggingEnabled = value ?? true;
  }
  log = console.log;
  logEvent = (event) => {
    if (this.loggingEnabled) {
      const id = event.traceID.toFixed(13).replaceAll(/\d{4}(?=\d)/g, "$&.");
      const msg = event.message ? `
\t\t${event.message}` : "";
      const method = rPad(`${event.method}-${event.event}`, 16);
      this.log(`${method} ID:${id} ts:${event.ts.toFixed(13)} ${chopUrl(event.url)}${msg}`);
    }
  };
  registerFileSystemProvider(...providers) {
    providers.forEach((provider) => this.providers.add(provider));
    this.reset();
    return {
      dispose: () => {
        for (const provider of providers) {
          for (const key of this.revCacheFs.get(provider) || []) {
            this.cachedFs.delete(key);
          }
          this.providers.delete(provider);
        }
        this.reset();
      }
    };
  }
  getFS(url) {
    return new CVFileSystem(this._getFS(url));
  }
  _getFS(url) {
    const key = `${url.protocol}${url.hostname}`;
    const cached = this.cachedFs.get(key);
    if (cached) {
      return cached;
    }
    const fnNext = (provider, next2) => {
      return (url2) => {
        let calledNext = false;
        const fs6 = provider.getFileSystem(url2, (_url) => {
          calledNext = calledNext || url2 === _url;
          return next2(_url);
        });
        if (fs6) {
          const s = this.revCacheFs.get(provider) || /* @__PURE__ */ new Set;
          s.add(key);
          this.revCacheFs.set(provider, s);
          return fs6;
        }
        if (!calledNext) {
          return next2(url2);
        }
        return;
      };
    };
    let next = (_url) => {
      return;
    };
    for (const provider of this.providers) {
      next = fnNext(provider, next);
    }
    const fs5 = new WrappedProviderFs(next(url), this.logEvent);
    this.cachedFs.set(key, fs5);
    return fs5;
  }
  reset() {
    this.disposeOfCachedFs();
  }
  disposeOfCachedFs() {
    for (const [key, fs5] of [...this.cachedFs].reverse()) {
      try {
        WrappedProviderFs.disposeOf(fs5);
      } catch {
      }
      this.cachedFs.delete(key);
    }
    this.cachedFs.clear();
    this.revCacheFs.clear();
  }
  dispose() {
    this.disposeOfCachedFs();
    const providers = [...this.providers].reverse();
    for (const provider of providers) {
      try {
        provider.dispose?.();
      } catch {
      }
    }
  }
};
function fsPassThroughCore(fs5) {
  function gfs(ur, name) {
    const url = urlOrReferenceToUrl(ur);
    const f = fs5(url);
    if (!f.hasProvider)
      throw new VFSErrorUnsupportedRequest(name, url, ur instanceof URL ? undefined : { url: ur.url.toString(), encoding: ur.encoding });
    return f;
  }
  return {
    providerInfo: { name: "default" },
    hasProvider: true,
    stat: async (url) => gfs(url, "stat").stat(url),
    readFile: async (url, options) => gfs(url, "readFile").readFile(url, options),
    writeFile: async (file) => gfs(file, "writeFile").writeFile(file),
    readDirectory: async (url) => gfs(url, "readDirectory").readDirectory(url).then((entries) => entries.map((e) => new CVfsDirEntry(e))),
    getCapabilities: (url) => gfs(url, "getCapabilities").getCapabilities(url)
  };
}
function createVirtualFS(cspellIO) {
  const cspell = cspellIO || getDefaultCSpellIO();
  const vfs = new CVirtualFS;
  vfs.registerFileSystemProvider(cspellIOToFsProvider(cspell));
  return vfs;
}
var defaultVirtualFs = undefined;
function getDefaultVirtualFs() {
  if (!defaultVirtualFs) {
    defaultVirtualFs = createVirtualFS();
  }
  return defaultVirtualFs;
}
var pipeline2 = promisify2(Stream.pipeline);

// node_modules/cspell-lib/dist/lib/fileSystem.js
function getVirtualFS() {
  return getDefaultVirtualFs();
}
function getFileSystem() {
  return getVirtualFS().fs;
}

// node_modules/cspell-lib/dist/lib/pkg-info.mjs
import { fileURLToPath as fileURLToPath7 } from "node:url";
var __dirname = "D:\\cspell-lsp\\node_modules\\cspell-lib\\dist\\lib";
var url = import.meta.url;
function calcSrcDirectory() {
  try {
    return __dirname;
  } catch {
    return url ? fileURLToPath7(new URL("./", url)) : process.cwd();
  }
}
var srcDirectory = calcSrcDirectory();

// node_modules/cspell-lib/dist/lib/util/templates.js
function replaceTemplate(template, replacements) {
  const templateStart = "${";
  const tLen = templateStart.length;
  const templateEnd = "}";
  const parts = [];
  let lastPos = 0;
  let p = template.indexOf(templateStart, lastPos);
  if (p < 0)
    return template;
  while (p >= 0) {
    parts.push(template.substring(lastPos, p));
    lastPos = p;
    const end = template.indexOf(templateEnd, p);
    if (end < 0)
      break;
    const name = template.substring(p + tLen, end);
    if (name in replacements) {
      parts.push(replacements[name] || "");
    } else {
      parts.push(template.substring(p, end + 1));
    }
    lastPos = end + 1;
    p = template.indexOf(templateStart, lastPos);
  }
  parts.push(template.substring(lastPos));
  return parts.join("");
}
function envToTemplateVars(env) {
  const vars = {};
  for (const [key, value] of Object.entries(env)) {
    vars[`env:${key}`] = value || "";
  }
  return vars;
}

// node_modules/cspell-lib/dist/lib/util/url.js
function getSourceDirectoryUrl() {
  const srcDirectoryURL = toFileDirURL(srcDirectory);
  return srcDirectoryURL;
}
function cwdURL() {
  return toFileDirURL("./");
}
function toFileUrl(file) {
  return toFileURL(file, cwdURL());
}
function fileURLOrPathToPath(filenameOrURL) {
  return toFilePathOrHref(filenameOrURL);
}
var regExpWindowsPathDriveLetter2 = /^([a-zA-Z]):[\\]/;
function windowsDriveLetterToUpper(absoluteFilePath) {
  return absoluteFilePath.replace(regExpWindowsPathDriveLetter2, (s) => s.toUpperCase());
}

// node_modules/cspell-lib/dist/lib/util/resolveFile.js
var regExpStartsWidthNodeModules = /^node_modules[/\\]/;
var debugMode = false;

class FileResolver {
  fs;
  templateReplacements;
  constructor(fs4, templateReplacements) {
    this.fs = fs4;
    this.templateReplacements = templateReplacements;
  }
  async resolveFile(filename, relativeTo) {
    if (filename instanceof URL) {
      return {
        filename: toFilePathOrHref(filename),
        relativeTo: relativeTo.toString(),
        found: await this.doesExist(filename),
        method: "url"
      };
    }
    const result = await this._resolveFile(filename, relativeTo);
    const match = filename.match(regExpStartsWidthNodeModules);
    if (match) {
      result.warning ??= `Import of '${filename}' should not start with '${match[0]}' in '${toFilePathOrHref(relativeTo)}'. Use '${filename.replace(regExpStartsWidthNodeModules, "")}' or a relative path instead.`;
    }
    return result;
  }
  async _resolveFile(filename, relativeTo) {
    filename = patchFilename(filename, this.templateReplacements);
    const steps = [
      { filename, fn: this.tryUrlRel },
      { filename, fn: this.tryCreateRequire },
      { filename, fn: this.tryNodeRequireResolve },
      { filename, fn: this.tryImportResolve },
      { filename, fn: this.tryResolveExists },
      { filename, fn: this.tryNodeResolveDefaultPaths },
      { filename, fn: this.tryResolveFrom },
      { filename, fn: this.tryResolveGlobal },
      { filename, fn: this.tryLegacyResolve }
    ];
    for (const step of steps) {
      const r = await step.fn(step.filename, relativeTo);
      if (r?.found)
        return r;
    }
    const result = await this.tryUrl(filename, relativeTo) || {
      filename: isRelative(filename) ? joinWith(filename, relativeTo) : filename.toString(),
      relativeTo: relativeTo.toString(),
      found: false,
      method: "not found"
    };
    return result;
  }
  async doesExist(file) {
    try {
      const s = await this.fs.stat(file);
      return s.isFile() || s.isUnknown();
    } catch {
      return false;
    }
  }
  tryUrlRel = async (filename, relativeToURL) => {
    if (isUrlLike(filename)) {
      const fileURL = toURL(filename);
      return {
        filename: toFilePathOrHref(fileURL),
        relativeTo: undefined,
        found: await this.doesExist(fileURL),
        method: "tryUrl"
      };
    }
    if (isRelative(filename) && isUrlLike(relativeToURL) && !isDataURL(relativeToURL)) {
      const relToURL = toURL(relativeToURL);
      const url2 = toFileURL(filename, relToURL);
      return {
        filename: toFilePathOrHref(url2),
        relativeTo: toFilePathOrHref(relToURL),
        found: await this.doesExist(url2),
        method: "tryUrl"
      };
    }
    return;
  };
  tryUrl = async (filename, relativeToURL) => {
    if (isUrlLike(relativeToURL) && !isDataURL(relativeToURL)) {
      const relToURL = toURL(relativeToURL);
      const url2 = toFileURL(filename, relToURL);
      return {
        filename: toFilePathOrHref(url2),
        relativeTo: toFilePathOrHref(relToURL),
        found: await this.doesExist(url2),
        method: "tryUrl"
      };
    }
    return;
  };
  tryCreateRequire = (filename, relativeTo) => {
    if (filename instanceof URL)
      return;
    const rel = !isUrlLike(relativeTo) || isFileURL(relativeTo) ? relativeTo : toFileDirURL("./");
    try {
      const require2 = createRequire2(rel);
      const r = require2.resolve(filename);
      return { filename: r, relativeTo: rel.toString(), found: true, method: "tryCreateRequire" };
    } catch (error) {
      if (debugMode) {
        console.error("Error in tryCreateRequire: %o", { filename, rel, relativeTo, error: `${error}` });
      }
      return;
    }
  };
  tryNodeResolveDefaultPaths = (filename) => {
    try {
      const r = __require.resolve(filename);
      return { filename: r, relativeTo: undefined, found: true, method: "tryNodeResolveDefaultPaths" };
    } catch {
      return;
    }
  };
  tryNodeRequireResolve = (filenameOrURL, relativeTo) => {
    if (isUrlLike(relativeTo) && !isFileURL(relativeTo))
      return;
    const filename = fileURLOrPathToPath(filenameOrURL);
    const relativeToPath = pathFromRelativeTo(relativeTo);
    const home = os2.homedir();
    function calcPaths(p) {
      const paths2 = [p];
      if (isRelative(filename)) {
        return paths2;
      }
      for (;p && path4.dirname(p) !== p && p !== home; p = path4.dirname(p)) {
        paths2.push(p);
      }
      return paths2;
    }
    const paths = calcPaths(path4.resolve(relativeToPath));
    try {
      const r = __require.resolve(filename, { paths });
      return { filename: r, relativeTo: relativeToPath, found: true, method: "tryNodeRequireResolve" };
    } catch {
      return;
    }
  };
  tryImportResolve = (filename, relativeTo) => {
    try {
      const paths = isRelative(filename) ? [relativeTo] : [relativeTo, srcDirectory];
      const resolved = fileURLToPath8(importResolveModuleName(filename, paths));
      return { filename: resolved, relativeTo: relativeTo.toString(), found: true, method: "tryImportResolve" };
    } catch {
      return;
    }
  };
  tryResolveGlobal = (filename) => {
    const r = resolveGlobal(filename);
    return r && { filename: r, relativeTo: undefined, found: true, method: "tryResolveGlobal" } || undefined;
  };
  tryResolveExists = async (filename, relativeTo) => {
    if (filename instanceof URL || isUrlLike(filename) || isUrlLike(relativeTo) && !isFileURL(relativeTo)) {
      return;
    }
    relativeTo = pathFromRelativeTo(relativeTo);
    const toTry = [{ filename }, { filename: path4.resolve(relativeTo, filename), relativeTo }];
    for (const { filename: filename2, relativeTo: relativeTo2 } of toTry) {
      const found = path4.isAbsolute(filename2) && await this.doesExist(toFileUrl(filename2));
      if (found)
        return { filename: filename2, relativeTo: relativeTo2?.toString(), found, method: "tryResolveExists" };
    }
    filename = path4.resolve(filename);
    return {
      filename,
      relativeTo: path4.resolve("."),
      found: await this.doesExist(toFileUrl(filename)),
      method: "tryResolveExists"
    };
  };
  tryResolveFrom = (filename, relativeTo) => {
    if (relativeTo instanceof URL)
      return;
    try {
      return {
        filename: import_resolve_from.default(pathFromRelativeTo(relativeTo), filename),
        relativeTo,
        found: true,
        method: "tryResolveFrom"
      };
    } catch {
      return;
    }
  };
  tryLegacyResolve = (filename, relativeTo) => {
    if (filename instanceof URL || isUrlLike(filename) || isUrlLike(relativeTo) && !isFileURL(relativeTo)) {
      return;
    }
    const relativeToPath = isUrlLike(relativeTo) ? fileURLToPath8(new URL("./", relativeTo)) : relativeTo.toString();
    const match = filename.match(regExpStartsWidthNodeModules);
    if (match) {
      const fixedFilename = filename.replace(regExpStartsWidthNodeModules, "");
      const found = this.tryImportResolve(fixedFilename, relativeToPath) || this.tryResolveFrom(fixedFilename, relativeToPath);
      if (found?.found) {
        found.method = "tryLegacyResolve";
        return found;
      }
    }
    return;
  };
}
function patchFilename(filename, templateReplacements) {
  const defaultReplacements = {
    cwd: process.cwd(),
    pathSeparator: path4.sep,
    userHome: os2.homedir()
  };
  filename = filename.replace(/^~(?=[/\\])/, defaultReplacements.userHome);
  filename = replaceTemplate(filename, { ...defaultReplacements, ...templateReplacements });
  return filename;
}
function resolveRelativeTo(filename, relativeTo, templateReplacements = envToTemplateVars(process.env)) {
  if (filename instanceof URL)
    return filename;
  filename = patchFilename(filename, templateReplacements);
  const relativeToUrl = toFileUrl(relativeTo);
  return toFileURL(filename, relativeToUrl);
}
function isRelative(filename) {
  if (filename instanceof URL)
    return false;
  if (isUrlLike(filename))
    return false;
  if (filename.startsWith("./"))
    return true;
  if (filename.startsWith("../"))
    return true;
  if (filename.startsWith("." + path4.sep))
    return true;
  if (filename.startsWith(".." + path4.sep))
    return true;
  return false;
}
function joinWith(filename, relativeTo) {
  return relativeTo instanceof URL || isUrlLike(relativeTo) ? toFilePathOrHref(new URL(filename, relativeTo)) : path4.resolve(relativeTo, filename);
}
function pathFromRelativeTo(relativeTo) {
  return relativeTo instanceof URL || isUrlLike(relativeTo) ? fileURLToPath8(new URL("./", relativeTo)) : relativeTo;
}
var loaderCache = new WeakMap;
function createFileResolver(fs4, templateVariables = envToTemplateVars(process.env)) {
  let loader = loaderCache.get(fs4);
  if (!loader) {
    loader = new FileResolver(fs4, templateVariables);
    loaderCache.set(fs4, loader);
  }
  return loader;
}
async function resolveFile(filename, relativeTo, fs4 = getFileSystem()) {
  const resolver = createFileResolver(fs4);
  return resolver.resolveFile(filename, relativeTo);
}

// node_modules/cspell-lib/dist/lib/Settings/DictionaryReferenceCollection.js
function createDictionaryReferenceCollection(dictionaries) {
  return new _DictionaryReferenceCollection(dictionaries);
}

class _DictionaryReferenceCollection {
  dictionaries;
  collection;
  constructor(dictionaries) {
    this.dictionaries = dictionaries;
    this.collection = collect(dictionaries);
  }
  isEnabled(name) {
    const entry = this.collection[name];
    return entry === undefined ? undefined : !!(entry & 1);
  }
  isBlocked(name) {
    const entry = this.collection[name];
    return entry === undefined ? undefined : !(entry & 1);
  }
  enabled() {
    return this.dictionaryIds.filter((n) => this.isEnabled(n));
  }
  blocked() {
    return this.dictionaryIds.filter((n) => this.isBlocked(n));
  }
  get dictionaryIds() {
    return Object.keys(this.collection);
  }
}
function collect(dictionaries) {
  const refs = dictionaries.map(normalizeName).map(mapReference);
  const col = {};
  for (const ref of refs) {
    col[ref.name] = Math.max(ref.weight, col[ref.name] || 0);
  }
  return col;
}
function normalizeName(entry) {
  return entry.normalize().trim();
}
function mapReference(ref) {
  const name = ref.replace(/^!+/, "");
  const weight = ref.length - name.length + 1;
  return { name: name.trim(), weight };
}

// node_modules/cspell-lib/dist/lib/Settings/DictionarySettings.js
function filterDictDefsToLoad(dictRefCol, defs) {
  const allActiveDefs = defs.filter(({ name }) => dictRefCol.isEnabled(name)).map(fixPath);
  return [...new Map(allActiveDefs.map((d) => [d.name, d])).values()];
}
function fixPath(def) {
  if (def instanceof _DictionaryDefinitionInternalWithSource) {
    return def;
  }
  const newPath = fixDicPath(def.path, def.file);
  return {
    ...def,
    file: undefined,
    path: newPath
  };
}
function fixDicPath(defPath, defFile) {
  const parts = [defPath || "", defFile || ""].filter((p) => !!p);
  return parts.length > 1 ? path5.join(...parts) : parts[0] || "";
}
function mapDictDefsToInternal(defs, pathToSettingsFile) {
  return defs?.map((def) => mapDictDefToInternal(def, pathToSettingsFile));
}
var internalDefs = createAutoResolveWeakWeakCache();
function mapDictDefToInternal(def, pathToSettingsFile) {
  return internalDefs.get(def, (def2) => _mapDictDefToInternal(def2, pathToSettingsFile));
}
function _mapDictDefToInternal(def, pathToSettingsFile) {
  if (isDictionaryDefinitionWithSource(def)) {
    return def;
  }
  const source = pathToSettingsFile.href;
  if (isDictionaryDefinitionInlineInternal(def)) {
    return { ...def, __source: source };
  }
  return new _DictionaryDefinitionInternalWithSource(def, pathToSettingsFile);
}
function determineName(filename, options) {
  return options.name || path5.basename(filename);
}
function calcDictionaryDefsToLoad(settings) {
  const { dictionaries = [], dictionaryDefinitions = [], noSuggestDictionaries = [] } = settings;
  const colNoSug = createDictionaryReferenceCollection(noSuggestDictionaries);
  const colDicts = createDictionaryReferenceCollection([...dictionaries, ...colNoSug.enabled()]);
  const modDefs = dictionaryDefinitions.map((def) => {
    const enabled = colNoSug.isEnabled(def.name);
    if (enabled === undefined)
      return def;
    return { ...def, noSuggest: enabled };
  });
  return filterDictDefsToLoad(colDicts, modDefs);
}
function isDictionaryDefinitionWithSource(d) {
  return isDictionaryFileDefinitionInternalWithSource(d) || isDictionaryDefinitionInlineInternalWithSource(d);
}
function isDictionaryFileDefinitionInternalWithSource(def) {
  return def instanceof _DictionaryDefinitionInternalWithSource;
}
function isDictionaryDefinitionInlineInternalWithSource(def) {
  return isDictionaryDefinitionInlineInternal(def) && !!def.__source;
}

class _DictionaryDefinitionInternalWithSource {
  sourceURL;
  _weightMap;
  name;
  path;
  addWords;
  description;
  dictionaryInformation;
  type;
  file;
  repMap;
  useCompounds;
  noSuggest;
  scope;
  __source;
  ddi;
  constructor(def, sourceURL) {
    this.sourceURL = sourceURL;
    this.__source = sourceURL.href;
    const defAll = def;
    const { path: relPath = "", file = "", addWords, description, dictionaryInformation, type, repMap, noSuggest, scope, useCompounds } = defAll;
    const defaultPath = sourceURL;
    const filePath = fixDicPath(relPath, file);
    const name = determineName(filePath, def);
    const resolvedPath = toFilePathOrHref(resolveRelativeTo(filePath, defaultPath));
    const ddi = {
      name,
      file: undefined,
      path: resolvedPath,
      addWords,
      description,
      dictionaryInformation,
      type,
      repMap,
      noSuggest,
      scope,
      useCompounds
    };
    Object.assign(this, clean5(ddi));
    this.ddi = ddi;
    this.name = ddi.name;
    this.file = ddi.file;
    this.path = ddi.path;
    this._weightMap = this.dictionaryInformation ? mapDictionaryInformationToWeightMap(this.dictionaryInformation) : undefined;
  }
  get weightMap() {
    return this._weightMap;
  }
  toJSON() {
    return this.ddi;
  }
}

// node_modules/@cspell/strong-weak-map/dist/esm/StrongWeakMap.js
class StrongWeakMap {
  map;
  constructor(init) {
    this.map = new Map(init?.map(([k, v]) => [k, new WeakRef(v)]));
  }
  clear() {
    this.map.clear();
  }
  delete(key) {
    return this.map.delete(key);
  }
  forEach(callbackfn, thisArg) {
    if (thisArg) {
      callbackfn = callbackfn.bind(thisArg);
    }
    for (const [key, value] of this) {
      callbackfn(value, key, this);
    }
  }
  get(key) {
    const ref = this.map.get(key);
    if (!ref)
      return;
    const value = ref.deref();
    if (!value) {
      this.map.delete(key);
      return;
    }
    return value;
  }
  autoGet(key, resolver) {
    const found = this.get(key);
    if (found)
      return found;
    const created = resolver(key);
    this.set(key, created);
    return created;
  }
  has(key) {
    const value = this.get(key);
    return !!value;
  }
  set(key, value) {
    this.map.set(key, new WeakRef(value));
    return this;
  }
  get size() {
    return this.map.size;
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  *entries() {
    for (const key of this.map.keys()) {
      const value = this.get(key);
      if (!value)
        continue;
      yield [key, value];
    }
  }
  keys() {
    return this.map.keys();
  }
  *values() {
    for (const [_, value] of this) {
      yield value;
    }
  }
  cleanKeys() {
    const keysToDel = [];
    for (const [key, ref] of this.map.entries()) {
      if (!ref.deref()) {
        keysToDel.push(key);
      }
    }
    for (const key of keysToDel) {
      this.map.delete(key);
    }
    return this;
  }
  [Symbol.toStringTag] = "StrongWeakMap";
}
// node_modules/cspell-lib/dist/lib/util/simpleCache.js
class SimpleWeakCache2 {
  size;
  L0 = new WeakMap;
  L1 = new WeakMap;
  L2 = new WeakMap;
  sizeL0 = 0;
  constructor(size) {
    this.size = size;
  }
  has(key) {
    for (const c of this.caches()) {
      if (c.has(key))
        return true;
    }
    return false;
  }
  get(key) {
    for (const c of this.caches()) {
      const entry = c.get(key);
      if (entry) {
        if (c !== this.L0) {
          this._set(key, entry);
        }
        return entry.v;
      }
    }
    return;
  }
  set(key, value) {
    this._set(key, { v: value });
  }
  _set(key, entry) {
    if (this.L0.has(key)) {
      this.L0.set(key, entry);
      return this;
    }
    if (this.sizeL0 >= this.size) {
      this.rotate();
    }
    this.sizeL0 += 1;
    this.L0.set(key, entry);
  }
  caches() {
    return [this.L0, this.L1, this.L2];
  }
  rotate() {
    this.L2 = this.L1;
    this.L1 = this.L0;
    this.L0 = new WeakMap;
    this.sizeL0 = 0;
  }
}
class SimpleCache2 {
  size;
  L0 = new Map;
  L1 = new Map;
  L2 = new Map;
  constructor(size) {
    this.size = size;
  }
  has(key) {
    for (const c of this.caches()) {
      if (c.has(key))
        return true;
    }
    return false;
  }
  get(key) {
    for (const c of this.caches()) {
      const entry = c.get(key);
      if (entry) {
        if (c !== this.L0) {
          this._set(key, entry);
        }
        return entry.v;
      }
    }
    return;
  }
  set(key, value) {
    this._set(key, { v: value });
  }
  delete(key) {
    let deleted = false;
    for (const c of this.caches()) {
      deleted = c.delete(key) || deleted;
    }
    return deleted;
  }
  _set(key, entry) {
    if (this.L0.has(key)) {
      this.L0.set(key, entry);
      return this;
    }
    if (this.L0.size >= this.size) {
      this.rotate();
    }
    this.L0.set(key, entry);
  }
  caches() {
    return [this.L0, this.L1, this.L2];
  }
  rotate() {
    const L2 = this.L2;
    this.L2 = this.L1;
    this.L1 = this.L0;
    this.L0 = L2;
    this.L0.clear();
  }
}

class AutoCache extends SimpleCache2 {
  factory;
  constructor(factory, size) {
    super(size);
    this.factory = factory;
  }
  get(key) {
    const v = super.get(key);
    if (v !== undefined)
      return v;
    const val = this.factory(key);
    this.set(key, val);
    return val;
  }
}

// node_modules/cspell-lib/dist/lib/SpellingDictionary/SpellingDictionaryError.js
class SpellingDictionaryLoadError extends Error {
  uri;
  options;
  cause;
  name;
  constructor(uri, options, cause, message) {
    super(message);
    this.uri = uri;
    this.options = options;
    this.cause = cause;
    this.name = options.name;
  }
}

// node_modules/cspell-lib/dist/lib/SpellingDictionary/DictionaryController/DictionaryLoader.js
var MAX_AGE = 1e4;
var loaders = {
  S: loadSimpleWordList,
  C: legacyWordList,
  W: wordsPerLineWordList,
  T: loadTrie,
  default: loadSimpleWordList
};
var LoadingState;
(function(LoadingState2) {
  LoadingState2[LoadingState2["Loaded"] = 0] = "Loaded";
  LoadingState2[LoadingState2["Loading"] = 1] = "Loading";
})(LoadingState || (LoadingState = {}));

class DictionaryLoader {
  fs;
  dictionaryCache = new StrongWeakMap;
  inlineDictionaryCache = new AutoResolveWeakCache2;
  dictionaryCacheByDef = new AutoResolveWeakWeakCache;
  reader;
  keepAliveCache;
  constructor(fs4, keepAliveSize = 10) {
    this.fs = fs4;
    this.reader = toReader(fs4);
    this.keepAliveCache = new SimpleCache2(keepAliveSize);
  }
  loadDictionary(def) {
    if (isDictionaryDefinitionInlineInternal(def)) {
      return Promise.resolve(this.loadInlineDict(def));
    }
    const { key, entry } = this.getCacheEntry(def);
    if (entry) {
      return entry.pending.then(([dictionary]) => dictionary);
    }
    const loadedEntry = this.loadEntry(def.path, def);
    this.setCacheEntry(key, loadedEntry, def);
    this.keepAliveCache.set(def, loadedEntry);
    return loadedEntry.pending.then(([dictionary]) => dictionary);
  }
  async refreshCacheEntries(maxAge = MAX_AGE, now = Date.now()) {
    await Promise.all([...this.dictionaryCache.values()].map((entry) => this.refreshEntry(entry, maxAge, now)));
  }
  getCacheEntry(def) {
    const defEntry = this.dictionaryCacheByDef.get(def);
    if (defEntry) {
      this.keepAliveCache.get(def);
      return defEntry;
    }
    const key = this.calcKey(def);
    const entry = this.dictionaryCache.get(key);
    if (entry) {
      entry.options = def;
      this.keepAliveCache.set(def, entry);
    }
    return { key, entry };
  }
  setCacheEntry(key, entry, def) {
    this.dictionaryCache.set(key, entry);
    this.dictionaryCacheByDef.set(def, { key, entry });
  }
  async refreshEntry(entry, maxAge, now) {
    if (now - entry.ts >= maxAge) {
      const sig = now + Math.random();
      entry.sig = sig;
      entry.ts = now;
      const pStat = this.getStat(entry.uri);
      const [newStat] = await Promise.all([pStat, entry.pending]);
      const hasChanged = !this.isEqual(newStat, entry.stat);
      const sigMatches = entry.sig === sig;
      if (sigMatches && hasChanged) {
        entry.loadingState = LoadingState.Loading;
        const key = this.calcKey(entry.options);
        const newEntry = this.loadEntry(entry.uri, entry.options);
        this.dictionaryCache.set(key, newEntry);
        this.dictionaryCacheByDef.set(entry.options, { key, entry: newEntry });
      }
    }
  }
  loadEntry(fileOrUri, options, now = Date.now()) {
    const url2 = toFileURL(fileOrUri);
    options = this.normalizeOptions(url2, options);
    const pDictionary = load(this.reader, toFileURL(fileOrUri), options).catch((e) => createFailedToLoadDictionary(options.name, fileOrUri, new SpellingDictionaryLoadError(url2.href, options, e, "failed to load"), options));
    const pStat = this.getStat(fileOrUri);
    const pending = Promise.all([pDictionary, pStat]);
    const sig = now + Math.random();
    const entry = {
      uri: url2.href,
      options,
      ts: now,
      stat: undefined,
      dictionary: undefined,
      pending,
      loadingState: LoadingState.Loading,
      sig
    };
    pending.then(([dictionary, stat]) => {
      entry.stat = stat;
      entry.dictionary = dictionary;
      entry.loadingState = LoadingState.Loaded;
      return;
    }).catch(() => {
      return;
    });
    return entry;
  }
  getStat(uri) {
    return this.fs.stat(toFileURL(uri)).catch(toError);
  }
  isEqual(a, b) {
    if (!b)
      return false;
    if (isError3(a)) {
      return isError3(b) && a.message === b.message && a.name === b.name;
    }
    return !isError3(b) && !compareStats(a, b);
  }
  normalizeOptions(uri, options) {
    if (options.name)
      return options;
    return { ...options, name: urlBasename(uri) };
  }
  loadInlineDict(def) {
    return this.inlineDictionaryCache.get(def, (def2) => createInlineSpellingDictionary(def2, def2.__source || "memory"));
  }
  calcKey(def) {
    const path6 = def.path;
    const loaderType = determineType(toFileURL(path6), def);
    const optValues = importantOptionKeys.map((k) => def[k]?.toString() || "");
    const parts = [path6, loaderType, ...optValues];
    return parts.join("|");
  }
}
function toReader(fs4) {
  async function readFile(url2) {
    return (await fs4.readFile(url2)).getText();
  }
  return {
    read: readFile,
    readLines: async (filename) => toLines(await readFile(filename))
  };
}
var importantOptionKeys = ["name", "noSuggest", "useCompounds", "type"];
function isError3(e) {
  const err = e;
  return !!err.message;
}
function determineType(uri, opts) {
  const t = opts.type && opts.type in loaders && opts.type || "S";
  const defLoaderType = t;
  const defType = uri.pathname.endsWith(".trie.gz") ? "T" : defLoaderType;
  const regTrieTest = /\.trie\b/i;
  return regTrieTest.test(uri.pathname) ? "T" : defType;
}
function load(reader, uri, options) {
  const type = determineType(uri, options);
  const loader = loaders[type] || loaders.default;
  return loader(reader, uri, options);
}
async function legacyWordList(reader, filename, options) {
  const lines = await reader.readLines(filename);
  return _legacyWordListSync(lines, filename, options);
}
function _legacyWordListSync(lines, filename, options) {
  const words = pipeSync(lines, opMapSync((line) => line.replaceAll(/#.*/g, "")), opConcatMapSync((line) => line.split(/[^\w\p{L}\p{M}']+/gu)), opFilterSync((word) => !!word));
  return createSpellingDictionary(words, options.name, filename.toString(), options);
}
async function wordsPerLineWordList(reader, filename, options) {
  const lines = await reader.readLines(filename);
  return _wordsPerLineWordList(lines, filename.toString(), options);
}
function _wordsPerLineWordList(lines, filename, options) {
  const words = pipeSync(lines, opMapSync((line) => line.replaceAll(/#.*/g, "")), opConcatMapSync((line) => line.split(/\s+/gu)), opFilterSync((word) => !!word));
  return createSpellingDictionary(words, options.name, filename, options);
}
async function loadSimpleWordList(reader, filename, options) {
  const lines = await reader.readLines(filename);
  return createSpellingDictionary(lines, options.name, filename.href, options);
}
async function loadTrie(reader, filename, options) {
  const content = await reader.read(filename);
  return createSpellingDictionaryFromTrieFile(content, options.name, filename.href, options);
}
function toLines(content) {
  return content.split(/\n|\r\n|\r/);
}
// node_modules/cspell-lib/dist/lib/SpellingDictionary/DictionaryLoader.js
var loader;
function getDictionaryLoader(vfs) {
  if (loader)
    return loader;
  return loader = new DictionaryLoader(vfs || getFileSystem());
}
function loadDictionary(def) {
  return getDictionaryLoader().loadDictionary(def);
}
async function refreshCacheEntries(maxAge, now) {
  return getDictionaryLoader().refreshCacheEntries(maxAge, now);
}

// node_modules/cspell-lib/dist/lib/SpellingDictionary/Dictionaries.js
function loadDictionaryDefs(defsToLoad) {
  return defsToLoad.map(loadDictionary);
}
function refreshDictionaryCache(maxAge) {
  return refreshCacheEntries(maxAge);
}
var emptyWords = Object.freeze([]);
async function getDictionaryInternal(settings) {
  const spellDictionaries = await Promise.all(loadDictionaryDefs(calcDictionaryDefsToLoad(settings)));
  return _getDictionaryInternal(settings, spellDictionaries);
}
var specialDictionaryNames = {
  words: "[words]",
  userWords: "[userWords]",
  flagWords: "[flagWords]",
  ignoreWords: "[ignoreWords]",
  suggestWords: "[suggestWords]"
};
var mapSpecialDictionaryNamesToSettings = new Map(Object.entries(specialDictionaryNames).map(([k, v]) => [v, k]));
function getInlineConfigDictionaries(settings) {
  const { words = emptyWords, userWords = emptyWords, flagWords = emptyWords, ignoreWords = emptyWords, suggestWords = emptyWords } = settings;
  const settingsWordsDictionary = createSpellingDictionary(words, specialDictionaryNames.words, "From Settings `words`", {
    caseSensitive: true,
    weightMap: undefined
  });
  const settingsUserWordsDictionary = userWords.length ? createSpellingDictionary(userWords, specialDictionaryNames.userWords, "From Settings `userWords`", {
    caseSensitive: true,
    weightMap: undefined
  }) : undefined;
  const ignoreWordsDictionary = createIgnoreWordsDictionary(ignoreWords, specialDictionaryNames.ignoreWords, "From Settings `ignoreWords`");
  const flagWordsDictionary = createFlagWordsDictionary(flagWords, specialDictionaryNames.flagWords, "From Settings `flagWords`");
  const suggestWordsDictionary = createSuggestDictionary(suggestWords, "[suggestWords]", "From Settings `suggestWords`");
  const dictionaries = [
    settingsWordsDictionary,
    settingsUserWordsDictionary,
    ignoreWordsDictionary,
    flagWordsDictionary,
    suggestWordsDictionary
  ].filter(isDefined6);
  return dictionaries;
}
function _getDictionaryInternal(settings, spellDictionaries) {
  const dictionaries = [...spellDictionaries, ...getInlineConfigDictionaries(settings)];
  return createCollection(dictionaries, "dictionary collection");
}
// node_modules/@cspell/filetypes/dist/definitions.js
var definitions = [
  { id: "ada", extensions: [".adb", ".ads"] },
  { id: "apiblueprint", extensions: [".apib", ".apiblueprint"] },
  { id: "argdown", extensions: [".ad", ".adown", ".argdn", ".argdown"] },
  { id: "asciidoc", extensions: [".adoc", ".asc", ".asciidoc"] },
  { id: "bat", extensions: [".bat", ".cmd"] },
  { id: "bazel", extensions: [".bazel", ".bzl"] },
  { id: "bibtex", extensions: [".bib"] },
  { id: "bicep", extensions: [".bicep"] },
  { id: "c", extensions: [".c", ".i"] },
  { id: "cache_files", extensions: [], filenames: [".DS_Store", ".cspellcache", ".eslintcache"] },
  { id: "clojure", extensions: [".clj", ".cljc", ".cljs", ".cljx", ".clojure", ".edn"] },
  { id: "cmake", extensions: [".cmake"], filenames: ["CMakeLists.txt"] },
  { id: "coffeescript", extensions: [".coffee", ".cson", ".iced"] },
  {
    id: "cpp",
    extensions: [
      ".c++",
      ".c++m",
      ".cc",
      ".ccm",
      ".cpp",
      ".cppm",
      ".cxx",
      ".cxxm",
      ".h",
      ".h++",
      ".h.in",
      ".hh",
      ".hpp",
      ".hpp.in",
      ".hxx",
      ".ii",
      ".inl",
      ".ino",
      ".ipp",
      ".ixx",
      ".mm",
      ".tpp",
      ".txx"
    ]
  },
  { id: "cpp_embedded_latex", extensions: [] },
  { id: "csharp", extensions: [".cake", ".cs", ".csx"] },
  { id: "css", extensions: [".css"] },
  { id: "cuda-cpp", extensions: [".cu", ".cuh"] },
  { id: "dart", extensions: [".dart"] },
  { id: "dhall", extensions: [".dhall"] },
  { id: "diff", extensions: [".diff", ".patch", ".rej"] },
  { id: "dockercompose", extensions: [], filenames: ["*docker*compose*.yaml", "*docker*compose*.yml", "compose.*.yaml", "compose.*.yml", "compose.yaml", "compose.yml"] },
  {
    id: "dockerfile",
    extensions: [".containerfile", ".dockerfile"],
    filenames: ["*.Dockerfile.*", "Containerfile", "Containerfile.*", "Dockerfile", "Dockerfile.*", "Dockerfile.dev", "dockerfile"]
  },
  { id: "elisp", extensions: [".el"] },
  { id: "elixir", extensions: [".ex", ".exs"] },
  { id: "elm", extensions: [".elm"] },
  { id: "erb", extensions: [".erb", ".html.erb", ".rhtml"] },
  { id: "fsharp", extensions: [".fs", ".fsi", ".fsscript", ".fsx"] },
  { id: "git-commit", extensions: [], filenames: ["COMMIT_EDITMSG", "MERGE_MSG"] },
  { id: "git-rebase", extensions: [], filenames: ["git-rebase-todo"] },
  { id: "github-issues", extensions: [".github-issues"] },
  { id: "go", extensions: [".go"] },
  { id: "godot", extensions: [".gd", ".godot", ".tres", ".tscn"] },
  { id: "gradle", extensions: [".gradle"] },
  { id: "groovy", extensions: [".gradle", ".groovy", ".gvy", ".jenkinsfile", ".nf"], filenames: ["Jenkinsfile", "Jenkinsfile*"] },
  { id: "haml", extensions: [".haml"] },
  { id: "handlebars", extensions: [".handlebars", ".hbs", ".hjs"] },
  { id: "haskell", extensions: [".hs", ".lhs"] },
  { id: "haxe", extensions: [".hx"] },
  { id: "hlsl", extensions: [".cginc", ".compute", ".fx", ".fxh", ".hlsl", ".hlsli", ".psh", ".vsh"] },
  { id: "html", extensions: [".asp", ".aspx", ".ejs", ".htm", ".html", ".jshtm", ".jsp", ".mdoc", ".rhtml", ".shtml", ".volt", ".vue", ".xht", ".xhtml"] },
  { id: "ignore", extensions: [".git-blame-ignore-revs", ".gitignore", ".gitignore_global", ".npmignore"], filenames: [".vscodeignore"] },
  { id: "ini", extensions: [".conf", ".ini"] },
  { id: "jade", extensions: [".jade", ".pug"] },
  { id: "java", extensions: [".jav", ".java"] },
  { id: "javascript", extensions: [".cjs", ".es6", ".js", ".mjs", ".pac"], filenames: ["jakefile"] },
  { id: "javascriptreact", extensions: [".jsx"] },
  { id: "jinja", extensions: [".jinja"] },
  {
    id: "json",
    extensions: [
      ".babelrc",
      ".bowerrc",
      ".code-profile",
      ".css.map",
      ".eslintrc",
      ".geojson",
      ".har",
      ".ipynb",
      ".js.map",
      ".jscsrc",
      ".jshintrc",
      ".jslintrc",
      ".json",
      ".jsonc",
      ".jsonld",
      ".ts.map",
      ".tsbuildinfo",
      ".vuerc",
      ".webmanifest"
    ],
    filenames: [".watchmanconfig", "composer.lock"]
  },
  {
    id: "jsonc",
    extensions: [
      ".babelrc",
      ".code-workspace",
      ".color-theme.json",
      ".eslintrc",
      ".eslintrc.json",
      ".hintrc",
      ".icon-theme.json",
      ".jsfmtrc",
      ".jshintrc",
      ".jsonc",
      ".language-configuration.json",
      ".swcrc"
    ],
    filenames: [
      ".babelrc.json",
      ".code-workspace",
      ".devcontainer.json",
      ".ember-cli",
      "argv.json",
      "babel.config.json",
      "devcontainer.json",
      "extensions.json",
      "jsconfig-*.json",
      "jsconfig.*.json",
      "jsconfig.json",
      "keybindings.json",
      "launch.json",
      "profiles.json",
      "settings.json",
      "tasks.json",
      "tsconfig-*.json",
      "tsconfig.*.json",
      "tsconfig.json",
      "typedoc.json"
    ]
  },
  { id: "jsonl", extensions: [".jsonl"] },
  { id: "jsx-tags", extensions: [] },
  { id: "julia", extensions: [".jl"] },
  { id: "juliamarkdown", extensions: [".jmd"] },
  { id: "jungle", extensions: [".jungle"] },
  { id: "kotlin", extensions: [".kt"] },
  { id: "latex", extensions: [".ctx", ".ltx", ".tex"] },
  { id: "less", extensions: [".less"] },
  { id: "lisp", extensions: [".fasl", ".l", ".lisp", ".lsp"] },
  { id: "literate haskell", extensions: [".lhs"] },
  { id: "lock", extensions: [".lock"], filenames: ["Cargo.lock", "berksfile.lock", "composer.lock", "package-lock.json"] },
  { id: "log", extensions: [".log"], filenames: ["*.log.?"] },
  { id: "lua", extensions: [".lua"] },
  { id: "makefile", extensions: [".mak", ".mk"], filenames: ["GNUmakefile", "Makefile", "OCamlMakefile", "makefile"] },
  { id: "map", extensions: [".map", ".css.map", ".ts.map", ".js.map"] },
  { id: "markdown", extensions: [".markdn", ".markdown", ".md", ".mdown", ".mdtext", ".mdtxt", ".mdwn", ".mkd", ".workbook"] },
  { id: "markdown_latex_combined", extensions: [] },
  { id: "markdown-math", extensions: [] },
  { id: "mdx", extensions: [".mdx"] },
  { id: "monkeyc", extensions: [".mb", ".mc"] },
  { id: "mustache", extensions: [".mst", ".mu", ".mustache", ".stache"] },
  { id: "nix", extensions: [".nix"] },
  { id: "nunjucks", extensions: [".nj", ".njk", ".nunj", ".nunjs", ".nunjucks", ".tmpl", ".tpl"] },
  { id: "objective-c", extensions: [".m"] },
  { id: "objective-cpp", extensions: [".mm"] },
  { id: "ocaml", extensions: [".eliom", ".eliomi", ".ml", ".mli", ".mll", ".mly"] },
  { id: "pdf", extensions: [".pdf"] },
  { id: "pem", extensions: [".pem", ".private-key.pem"] },
  { id: "pem-private-key", extensions: [".private-key.pem"] },
  { id: "perl", extensions: [".PL", ".pl", ".pm", ".pod", ".psgi", ".t"] },
  { id: "perl6", extensions: [".nqp", ".p6", ".pl6", ".pm6"] },
  { id: "php", extensions: [".ctp", ".php", ".php4", ".php5", ".phtml"] },
  { id: "plaintext", extensions: [".txt"] },
  { id: "powershell", extensions: [".ps1", ".psd1", ".psm1", ".psrc", ".pssc"] },
  {
    id: "properties",
    extensions: [".cfg", ".conf", ".directory", ".editorconfig", ".gitattributes", ".gitconfig", ".gitmodules", ".npmrc", ".properties", ".repo"],
    filenames: [".env", "gitconfig"]
  },
  { id: "puppet", extensions: [".puppet"] },
  { id: "purescript", extensions: [".purs"] },
  { id: "python", extensions: [".cpy", ".gyp", ".gypi", ".ipy", ".py", ".pyi", ".pyt", ".pyw", ".rpy"], filenames: ["SConscript", "SConstruct"] },
  { id: "r", extensions: [".R", ".r", ".rhistory", ".rprofile", ".rt"] },
  { id: "raku", extensions: [".nqp", ".p6", ".pl6", ".pm6", ".raku", ".rakudoc", ".rakumod", ".rakutest"] },
  { id: "razor", extensions: [".cshtml", ".razor"] },
  { id: "rescript", extensions: [".res", ".resi"] },
  { id: "restructuredtext", extensions: [".rst"] },
  { id: "rsa", extensions: [".pub"], filenames: ["id_rsa", "id_rsa.pub"] },
  {
    id: "ruby",
    extensions: [".erb", ".gemspec", ".podspec", ".rake", ".rb", ".rbi", ".rbx", ".rjs", ".ru"],
    filenames: [
      "Gemfile",
      "appfile",
      "appraisals",
      "berksfile",
      "berksfile.lock",
      "brewfile",
      "capfile",
      "cheffile",
      "dangerfile",
      "deliverfile",
      "fastfile",
      "gemfile",
      "guardfile",
      "gymfile",
      "hobofile",
      "matchfile",
      "podfile",
      "puppetfile",
      "rakefile",
      "rantfile",
      "scanfile",
      "snapfile",
      "thorfile",
      "vagrantfile"
    ]
  },
  { id: "rust", extensions: [".rs"] },
  { id: "sass", extensions: [".sass"] },
  { id: "scala", extensions: [".sbt", ".sc", ".scala"] },
  { id: "scss", extensions: [".scss"] },
  { id: "search-result", extensions: [".code-search"] },
  { id: "shaderlab", extensions: [".cginc", ".shader"] },
  {
    id: "shellscript",
    extensions: [
      ".Xsession",
      ".bash",
      ".bash_aliases",
      ".bash_login",
      ".bash_logout",
      ".bash_profile",
      ".bashrc",
      ".csh",
      ".cshrc",
      ".ebuild",
      ".eclass",
      ".fish",
      ".install",
      ".ksh",
      ".profile",
      ".sh",
      ".tcshrc",
      ".xprofile",
      ".xsession",
      ".xsessionrc",
      ".yash_profile",
      ".yashrc",
      ".zlogin",
      ".zlogout",
      ".zprofile",
      ".zsh",
      ".zsh-theme",
      ".zshenv",
      ".zshrc"
    ],
    filenames: [".env.*", ".envrc", ".hushlogin", "APKBUILD", "PKGBUILD", "bashrc_Apple_Terminal", "zlogin", "zlogout", "zprofile", "zshenv", "zshrc", "zshrc_Apple_Terminal"]
  },
  { id: "snippets", extensions: [".code-snippets"] },
  { id: "sql", extensions: [".dsql", ".sql"] },
  { id: "stylus", extensions: [".styl"] },
  { id: "svelte", extensions: [".svelte"] },
  { id: "swift", extensions: [".swift"] },
  { id: "terraform", extensions: [".hcl", ".tf", ".tf.json", ".tfvars"] },
  { id: "tex", extensions: [".bbx", ".cbx", ".cls", ".sty"] },
  { id: "tfvars", extensions: [".tfvars"], description: "Terraform Variables" },
  { id: "todo", extensions: [], filenames: ["todo"] },
  { id: "toml", extensions: [".toml"], filenames: ["Cargo.lock", "Cargo.toml"] },
  { id: "typescript", extensions: [".cts", ".mts", ".ts"] },
  { id: "typescriptreact", extensions: [".tsx"] },
  { id: "typst", extensions: [".typst"] },
  { id: "vala", extensions: [".vala"] },
  { id: "vb", extensions: [".bas", ".brs", ".vb", ".vba", ".vbs"] },
  { id: "vue", extensions: [".vue"] },
  {
    id: "xml",
    extensions: [
      ".ascx",
      ".atom",
      ".axaml",
      ".axml",
      ".bpmn",
      ".config",
      ".cpt",
      ".csl",
      ".csproj",
      ".csproj.user",
      ".dita",
      ".ditamap",
      ".dtd",
      ".dtml",
      ".ent",
      ".fsproj",
      ".fxml",
      ".iml",
      ".isml",
      ".jmx",
      ".launch",
      ".menu",
      ".mod",
      ".mxml",
      ".nuspec",
      ".opml",
      ".owl",
      ".proj",
      ".props",
      ".pt",
      ".publishsettings",
      ".pubxml",
      ".pubxml.user",
      ".rbxlx",
      ".rbxmx",
      ".rdf",
      ".rng",
      ".rss",
      ".shproj",
      ".storyboard",
      ".svg",
      ".targets",
      ".tld",
      ".tmx",
      ".vbproj",
      ".vbproj.user",
      ".vcxproj",
      ".vcxproj.filters",
      ".wsdl",
      ".wxi",
      ".wxl",
      ".wxs",
      ".xaml",
      ".xbl",
      ".xib",
      ".xlf",
      ".xliff",
      ".xml",
      ".xoml",
      ".xpdl",
      ".xsd",
      ".xul"
    ]
  },
  { id: "xsl", extensions: [".xsl", ".xslt"] },
  { id: "yaml", extensions: [".cff", ".eyaml", ".eyml", ".yaml", ".yaml-tmlanguage", ".yaml-tmpreferences", ".yaml-tmtheme", ".yml"] },
  { id: "binary", extensions: [".bin", ".cur", ".dll", ".eot", ".exe", ".gz", ".lib", ".o", ".obj", ".phar", ".zip"], format: "Binary" },
  { id: "dll", extensions: [".dll"], format: "Binary" },
  { id: "exe", extensions: [".exe"], format: "Binary" },
  { id: "fonts", extensions: [".ttf", ".woff", ".woff2"], format: "Binary" },
  { id: "gzip", extensions: [".gz"], format: "Binary" },
  {
    id: "image",
    extensions: [".bmp", ".exr", ".gif", ".heic", ".ico", ".jpeg", ".jpg", ".pbm", ".pgm", ".png", ".ppm", ".ras", ".sgi", ".tiff", ".webp", ".xbm"],
    format: "Binary",
    description: "Some image extensions"
  },
  { id: "jar", extensions: [".jar"], format: "Binary" },
  { id: "mdb", extensions: [".mdb"], format: "Binary", description: "Microsoft Access DB" },
  { id: "object-file", extensions: [".o", ".obj"], format: "Binary" },
  { id: "spv", extensions: [".spv"], format: "Binary", description: "SPSS Output Document" },
  { id: "trie", extensions: [".trie"], format: "Binary", description: "CSpell dictionary file." },
  { id: "video", extensions: [".avi", ".flv", ".mkv", ".mov", ".mp4", ".mpeg", ".mpg", ".wmv"], format: "Binary" },
  { id: "webm", extensions: [".webm"], format: "Binary", description: "WebM is an audiovisual media file format." },
  { id: "wheel", extensions: [".whl"], format: "Binary" }
];

// node_modules/@cspell/filetypes/dist/filetypes.js
var binaryFormatIds = definitions.filter((d) => d.format === "Binary").map((d) => d.id);
var binaryLanguages = new Set(["binary", "image", "video", "fonts", ...binaryFormatIds]);
var generatedFiles = new Set([
  ...binaryLanguages,
  "map",
  "lock",
  "pdf",
  "cache_files",
  "rsa",
  "pem",
  "trie",
  "log"
]);
var languageIds = definitions.map(({ id }) => id);
var mapExtensionToSetOfLanguageIds = buildLanguageExtensionMapSet(definitions);
var mapExtensionToLanguageIds = buildExtensionToLanguageIdMap(mapExtensionToSetOfLanguageIds);
var idsWithRegExp = definitions.map(defToRegExp).filter((f) => !!f);
function buildLanguageExtensionMapSet(defs) {
  return defs.reduce((map3, def) => {
    function addId(value) {
      autoResolve3(map3, value, () => new Set).add(def.id);
    }
    def.extensions.forEach(addId);
    def.filenames?.forEach((filename) => typeof filename === "string" ? addId(filename) : undefined);
    return map3;
  }, new Map);
}
function buildExtensionToLanguageIdMap(map3) {
  return new Map([...map3].map(([k, s]) => [k, [...s]]));
}
function matchPatternsToFilename(basename2) {
  return idsWithRegExp.filter(({ regexp }) => regexp.test(basename2)).map(({ id }) => id);
}
function _getLanguagesForBasename(basename2) {
  const found = mapExtensionToLanguageIds.get(basename2);
  if (found)
    return found;
  const patternMatches = matchPatternsToFilename(basename2);
  if (patternMatches.length)
    return patternMatches;
  for (let pos = basename2.indexOf(".");pos >= 0; pos = basename2.indexOf(".", pos + 1)) {
    const ids = mapExtensionToLanguageIds.get(basename2.slice(pos));
    if (ids)
      return ids;
  }
  return;
}
function findMatchingFileTypes(filename) {
  filename = basename2(filename);
  return _getLanguagesForBasename(filename) || _getLanguagesForBasename(filename.toLowerCase()) || [];
}
var regExpPathSep = /[\\/]/g;
function basename2(filename) {
  return regExpPathSep.test(filename) ? filename.split(regExpPathSep).slice(-1).join("") : filename;
}
function autoResolve3(map3, key, resolve3) {
  const found = map3.get(key);
  if (found !== undefined || map3.has(key))
    return found;
  const value = resolve3(key);
  map3.set(key, value);
  return value;
}
function escapeRegEx2(s) {
  return s.replaceAll(/[|\\{}()[\]^$+*?.]/g, "\\$&").replaceAll("-", "\\x2d");
}
function stringOrGlob(s) {
  return s.includes("*") ? simpleGlob(s) : s;
}
function simpleGlob(s) {
  s = s.replaceAll("**", "*");
  let pattern = "";
  for (const char of s) {
    switch (char) {
      case "?": {
        pattern += ".";
        break;
      }
      case "*": {
        pattern += ".*";
        break;
      }
      default: {
        pattern += escapeRegEx2(char);
      }
    }
  }
  return new RegExp(pattern);
}
function defToRegExp(def) {
  if (!def.filenames)
    return;
  const regExps = def.filenames.map(stringOrGlob).map((f) => f instanceof RegExp ? f : undefined).filter((f) => !!f);
  if (!regExps.length)
    return;
  const regexp = new RegExp(regExps.map((r) => r.source).join("|"));
  return { regexp, id: def.id };
}
// node_modules/cspell-lib/dist/lib/util/Uri.js
import assert11 from "node:assert";

// node_modules/vscode-uri/lib/esm/index.mjs
var LIB;
(() => {
  var t = { 470: (t2) => {
    function e2(t3) {
      if (typeof t3 != "string")
        throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
    }
    function r2(t3, e3) {
      for (var r3, n3 = "", i = 0, o = -1, s = 0, h = 0;h <= t3.length; ++h) {
        if (h < t3.length)
          r3 = t3.charCodeAt(h);
        else {
          if (r3 === 47)
            break;
          r3 = 47;
        }
        if (r3 === 47) {
          if (o === h - 1 || s === 1)
            ;
          else if (o !== h - 1 && s === 2) {
            if (n3.length < 2 || i !== 2 || n3.charCodeAt(n3.length - 1) !== 46 || n3.charCodeAt(n3.length - 2) !== 46) {
              if (n3.length > 2) {
                var a = n3.lastIndexOf("/");
                if (a !== n3.length - 1) {
                  a === -1 ? (n3 = "", i = 0) : i = (n3 = n3.slice(0, a)).length - 1 - n3.lastIndexOf("/"), o = h, s = 0;
                  continue;
                }
              } else if (n3.length === 2 || n3.length === 1) {
                n3 = "", i = 0, o = h, s = 0;
                continue;
              }
            }
            e3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", i = 2);
          } else
            n3.length > 0 ? n3 += "/" + t3.slice(o + 1, h) : n3 = t3.slice(o + 1, h), i = h - o - 1;
          o = h, s = 0;
        } else
          r3 === 46 && s !== -1 ? ++s : s = -1;
      }
      return n3;
    }
    var n2 = { resolve: function() {
      for (var t3, n3 = "", i = false, o = arguments.length - 1;o >= -1 && !i; o--) {
        var s;
        o >= 0 ? s = arguments[o] : (t3 === undefined && (t3 = process.cwd()), s = t3), e2(s), s.length !== 0 && (n3 = s + "/" + n3, i = s.charCodeAt(0) === 47);
      }
      return n3 = r2(n3, !i), i ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
    }, normalize: function(t3) {
      if (e2(t3), t3.length === 0)
        return ".";
      var n3 = t3.charCodeAt(0) === 47, i = t3.charCodeAt(t3.length - 1) === 47;
      return (t3 = r2(t3, !n3)).length !== 0 || n3 || (t3 = "."), t3.length > 0 && i && (t3 += "/"), n3 ? "/" + t3 : t3;
    }, isAbsolute: function(t3) {
      return e2(t3), t3.length > 0 && t3.charCodeAt(0) === 47;
    }, join: function() {
      if (arguments.length === 0)
        return ".";
      for (var t3, r3 = 0;r3 < arguments.length; ++r3) {
        var i = arguments[r3];
        e2(i), i.length > 0 && (t3 === undefined ? t3 = i : t3 += "/" + i);
      }
      return t3 === undefined ? "." : n2.normalize(t3);
    }, relative: function(t3, r3) {
      if (e2(t3), e2(r3), t3 === r3)
        return "";
      if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3)))
        return "";
      for (var i = 1;i < t3.length && t3.charCodeAt(i) === 47; ++i)
        ;
      for (var o = t3.length, s = o - i, h = 1;h < r3.length && r3.charCodeAt(h) === 47; ++h)
        ;
      for (var a = r3.length - h, c = s < a ? s : a, f = -1, u = 0;u <= c; ++u) {
        if (u === c) {
          if (a > c) {
            if (r3.charCodeAt(h + u) === 47)
              return r3.slice(h + u + 1);
            if (u === 0)
              return r3.slice(h + u);
          } else
            s > c && (t3.charCodeAt(i + u) === 47 ? f = u : u === 0 && (f = 0));
          break;
        }
        var l = t3.charCodeAt(i + u);
        if (l !== r3.charCodeAt(h + u))
          break;
        l === 47 && (f = u);
      }
      var g = "";
      for (u = i + f + 1;u <= o; ++u)
        u !== o && t3.charCodeAt(u) !== 47 || (g.length === 0 ? g += ".." : g += "/..");
      return g.length > 0 ? g + r3.slice(h + f) : (h += f, r3.charCodeAt(h) === 47 && ++h, r3.slice(h));
    }, _makeLong: function(t3) {
      return t3;
    }, dirname: function(t3) {
      if (e2(t3), t3.length === 0)
        return ".";
      for (var r3 = t3.charCodeAt(0), n3 = r3 === 47, i = -1, o = true, s = t3.length - 1;s >= 1; --s)
        if ((r3 = t3.charCodeAt(s)) === 47) {
          if (!o) {
            i = s;
            break;
          }
        } else
          o = false;
      return i === -1 ? n3 ? "/" : "." : n3 && i === 1 ? "//" : t3.slice(0, i);
    }, basename: function(t3, r3) {
      if (r3 !== undefined && typeof r3 != "string")
        throw new TypeError('"ext" argument must be a string');
      e2(t3);
      var n3, i = 0, o = -1, s = true;
      if (r3 !== undefined && r3.length > 0 && r3.length <= t3.length) {
        if (r3.length === t3.length && r3 === t3)
          return "";
        var h = r3.length - 1, a = -1;
        for (n3 = t3.length - 1;n3 >= 0; --n3) {
          var c = t3.charCodeAt(n3);
          if (c === 47) {
            if (!s) {
              i = n3 + 1;
              break;
            }
          } else
            a === -1 && (s = false, a = n3 + 1), h >= 0 && (c === r3.charCodeAt(h) ? --h == -1 && (o = n3) : (h = -1, o = a));
        }
        return i === o ? o = a : o === -1 && (o = t3.length), t3.slice(i, o);
      }
      for (n3 = t3.length - 1;n3 >= 0; --n3)
        if (t3.charCodeAt(n3) === 47) {
          if (!s) {
            i = n3 + 1;
            break;
          }
        } else
          o === -1 && (s = false, o = n3 + 1);
      return o === -1 ? "" : t3.slice(i, o);
    }, extname: function(t3) {
      e2(t3);
      for (var r3 = -1, n3 = 0, i = -1, o = true, s = 0, h = t3.length - 1;h >= 0; --h) {
        var a = t3.charCodeAt(h);
        if (a !== 47)
          i === -1 && (o = false, i = h + 1), a === 46 ? r3 === -1 ? r3 = h : s !== 1 && (s = 1) : r3 !== -1 && (s = -1);
        else if (!o) {
          n3 = h + 1;
          break;
        }
      }
      return r3 === -1 || i === -1 || s === 0 || s === 1 && r3 === i - 1 && r3 === n3 + 1 ? "" : t3.slice(r3, i);
    }, format: function(t3) {
      if (t3 === null || typeof t3 != "object")
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
      return function(t4, e3) {
        var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || "") + (e3.ext || "");
        return r3 ? r3 === e3.root ? r3 + n3 : r3 + "/" + n3 : n3;
      }(0, t3);
    }, parse: function(t3) {
      e2(t3);
      var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
      if (t3.length === 0)
        return r3;
      var n3, i = t3.charCodeAt(0), o = i === 47;
      o ? (r3.root = "/", n3 = 1) : n3 = 0;
      for (var s = -1, h = 0, a = -1, c = true, f = t3.length - 1, u = 0;f >= n3; --f)
        if ((i = t3.charCodeAt(f)) !== 47)
          a === -1 && (c = false, a = f + 1), i === 46 ? s === -1 ? s = f : u !== 1 && (u = 1) : s !== -1 && (u = -1);
        else if (!c) {
          h = f + 1;
          break;
        }
      return s === -1 || a === -1 || u === 0 || u === 1 && s === a - 1 && s === h + 1 ? a !== -1 && (r3.base = r3.name = h === 0 && o ? t3.slice(1, a) : t3.slice(h, a)) : (h === 0 && o ? (r3.name = t3.slice(1, s), r3.base = t3.slice(1, a)) : (r3.name = t3.slice(h, s), r3.base = t3.slice(h, a)), r3.ext = t3.slice(s, a)), h > 0 ? r3.dir = t3.slice(0, h - 1) : o && (r3.dir = "/"), r3;
    }, sep: "/", delimiter: ":", win32: null, posix: null };
    n2.posix = n2, t2.exports = n2;
  } }, e = {};
  function r(n2) {
    var i = e[n2];
    if (i !== undefined)
      return i.exports;
    var o = e[n2] = { exports: {} };
    return t[n2](o, o.exports, r), o.exports;
  }
  r.d = (t2, e2) => {
    for (var n2 in e2)
      r.o(e2, n2) && !r.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: e2[n2] });
  }, r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) => {
    typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
  };
  var n = {};
  (() => {
    let t2;
    if (r.r(n), r.d(n, { URI: () => f, Utils: () => P }), typeof process == "object")
      t2 = process.platform === "win32";
    else if (typeof navigator == "object") {
      let e3 = navigator.userAgent;
      t2 = e3.indexOf("Windows") >= 0;
    }
    const e2 = /^\w[\w\d+.-]*$/, i = /^\//, o = /^\/\//;
    function s(t3, r2) {
      if (!t3.scheme && r2)
        throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t3.authority}", path: "${t3.path}", query: "${t3.query}", fragment: "${t3.fragment}"}`);
      if (t3.scheme && !e2.test(t3.scheme))
        throw new Error("[UriError]: Scheme contains illegal characters.");
      if (t3.path) {
        if (t3.authority) {
          if (!i.test(t3.path))
            throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
        } else if (o.test(t3.path))
          throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
      }
    }
    const h = "", a = "/", c = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;

    class f {
      static isUri(t3) {
        return t3 instanceof f || !!t3 && typeof t3.authority == "string" && typeof t3.fragment == "string" && typeof t3.path == "string" && typeof t3.query == "string" && typeof t3.scheme == "string" && typeof t3.fsPath == "string" && typeof t3.with == "function" && typeof t3.toString == "function";
      }
      scheme;
      authority;
      path;
      query;
      fragment;
      constructor(t3, e3, r2, n2, i2, o2 = false) {
        typeof t3 == "object" ? (this.scheme = t3.scheme || h, this.authority = t3.authority || h, this.path = t3.path || h, this.query = t3.query || h, this.fragment = t3.fragment || h) : (this.scheme = function(t4, e4) {
          return t4 || e4 ? t4 : "file";
        }(t3, o2), this.authority = e3 || h, this.path = function(t4, e4) {
          switch (t4) {
            case "https":
            case "http":
            case "file":
              e4 ? e4[0] !== a && (e4 = a + e4) : e4 = a;
          }
          return e4;
        }(this.scheme, r2 || h), this.query = n2 || h, this.fragment = i2 || h, s(this, o2));
      }
      get fsPath() {
        return m(this, false);
      }
      with(t3) {
        if (!t3)
          return this;
        let { scheme: e3, authority: r2, path: n2, query: i2, fragment: o2 } = t3;
        return e3 === undefined ? e3 = this.scheme : e3 === null && (e3 = h), r2 === undefined ? r2 = this.authority : r2 === null && (r2 = h), n2 === undefined ? n2 = this.path : n2 === null && (n2 = h), i2 === undefined ? i2 = this.query : i2 === null && (i2 = h), o2 === undefined ? o2 = this.fragment : o2 === null && (o2 = h), e3 === this.scheme && r2 === this.authority && n2 === this.path && i2 === this.query && o2 === this.fragment ? this : new l(e3, r2, n2, i2, o2);
      }
      static parse(t3, e3 = false) {
        const r2 = c.exec(t3);
        return r2 ? new l(r2[2] || h, C(r2[4] || h), C(r2[5] || h), C(r2[7] || h), C(r2[9] || h), e3) : new l(h, h, h, h, h);
      }
      static file(e3) {
        let r2 = h;
        if (t2 && (e3 = e3.replace(/\\/g, a)), e3[0] === a && e3[1] === a) {
          const t3 = e3.indexOf(a, 2);
          t3 === -1 ? (r2 = e3.substring(2), e3 = a) : (r2 = e3.substring(2, t3), e3 = e3.substring(t3) || a);
        }
        return new l("file", r2, e3, h, h);
      }
      static from(t3) {
        const e3 = new l(t3.scheme, t3.authority, t3.path, t3.query, t3.fragment);
        return s(e3, true), e3;
      }
      toString(t3 = false) {
        return y(this, t3);
      }
      toJSON() {
        return this;
      }
      static revive(t3) {
        if (t3) {
          if (t3 instanceof f)
            return t3;
          {
            const e3 = new l(t3);
            return e3._formatted = t3.external, e3._fsPath = t3._sep === u ? t3.fsPath : null, e3;
          }
        }
        return t3;
      }
    }
    const u = t2 ? 1 : undefined;

    class l extends f {
      _formatted = null;
      _fsPath = null;
      get fsPath() {
        return this._fsPath || (this._fsPath = m(this, false)), this._fsPath;
      }
      toString(t3 = false) {
        return t3 ? y(this, true) : (this._formatted || (this._formatted = y(this, false)), this._formatted);
      }
      toJSON() {
        const t3 = { $mid: 1 };
        return this._fsPath && (t3.fsPath = this._fsPath, t3._sep = u), this._formatted && (t3.external = this._formatted), this.path && (t3.path = this.path), this.scheme && (t3.scheme = this.scheme), this.authority && (t3.authority = this.authority), this.query && (t3.query = this.query), this.fragment && (t3.fragment = this.fragment), t3;
      }
    }
    const g = { 58: "%3A", 47: "%2F", 63: "%3F", 35: "%23", 91: "%5B", 93: "%5D", 64: "%40", 33: "%21", 36: "%24", 38: "%26", 39: "%27", 40: "%28", 41: "%29", 42: "%2A", 43: "%2B", 44: "%2C", 59: "%3B", 61: "%3D", 32: "%20" };
    function d(t3, e3, r2) {
      let n2, i2 = -1;
      for (let o2 = 0;o2 < t3.length; o2++) {
        const s2 = t3.charCodeAt(o2);
        if (s2 >= 97 && s2 <= 122 || s2 >= 65 && s2 <= 90 || s2 >= 48 && s2 <= 57 || s2 === 45 || s2 === 46 || s2 === 95 || s2 === 126 || e3 && s2 === 47 || r2 && s2 === 91 || r2 && s2 === 93 || r2 && s2 === 58)
          i2 !== -1 && (n2 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), n2 !== undefined && (n2 += t3.charAt(o2));
        else {
          n2 === undefined && (n2 = t3.substr(0, o2));
          const e4 = g[s2];
          e4 !== undefined ? (i2 !== -1 && (n2 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), n2 += e4) : i2 === -1 && (i2 = o2);
        }
      }
      return i2 !== -1 && (n2 += encodeURIComponent(t3.substring(i2))), n2 !== undefined ? n2 : t3;
    }
    function p(t3) {
      let e3;
      for (let r2 = 0;r2 < t3.length; r2++) {
        const n2 = t3.charCodeAt(r2);
        n2 === 35 || n2 === 63 ? (e3 === undefined && (e3 = t3.substr(0, r2)), e3 += g[n2]) : e3 !== undefined && (e3 += t3[r2]);
      }
      return e3 !== undefined ? e3 : t3;
    }
    function m(e3, r2) {
      let n2;
      return n2 = e3.authority && e3.path.length > 1 && e3.scheme === "file" ? `//${e3.authority}${e3.path}` : e3.path.charCodeAt(0) === 47 && (e3.path.charCodeAt(1) >= 65 && e3.path.charCodeAt(1) <= 90 || e3.path.charCodeAt(1) >= 97 && e3.path.charCodeAt(1) <= 122) && e3.path.charCodeAt(2) === 58 ? r2 ? e3.path.substr(1) : e3.path[1].toLowerCase() + e3.path.substr(2) : e3.path, t2 && (n2 = n2.replace(/\//g, "\\")), n2;
    }
    function y(t3, e3) {
      const r2 = e3 ? p : d;
      let n2 = "", { scheme: i2, authority: o2, path: s2, query: h2, fragment: c2 } = t3;
      if (i2 && (n2 += i2, n2 += ":"), (o2 || i2 === "file") && (n2 += a, n2 += a), o2) {
        let t4 = o2.indexOf("@");
        if (t4 !== -1) {
          const e4 = o2.substr(0, t4);
          o2 = o2.substr(t4 + 1), t4 = e4.lastIndexOf(":"), t4 === -1 ? n2 += r2(e4, false, false) : (n2 += r2(e4.substr(0, t4), false, false), n2 += ":", n2 += r2(e4.substr(t4 + 1), false, true)), n2 += "@";
        }
        o2 = o2.toLowerCase(), t4 = o2.lastIndexOf(":"), t4 === -1 ? n2 += r2(o2, false, true) : (n2 += r2(o2.substr(0, t4), false, true), n2 += o2.substr(t4));
      }
      if (s2) {
        if (s2.length >= 3 && s2.charCodeAt(0) === 47 && s2.charCodeAt(2) === 58) {
          const t4 = s2.charCodeAt(1);
          t4 >= 65 && t4 <= 90 && (s2 = `/${String.fromCharCode(t4 + 32)}:${s2.substr(3)}`);
        } else if (s2.length >= 2 && s2.charCodeAt(1) === 58) {
          const t4 = s2.charCodeAt(0);
          t4 >= 65 && t4 <= 90 && (s2 = `${String.fromCharCode(t4 + 32)}:${s2.substr(2)}`);
        }
        n2 += r2(s2, true, false);
      }
      return h2 && (n2 += "?", n2 += r2(h2, false, false)), c2 && (n2 += "#", n2 += e3 ? c2 : d(c2, false, false)), n2;
    }
    function v(t3) {
      try {
        return decodeURIComponent(t3);
      } catch {
        return t3.length > 3 ? t3.substr(0, 3) + v(t3.substr(3)) : t3;
      }
    }
    const b = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
    function C(t3) {
      return t3.match(b) ? t3.replace(b, (t4) => v(t4)) : t3;
    }
    var A = r(470);
    const w = A.posix || A, x = "/";
    var P;
    (function(t3) {
      t3.joinPath = function(t4, ...e3) {
        return t4.with({ path: w.join(t4.path, ...e3) });
      }, t3.resolvePath = function(t4, ...e3) {
        let r2 = t4.path, n2 = false;
        r2[0] !== x && (r2 = x + r2, n2 = true);
        let i2 = w.resolve(r2, ...e3);
        return n2 && i2[0] === x && !t4.authority && (i2 = i2.substring(1)), t4.with({ path: i2 });
      }, t3.dirname = function(t4) {
        if (t4.path.length === 0 || t4.path === x)
          return t4;
        let e3 = w.dirname(t4.path);
        return e3.length === 1 && e3.charCodeAt(0) === 46 && (e3 = ""), t4.with({ path: e3 });
      }, t3.basename = function(t4) {
        return w.basename(t4.path);
      }, t3.extname = function(t4) {
        return w.extname(t4.path);
      };
    })(P || (P = {}));
  })(), LIB = n;
})();
var { URI, Utils } = LIB;

// node_modules/cspell-lib/dist/lib/util/Uri.js
var STDIN_PROTOCOL = "stdin:";
function toUri(uriOrFile) {
  if (UriImpl.isUri(uriOrFile))
    return uriOrFile;
  if (URI.isUri(uriOrFile))
    return UriImpl.from(uriOrFile);
  if (uriOrFile instanceof URL)
    return UriImpl.parse(uriOrFile.toString());
  if (isHRef(uriOrFile))
    return UriImpl.parse(uriOrFile.href);
  if (isUri(uriOrFile))
    return UriImpl.from(uriOrFile);
  if (isUrlLike(uriOrFile))
    return UriImpl.parse(uriOrFile);
  return UriImpl.file(normalizeDriveLetter(uriOrFile));
}
var isWindows3 = process.platform === "win32";
var hasDriveLetter = /^[a-zA-Z]:[\\/]/;
var rootUrl = toFileDirURL("/");
function uriToFilePath(uri) {
  let url2 = documentUriToURL(uri);
  url2 = url2.protocol === "stdin:" ? new URL(url2.pathname, rootUrl) : url2;
  return toFilePathOrHref(url2);
}
function normalizeDriveLetter(path6) {
  return hasDriveLetter.test(path6) ? path6[0].toUpperCase() + path6.slice(1) : path6;
}
function isHRef(url2) {
  return !!url2 && typeof url2 === "object" && typeof url2.href === "string" || false;
}
function isUri(uri) {
  if (!uri || typeof uri !== "object")
    return false;
  if (UriImpl.isUri(uri))
    return true;
  if (URI.isUri(uri))
    return true;
  const u = uri;
  return typeof u.path === "string" && typeof u.scheme === "string";
}
function basename3(uri) {
  return Utils.basename(URI.from(uri));
}
function uriFrom(uri, ...parts) {
  return UriImpl.from(uri, ...parts);
}
var keys2 = ["scheme", "authority", "path", "query", "fragment"];

class UriImpl extends URI {
  constructor(uri) {
    super(uri.scheme, uri.authority, uri.path, uri.query, uri.fragment);
  }
  toString() {
    const path6 = encodeURI(this.path || "").replaceAll(/[#?]/g, (c) => `%${(c.codePointAt(0) || 0).toString(16)}`);
    const base = `${this.scheme}://${this.authority || ""}${path6}`;
    const query = this.query && `?${this.query}` || "";
    const fragment = this.fragment && `#${this.fragment}` || "";
    const url2 = base + query + fragment;
    return url2;
  }
  toJSON() {
    const { scheme, authority, path: path6, query, fragment } = this;
    return { scheme, authority, path: path6, query, fragment };
  }
  with(change) {
    const { scheme, authority, path: path6, query, fragment } = this;
    const u = { scheme, authority, path: path6, query, fragment };
    for (const key of keys2) {
      if (change[key] && typeof change[key] === "string") {
        u[key] = change[key];
      }
    }
    return new UriImpl(u);
  }
  static isUri(uri) {
    return uri instanceof UriImpl;
  }
  static from(uri, ...parts) {
    let u = new UriImpl(uri);
    for (const part of parts) {
      u = u.with(part);
    }
    return u;
  }
  static parse(uri) {
    if (uri.startsWith(STDIN_PROTOCOL)) {
      return UriImpl.from(parseStdinUri(uri));
    }
    const u = URI.parse(uri);
    return UriImpl.from(u);
  }
  static file(filename) {
    if (!isWindows3 && hasDriveLetter.test(filename)) {
      filename = "/" + filename.replaceAll("\\", "/");
    }
    const url2 = toFileURL(filename);
    return UriImpl.parse(url2.href);
  }
  static stdin(filePath = "") {
    return UriImpl.from(UriImpl.file(filePath), { scheme: "stdin" });
  }
}
function normalizeFilePath(path6) {
  return normalizeDriveLetter(path6.replaceAll("\\", "/"));
}
function parseStdinUri(uri) {
  assert11(uri.startsWith(STDIN_PROTOCOL));
  const idxSlash = STDIN_PROTOCOL.length;
  let idxSlashEnd = idxSlash;
  for (;uri[idxSlashEnd] === "/"; ++idxSlashEnd) {
  }
  const pathStart = idxSlashEnd;
  const iH = uri.indexOf("#", pathStart);
  const idxHash = iH > 0 ? iH : uri.length;
  const iQ = uri.indexOf("?", pathStart);
  const idxQ = iQ > 0 && iQ < idxHash ? iQ : idxHash;
  const pathEnd = idxQ;
  const path6 = uri.slice(pathStart, pathEnd);
  const query = idxQ < idxHash ? uri.slice(idxQ + 1, idxHash) : "";
  const hash = uri.slice(idxHash + 1);
  const pathPrefix = idxSlashEnd - idxSlash > 2 ? "/" : "";
  return {
    scheme: "stdin",
    path: pathPrefix + normalizeFilePath(decodeURI(path6)),
    query: decodeURI(query),
    fragment: decodeURI(hash)
  };
}
function documentUriToURL(uri) {
  return toURL(uri instanceof URL ? uri : typeof uri === "string" ? toFileURL(uri) : new URL(uriFrom(uri).toString()));
}

// node_modules/cspell-lib/dist/lib/Models/TextDocument.js
import assert12 from "node:assert";
class TextDocumentImpl {
  languageId;
  locale;
  vsTextDoc;
  uri;
  constructor(uri, text, languageId, locale, version2) {
    this.languageId = languageId;
    this.locale = locale;
    const primaryLanguageId = typeof languageId === "string" ? languageId : languageId[0] || "plaintext";
    this.vsTextDoc = TextDocument.create(uri.toString(), primaryLanguageId, version2, text);
    this.uri = documentUriToURL(uri);
  }
  get version() {
    return this.vsTextDoc.version;
  }
  get text() {
    return this.vsTextDoc.getText();
  }
  positionAt(offset) {
    return this.vsTextDoc.positionAt(offset);
  }
  offsetAt(position) {
    return this.vsTextDoc.offsetAt(position);
  }
  lineAt(offset) {
    const position = this.vsTextDoc.positionAt(offset);
    return this.getLine(position.line);
  }
  getLine(lineNum) {
    const position = { line: lineNum, character: 0 };
    const end = { line: lineNum + 1, character: 0 };
    const range = {
      start: position,
      end
    };
    const lineOffset = this.vsTextDoc.offsetAt(position);
    const text = this.vsTextDoc.getText(range);
    return {
      text,
      offset: lineOffset,
      position
    };
  }
  *getLines() {
    const range = {
      start: { line: 0, character: 0 },
      end: { line: 1, character: 0 }
    };
    while (this.vsTextDoc.offsetAt(range.end) > this.vsTextDoc.offsetAt(range.start)) {
      const offset = this.vsTextDoc.offsetAt(range.start);
      yield {
        text: this.vsTextDoc.getText(range),
        offset,
        position: range.start
      };
      ++range.start.line;
      ++range.end.line;
    }
  }
  update(edits, version2) {
    version2 = version2 ?? this.version + 1;
    for (const edit of edits) {
      const vsEdit = edit.range ? {
        range: { start: this.positionAt(edit.range[0]), end: this.positionAt(edit.range[1]) },
        text: edit.text
      } : edit;
      TextDocument.update(this.vsTextDoc, [vsEdit], version2);
    }
    return this;
  }
}
function createTextDocument({ uri, content, languageId, locale, version: version2 }) {
  version2 = version2 ?? 1;
  uri = toUri(uri);
  languageId = languageId ?? findMatchingFileTypes(basename3(uri));
  languageId = languageId.length === 0 ? "text" : languageId;
  return new TextDocumentImpl(uri, content, languageId, locale, version2);
}
function updateTextDocument(doc, edits, version2) {
  assert12(isTextDocumentImpl(doc), "Unknown TextDocument type");
  return doc.update(edits, version2);
}
function isTextDocumentImpl(doc) {
  return doc instanceof TextDocumentImpl;
}

// node_modules/cspell-glob/dist/globHelper.js
import * as Path2 from "node:path";
var { posix } = Path2;
var isGlobalPatternRegExp = /^!*[*]{2}/;
var fileUrlBuilder2 = new FileUrlBuilder;
var GlobPlaceHolders = {
  cwd: "${cwd}"
};
var GlobPatterns = {
  suffixAny: "/**",
  suffixDir: "/**/*",
  prefixAny: "**/"
};
var cache3 = new Map;
function isGlobPatternWithOptionalRoot(g) {
  return typeof g !== "string" && typeof g.glob === "string";
}
function isGlobPatternWithRoot(g) {
  if (typeof g === "string")
    return false;
  return typeof g.root === "string" && "isGlobalPattern" in g;
}
function isGlobPatternNormalized(g) {
  if (!isGlobPatternWithRoot(g))
    return false;
  const gr = g;
  return "rawGlob" in gr && "rawRoot" in gr && typeof gr.rawGlob === "string";
}
function isGlobPatternNormalizedToRoot(g, options) {
  if (!isGlobPatternNormalized(g))
    return false;
  return g.root === options.root;
}
function urlBuilder(path6 = Path2) {
  return path6 === Path2 ? fileUrlBuilder2 : new FileUrlBuilder({ path: path6 });
}
function normalizePattern(pattern, nested) {
  pattern = pattern.replace(/^(!!)+/, "");
  const isNeg = pattern.startsWith("!");
  const prefix = isNeg ? "!" : "";
  pattern = isNeg ? pattern.slice(1) : pattern;
  const patterns = nested ? normalizePatternNested(pattern) : normalizePatternGeneral(pattern);
  return patterns.map((p) => prefix + p);
}
function normalizePatternNested(pattern) {
  if (!pattern.includes("/")) {
    if (pattern === "**")
      return ["**"];
    return ["**/" + pattern, "**/" + pattern + "/**"];
  }
  const hasLeadingSlash = pattern.startsWith("/");
  pattern = hasLeadingSlash ? pattern.slice(1) : pattern;
  if (pattern.endsWith("/")) {
    return hasLeadingSlash || pattern.slice(0, -1).includes("/") ? [pattern + "**/*"] : ["**/" + pattern + "**/*"];
  }
  if (pattern.endsWith("**")) {
    return [pattern];
  }
  return [pattern, pattern + "/**"];
}
function normalizePatternGeneral(pattern) {
  pattern = pattern.startsWith("/") ? pattern.slice(1) : pattern;
  pattern = pattern.endsWith("/") ? pattern + "**/*" : pattern;
  return [pattern];
}
function normalizeGlobPatterns(patterns, options) {
  function* normalize3() {
    for (const glob of patterns) {
      if (isGlobPatternNormalized(glob)) {
        yield isGlobPatternNormalizedToRoot(glob, options) ? glob : normalizeGlobToRoot(glob, options.root, options.nodePath || Path2);
        continue;
      }
      yield* normalizeGlobPattern(glob, options);
    }
  }
  return [...normalize3()];
}
function normalizeGlobPattern(g, options) {
  const { root, nodePath: path6 = Path2, nested } = options;
  const builder = urlBuilder(path6);
  const cwd = options.cwd ?? path6.resolve();
  const cwdUrl = builder.toFileDirURL(cwd);
  const rootUrl2 = builder.toFileDirURL(root, cwdUrl);
  const gIsGlobalPattern = isGlobPatternWithRoot(g) ? g.isGlobalPattern : undefined;
  g = !isGlobPatternWithOptionalRoot(g) ? { glob: g } : g;
  const gr = { ...g, root: g.root ?? root };
  const rawRoot = gr.root;
  const rawGlob = g.glob;
  gr.glob = trimGlob(g.glob);
  if (gr.glob.startsWith(GlobPlaceHolders.cwd)) {
    gr.glob = gr.glob.replace(GlobPlaceHolders.cwd, "");
    gr.root = GlobPlaceHolders.cwd;
  }
  if (gr.root.startsWith(GlobPlaceHolders.cwd)) {
    const relRoot = gr.root.replace(GlobPlaceHolders.cwd, "./");
    const r = builder.toFileDirURL(relRoot, cwdUrl);
    r.pathname = posix.normalize(r.pathname);
    gr.root = builder.urlToFilePathOrHref(r);
  }
  const isGlobalPattern = gIsGlobalPattern ?? isGlobalGlob(gr.glob);
  gr.root = builder.urlToFilePathOrHref(builder.toFileDirURL(gr.root, rootUrl2));
  const globs = normalizePattern(gr.glob, nested);
  return globs.map((glob) => ({ ...gr, glob, rawGlob, rawRoot, isGlobalPattern }));
}
function normalizeGlobToRoot(glob, root, path6) {
  const builder = urlBuilder(path6);
  glob = { ...glob };
  fixPatternRoot(glob, builder);
  const rootURL = builder.toFileDirURL(root);
  root = builder.urlToFilePathOrHref(rootURL);
  if (glob.root === root) {
    return glob;
  }
  const globRootUrl = builder.toFileDirURL(glob.root);
  const relFromRootToGlob = builder.relative(rootURL, globRootUrl);
  if (!relFromRootToGlob) {
    return glob;
  }
  if (glob.isGlobalPattern) {
    return { ...glob, root };
  }
  const relFromGlobToRoot = builder.relative(globRootUrl, rootURL);
  const globIsUnderRoot = isRelativeValueNested(relFromRootToGlob);
  const rootIsUnderGlob = isRelativeValueNested(relFromGlobToRoot);
  if (!globIsUnderRoot && !rootIsUnderGlob) {
    return glob;
  }
  const isNeg = glob.glob.startsWith("!");
  const g = isNeg ? glob.glob.slice(1) : glob.glob;
  const prefix = isNeg ? "!" : "";
  if (globIsUnderRoot) {
    const relGlob = relFromRootToGlob;
    return {
      ...glob,
      glob: prefix + posix.join(relGlob, g),
      root
    };
  }
  const rebasedGlob = rebaseGlob(g, nRel(relFromRootToGlob), nRel(relFromGlobToRoot));
  return rebasedGlob ? { ...glob, glob: prefix + rebasedGlob, root } : glob;
}
function nRel(rel) {
  return rel.endsWith("/") ? rel : rel + "/";
}
function isRelativeValueNested(rel) {
  return !rel || !(rel === ".." || rel.startsWith("../") || rel.startsWith("/"));
}
function rebaseGlob(glob, fromRootToGlob, fromGlobToRoot) {
  if (!fromGlobToRoot || fromGlobToRoot === "/")
    return glob;
  if (fromRootToGlob.startsWith("../") && !fromGlobToRoot.startsWith("../") && glob.startsWith("**"))
    return glob;
  fromRootToGlob = nRel(fromRootToGlob);
  fromGlobToRoot = nRel(fromGlobToRoot);
  const relToParts = fromRootToGlob.split("/");
  const relFromParts = fromGlobToRoot.split("/");
  if (glob.startsWith(fromGlobToRoot) && fromRootToGlob === "../".repeat(relToParts.length - 1)) {
    return glob.slice(fromGlobToRoot.length);
  }
  const lastRelIdx = relToParts.findIndex((s) => s !== "..");
  const lastRel = lastRelIdx < 0 ? relToParts.length : lastRelIdx;
  const globParts = [...relToParts.slice(lastRel).filter((a) => a), ...glob.split("/")];
  relToParts.length = lastRel;
  if (fromRootToGlob.startsWith("../") && relFromParts.length !== relToParts.length + 1) {
    return fromRootToGlob + (glob.startsWith("/") ? glob.slice(1) : glob);
  }
  for (let i = 0;i < relFromParts.length && i < globParts.length; ++i) {
    const relSeg = relFromParts[i];
    const globSeg = globParts[i];
    if (!relSeg || globSeg === "**") {
      return globParts.slice(i).join("/");
    }
    if (relSeg !== globSeg && globSeg !== "*") {
      break;
    }
  }
  return fromRootToGlob + (glob.startsWith("/") ? glob.slice(1) : glob);
}
function trimGlob(glob) {
  glob = globRemoveComment(glob);
  glob = trimGlobLeft(glob);
  glob = trimGlobRight(glob);
  return glob;
}
function globRemoveComment(glob) {
  return glob.replace(/(?<=^|\s)#.*/, "");
}
var spaces = {
  " ": true,
  "\t": true,
  "\n": true,
  "\r": true
};
function trimGlobRight(glob) {
  const lenMin1 = glob.length - 1;
  let i = lenMin1;
  while (i >= 0 && glob[i] in spaces) {
    --i;
  }
  if (glob[i] === "\\") {
    ++i;
  }
  ++i;
  return i ? glob.slice(0, i) : "";
}
function trimGlobLeft(glob) {
  return glob.trimStart();
}
function isGlobalGlob(glob) {
  return isGlobalPatternRegExp.test(glob);
}
function rootToUrl(root, builder) {
  if (root.startsWith(GlobPlaceHolders.cwd)) {
    return new URL(builder.normalizeFilePathForUrl(root.replace(GlobPlaceHolders.cwd, ".")), builder.cwd);
  }
  return builder.toFileDirURL(root);
}
function fixPatternRoot(glob, builder) {
  if (glob.root.startsWith(GlobPlaceHolders.cwd)) {
    return glob;
  }
  glob.root = builder.urlToFilePathOrHref(rootToUrl(glob.root, builder));
  return glob;
}

// node_modules/cspell-glob/dist/GlobMatcher.js
import * as Path3 from "node:path";
var import_micromatch = __toESM(require_micromatch(), 1);
var traceMode = false;
var idGlobMatcher = 0;

class GlobMatcher {
  matchEx;
  path;
  patterns;
  patternsNormalizedToRoot;
  root;
  dot;
  options;
  id;
  constructor(patterns, rootOrOptions, _nodePath) {
    this.id = idGlobMatcher++;
    const options = typeof rootOrOptions === "string" || rootOrOptions instanceof URL ? { root: rootOrOptions.toString() } : rootOrOptions ?? {};
    const mode = options.mode ?? "exclude";
    const isExcludeMode = mode !== "include";
    const nodePath = options.nodePath ?? _nodePath ?? Path3;
    this.path = nodePath;
    const cwd = options.cwd ?? nodePath.resolve();
    const dot = options.dot ?? isExcludeMode;
    const nested = options.nested ?? isExcludeMode;
    const nobrace = options.nobrace;
    const root = options.root ?? nodePath.resolve();
    const builder = new FileUrlBuilder({ path: nodePath });
    const rootURL = builder.toFileDirURL(root);
    const normalizedRoot = builder.urlToFilePathOrHref(rootURL);
    this.options = { root: normalizedRoot, dot, nodePath, nested, mode, nobrace, cwd };
    patterns = Array.isArray(patterns) ? patterns : typeof patterns === "string" ? patterns.split(/\r?\n/g) : [patterns];
    const globPatterns = normalizeGlobPatterns(patterns, this.options);
    this.patternsNormalizedToRoot = globPatterns.map((g) => normalizeGlobToRoot(g, normalizedRoot, nodePath)).filter((g) => builder.relative(builder.toFileDirURL(g.root), rootURL) === "");
    this.patterns = globPatterns;
    this.root = normalizedRoot;
    this.dot = dot;
    this.matchEx = buildMatcherFn(this.id, this.patterns, this.options);
  }
  match(filename) {
    return this.matchEx(filename).matched;
  }
}
function buildMatcherFn(_id, patterns, options) {
  const { nodePath, dot, nobrace } = options;
  const builder = new FileUrlBuilder({ path: nodePath });
  const makeReOptions = { dot, nobrace };
  const suffixDir = GlobPatterns.suffixDir;
  const rules = patterns.map((pattern, index) => ({ pattern, index })).filter((r) => !!r.pattern.glob).filter((r) => !r.pattern.glob.startsWith("#")).map(({ pattern, index }) => {
    const matchNeg = pattern.glob.match(/^!/);
    const glob = pattern.glob.replace(/^!/, "");
    const isNeg = matchNeg && matchNeg[0].length & 1 && true || false;
    const reg = import_micromatch.default.makeRe(glob, makeReOptions);
    const fn2 = pattern.glob.endsWith(suffixDir) ? (filename) => {
      return reg.test(filename) || filename.endsWith("/") && reg.test(filename + " ");
    } : (filename) => {
      return reg.test(filename);
    };
    return { pattern, index, isNeg, fn: fn2, reg };
  });
  const negRules = rules.filter((r) => r.isNeg);
  const posRules = rules.filter((r) => !r.isNeg);
  const mapRoots = new Map;
  const fn = (filename) => {
    const fileUrl = builder.toFileURL(filename);
    const relFilePathname = builder.relative(new URL("file:///"), fileUrl);
    let lastRoot = new URL("placeHolder://");
    let lastRel = "";
    function rootToUrl2(root) {
      const found = mapRoots.get(root);
      if (found)
        return found;
      const url2 = builder.toFileDirURL(root);
      mapRoots.set(root, url2);
      return url2;
    }
    function relativeToRoot(root) {
      if (root.href !== lastRoot.href) {
        lastRoot = root;
        lastRel = builder.relative(root, fileUrl);
      }
      return lastRel;
    }
    function testRules(rules2, matched) {
      for (const rule of rules2) {
        const pattern = rule.pattern;
        const root = pattern.root;
        const rootURL = rootToUrl2(root);
        const isRelPat = !pattern.isGlobalPattern;
        let fname = relFilePathname;
        if (isRelPat) {
          const relPathToFile = relativeToRoot(rootURL);
          if (!isRelativeValueNested(relPathToFile)) {
            continue;
          }
          fname = relPathToFile;
        }
        if (rule.fn(fname)) {
          return {
            matched,
            glob: pattern.glob,
            root,
            pattern,
            index: rule.index,
            isNeg: rule.isNeg
          };
        }
      }
    }
    const result = testRules(negRules, false) || testRules(posRules, true) || { matched: false };
    traceMode && logMatchTest(_id, filename, result);
    return result;
  };
  return fn;
}
function logMatchTest(id, filename, match) {
  console.warn("%s;%d;%s", filename, id, JSON.stringify(match.matched));
}
// node_modules/cspell-lib/dist/lib/Settings/CSpellSettingsServer.js
import assert13 from "node:assert";

// node_modules/cspell-lib/dist/lib/Settings/constants.js
var configSettingsFileVersion0_1 = "0.1";
var configSettingsFileVersion0_2 = "0.2";
var currentSettingsFileVersion = configSettingsFileVersion0_2;
var ENV_CSPELL_GLOB_ROOT = "CSPELL_GLOB_ROOT";
var defaultConfigFileModuleRef = "@cspell/cspell-bundled-dicts/cspell-default.json";

// node_modules/cspell-lib/dist/lib/Settings/mergeCache.js
class CalcLeftRightResultWeakCache {
  map = new AutoResolveWeakCache2;
  _toDispose;
  constructor() {
    this._toDispose = onClearCache(() => {
      this.clear();
    });
  }
  get(left, right, calc) {
    const m = this.map.get(left, () => new AutoResolveWeakCache2);
    return m.get(right, () => calc(left, right));
  }
  clear() {
    this.map.clear();
  }
  dispose() {
    this.map.dispose();
    this._toDispose?.dispose();
    this._toDispose = undefined;
  }
  stats() {
    return this.map.stats();
  }
}

// node_modules/cspell-lib/dist/lib/Settings/mergeList.js
var cacheMergeListUnique = new CalcLeftRightResultWeakCache;
var cacheMergeLists = new CalcLeftRightResultWeakCache;
function mergeListUnique(left, right) {
  if (!Array.isArray(left))
    return Array.isArray(right) ? right : undefined;
  if (!Array.isArray(right))
    return left;
  if (!right.length)
    return left;
  if (!left.length)
    return right;
  const result = cacheMergeListUnique.get(left, right, (left2, right2) => [...new Set([...left2, ...right2])]);
  Object.freeze(left);
  Object.freeze(right);
  Object.freeze(result);
  return result;
}
function mergeList(left, right) {
  if (!Array.isArray(left))
    return Array.isArray(right) ? right : undefined;
  if (!Array.isArray(right))
    return left;
  if (!left.length)
    return right;
  if (!right.length)
    return left;
  const result = cacheMergeLists.get(left, right, (left2, right2) => [...left2, ...right2]);
  Object.freeze(left);
  Object.freeze(right);
  Object.freeze(result);
  return result;
}
function stats() {
  return {
    cacheMergeListUnique: cacheMergeListUnique.stats(),
    cacheMergeLists: cacheMergeLists.stats()
  };
}

// node_modules/cspell-lib/dist/lib/util/textRegex.js
var regExSplitWords = /(\p{Ll}\p{M}?)(\p{Lu})/gu;
var regExSplitWords2 = /(\p{Lu}\p{M}?)((\p{Lu}\p{M}?)\p{Ll})/gu;
var regExpCamelCaseWordBreaksWithEnglishSuffix = /(?<=\p{Ll}\p{M}?)(?=\p{Lu})|(?<=\p{Lu}\p{M}?)(?=\p{Lu}\p{M}?\p{Ll})(?!\p{Lu}\p{M}?(?:s|ing|ies|es|ings|ed|ning)(?!\p{Ll}))/gu;
var regExWords = /\p{L}\p{M}?(?:(?:\\?['])?\p{L}\p{M}?)*/gu;
var regExWordsAndDigits = /[\p{L}\w'`.+-](?:(?:\\(?=[']))?[\p{L}\p{M}\w'`.+-])*/gu;
var regExIgnoreCharacters = /[\p{sc=Hiragana}\p{sc=Han}\p{sc=Katakana}\u30A0-\u30FF\p{sc=Hangul}]/gu;
var regExFirstUpper = /^\p{Lu}\p{M}?\p{Ll}+$/u;
var regExAllUpper2 = /^(?:\p{Lu}\p{M}?)+$/u;
var regExAllLower = /^(?:\p{Ll}\p{M}?)+$/u;
var regExPossibleWordBreaks = /[-+_'`.\s]/g;
var regExMatchRegExParts = /^\s*\/([\s\S]*?)\/([gimuxy]*)\s*$/;
var regExAccents2 = /\p{M}/gu;
var regExEscapeCharacters = /(?<=\\)[anrvtbf]/gi;
var regExDanglingQuote = /(?<=(?:^|(?!\p{M})\P{L})(?:\p{L}\p{M}?)?)[']/gu;
var regExTrailingEndings = /(?<=(?:\p{Lu}\p{M}?){2})[']?(?:s|d|ings?|ies|e[ds]?|ning|th|nth)(?!\p{Ll})/gu;
var regExNumericLiteral = /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][-+]?\d+)?$/;
function stringToRegExp(pattern, defaultFlags = "gimu", forceFlags = "g") {
  if (pattern instanceof RegExp) {
    return pattern;
  }
  try {
    const [, pat, flag] = [
      ...pattern.match(regExMatchRegExParts) || ["", pattern.trim(), defaultFlags],
      forceFlags
    ];
    if (pat) {
      const regPattern = flag.includes("x") ? removeVerboseFromRegExp(pat) : pat;
      const flags = [...new Set(forceFlags + flag)].join("").replaceAll(/[^gimuy]/g, "");
      const regex = new RegExp(regPattern, flags);
      return regex;
    }
  } catch {
  }
  return;
}
var SPACES = {
  " ": true,
  "\n": true,
  "\r": true,
  "\t": true
};
function removeVerboseFromRegExp(pattern) {
  function escape(acc) {
    const char = pattern[acc.idx];
    if (char !== "\\")
      return;
    const next = pattern[++acc.idx];
    acc.idx++;
    if (next === "#") {
      acc.result += "#";
      return acc;
    }
    if (!(next in SPACES)) {
      acc.result += "\\" + next;
      return acc;
    }
    acc.result += next;
    if (next === "\r" && pattern[acc.idx] === `
`) {
      acc.result += `
`;
      acc.idx++;
    }
    return acc;
  }
  function braces(acc) {
    const char = pattern[acc.idx];
    if (char !== "[")
      return;
    acc.result += char;
    acc.idx++;
    let escCount = 0;
    while (acc.idx < pattern.length) {
      const char2 = pattern[acc.idx];
      acc.result += char2;
      acc.idx++;
      if (char2 === "]" && !(escCount & 1))
        break;
      escCount = char2 === "\\" ? escCount + 1 : 0;
    }
    return acc;
  }
  function spaces2(acc) {
    const char = pattern[acc.idx];
    if (!(char in SPACES))
      return;
    acc.idx++;
    return acc;
  }
  function comments(acc) {
    const char = pattern[acc.idx];
    if (char !== "#")
      return;
    while (acc.idx < pattern.length && pattern[acc.idx] !== `
`) {
      acc.idx++;
    }
    return acc;
  }
  function copy(acc) {
    const char = pattern[acc.idx++];
    acc.result += char;
    return acc;
  }
  const reducers = [escape, braces, spaces2, comments, copy];
  const result = { idx: 0, result: "" };
  while (result.idx < pattern.length) {
    for (const r of reducers) {
      if (r(result))
        break;
    }
  }
  return result.result;
}

// node_modules/cspell-lib/dist/lib/Settings/patterns.js
var emptyRegExpList = [];
var emptyPatternDefinitions = [];
var cache4 = new CalcLeftRightResultWeakCache;
function resolvePatterns(regExpList = emptyRegExpList, patternDefinitions = emptyPatternDefinitions) {
  return cache4.get(regExpList, patternDefinitions, _resolvePatterns);
}
function _resolvePatterns(regExpList, patternDefinitions) {
  const patternMap = new Map(patternDefinitions.map((def) => [def.name.toLowerCase(), def.pattern]));
  const resolved = new Set;
  function resolvePattern(p) {
    if (resolved.has(p))
      return;
    resolved.add(p);
    return patternMap.get(p.toString().toLowerCase()) || p;
  }
  function* flatten(patterns) {
    for (const pattern of patterns) {
      if (Array.isArray(pattern)) {
        yield* flatten(pattern.map(resolvePattern).filter(isDefined6));
      } else {
        yield pattern;
      }
    }
  }
  const patternList = regExpList.map(resolvePattern).filter(isDefined6);
  const result = [...flatten(patternList)].map(toRegExp).filter(isDefined6);
  Object.freeze(regExpList);
  Object.freeze(patternDefinitions);
  Object.freeze(result);
  return result;
}
function toRegExp(pattern) {
  return pattern instanceof RegExp ? new RegExp(pattern) : stringToRegExp(pattern, "gim", "g");
}

// node_modules/cspell-lib/dist/lib/Settings/resolveCwd.js
class CwdUrlResolver {
  #lastPath;
  #lastUrl;
  #cwd;
  #cwdUrl;
  constructor() {
    this.#cwd = process.cwd();
    this.#cwdUrl = toFileDirURL(this.#cwd);
    this.#lastPath = this.#cwd;
    this.#lastUrl = this.#cwdUrl;
  }
  resolveUrl(path6) {
    path6 = path6 || this.#cwd;
    if (path6 === this.#lastPath)
      return this.#lastUrl;
    if (path6 === this.#cwd)
      return this.#cwdUrl;
    this.#lastPath = path6;
    this.#lastUrl = toFileURL(path6);
    return this.#lastUrl;
  }
  reset(cwd = process.cwd()) {
    this.#cwd = cwd;
    this.#cwdUrl = toFileDirURL(this.#cwd);
  }
}

// node_modules/cspell-lib/dist/lib/Settings/CSpellSettingsServer.js
var emptyWords2 = [];
Object.freeze(emptyWords2);
var cachedMerges = new AutoResolveWeakCache2;
var mergeCache = new AutoResolveWeakCache2;
var cacheInternalSettings = new AutoResolveWeakCache2;
var parserCache = new AutoResolveWeakCache2;
var emptyParserMap = new Map;
var cwdResolver = new CwdUrlResolver;
var envCSpellGlobRoot = process.env[ENV_CSPELL_GLOB_ROOT];
onClearCache(() => {
  parserCache.clear();
  emptyParserMap.clear();
  cachedMerges.clear();
  mergeCache.clear();
  cacheInternalSettings.clear();
  cwdResolver.reset();
  envCSpellGlobRoot = process.env[ENV_CSPELL_GLOB_ROOT];
});
function _mergeWordsCached(left, right) {
  const map3 = autoResolveWeak2(cachedMerges, left, () => new WeakMap);
  return autoResolveWeak2(map3, right, () => [...left, ...right]);
}
function mergeWordsCached(left, right) {
  if (!Array.isArray(left) || !left.length) {
    return Array.isArray(right) ? right.length ? right : emptyWords2 : undefined;
  }
  if (!Array.isArray(right) || !right.length)
    return left;
  return _mergeWordsCached(left, right);
}
function mergeObjects(left, right) {
  if (!left || typeof left !== "object")
    return !right || typeof right !== "object" ? undefined : right;
  if (!right || typeof right !== "object")
    return left;
  return { ...left, ...right };
}
function replaceIfNotEmpty(left = [], right = []) {
  const filtered = right.filter((a) => !!a);
  if (filtered.length) {
    return filtered;
  }
  return left;
}
function mergeSettings(left, ...settings) {
  const rawSettings = settings.filter(isDefined6).reduce(merge2, toInternalSettings(left));
  return clean5(rawSettings);
}
function isEmpty(obj) {
  return !obj || Object.keys(obj).length === 0;
}
function merge2(left, right) {
  const map3 = mergeCache.get(left, () => new WeakMap);
  return autoResolveWeak2(map3, right, () => _merge(left, right));
}
function _merge(left, right) {
  const _left = toInternalSettings(left);
  const _right = toInternalSettings(right);
  if (left === right) {
    return _left;
  }
  if (isEmpty(right)) {
    return _left;
  }
  if (isEmpty(left)) {
    return _right;
  }
  if (isLeftAncestorOfRight(_left, _right)) {
    return _right;
  }
  if (doesLeftHaveRightAncestor(_left, _right)) {
    return _left;
  }
  const includeRegExpList = takeRightOtherwiseLeft(_left.includeRegExpList, _right.includeRegExpList);
  const optionals = includeRegExpList?.length ? { includeRegExpList } : {};
  const version2 = max3(_left.version, _right.version);
  const valuesToClear = {
    name: undefined,
    id: undefined,
    description: undefined,
    globRoot: undefined,
    import: undefined,
    __importRef: undefined
  };
  const settings = cleanCSpellSettingsInternal({
    ..._left,
    ..._right,
    ...optionals,
    ...valuesToClear,
    version: version2,
    words: mergeWordsCached(_left.words, _right.words),
    userWords: mergeWordsCached(_left.userWords, _right.userWords),
    flagWords: mergeWordsCached(_left.flagWords, _right.flagWords),
    ignoreWords: mergeWordsCached(_left.ignoreWords, _right.ignoreWords),
    suggestWords: mergeWordsCached(_left.suggestWords, _right.suggestWords),
    enabledLanguageIds: replaceIfNotEmpty(_left.enabledLanguageIds, _right.enabledLanguageIds),
    enableFiletypes: mergeList(_left.enableFiletypes, _right.enableFiletypes),
    enabledFileTypes: mergeObjects(_left.enabledFileTypes, _right.enabledFileTypes),
    ignoreRegExpList: mergeListUnique(_left.ignoreRegExpList, _right.ignoreRegExpList),
    patterns: mergeListUnique(_left.patterns, _right.patterns),
    dictionaryDefinitions: mergeListUnique(_left.dictionaryDefinitions, _right.dictionaryDefinitions),
    dictionaries: mergeListUnique(_left.dictionaries, _right.dictionaries),
    noSuggestDictionaries: mergeListUnique(_left.noSuggestDictionaries, _right.noSuggestDictionaries),
    languageSettings: mergeList(_left.languageSettings, _right.languageSettings),
    enabled: _right.enabled !== undefined ? _right.enabled : _left.enabled,
    files: mergeListUnique(_left.files, _right.files),
    ignorePaths: versionBasedMergeList(_left.ignorePaths, _right.ignorePaths, version2),
    overrides: versionBasedMergeList(_left.overrides, _right.overrides, version2),
    features: mergeObjects(_left.features, _right.features),
    source: mergeSources(_left, _right),
    plugins: mergeList(_left.plugins, _right.plugins),
    __imports: mergeImportRefs(_left, _right)
  });
  return settings;
}
function versionBasedMergeList(left, right, version2) {
  if (version2 === configSettingsFileVersion0_1) {
    return takeRightOtherwiseLeft(left, right);
  }
  return mergeListUnique(left, right);
}
function isLeftAncestorOfRight(left, right) {
  return hasAncestor(right, left, 0);
}
function doesLeftHaveRightAncestor(left, right) {
  return hasAncestor(left, right, 1);
}
function hasAncestor(s, ancestor, side) {
  const sources = s.source?.sources;
  if (!sources)
    return false;
  const i = side ? sources.length - 1 : 0;
  const src = sources[i];
  return src === ancestor || src && hasAncestor(src, ancestor, side) || false;
}
function takeRightOtherwiseLeft(left, right) {
  if (right?.length) {
    return right;
  }
  return left || right;
}
function finalizeSettings(settings) {
  return _finalizeSettings(toInternalSettings(settings));
}
function _finalizeSettings(settings) {
  const finalized = {
    ...settings,
    finalized: true,
    ignoreRegExpList: resolvePatterns(settings.ignoreRegExpList, settings.patterns),
    includeRegExpList: resolvePatterns(settings.includeRegExpList, settings.patterns),
    parserFn: resolveParser(settings)
  };
  finalized.name = "Finalized " + (finalized.name || "");
  finalized.source = { name: settings.name || "src", sources: [settings] };
  return finalized;
}
function toInternalSettings(settings) {
  if (settings === undefined)
    return;
  if (isCSpellSettingsInternal(settings))
    return settings;
  return cacheInternalSettings.get(settings, _toInternalSettings);
}
function _toInternalSettings(settings) {
  const { dictionaryDefinitions: defs, ...rest } = settings;
  const dictionaryDefinitions = defs && mapDictDefsToInternal(defs, settings.source?.filename && toFileUrl(settings.source?.filename) || resolveCwd());
  const setting = dictionaryDefinitions ? { ...rest, dictionaryDefinitions } : rest;
  return cleanCSpellSettingsInternal(setting);
}
function mergeSources(left, right) {
  return {
    name: "merged",
    sources: [left, right]
  };
}
function max3(a, b) {
  if (a === undefined || a === null)
    return b;
  if (b === undefined || b === null)
    return a;
  return a > b ? a : b;
}
function getSources(settings) {
  const visited = new Set;
  const sources = [];
  function _walkSourcesTree(settings2) {
    if (!settings2 || visited.has(settings2))
      return;
    visited.add(settings2);
    if (!settings2.source?.sources?.length) {
      sources.push(settings2);
      return;
    }
    settings2.source.sources.forEach(_walkSourcesTree);
  }
  _walkSourcesTree(settings);
  return sources;
}
function mergeImportRefs(left, right = {}) {
  const imports = new Map(left.__imports || []);
  if (left.__importRef) {
    imports.set(left.__importRef.filename, left.__importRef);
  }
  if (right.__importRef) {
    imports.set(right.__importRef.filename, right.__importRef);
  }
  const rightImports = right.__imports?.values() || [];
  for (const ref of rightImports) {
    imports.set(ref.filename, ref);
  }
  return imports.size ? imports : undefined;
}
function resolveCwd() {
  return cwdResolver.resolveUrl(envCSpellGlobRoot);
}
function resolveParser(settings) {
  if (!settings.parser)
    return;
  if (typeof settings.parser === "function")
    return settings.parser;
  const parserName = settings.parser;
  assert13(typeof parserName === "string");
  const parsers = extractParsers(settings.plugins);
  const parser = parsers.get(parserName);
  assert13(parser, `Parser "${parserName}" not found.`);
  return parser;
}
function* parsers(plugins) {
  for (const plugin of plugins) {
    if (!plugin.parsers)
      continue;
    for (const parser of plugin.parsers) {
      yield [parser.name, parser];
    }
  }
}
function mapPlugins(plugins) {
  return new Map(parsers(plugins));
}
function extractParsers(plugins) {
  if (!plugins || !plugins.length)
    return emptyParserMap;
  return parserCache.get(plugins, mapPlugins);
}

// node_modules/cspell-lib/dist/lib/getDictionary.js
async function getDictionary(settings) {
  return getDictionaryInternal(toInternalSettings(settings));
}
// node_modules/cspell-lib/dist/lib/perf/timer.js
function createPerfTimer2(name, onEnd, timeNowFn) {
  return new SimpleTimer(name, onEnd, timeNowFn);
}

class SimpleTimer {
  name;
  onEnd;
  timeNowFn;
  _start = performance.now();
  _elapsed = undefined;
  _running = true;
  constructor(name, onEnd, timeNowFn = performance.now) {
    this.name = name;
    this.onEnd = onEnd;
    this.timeNowFn = timeNowFn;
  }
  get startTime() {
    return this._start;
  }
  get elapsed() {
    return this._elapsed ?? performance.now() - this._start;
  }
  end() {
    if (!this._running)
      return;
    this._running = false;
    const end = performance.now();
    this._elapsed = end - this._start;
    this.onEnd?.(this._elapsed, this.name);
  }
  start() {
    this._start = performance.now();
    this._running = true;
  }
}
// node_modules/cspell-lib/dist/lib/globs/getGlobMatcher.js
var simpleGlobCache = new Map;
var globCache = new WeakMap;
onClearCache(() => {
  globCache = new WeakMap;
  simpleGlobCache.clear();
});
var emptyIgnorePaths = [];
function getGlobMatcherForExcluding(glob) {
  if (!glob || Array.isArray(glob) && !glob.length)
    return getGlobMatcherGlobGlob(emptyIgnorePaths);
  return typeof glob === "string" ? getGlobMatcherGlobString(glob) : getGlobMatcherGlobGlob(glob);
}
function getGlobMatcherGlobString(glob) {
  const cached = simpleGlobCache.get(glob);
  if (cached)
    return cached;
  const m = new GlobMatcher(glob);
  simpleGlobCache.set(glob, m);
  return m;
}
function getGlobMatcherGlobGlob(glob) {
  const cached = globCache.get(glob);
  if (cached)
    return cached;
  const m = new GlobMatcher(glob);
  globCache.set(glob, m);
  return m;
}

// node_modules/cspell-lib/dist/lib/globs/checkFilenameMatchesGlob.js
function checkFilenameMatchesExcludeGlob(filename, globs) {
  const m = getGlobMatcherForExcluding(globs);
  return m.match(filename);
}

// node_modules/cspell-lib/dist/lib/Settings/calcOverrideSettings.js
function calcOverrideSettings(settings, filename) {
  const _settings = toInternalSettings(settings);
  const overrides = _settings.overrides || [];
  const result = overrides.filter((override) => checkFilenameMatchesExcludeGlob(filename, override.filename)).reduce((settings2, override) => mergeSettings(settings2, override), _settings);
  return result;
}
// node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/configLoader.js
import assert14 from "node:assert";
import path10 from "node:path";
import { fileURLToPath as fileURLToPath12 } from "node:url";

// node_modules/cspell-config-lib/dist/CSpellConfigFileReaderWriter.js
import { extname as extname2 } from "node:path/posix";

// node_modules/cspell-config-lib/dist/CSpellConfigFile.js
class CSpellConfigFile {
  url;
  constructor(url2) {
    this.url = url2;
  }
  get readonly() {
    return this.settings.readonly || this.url.protocol !== "file:";
  }
  get virtual() {
    return false;
  }
  get remote() {
    return this.url.protocol !== "file:";
  }
}

class ImplCSpellConfigFile extends CSpellConfigFile {
  url;
  settings;
  constructor(url2, settings) {
    super(url2);
    this.url = url2;
    this.settings = settings;
  }
  addWords(words) {
    if (this.readonly)
      throw new Error(`Config file is readonly: ${this.url.href}`);
    const w = this.settings.words || [];
    this.settings.words = w;
    addUniqueWordsToListAndSort(w, words);
    return this;
  }
}
function addUniqueWordsToListAndSort(list, toAdd) {
  list.unshift(...toAdd);
  list.sort();
  for (let i = 1;i < list.length; ++i) {
    if (list[i] === list[i - 1]) {
      list.splice(i, 1);
      --i;
    }
  }
}
function satisfiesCSpellConfigFile(obj) {
  const r = obj instanceof CSpellConfigFile || !!obj && typeof obj === "object" && "url" in obj && obj.url instanceof URL && "settings" in obj && !!obj.settings && typeof obj.settings === "object";
  return r;
}

// node_modules/cspell-config-lib/dist/CSpellConfigFile/CSpellConfigFileInMemory.js
class CSpellConfigFileInMemory extends ImplCSpellConfigFile {
  url;
  settings;
  constructor(url2, settings) {
    super(url2, settings);
    this.url = url2;
    this.settings = settings;
  }
  get virtual() {
    return true;
  }
}
// node_modules/cspell-config-lib/dist/CSpellConfigFile/CSpellConfigFileJavaScript.js
class CSpellConfigFileJavaScript extends ImplCSpellConfigFile {
  url;
  settings;
  get readonly() {
    return true;
  }
  constructor(url2, settings) {
    super(url2, settings);
    this.url = url2;
    this.settings = settings;
  }
  addWords(_words) {
    throw new Error("Unable to add words to a JavaScript config file.");
  }
}

// node_modules/cspell-config-lib/dist/CSpellConfigFile/CSpellConfigFileJson.js
var import_comment_json = __toESM(require_src2(), 1);

// node_modules/cspell-config-lib/dist/serializers/util.js
function detectIndent(content) {
  const m = content.match(/^[ \t]+/m);
  return m && m[0] || "  ";
}
function detectIndentAsNum(content) {
  const indent = detectIndent(content).replaceAll("\t", "    ").replaceAll(/[^ ]/g, "");
  return indent.length;
}

// node_modules/cspell-config-lib/dist/CSpellConfigFile/CSpellConfigFileJson.js
class CSpellConfigFileJson extends ImplCSpellConfigFile {
  url;
  settings;
  indent = 2;
  constructor(url2, settings) {
    super(url2, settings);
    this.url = url2;
    this.settings = settings;
  }
  serialize() {
    return import_comment_json.stringify(this.settings, undefined, this.indent) + `
`;
  }
  static parse(file) {
    try {
      const cspell = import_comment_json.parse(file.content);
      if (!isCSpellSettings(cspell)) {
        throw new ParseError(file.url);
      }
      const indent = detectIndent(file.content);
      const cfg = new CSpellConfigFileJson(file.url, cspell);
      cfg.indent = indent;
      return cfg;
    } catch (cause) {
      if (cause instanceof ParseError) {
        throw cause;
      }
      throw new ParseError(file.url, undefined, { cause });
    }
  }
}
function parseCSpellConfigFileJson(file) {
  return CSpellConfigFileJson.parse(file);
}
function isCSpellSettings(cfg) {
  return !(!cfg || typeof cfg !== "object" || Array.isArray(cfg));
}

class ParseError extends Error {
  url;
  constructor(url2, message, options) {
    super(message || `Unable to parse ${url2}`, options);
    this.url = url2;
  }
}
// node_modules/cspell-config-lib/dist/CSpellConfigFile/CSpellConfigFilePackageJson.js
class CSpellConfigFilePackageJson extends ImplCSpellConfigFile {
  url;
  settings;
  serializer;
  constructor(url2, settings, serializer) {
    super(url2, settings);
    this.url = url2;
    this.settings = settings;
    this.serializer = serializer;
  }
  serialize() {
    return this.serializer(this.settings);
  }
}
function parseCSpellConfigFilePackageJson(file) {
  const { url: url2, content } = file;
  const packageJson = JSON.parse(content);
  if (!packageJson || typeof packageJson !== "object" || Array.isArray(packageJson)) {
    throw new Error(`Unable to parse ${url2}`);
  }
  packageJson["cspell"] = packageJson["cspell"] || {};
  const cspell = packageJson["cspell"];
  if (typeof cspell !== "object" || Array.isArray(cspell)) {
    throw new TypeError(`Unable to parse ${url2}`);
  }
  const indent = detectIndent(content);
  function serialize(settings) {
    packageJson["cspell"] = settings;
    return JSON.stringify(packageJson, undefined, indent) + `
`;
  }
  return new CSpellConfigFilePackageJson(url2, cspell, serialize);
}

// node_modules/yaml/dist/index.js
var composer = require_composer();
var Document = require_Document();
var Schema = require_Schema();
var errors = require_errors();
var Alias = require_Alias();
var identity = require_identity();
var Pair = require_Pair();
var Scalar = require_Scalar();
var YAMLMap = require_YAMLMap();
var YAMLSeq = require_YAMLSeq();
var cst = require_cst();
var lexer = require_lexer();
var lineCounter = require_line_counter();
var parser = require_parser();
var publicApi = require_public_api();
var visit = require_visit();
var $Composer = composer.Composer;
var $Document = Document.Document;
var $Schema = Schema.Schema;
var $YAMLError = errors.YAMLError;
var $YAMLParseError = errors.YAMLParseError;
var $YAMLWarning = errors.YAMLWarning;
var $Alias = Alias.Alias;
var $isAlias = identity.isAlias;
var $isCollection = identity.isCollection;
var $isDocument = identity.isDocument;
var $isMap = identity.isMap;
var $isNode = identity.isNode;
var $isPair = identity.isPair;
var $isScalar = identity.isScalar;
var $isSeq = identity.isSeq;
var $Pair = Pair.Pair;
var $Scalar = Scalar.Scalar;
var $YAMLMap = YAMLMap.YAMLMap;
var $YAMLSeq = YAMLSeq.YAMLSeq;
var $Lexer = lexer.Lexer;
var $LineCounter = lineCounter.LineCounter;
var $Parser = parser.Parser;
var $parse = publicApi.parse;
var $parseAllDocuments = publicApi.parseAllDocuments;
var $parseDocument = publicApi.parseDocument;
var $stringify = publicApi.stringify;
var $visit = visit.visit;
var $visitAsync = visit.visitAsync;

// node_modules/cspell-config-lib/dist/CSpellConfigFile/CSpellConfigFileYaml.js
class CSpellConfigFileYaml extends ImplCSpellConfigFile {
  url;
  settings;
  serializer;
  constructor(url2, settings, serializer) {
    super(url2, settings);
    this.url = url2;
    this.settings = settings;
    this.serializer = serializer;
  }
  serialize() {
    return this.serializer(this.settings);
  }
}
function parseCSpellConfigFileYaml(file) {
  const { url: url2, content } = file;
  const cspell = $parse(content) || {};
  if (!cspell || typeof cspell !== "object" || Array.isArray(cspell)) {
    throw new Error(`Unable to parse ${url2}`);
  }
  const indent = detectIndentAsNum(content);
  function serialize(settings) {
    return $stringify(settings, { indent });
  }
  return new CSpellConfigFileYaml(url2, cspell, serialize);
}

// node_modules/cspell-config-lib/dist/defaultNext.js
var defaultNextDeserializer = (content) => {
  throw new Error(`Unable to parse config file: "${content.url}"`);
};
var defaultNextSerializer = (file) => {
  throw new Error(`Unable to serialize config file: "${file.url}"`);
};

// node_modules/cspell-config-lib/dist/middlewareHelper.js
function getDeserializer(middleware) {
  let next = defaultNextDeserializer;
  for (const des of middleware) {
    next = curryDeserialize(des, next);
  }
  return next;
}
function getSerializer(middleware) {
  let next = defaultNextSerializer;
  for (const des of middleware) {
    next = currySerialize(des, next);
  }
  return next;
}
function curryDeserialize(middle, next) {
  return (content) => middle.deserialize(content, next);
}
function currySerialize(middle, next) {
  return (cfg) => middle.serialize(cfg, next);
}
function curryLoader(loader2, next) {
  return (req) => loader2.load(req, next);
}
async function defaultLoader(req) {
  const { io, deserialize } = req.context;
  const url2 = req.url;
  const file = await io.readFile(url2);
  return deserialize(file);
}
function getLoader(loaders2) {
  let next = defaultLoader;
  for (const loader2 of loaders2) {
    next = curryLoader(loader2, next);
  }
  return next;
}

// node_modules/cspell-config-lib/dist/util/toURL.js
function toURL3(url2) {
  return typeof url2 === "string" ? new URL(url2) : url2;
}

// node_modules/cspell-config-lib/dist/CSpellConfigFileReaderWriter.js
class CSpellConfigFileReaderWriterImpl {
  io;
  middleware;
  loaders;
  constructor(io, middleware, loaders2) {
    this.io = io;
    this.middleware = middleware;
    this.loaders = loaders2;
  }
  _untrustedExtensions = new Set;
  _trustedUrls = [];
  get untrustedExtensions() {
    return [...this._untrustedExtensions];
  }
  get trustedUrls() {
    return [...this._trustedUrls].map((url2) => new URL(url2));
  }
  readConfig(uri) {
    const url2 = new URL(uri);
    if (!isTrusted(url2, this._trustedUrls, this._untrustedExtensions)) {
      return Promise.reject(new UntrustedUrlError(url2));
    }
    const loader2 = getLoader(this.loaders);
    return loader2({ url: toURL3(uri), context: { deserialize: this.getDeserializer(), io: this.io } });
  }
  toCSpellConfigFile(configFile) {
    return configFile instanceof CSpellConfigFile ? configFile : new CSpellConfigFileInMemory(configFile.url, configFile.settings);
  }
  getDeserializer() {
    return getDeserializer(this.middleware);
  }
  serialize(configFile) {
    const serializer = getSerializer(this.middleware);
    return serializer(configFile);
  }
  async writeConfig(configFile) {
    if (configFile.readonly)
      throw new Error(`Config file is readonly: ${configFile.url.href}`);
    const content = this.serialize(configFile);
    await this.io.writeFile({ url: configFile.url, content });
    return { url: configFile.url };
  }
  setUntrustedExtensions(ext) {
    this._untrustedExtensions.clear();
    ext.forEach((e) => this._untrustedExtensions.add(e.toLowerCase()));
    return this;
  }
  setTrustedUrls(urls) {
    this._trustedUrls = [...new Set(urls.map((url2) => new URL(url2).href))].sort();
    return this;
  }
  clearCachedFiles() {
    for (const loader2 of this.loaders) {
      loader2.reset?.();
    }
  }
}
function isTrusted(url2, trustedUrls, untrustedExtensions) {
  const path6 = url2.pathname;
  const ext = extname2(path6).toLowerCase();
  if (!untrustedExtensions.has(ext))
    return true;
  const href = url2.href;
  return trustedUrls.some((trustedUrl) => href.startsWith(trustedUrl));
}

class UntrustedUrlError extends Error {
  constructor(url2) {
    super(`Untrusted URL: "${url2.href}"`);
  }
}

// node_modules/cspell-config-lib/dist/defaultIO.js
import { promises as fs4 } from "node:fs";
var defaultIO = {
  readFile,
  writeFile: writeFile2
};
async function readFile(url2) {
  const content = await fs4.readFile(url2, "utf8");
  return { url: url2, content };
}
async function writeFile2(file) {
  await fs4.writeFile(file.url, file.content);
  return { url: file.url };
}

// node_modules/cspell-config-lib/dist/loaders/loaderJavaScript.js
import { extname as extname3 } from "node:path/posix";
var _debug = false;
var _log = _debug ? console.warn.bind(console) : () => {
  return;
};
async function importJavaScript(url2, hashSuffix) {
  try {
    const _url = new URL(url2.href);
    _url.hash = `${_url.hash};loaderSuffix=${hashSuffix}`;
    _log("importJavaScript: %o", { url: _url.href });
    const result = await import(_url.href);
    const settingsOrFunction = await (result.default ?? result);
    const settings = typeof settingsOrFunction === "function" ? await settingsOrFunction() : settingsOrFunction;
    return new CSpellConfigFileJavaScript(url2, settings);
  } catch (e) {
    _log("importJavaScript Error: %o", { url: url2.href, error: e, hashSuffix });
    throw e;
  } finally {
    _log("importJavaScript Done: %o", { url: url2.href, hashSuffix });
  }
}

class LoaderJavaScript {
  hashSuffix = 1;
  async _load(req, next) {
    const { url: url2 } = req;
    const ext = extname3(url2.pathname).toLowerCase();
    switch (ext) {
      case ".js":
      case ".cjs":
      case ".mjs": {
        return importJavaScript(url2, this.hashSuffix);
      }
    }
    return next(req);
  }
  load = this._load.bind(this);
  reset() {
    this.hashSuffix += 1;
  }
}
var loaderJavaScript = new LoaderJavaScript;

// node_modules/cspell-config-lib/dist/loaders/index.js
var defaultLoaders = [loaderJavaScript];

// node_modules/cspell-config-lib/dist/serializers/cspellJson.js
function deserializer(params, next) {
  if (!isJsonFile(params.url.pathname))
    return next(params);
  return parseCSpellConfigFileJson(params);
}
function isJsonFile(pathname) {
  pathname = pathname.toLowerCase();
  return pathname.endsWith(".json") || pathname.endsWith(".jsonc");
}
function serializer(settings, next) {
  if (!(settings instanceof CSpellConfigFileJson))
    return next(settings);
  return settings.serialize();
}
var serializerCSpellJson = { deserialize: deserializer, serialize: serializer };

// node_modules/cspell-config-lib/dist/serializers/cspellYaml.js
function deserializer2(params, next) {
  if (!isYamlFile(params.url.pathname))
    return next(params);
  return parseCSpellConfigFileYaml(params);
}
function isYamlFile(pathname) {
  pathname = pathname.toLowerCase();
  return pathname.endsWith(".yml") || pathname.endsWith(".yaml");
}
function serializer2(settings, next) {
  if (!(settings instanceof CSpellConfigFileYaml))
    return next(settings);
  return settings.serialize();
}
var serializerCSpellYaml = { deserialize: deserializer2, serialize: serializer2 };

// node_modules/cspell-config-lib/dist/serializers/packageJson.js
var isSupportedFormat = /\bpackage\.json$/i;
function deserializer3(params, next) {
  if (!isSupportedFormat.test(params.url.pathname))
    return next(params);
  return parseCSpellConfigFilePackageJson(params);
}
function serializer3(settings, next) {
  if (!(settings instanceof CSpellConfigFilePackageJson))
    return next(settings);
  return settings.serialize();
}
var serializerPackageJson = { deserialize: deserializer3, serialize: serializer3 };

// node_modules/cspell-config-lib/dist/serializers/index.js
var defaultDeserializers = [
  serializerCSpellJson,
  serializerCSpellYaml,
  serializerPackageJson
];

// node_modules/cspell-config-lib/dist/createReaderWriter.js
function createReaderWriter(deserializers2 = [], loaders2 = [], io = defaultIO) {
  return new CSpellConfigFileReaderWriterImpl(io, [...defaultDeserializers, ...deserializers2], [...defaultLoaders, ...loaders2]);
}
// node_modules/cspell-lib/dist/lib/util/logger.js
var _logger = console;
function logError(...args) {
  _logger.error(...args);
}
function logWarning(...args) {
  _logger.warn(...args);
}

// node_modules/cspell-lib/dist/lib/Settings/cfgStore.js
import fs6 from "node:fs/promises";
import path8 from "node:path";

// node_modules/env-paths/index.js
import path6 from "node:path";
import os3 from "node:os";
import process4 from "node:process";
var homedir2 = os3.homedir();
var tmpdir = os3.tmpdir();
var { env } = process4;
var macos = (name) => {
  const library = path6.join(homedir2, "Library");
  return {
    data: path6.join(library, "Application Support", name),
    config: path6.join(library, "Preferences", name),
    cache: path6.join(library, "Caches", name),
    log: path6.join(library, "Logs", name),
    temp: path6.join(tmpdir, name)
  };
};
var windows = (name) => {
  const appData = env.APPDATA || path6.join(homedir2, "AppData", "Roaming");
  const localAppData = env.LOCALAPPDATA || path6.join(homedir2, "AppData", "Local");
  return {
    data: path6.join(localAppData, name, "Data"),
    config: path6.join(appData, name, "Config"),
    cache: path6.join(localAppData, name, "Cache"),
    log: path6.join(localAppData, name, "Log"),
    temp: path6.join(tmpdir, name)
  };
};
var linux = (name) => {
  const username = path6.basename(homedir2);
  return {
    data: path6.join(env.XDG_DATA_HOME || path6.join(homedir2, ".local", "share"), name),
    config: path6.join(env.XDG_CONFIG_HOME || path6.join(homedir2, ".config"), name),
    cache: path6.join(env.XDG_CACHE_HOME || path6.join(homedir2, ".cache"), name),
    log: path6.join(env.XDG_STATE_HOME || path6.join(homedir2, ".local", "state"), name),
    temp: path6.join(tmpdir, username, name)
  };
};
function envPaths(name, { suffix = "nodejs" } = {}) {
  if (typeof name !== "string") {
    throw new TypeError(`Expected a string, got ${typeof name}`);
  }
  if (suffix) {
    name += `-${suffix}`;
  }
  if (process4.platform === "darwin") {
    return macos(name);
  }
  if (process4.platform === "win32") {
    return windows(name);
  }
  return linux(name);
}

// node_modules/xdg-basedir/index.js
import os4 from "os";
import path7 from "path";
var homeDirectory = os4.homedir();
var { env: env2 } = process;
var xdgData = env2.XDG_DATA_HOME || (homeDirectory ? path7.join(homeDirectory, ".local", "share") : undefined);
var xdgConfig = env2.XDG_CONFIG_HOME || (homeDirectory ? path7.join(homeDirectory, ".config") : undefined);
var xdgState = env2.XDG_STATE_HOME || (homeDirectory ? path7.join(homeDirectory, ".local", "state") : undefined);
var xdgCache = env2.XDG_CACHE_HOME || (homeDirectory ? path7.join(homeDirectory, ".cache") : undefined);
var xdgRuntime = env2.XDG_RUNTIME_DIR || undefined;
var xdgDataDirectories = (env2.XDG_DATA_DIRS || "/usr/local/share/:/usr/share/").split(":");
if (xdgData) {
  xdgDataDirectories.unshift(xdgData);
}
var xdgConfigDirectories = (env2.XDG_CONFIG_DIRS || "/etc/xdg").split(":");
if (xdgConfig) {
  xdgConfigDirectories.unshift(xdgConfig);
}

// node_modules/cspell-lib/dist/lib/Settings/cfgStore.js
var packageName = "cspell";
var legacyLocationDir = xdgConfig ? path8.join(xdgConfig, "configstore") : undefined;
var cspellGlobalLocationDir = envPaths(packageName, { suffix: "" }).config;
var defaultConfigFileName = "cspell.json";
var searchOrder = [cspellGlobalLocationDir, legacyLocationDir].filter(isDefined6);

class GlobalConfigStore {
  #foundLocation;
  #baseFilename;
  constructor(filename = defaultConfigFileName) {
    this.#baseFilename = filename;
  }
  async#readConfigFile(location) {
    try {
      const json = await fs6.readFile(location, "utf8");
      return { filename: location, config: JSON.parse(json) };
    } catch {
      return;
    }
  }
  async readConfigFile() {
    if (this.#foundLocation) {
      const found = await this.#readConfigFile(this.#foundLocation);
      if (found)
        return found;
    }
    const firstFile = path8.resolve(cspellGlobalLocationDir, this.#baseFilename);
    const possibleLocations = new Set([
      firstFile,
      ...searchOrder.map((p) => path8.resolve(p, defaultConfigFileName))
    ]);
    for (const filename of possibleLocations) {
      const found = await this.#readConfigFile(filename);
      if (found) {
        this.#foundLocation = found.filename;
        return found;
      }
    }
    return;
  }
  async writeConfigFile(cfg) {
    this.#foundLocation ??= path8.join(cspellGlobalLocationDir, this.#baseFilename);
    await fs6.mkdir(path8.dirname(this.#foundLocation), { recursive: true });
    await fs6.writeFile(this.#foundLocation, JSON.stringify(cfg, undefined, 2) + `
`);
    return this.#foundLocation;
  }
  get location() {
    return this.#foundLocation;
  }
  static create() {
    return new this;
  }
  static defaultLocation = path8.join(cspellGlobalLocationDir, defaultConfigFileName);
}

// node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/normalizeRawSettings.js
import { homedir as homedir3 } from "node:os";
import { fileURLToPath as fileURLToPath9 } from "node:url";

// node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/toGlobDef.js
function toGlobDef(g, root, source) {
  if (g === undefined)
    return;
  if (Array.isArray(g)) {
    return g.map((g2) => toGlobDef(g2, root, source));
  }
  if (typeof g === "string") {
    const glob = { glob: g };
    if (root !== undefined) {
      glob.root = root;
    }
    return toGlobDef(glob, root, source);
  }
  if (source) {
    return { ...g, source };
  }
  return g;
}

// node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/normalizeRawSettings.js
function normalizeRawConfig(config) {
  if (typeof config.version === "number") {
    config.version = config.version.toString();
  }
  if (config.import) {
    config.import = normalizeImport(config.import);
  }
}
function normalizeDictionaryDefs(settings, settingsFileUrl) {
  const dictionaryDefinitions = mapDictDefsToInternal(settings.dictionaryDefinitions, settingsFileUrl);
  const languageSettings = settings.languageSettings?.map((langSetting) => clean5({
    ...langSetting,
    dictionaryDefinitions: mapDictDefsToInternal(langSetting.dictionaryDefinitions, settingsFileUrl)
  }));
  return clean5({
    dictionaryDefinitions,
    languageSettings
  });
}
function normalizeOverrides(settings, pathToSettingsFile) {
  const { globRoot = toFilePathOrHref(new URL(".", pathToSettingsFile)) } = settings;
  const overrides = settings.overrides?.map((override) => {
    const filename = toGlobDef(override.filename, globRoot, toFilePathOrHref(pathToSettingsFile));
    const { dictionaryDefinitions, languageSettings } = normalizeDictionaryDefs(override, pathToSettingsFile);
    return clean5({
      ...override,
      filename,
      dictionaryDefinitions,
      languageSettings: normalizeLanguageSettings(languageSettings)
    });
  });
  return overrides ? { overrides } : {};
}
async function normalizeReporters(settings, pathToSettingsFile) {
  if (settings.reporters === undefined)
    return {};
  async function resolve3(s) {
    if (s === "default")
      return s;
    const r = await resolveFile(s, pathToSettingsFile);
    if (!r.found) {
      throw new Error(`Not found: "${s}"`);
    }
    return r.filename;
  }
  async function resolveReporter(s) {
    if (typeof s === "string") {
      return resolve3(s);
    }
    if (!Array.isArray(s) || typeof s[0] !== "string")
      throw new Error("Invalid Reporter");
    const [r, ...rest] = s;
    return [await resolve3(r), ...rest];
  }
  return {
    reporters: await Promise.all(settings.reporters.map(resolveReporter))
  };
}
function normalizeLanguageSettings(languageSettings) {
  if (!languageSettings)
    return;
  function fixLocale(s) {
    const { local: locale, ...rest } = s;
    return clean5({ locale, ...rest });
  }
  return languageSettings.map(fixLocale);
}
function normalizeGitignoreRoot(settings, pathToSettingsFile) {
  const { gitignoreRoot } = settings;
  if (!gitignoreRoot)
    return {};
  const roots = Array.isArray(gitignoreRoot) ? gitignoreRoot : [gitignoreRoot];
  return {
    gitignoreRoot: roots.map((p) => resolveFilePathToPath(p, pathToSettingsFile))
  };
}
function normalizeSettingsGlobs(settings, pathToSettingsFile) {
  const { globRoot } = settings;
  const normalized = {};
  if (settings.ignorePaths) {
    normalized.ignorePaths = toGlobDef(settings.ignorePaths, globRoot, toFilePathOrHref(pathToSettingsFile));
  }
  if (settings.files) {
    normalized.files = toGlobDef(settings.files, globRoot, toFilePathOrHref(pathToSettingsFile));
  }
  return normalized;
}
function normalizeCacheSettings(settings, pathToSettingsFile) {
  const { cache: cache5 } = settings;
  if (cache5 === undefined)
    return {};
  const { cacheLocation } = cache5;
  if (cacheLocation === undefined)
    return { cache: cache5 };
  return { cache: { ...cache5, cacheLocation: toFilePathOrHref(resolveFilePath(cacheLocation, pathToSettingsFile)) } };
}
function resolveFilePath(filename, pathToSettingsFile) {
  const cwd = process.cwd();
  return toFileURL(filename.replace("${cwd}", cwd).replace(/^~/, homedir3()), pathToSettingsFile);
}
function resolveFilePathToPath(filename, pathToSettingsFile) {
  const url2 = resolveFilePath(filename, pathToSettingsFile);
  return url2.protocol === "file:" ? fileURLToPath9(url2) : url2.toString();
}
function normalizeImport(imports) {
  if (typeof imports === "string") {
    return [imports];
  }
  if (Array.isArray(imports)) {
    return imports;
  }
  return [];
}

// node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/configToRawSettings.js
function configToRawSettings(cfgFile) {
  if (!cfgFile)
    return {};
  const url2 = cfgFile.url;
  const filename = toFilePathOrHref(url2);
  const fileRef = {
    filename,
    error: undefined
  };
  const source = {
    name: cfgFile.settings.name || filename,
    filename: cfgFile.virtual ? undefined : filename
  };
  const rawSettings = { ...cfgFile.settings };
  rawSettings.import = normalizeImport(rawSettings.import);
  normalizeRawConfig(rawSettings);
  rawSettings.source = source;
  if (!cfgFile.virtual) {
    rawSettings.__importRef = fileRef;
  }
  const id = rawSettings.id || urlToSimpleId(url2);
  const name = rawSettings.name || id;
  rawSettings.id = id;
  rawSettings.name = cfgFile.settings.name || name;
  return rawSettings;
}
function urlToSimpleId(url2) {
  return url2.pathname.split("/").slice(-2).join("/");
}

// node_modules/cspell-lib/dist/lib/Settings/GlobalSettings.js
var globalConfig = new GlobalConfigStore;
async function getGlobalConfig() {
  const name = "CSpell Configstore";
  const configPath = getGlobalConfigPath();
  let urlGlobal = configPath ? toFileURL(configPath) : new URL("global-config.json", getSourceDirectoryUrl());
  const source = {
    name,
    filename: toFilePathOrHref(urlGlobal)
  };
  const globalConf = { source };
  let hasGlobalConfig = false;
  const found = await globalConfig.readConfigFile();
  if (found && found.config && found.filename) {
    const cfg = found.config;
    urlGlobal = toFileURL(found.filename);
    if (cfg && Object.keys(cfg).length) {
      Object.assign(globalConf, cfg);
      globalConf.source = {
        name,
        filename: found.filename
      };
      hasGlobalConfig = Object.keys(cfg).length > 0;
    }
  }
  const settings = { ...globalConf, name, source };
  const ConfigFile = hasGlobalConfig ? CSpellConfigFileJson : CSpellConfigFileInMemory;
  return new ConfigFile(urlGlobal, settings);
}
function getGlobalConfigPath() {
  try {
    return globalConfig.location || GlobalConfigStore.defaultLocation;
  } catch {
    return;
  }
}

// node_modules/cspell-lib/dist/lib/Settings/Controller/ImportError.js
class ImportError extends Error {
  cause;
  constructor(msg, cause) {
    super(msg);
    this.cause = isError(cause) ? cause : undefined;
  }
}
class UnsupportedPnpFile extends Error {
  constructor(msg) {
    super(msg);
  }
}

// node_modules/cspell-lib/dist/lib/Settings/Controller/pnpLoader.js
var import_clear_module = __toESM(require_clear_module(), 1);
var import_import_fresh = __toESM(require_import_fresh(), 1);
import { fileURLToPath as fileURLToPath11 } from "node:url";

// node_modules/cspell-lib/dist/lib/util/findUp.js
import { stat } from "node:fs/promises";
import path9 from "node:path";
import { fileURLToPath as fileURLToPath10 } from "node:url";
async function findUp(name, options = {}) {
  const { cwd = process.cwd(), type: entryType = "file", stopAt } = options;
  let dir = path9.resolve(toDirPath(cwd));
  const root = path9.parse(dir).root;
  const predicate = makePredicate2(name, entryType);
  const stopAtDir = path9.resolve(toDirPath(stopAt || root));
  while (dir !== root && dir !== stopAtDir) {
    const found = await predicate(dir);
    if (found !== undefined)
      return found;
    dir = path9.dirname(dir);
  }
  return;
}
function makePredicate2(name, entryType) {
  if (typeof name === "function")
    return name;
  const checkStat = entryType === "file" ? "isFile" : "isDirectory";
  function checkName(dir, name2) {
    const f = path9.join(dir, name2);
    return stat(f).then((stats2) => stats2[checkStat]() && f || undefined).catch(() => {
      return;
    });
  }
  if (!Array.isArray(name))
    return (dir) => checkName(dir, name);
  return async (dir) => {
    const pending = name.map((n) => checkName(dir, n));
    for (const p of pending) {
      const found = await p;
      if (found)
        return found;
    }
    return;
  };
}
function toDirPath(urlOrPath) {
  return urlOrPath instanceof URL ? fileURLToPath10(new URL(".", urlOrPath)) : urlOrPath;
}

// node_modules/cspell-lib/dist/lib/Settings/Controller/pnpLoader.js
var defaultPnpFiles = [".pnp.cjs", ".pnp.js"];
var supportedSchemas = new Set(["file:"]);
var cachedRequests = new Map;
var lock = undefined;
var cachedPnpImportsSync = new Map;
var cachedRequestsSync = new Map;

class PnpLoader {
  pnpFiles;
  cacheKeySuffix;
  constructor(pnpFiles = defaultPnpFiles) {
    this.pnpFiles = pnpFiles;
    this.cacheKeySuffix = ":" + pnpFiles.join(",");
  }
  async load(urlDirectory) {
    if (!isSupported(urlDirectory))
      return;
    await lock;
    const cacheKey = this.calcKey(urlDirectory);
    const cached = cachedRequests.get(cacheKey);
    if (cached)
      return cached;
    const r = findPnpAndLoad(urlDirectory, this.pnpFiles);
    cachedRequests.set(cacheKey, r);
    const result = await r;
    cachedRequestsSync.set(cacheKey, result);
    return result;
  }
  async peek(urlDirectory) {
    if (!isSupported(urlDirectory))
      return;
    await lock;
    const cacheKey = this.calcKey(urlDirectory);
    return cachedRequests.get(cacheKey) ?? Promise.resolve(undefined);
  }
  clearCache() {
    return clearPnPGlobalCache();
  }
  calcKey(urlDirectory) {
    return urlDirectory.toString() + this.cacheKeySuffix;
  }
}
function pnpLoader(pnpFiles) {
  return new PnpLoader(pnpFiles);
}
async function findPnpAndLoad(urlDirectory, pnpFiles) {
  const found = await findUp(pnpFiles, { cwd: fileURLToPath11(urlDirectory) });
  return loadPnpIfNeeded(found);
}
function loadPnpIfNeeded(found) {
  if (!found)
    return;
  const c = cachedPnpImportsSync.get(found);
  if (c || cachedPnpImportsSync.has(found))
    return c;
  const r = loadPnp(found);
  cachedPnpImportsSync.set(found, r);
  return r;
}
function loadPnp(pnpFile) {
  const pnp = import_import_fresh.default(pnpFile);
  if (pnp.setup) {
    pnp.setup();
    return toFileUrl(pnpFile);
  }
  throw new UnsupportedPnpFile(`Unsupported pnp file: "${pnpFile}"`);
}
function clearPnPGlobalCache() {
  if (lock)
    return lock;
  lock = _cleanCache().finally(() => {
    lock = undefined;
  });
  return lock;
}
async function _cleanCache() {
  await Promise.all([...cachedRequests.values()].map(rejectToUndefined));
  const modules = [...cachedPnpImportsSync.values()];
  modules.forEach((r) => r && import_clear_module.default.single(fileURLToPath11(r)));
  cachedRequests.clear();
  cachedRequestsSync.clear();
  cachedPnpImportsSync.clear();
  return;
}
function rejectToUndefined(p) {
  return p.catch(() => {
    return;
  });
}
function isSupported(url2) {
  return supportedSchemas.has(url2.protocol);
}

// node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/configLocations.js
var supportedExtensions = [".json", ".jsonc", ".yaml", ".yml", ".mjs", ".cjs", ".js"];
var setOfLocations = new Set([
  "package.json",
  ".cspell.json",
  "cspell.json",
  ".cSpell.json",
  "cSpell.json",
  ".cspell.jsonc",
  "cspell.jsonc",
  ".vscode/cspell.json",
  ".vscode/cSpell.json",
  ".vscode/.cspell.json",
  ".cspell.config.json",
  ".cspell.config.jsonc",
  ".cspell.config.yaml",
  ".cspell.config.yml",
  "cspell.config.json",
  "cspell.config.jsonc",
  "cspell.config.yaml",
  "cspell.config.yml",
  ...genCfgLoc("cspell.config", supportedExtensions),
  ...genCfgLoc(".cspell.config", supportedExtensions),
  ".cspell.yaml",
  ".cspell.yml",
  "cspell.yaml",
  "cspell.yml",
  ".config/.cspell.json",
  ".config/cspell.json",
  ".config/.cSpell.json",
  ".config/cSpell.json",
  ".config/.cspell.jsonc",
  ".config/cspell.jsonc",
  ...genCfgLoc(".config/cspell.config", supportedExtensions),
  ...genCfgLoc(".config/.cspell.config", supportedExtensions),
  ".config/cspell.yaml",
  ".config/cspell.yml"
]);
var searchPlaces = Object.freeze([...setOfLocations]);
var defaultConfigFilenames = Object.freeze([...searchPlaces]);
function genCfgLoc(filename, extensions) {
  return extensions.map((ext) => filename + ext);
}

// node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/configSearch.js
import { extname as extname4 } from "node:path/posix";

// node_modules/cspell-lib/dist/lib/util/findUpFromUrl.js
async function findUpFromUrl2(name, from, options = {}) {
  const fs5 = options.fs ?? getVirtualFS().fs;
  return fs5.findUp(name, from, options);
}

// node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/configSearch.js
class ConfigSearch {
  searchPlaces;
  allowedExtensionsByProtocol;
  fs;
  searchCache = new Map;
  searchDirCache = new Map;
  searchPlacesByProtocol;
  constructor(searchPlaces2, allowedExtensionsByProtocol, fs5) {
    this.searchPlaces = searchPlaces2;
    this.allowedExtensionsByProtocol = allowedExtensionsByProtocol;
    this.fs = fs5;
    this.searchPlacesByProtocol = setupSearchPlacesByProtocol(searchPlaces2, allowedExtensionsByProtocol);
    this.searchPlaces = this.searchPlacesByProtocol.get("*") || searchPlaces2;
  }
  searchForConfig(searchFromURL) {
    const dirUrl = new URL(".", searchFromURL);
    const searchHref = dirUrl.href;
    const searchCache = this.searchCache;
    const cached = searchCache.get(searchHref);
    if (cached) {
      return cached;
    }
    const toPatchCache = [];
    const pFoundUrl = this.findUpConfigPath(dirUrl, storeVisit);
    this.searchCache.set(searchHref, pFoundUrl);
    const searchDirCache = this.searchDirCache;
    const patch = async () => {
      try {
        await pFoundUrl;
        for (const dir of toPatchCache) {
          searchDirCache.set(dir.href, searchDirCache.get(dir.href) || pFoundUrl);
          searchCache.set(dir.href, searchCache.get(dir.href) || pFoundUrl);
        }
        const result = searchCache.get(searchHref) || pFoundUrl;
        searchCache.set(searchHref, result);
      } catch {
      }
    };
    patch();
    return pFoundUrl;
    function storeVisit(dir) {
      toPatchCache.push(dir);
    }
  }
  clearCache() {
    this.searchCache.clear();
    this.searchDirCache.clear();
  }
  findUpConfigPath(cwd, visit2) {
    const searchDirCache = this.searchDirCache;
    const cached = searchDirCache.get(cwd.href);
    if (cached)
      return cached;
    return findUpFromUrl2((dir) => this.hasConfig(dir, visit2), cwd, { type: "file" });
  }
  hasConfig(dir, visited) {
    const cached = this.searchDirCache.get(dir.href);
    if (cached)
      return cached;
    visited(dir);
    const result = this.hasConfigDir(dir);
    this.searchDirCache.set(dir.href, result);
    return result;
  }
  createHasFileDirSearch() {
    const dirInfoCache = createAutoResolveCache();
    const hasFile = async (filename) => {
      const dir = new URL(".", filename);
      const parent = new URL("..", dir);
      const parentHref = parent.href;
      const parentInfoP = dirInfoCache.get(parentHref);
      if (parentInfoP) {
        const parentInfo = await parentInfoP;
        const name2 = urlBasename(dir).slice(0, -1);
        const found2 = parentInfo.get(name2);
        if (!found2?.isDirectory() && !found2?.isSymbolicLink())
          return false;
      }
      const dirUrlHref = dir.href;
      const dirInfo = await dirInfoCache.get(dirUrlHref, async () => await this.readDir(dir));
      const name = urlBasename(filename);
      const found = dirInfo.get(name);
      return found?.isFile() || found?.isSymbolicLink() || false;
    };
    return hasFile;
  }
  async readDir(dir) {
    try {
      const dirInfo = await this.fs.readDirectory(dir);
      return new Map(dirInfo.map((ent) => [ent.name, ent]));
    } catch {
      return new Map;
    }
  }
  createHasFileStatCheck() {
    const hasFile = async (filename) => {
      const stat2 = await this.fs.stat(filename).catch(() => {
        return;
      });
      return !!stat2?.isFile();
    };
    return hasFile;
  }
  async hasConfigDir(dir) {
    const hasFile = this.fs.getCapabilities(dir).readDirectory ? this.createHasFileDirSearch() : this.createHasFileStatCheck();
    const searchPlaces2 = this.searchPlacesByProtocol.get(dir.protocol) || this.searchPlaces;
    for (const searchPlace of searchPlaces2) {
      const file = new URL(searchPlace, dir);
      const found = await hasFile(file);
      if (found) {
        if (urlBasename(file) !== "package.json")
          return file;
        if (await checkPackageJson(this.fs, file))
          return file;
      }
    }
    return;
  }
}
function setupSearchPlacesByProtocol(searchPlaces2, allowedExtensionsByProtocol) {
  const map3 = new Map([...allowedExtensionsByProtocol.entries()].map(([k, v]) => [k, new Set(v)]).map(([protocol, exts]) => [protocol, searchPlaces2.filter((url2) => exts.has(extname4(url2)))]));
  return map3;
}
async function checkPackageJson(fs5, filename) {
  try {
    const file = await fs5.readFile(filename);
    const pkg = JSON.parse(file.getText());
    return typeof pkg.cspell === "object";
  } catch {
    return false;
  }
}

// node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/defaultSettings.js
var defaultSettings = createCSpellSettingsInternal({
  id: "default",
  name: "default",
  version: currentSettingsFileVersion
});

// node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/PnPSettings.js
var defaultPnPSettings = Object.freeze({});
var lastPnP = defaultPnPSettings;
function normalizePnPSettings(settings) {
  if (equal(lastPnP, settings))
    return lastPnP;
  if (equal(defaultPnPSettings, settings))
    return defaultPnPSettings;
  const { usePnP, pnpFiles } = settings;
  return lastPnP = clean5({ usePnP, pnpFiles });
}
function equal(a, b) {
  return a === b || a.usePnP === b.usePnP && (a.pnpFiles === b.pnpFiles || a.pnpFiles?.join("|") === b.pnpFiles?.join("|"));
}

// node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/configLoader.js
var supportedCSpellConfigVersions = [configSettingsFileVersion0_2];
var setOfSupportedConfigVersions = Object.freeze(new Set(supportedCSpellConfigVersions));
var defaultConfigLoader = undefined;
var defaultExtensions = [".json", ".yaml", ".yml", ".jsonc"];
var defaultJsExtensions = [".js", ".cjs", ".mjs"];
var trustedSearch = new Map([
  ["*", defaultExtensions],
  ["file:", [...defaultExtensions, ...defaultJsExtensions]]
]);
var unTrustedSearch = new Map([["*", defaultExtensions]]);

class ConfigLoader {
  fs;
  templateVariables;
  onReady;
  fileResolver;
  _isTrusted = true;
  constructor(fs5, templateVariables = envToTemplateVars(process.env)) {
    this.fs = fs5;
    this.templateVariables = templateVariables;
    this.configSearch = new ConfigSearch(searchPlaces, trustedSearch, fs5);
    this.cspellConfigFileReaderWriter = createReaderWriter(undefined, undefined, createIO(fs5));
    this.fileResolver = new FileResolver(fs5, this.templateVariables);
    this.onReady = this.init();
    this.subscribeToEvents();
  }
  subscribeToEvents() {
    this.toDispose.push(onClearCache(() => this.clearCachedSettingsFiles()));
  }
  cachedConfig = new Map;
  cachedConfigFiles = new Map;
  cachedPendingConfigFile = new AutoResolveCache2;
  cachedMergedConfig = new WeakMap;
  cachedCSpellConfigFileInMemory = new WeakMap;
  globalSettings;
  cspellConfigFileReaderWriter;
  configSearch;
  toDispose = [];
  async readSettingsAsync(filename, relativeTo, pnpSettings) {
    await this.onReady;
    const ref = await this.resolveFilename(filename, relativeTo || toFileDirURL("./"));
    const entry = this.importSettings(ref, pnpSettings || defaultPnPSettings, []);
    return entry.onReady;
  }
  async readConfigFile(filenameOrURL, relativeTo) {
    const ref = await this.resolveFilename(filenameOrURL.toString(), relativeTo || toFileDirURL("./"));
    const url2 = toFileURL(ref.filename);
    const href = url2.href;
    if (ref.error)
      return new ImportError(`Failed to read config file: "${ref.filename}"`, ref.error);
    const cached = this.cachedConfigFiles.get(href);
    if (cached)
      return cached;
    return this.cachedPendingConfigFile.get(href, async () => {
      try {
        const file = await this.cspellConfigFileReaderWriter.readConfig(href);
        this.cachedConfigFiles.set(href, file);
        return file;
      } catch (error) {
        return new ImportError(`Failed to read config file: "${ref.filename}"`, error);
      } finally {
        setTimeout(() => this.cachedPendingConfigFile.delete(href), 1);
      }
    });
  }
  async searchForConfigFileLocation(searchFrom) {
    const url2 = toFileURL(searchFrom || cwdURL(), cwdURL());
    if (typeof searchFrom === "string" && !isUrlLike(searchFrom) && url2.protocol === "file:" && await isDirectory(this.fs, url2)) {
      return this.configSearch.searchForConfig(addTrailingSlash(url2));
    }
    return this.configSearch.searchForConfig(url2);
  }
  async searchForConfigFile(searchFrom) {
    const location = await this.searchForConfigFileLocation(searchFrom);
    if (!location)
      return;
    const file = await this.readConfigFile(location);
    return file instanceof Error ? undefined : file;
  }
  async searchForConfig(searchFrom, pnpSettings = defaultPnPSettings) {
    const configFile = await this.searchForConfigFile(searchFrom);
    if (!configFile)
      return;
    return this.mergeConfigFileWithImports(configFile, pnpSettings);
  }
  getGlobalSettings() {
    assert14(this.globalSettings, "Global settings not loaded");
    return this.globalSettings;
  }
  async getGlobalSettingsAsync() {
    if (!this.globalSettings) {
      const globalConfFile = await getGlobalConfig();
      const normalized = await this.mergeConfigFileWithImports(globalConfFile, undefined);
      normalized.id ??= "global_config";
      this.globalSettings = normalized;
    }
    return this.globalSettings;
  }
  clearCachedSettingsFiles() {
    this.globalSettings = undefined;
    this.cachedConfig.clear();
    this.cachedConfigFiles.clear();
    this.configSearch.clearCache();
    this.cachedPendingConfigFile.clear();
    this.cspellConfigFileReaderWriter.clearCachedFiles();
    this.cachedMergedConfig = new WeakMap;
    this.cachedCSpellConfigFileInMemory = new WeakMap;
    this.prefetchGlobalSettingsAsync();
  }
  resolveSettingsImports(settings, filename) {
    const settingsFile = this.createCSpellConfigFile(filename, settings);
    return this.mergeConfigFileWithImports(settingsFile, settings);
  }
  init() {
    this.onReady = Promise.all([this.prefetchGlobalSettingsAsync(), this.resolveDefaultConfig()]).then(() => {
      return;
    });
    return this.onReady;
  }
  async prefetchGlobalSettingsAsync() {
    await this.getGlobalSettingsAsync().catch((e) => logError(e));
  }
  async resolveDefaultConfig() {
    const r = await this.fileResolver.resolveFile(defaultConfigFileModuleRef, srcDirectory);
    const url2 = toFileURL(r.filename);
    this.cspellConfigFileReaderWriter.setTrustedUrls([new URL("../..", url2)]);
    return url2;
  }
  importSettings(fileRef, pnpSettings, backReferences) {
    const url2 = toFileURL(fileRef.filename);
    const cacheKey = url2.href;
    const cachedImport = this.cachedConfig.get(cacheKey);
    if (cachedImport) {
      backReferences.forEach((ref) => cachedImport.referencedSet.add(ref));
      return cachedImport;
    }
    if (fileRef.error) {
      const settings = createCSpellSettingsInternal({
        __importRef: fileRef,
        source: { name: fileRef.filename, filename: fileRef.filename }
      });
      const importedConfig2 = {
        href: cacheKey,
        fileRef,
        configFile: undefined,
        settings,
        isReady: true,
        onReady: Promise.resolve(settings),
        onConfigFileReady: Promise.resolve(fileRef.error),
        referencedSet: new Set(backReferences)
      };
      this.cachedConfig.set(cacheKey, importedConfig2);
      return importedConfig2;
    }
    const source = {
      name: fileRef.filename,
      filename: fileRef.filename
    };
    const mergeImports = (cfgFile) => {
      if (cfgFile instanceof Error) {
        fileRef.error = cfgFile;
        return createCSpellSettingsInternal({ __importRef: fileRef, source });
      }
      return this.mergeConfigFileWithImports(cfgFile, pnpSettings, backReferences);
    };
    const referencedSet = new Set(backReferences);
    const onConfigFileReady = onConfigFileReadyFixUp(this.readConfigFile(fileRef.filename));
    const importedConfig = {
      href: cacheKey,
      fileRef,
      configFile: undefined,
      settings: undefined,
      isReady: false,
      onReady: onReadyFixUp(onConfigFileReady.then(mergeImports)),
      onConfigFileReady,
      referencedSet
    };
    this.cachedConfig.set(cacheKey, importedConfig);
    return importedConfig;
    async function onReadyFixUp(pSettings) {
      const settings = await pSettings;
      settings.source ??= source;
      settings.__importRef ??= fileRef;
      importedConfig.isReady = true;
      importedConfig.settings = settings;
      return settings;
    }
    async function onConfigFileReadyFixUp(pCfgFile) {
      const cfgFile = await pCfgFile;
      if (cfgFile instanceof Error) {
        importedConfig.fileRef.error = cfgFile;
        return cfgFile;
      }
      source.name = cfgFile.settings.name || source.name;
      importedConfig.configFile = cfgFile;
      return cfgFile;
    }
  }
  async setupPnp(cfgFile, pnpSettings) {
    if (!pnpSettings?.usePnP || pnpSettings === defaultPnPSettings)
      return;
    if (cfgFile.url.protocol !== "file:")
      return;
    const { usePnP = pnpSettings.usePnP, pnpFiles = pnpSettings.pnpFiles } = cfgFile.settings;
    const pnpSettingsToUse = normalizePnPSettings({ usePnP, pnpFiles });
    const pathToSettingsDir = new URL(".", cfgFile.url);
    await loadPnP(pnpSettingsToUse, pathToSettingsDir);
  }
  mergeConfigFileWithImports(cfg, pnpSettings, referencedBy) {
    const cfgFile = this.toCSpellConfigFile(cfg);
    const cached = this.cachedMergedConfig.get(cfgFile);
    if (cached && cached.pnpSettings === pnpSettings && cached.referencedBy === referencedBy) {
      return cached.result;
    }
    const pnp = {
      usePnP: cfg.settings.usePnP ?? pnpSettings?.usePnP ?? !!process.versions.pnp,
      pnpFiles: cfg.settings.pnpFiles ?? pnpSettings?.pnpFiles
    };
    const result = this._mergeConfigFileWithImports(cfgFile, pnp, referencedBy);
    this.cachedMergedConfig.set(cfgFile, { pnpSettings, referencedBy, result });
    return result;
  }
  async _mergeConfigFileWithImports(cfgFile, pnpSettings, referencedBy = []) {
    await this.setupPnp(cfgFile, pnpSettings);
    const href = cfgFile.url.href;
    const referencedSet = new Set(referencedBy);
    const imports = normalizeImport(cfgFile.settings.import);
    const __imports = await Promise.all(imports.map((name) => this.resolveFilename(name, cfgFile.url)));
    const toImport = __imports.map((ref) => this.importSettings(ref, pnpSettings, [...referencedBy, href]));
    toImport.forEach((entry) => {
      entry.referencedSet.add(href);
    });
    const pendingImports = toImport.map((entry) => {
      return referencedSet.has(entry.href) ? entry.settings || configToRawSettings(entry.configFile) : entry.onReady;
    });
    const importSettings = await Promise.all(pendingImports);
    const cfg = await this.mergeImports(cfgFile, importSettings);
    return cfg;
  }
  async mergeImports(cfgFile, importedSettings) {
    const rawSettings = configToRawSettings(cfgFile);
    const url2 = cfgFile.url;
    const fileRef = rawSettings.__importRef;
    const source = rawSettings.source;
    assert14(source);
    const settings = {
      version: defaultSettings.version,
      ...rawSettings,
      globRoot: resolveGlobRoot(rawSettings, cfgFile.url),
      languageSettings: normalizeLanguageSettings(rawSettings.languageSettings)
    };
    const normalizedDictionaryDefs = normalizeDictionaryDefs(settings, url2);
    const normalizedSettingsGlobs = normalizeSettingsGlobs(settings, url2);
    const normalizedOverrides = normalizeOverrides(settings, url2);
    const normalizedReporters = await normalizeReporters(settings, url2);
    const normalizedGitignoreRoot = normalizeGitignoreRoot(settings, url2);
    const normalizedCacheSettings = normalizeCacheSettings(settings, url2);
    const fileSettings = createCSpellSettingsInternal({
      ...settings,
      source,
      ...normalizedDictionaryDefs,
      ...normalizedSettingsGlobs,
      ...normalizedOverrides,
      ...normalizedReporters,
      ...normalizedGitignoreRoot,
      ...normalizedCacheSettings
    });
    if (!importedSettings.length) {
      return fileSettings;
    }
    const mergedImportedSettings = importedSettings.reduce((a, b) => mergeSettings(a, b));
    const finalizeSettings2 = mergeSettings(mergedImportedSettings, fileSettings);
    finalizeSettings2.name = settings.name || finalizeSettings2.name || "";
    finalizeSettings2.id = settings.id || finalizeSettings2.id || "";
    if (fileRef) {
      finalizeSettings2.__importRef = fileRef;
    }
    return finalizeSettings2;
  }
  createCSpellConfigFile(filename, settings) {
    const map3 = autoResolveWeak2(this.cachedCSpellConfigFileInMemory, settings, () => new Map);
    return autoResolve2(map3, filename, () => this.cspellConfigFileReaderWriter.toCSpellConfigFile({ url: toFileURL(filename), settings }));
  }
  toCSpellConfigFile(cfg) {
    if (cfg instanceof CSpellConfigFile)
      return cfg;
    return this.createCSpellConfigFile(cfg.url, cfg.settings);
  }
  dispose() {
    while (this.toDispose.length) {
      try {
        this.toDispose.pop()?.dispose();
      } catch (e) {
        logError(e);
      }
    }
  }
  getStats() {
    return { ...stats() };
  }
  async resolveConfigFileLocation(filenameOrURL, relativeTo) {
    const r = await this.fileResolver.resolveFile(filenameOrURL, relativeTo);
    return r.found ? toFileURL(r.filename) : undefined;
  }
  async resolveFilename(filename, relativeTo) {
    if (filename instanceof URL)
      return { filename: toFilePathOrHref(filename) };
    if (isUrlLike(filename))
      return { filename: toFilePathOrHref(filename) };
    const r = await this.fileResolver.resolveFile(filename, relativeTo);
    if (r.warning) {
      logWarning(r.warning);
    }
    return {
      filename: r.filename.startsWith("file:/") ? fileURLToPath12(r.filename) : r.filename,
      error: r.found ? undefined : new ConfigurationLoaderFailedToResolveError(filename, relativeTo)
    };
  }
  get isTrusted() {
    return this._isTrusted;
  }
  setIsTrusted(isTrusted2) {
    this._isTrusted = isTrusted2;
    this.clearCachedSettingsFiles();
    this.configSearch = new ConfigSearch(searchPlaces, isTrusted2 ? trustedSearch : unTrustedSearch, this.fs);
    this.cspellConfigFileReaderWriter.setUntrustedExtensions(isTrusted2 ? [] : defaultJsExtensions);
  }
}

class ConfigLoaderInternal extends ConfigLoader {
  constructor(vfs) {
    super(vfs);
  }
  get _cachedFiles() {
    return this.cachedConfig;
  }
}
function loadPnP(pnpSettings, searchFrom) {
  if (!pnpSettings.usePnP) {
    return Promise.resolve(undefined);
  }
  const loader2 = pnpLoader(pnpSettings.pnpFiles);
  return loader2.load(searchFrom);
}
var nestedConfigDirectories = {
  ".vscode": true,
  ".config": true
};
function resolveGlobRoot(settings, urlSettingsFile) {
  const urlSettingsFileDir = new URL(".", urlSettingsFile);
  const uriSettingsFileDir = URI.parse(urlSettingsFileDir.href);
  const settingsFileDirName = Utils.basename(uriSettingsFileDir);
  const isNestedConfig = settingsFileDirName in nestedConfigDirectories;
  const isVSCode = settingsFileDirName === ".vscode";
  const settingsFileDir = (isNestedConfig ? Utils.dirname(uriSettingsFileDir) : uriSettingsFileDir).toString();
  const envGlobRoot = process.env[ENV_CSPELL_GLOB_ROOT];
  const defaultGlobRoot = envGlobRoot ?? "${cwd}";
  const rawRoot = settings.globRoot ?? (settings.version === configSettingsFileVersion0_1 || envGlobRoot && !settings.version || isVSCode && !settings.version ? defaultGlobRoot : settingsFileDir);
  const globRoot = rawRoot.startsWith("${cwd}") ? rawRoot : toFileURL(rawRoot, new URL(settingsFileDir));
  return typeof globRoot === "string" ? globRoot : globRoot.protocol === "file:" ? windowsDriveLetterToUpper(path10.resolve(fileURLToPath12(globRoot))) : addTrailingSlash(globRoot).href;
}
function createConfigLoaderInternal(fs5) {
  return new ConfigLoaderInternal(fs5 ?? getVirtualFS().fs);
}
function getDefaultConfigLoaderInternal() {
  if (defaultConfigLoader)
    return defaultConfigLoader;
  return defaultConfigLoader = createConfigLoaderInternal();
}
function createIO(fs5) {
  const readFile2 = (url2) => fs5.readFile(url2).then((file) => ({ url: file.url, content: file.getText() }));
  const writeFile3 = (file) => fs5.writeFile(file);
  return {
    readFile: readFile2,
    writeFile: writeFile3
  };
}
async function isDirectory(fs5, path11) {
  try {
    return (await fs5.stat(path11)).isDirectory();
  } catch {
    return false;
  }
}

class ConfigurationLoaderError extends Error {
  configurationFile;
  relativeTo;
  constructor(message, configurationFile, relativeTo, cause) {
    super(message);
    this.configurationFile = configurationFile;
    this.relativeTo = relativeTo;
    this.name = "Configuration Loader Error";
    if (cause) {
      this.cause = cause;
    }
  }
}

class ConfigurationLoaderFailedToResolveError extends ConfigurationLoaderError {
  configurationFile;
  relativeTo;
  constructor(configurationFile, relativeTo, cause) {
    const filename = configurationFile.startsWith("file:/") ? fileURLToPath12(configurationFile) : configurationFile;
    const relSource = relativeToCwd(relativeTo);
    const message = `Failed to resolve configuration file: "${filename}" referenced from "${relSource}"`;
    super(message, configurationFile, relativeTo, cause);
    this.configurationFile = configurationFile;
    this.relativeTo = relativeTo;
  }
}
function relativeToCwd(file) {
  const url2 = toFileUrl(file);
  const cwdPath = cwdURL().pathname.split("/").slice(0, -1);
  const urlPath = url2.pathname.split("/");
  if (urlPath[0] !== cwdPath[0])
    return toFilePathOrHref(file);
  let i = 0;
  for (;i < cwdPath.length; ++i) {
    if (cwdPath[i] !== urlPath[i])
      break;
  }
  const segments = cwdPath.length - i;
  if (segments > 3)
    return toFilePathOrHref(file);
  const prefix = [...".".repeat(segments)].map(() => "..").join("/");
  return [prefix || ".", ...urlPath.slice(i)].join("/");
}

// node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/defaultConfigLoader.js
var gcl = getDefaultConfigLoaderInternal;
function searchForConfig(searchFrom, pnpSettings = defaultPnPSettings) {
  return gcl().searchForConfig(searchFrom, pnpSettings);
}
async function loadConfig(file, pnpSettings) {
  return gcl().readSettingsAsync(file, undefined, pnpSettings);
}
async function resolveSettingsImports(settings, filename) {
  return gcl().resolveSettingsImports(settings, filename);
}
async function resolveConfigFileImports(configFile) {
  return gcl().mergeConfigFileWithImports(configFile, configFile.settings);
}
function getGlobalSettingsAsync() {
  return gcl().getGlobalSettingsAsync();
}
function getDefaultConfigLoader() {
  return getDefaultConfigLoaderInternal();
}
// node_modules/cspell-lib/dist/lib/Settings/Controller/configLoader/readSettings.js
async function readSettings(filename, relativeToOrPnP, pnpSettings) {
  const loader2 = getDefaultConfigLoader();
  const relativeTo = typeof relativeToOrPnP === "string" || relativeToOrPnP instanceof URL ? relativeToOrPnP : undefined;
  const pnp = pnpSettings ? pnpSettings : !(typeof relativeToOrPnP === "string" || relativeToOrPnP instanceof URL) ? relativeToOrPnP : undefined;
  return loader2.readSettingsAsync(filename, relativeTo, pnp);
}
// node_modules/cspell-grammar/dist/parser/grammarTypesHelpers.js
function isPatternInclude(p) {
  return !!p.include;
}
var TypeofMatch = {
  object: true,
  string: true
};
var TypeofBegin = TypeofMatch;
var TypeofEnd = { ...TypeofBegin, undefined: true };
function isPatternMatch(pattern) {
  const p = pattern;
  return !!p.match && typeof p.match in TypeofMatch;
}
function isPatternBeginEnd(pattern) {
  const p = pattern;
  return p.begin !== undefined && typeof p.begin in TypeofBegin && typeof p.end in TypeofEnd;
}
function isPatternPatterns(p) {
  return Array.isArray(p.patterns);
}

// node_modules/cspell-grammar/dist/parser/matchResult.js
function segmentMatch(mr) {
  const { matches, index, groups, input } = mr;
  const segments = [];
  let p = index;
  for (let groupNum = 0;groupNum < matches.length; ++groupNum) {
    const m = matches[groupNum];
    if (!m)
      continue;
    const idx0 = input.indexOf(m, p);
    const idx2 = idx0 >= p ? idx0 : input.lastIndexOf(m, p);
    if (idx2 < 0)
      continue;
    segments.push({ match: m, index: idx2, groupNum, groupName: undefined });
    p = idx2;
  }
  const textToSeg = new Map(segments.map((s) => [s.match, s]));
  for (const [name, value] of Object.entries(groups)) {
    const s = value && textToSeg.get(value);
    if (!s)
      continue;
    s.groupName = s.groupName ? Array.isArray(s.groupName) ? [...s.groupName, name] : [s.groupName, name] : name;
  }
  return segments;
}
function createMatchResult(r, lineNumber) {
  const groups = Object.create(null);
  r.groups && Object.assign(groups, r.groups);
  const matches = r;
  const match = r[0];
  return { index: r.index, input: r.input, match, matches, groups, lineNumber };
}
function createSimpleMatchResult(match, input, index, lineNumber) {
  const groups = Object.create(null);
  return { index, input, match, matches: [match], groups, lineNumber };
}

// node_modules/cspell-grammar/dist/parser/scope.js
import assert15 from "node:assert";

class Scope {
  value;
  parent;
  constructor(value, parent) {
    this.value = value;
    this.parent = parent;
  }
  toString(ltr = false) {
    if (!this.parent)
      return this.value;
    return ltr ? this.parent.toString(ltr) + " " + this.value : this.value + " " + this.parent.toString(ltr);
  }
  static isScope(value) {
    return value instanceof Scope;
  }
}

class ScopePool {
  pool = new Map;
  getScope(scopeValue, parent) {
    const foundPoolMap = this.pool.get(scopeValue);
    const poolMap = foundPoolMap || new Map;
    if (poolMap !== foundPoolMap) {
      this.pool.set(scopeValue, poolMap);
    }
    const foundScope = poolMap.get(parent);
    if (foundScope)
      return foundScope.v;
    const scope = new Scope(scopeValue, parent);
    poolMap.set(parent, { v: scope });
    return scope;
  }
  parseScope(scopes, ltr = false) {
    if (Scope.isScope(scopes))
      return scopes;
    if (isScopeLike(scopes)) {
      const parent = scopes.parent ? this.parseScope(scopes.parent) : undefined;
      return this.getScope(scopes.value, parent);
    }
    return this.parseScopeString(scopes, ltr);
  }
  parseScopeString(scopes, ltr) {
    scopes = Array.isArray(scopes) ? scopes : scopes.split(" ");
    const parentToChild = ltr ? scopes : scopes.reverse();
    let parent = undefined;
    for (const value of parentToChild) {
      parent = this.getScope(value, parent);
    }
    assert15(parent, "Empty scope is not allowed.");
    return parent;
  }
}
function isScopeLike(value) {
  return typeof value === "object" && !Array.isArray(value) && value.value !== undefined;
}

// node_modules/cspell-grammar/dist/parser/grammarNormalizer.js
function normalizeGrammar(grammar) {
  return new ImplNGrammar(grammar);
}
var SpecialRepositoryReferences = {
  $self: true,
  $base: true
};
function nPattern(p) {
  if (isPatternMatch(p))
    return normalizePatternMatch(p);
  if (isPatternBeginEnd(p))
    return normalizePatternBeginEnd(p);
  if (isPatternInclude(p))
    return normalizePatternInclude(p);
  if (isPatternPatterns(p))
    return normalizePatternsPatterns(p);
  return normalizePatternName(p);
}
function normalizePatternMatch(p) {
  const regExec = makeTestMatchFn(p.match);
  const self = {
    ...p,
    captures: normalizeCapture(p.captures),
    findMatch
  };
  function findMatch(line, parentRule) {
    const match = regExec(line);
    if (!match)
      return;
    const rule = factoryRule(parentRule, self);
    return { rule, match, line };
  }
  return self;
}
function normalizePatternBeginEnd(p) {
  const patterns = normalizePatterns(p.patterns);
  const self = {
    ...p,
    captures: normalizeCapture(p.captures),
    beginCaptures: normalizeCapture(p.beginCaptures),
    endCaptures: normalizeCapture(p.endCaptures),
    patterns,
    findMatch
  };
  function findMatch(line, parentRule) {
    const match = testBegin(line);
    if (!match)
      return;
    const rule = factoryRule(parentRule, self, findNext, end);
    return { rule, match, line };
  }
  const testBegin = makeTestMatchFn(p.begin);
  const testEnd = p.end !== undefined ? makeTestMatchFn(p.end) : () => {
    return;
  };
  function findNext(line) {
    return patterns && findInPatterns(patterns, line, this);
  }
  function end(line) {
    return testEnd(line);
  }
  return self;
}
function normalizePatternName(p) {
  const patterns = undefined;
  const self = {
    ...p,
    patterns,
    findMatch
  };
  function findMatch(line, parentRule) {
    const rule = factoryRule(parentRule, self);
    const input = line.text.slice(line.offset);
    const match = createSimpleMatchResult(input, input, line.offset, line.lineNumber);
    return { rule, match, line };
  }
  return self;
}
function normalizePatternInclude(p) {
  const { include } = p;
  return include.startsWith("#") || include in SpecialRepositoryReferences ? normalizePatternIncludeRef(p) : normalizePatternIncludeExt(p);
}
function normalizePatternIncludeRef(p) {
  const { include, ...rest } = p;
  const reference = include.startsWith("#") ? include.slice(1) : include;
  const self = {
    ...rest,
    reference,
    findMatch
  };
  function findMatch(line, parentRule) {
    const pat = parentRule.repository[reference];
    if (pat === undefined)
      throw new Error(`Unknown Include Reference ${include}`);
    return pat.findMatch(line, parentRule);
  }
  return self;
}
function normalizePatternIncludeExt(p) {
  function findMatch(_line) {
    return;
  }
  const self = {
    ...p,
    findMatch
  };
  return self;
}
function normalizePatternsPatterns(p) {
  return new ImplNPatternPatterns(p);
}
function findInPatterns(patterns, line, rule) {
  let r = undefined;
  for (const pat of patterns) {
    if (pat.disabled)
      continue;
    const er = pat.findMatch(line, rule);
    if (er?.match !== undefined && !er.rule.pattern.disabled) {
      r = r && r.match && r.match.index <= er.match.index && r || er;
    }
  }
  return r;
}
function normalizePatterns(patterns) {
  if (!patterns)
    return;
  return patterns.map((p) => typeof p === "string" ? { include: p } : p).map(nPattern);
}
var emptyRepository = Object.freeze(Object.create(null));
function normalizePatternRepository(rep) {
  if (!rep)
    return emptyRepository;
  return normalizeRepository(rep);
}
function normalizeRepository(rep) {
  const repository = Object.create(null);
  for (const [key, pat] of Object.entries(rep)) {
    repository[key] = nPattern(pat);
  }
  return repository;
}
var ruleCounter = 0;
function factoryRuleBase(parent, pattern, repository, grammar, findNext, end) {
  const depth = parent ? parent.depth + 1 : 0;
  return {
    id: ruleCounter++,
    grammar,
    pattern,
    parent,
    repository,
    depth,
    findNext,
    end
  };
}
function factoryRule(parent, pattern, findNext, end) {
  return factoryRuleBase(parent, pattern, parent.repository, parent.grammar, findNext, end);
}
function normalizeCapture(cap) {
  if (cap === undefined)
    return;
  if (typeof cap === "string")
    return { [0]: cap };
  const capture = Object.create(null);
  for (const [key, pat] of Object.entries(cap)) {
    capture[key] = typeof pat === "string" ? pat : normalizePatternName(pat).name;
  }
  return capture;
}
function makeTestMatchFn(reg) {
  if (typeof reg === "string")
    return matchString(reg);
  return matchRegExp(reg);
}
function matchString(s) {
  return (line) => {
    const input = line.text;
    const index = input.indexOf(s, line.offset);
    if (index < 0)
      return;
    return createSimpleMatchResult(s, input, index, line.lineNumber);
  };
}
function matchRegExp(r) {
  return (line) => {
    const rg = RegExp(r, "gm");
    rg.lastIndex = line.offset;
    const m = rg.exec(line.text);
    return (m && createMatchResult(m, line.lineNumber)) ?? undefined;
  };
}
function extractScope(er, isContent = true) {
  const scope = [];
  for (let rule = er;rule; rule = rule.parent) {
    const pattern = rule.pattern;
    const { name, contentName } = pattern;
    if (contentName && isContent) {
      scope.push(contentName);
    }
    if (name !== undefined) {
      scope.push(name);
    }
    isContent = true;
  }
  return er.grammar.scopePool.parseScope(scope);
}

class ImplNGrammar {
  scopeName;
  name;
  comment;
  disabled;
  patterns;
  repository;
  grammarName;
  self;
  scopePool;
  constructor(grammar) {
    this.scopeName = grammar.scopeName;
    this.name = grammar.scopeName;
    this.comment = grammar.comment;
    this.disabled = grammar.disabled;
    this.grammarName = grammar.name;
    const self = nPattern({
      patterns: [{ patterns: grammar.patterns }]
    });
    const repository = normalizePatternRepository(grammar.repository);
    this.patterns = self.patterns;
    this.repository = repository;
    this.self = self;
    this.scopePool = new ScopePool;
  }
  begin(parentRule) {
    const patterns = this.patterns;
    function grammarToRule(grammar, baseGrammar, parent) {
      const repository = Object.create(null);
      Object.assign(repository, grammar.repository);
      repository["$self"] = grammar.self;
      repository["$base"] = repository["$base"] || baseGrammar.self;
      function findNext(line) {
        return findInPatterns(patterns, line, this);
      }
      function end(_line) {
        return;
      }
      return factoryRuleBase(parent, grammar, repository, grammar, findNext, end);
    }
    return grammarToRule(this, parentRule?.grammar ?? this, parentRule);
  }
}

class ImplNPatternPatterns {
  name;
  comment;
  disabled;
  patterns;
  constructor(p) {
    const { name, comment, disabled, ...rest } = p;
    this.patterns = normalizePatterns(rest.patterns);
    this.name = name;
    this.comment = comment;
    this.disabled = disabled;
  }
  findMatch(line, parentRule) {
    const patterns = this.patterns;
    const rule = factoryRule(parentRule, this, findNext);
    function findNext(line2) {
      return findInPatterns(patterns, line2, this);
    }
    return rule.findNext?.(line);
  }
}

// node_modules/cspell-grammar/dist/parser/grammar.js
function compileGrammar(grammar) {
  return normalizeGrammar(grammar);
}

// node_modules/cspell-grammar/dist/parser/tokenizeLine.js
import assert16 from "node:assert";

// node_modules/cspell-grammar/dist/parser/util.js
function isDefined7(t) {
  return t !== undefined && t !== null;
}

// node_modules/cspell-grammar/dist/parser/processors/procMatchingRule.js
function applyCaptureToBeginOrMatch(matchRuleResult) {
  const { match, rule } = matchRuleResult;
  const bePattern = rule.pattern;
  const captures = bePattern.beginCaptures ?? bePattern.captures;
  return applyCaptures(rule, match, captures);
}
function applyCaptureToEnd(rule, match) {
  const { pattern } = rule;
  const bePattern = pattern;
  const captures = bePattern.endCaptures ?? bePattern.captures;
  return applyCaptures(rule, match, captures);
}
function applyCaptures(rule, match, captures) {
  const scope = extractScope(rule, false);
  const pool = rule.grammar.scopePool;
  const text = match.match;
  const input = match.input;
  const range = [match.index, match.index + text.length, match.lineNumber];
  if (!text && !captures)
    return [];
  if (!captures) {
    const tokenized = {
      scope,
      text,
      range
    };
    return [tokenized];
  }
  const captureScopes = new Map(Object.entries(captures));
  const cap0 = captureScopes.get("0");
  if (captureScopes.size === 1 && cap0) {
    const tokenized = {
      scope: rule.grammar.scopePool.getScope(cap0, scope),
      text,
      range
    };
    return [tokenized];
  }
  const min3 = match.index;
  const max4 = match.index + text.length;
  function trimSegment(seg) {
    const { index, match: match2 } = seg;
    const right = match2.length;
    if (index >= min3 && right <= max4)
      return seg;
    if (index >= max4 || right < min3)
      return;
    const a = Math.max(index, min3) - index;
    const b = Math.min(right, max4) - index;
    const text2 = match2.slice(a, b);
    return {
      ...seg,
      index: index + a,
      match: text2
    };
  }
  const segments = segmentMatch(match).map(trimSegment).filter(isDefined7);
  function processSegments(segments2) {
    const base = segments2[0];
    const root = {
      a: base.index,
      b: base.index + base.match.length,
      s: { seg: base }
    };
    let m;
    for (let i = 1;i < segments2.length; ++i) {
      const seg = segments2[i];
      const index = seg.index;
      const end = index + seg.match.length;
      m = m && m.a <= index ? m : root;
      while (m && m.b <= index) {
        m = m.n;
      }
      while (m && m.a < end) {
        if (m.a < index) {
          const n = { ...m, a: index };
          m.n = n;
          m.b = index;
          m = n;
        }
        if (m.b > end) {
          const n = { ...m, a: end };
          m.b = end;
          m.n = n;
        }
        m.s = { seg, next: m.s };
        m = m.n;
      }
    }
    return root;
  }
  function segChainToScope(chain) {
    function* _chain(chain2) {
      while (chain2) {
        const seg = chain2.seg;
        if (seg.groupName) {
          if (Array.isArray(seg.groupName)) {
            yield* seg.groupName;
          } else {
            yield seg.groupName;
          }
        }
        yield seg.groupNum.toString();
        chain2 = chain2.next;
      }
    }
    const scopeValues = [..._chain(chain)].map((cap) => captureScopes.get(cap)).filter(isDefined7).reverse();
    return scopeValues.reduce((s, v) => pool.getScope(v, s), scope);
  }
  const merged = processSegments(segments);
  function* emit(m) {
    while (m) {
      const t = {
        text: input.slice(m.a, m.b),
        range: [m.a, m.b, match.lineNumber],
        scope: segChainToScope(m.s)
      };
      yield t;
      m = m.n;
    }
  }
  const parsedText = [...emit(merged)];
  return parsedText;
}

// node_modules/cspell-grammar/dist/parser/tokenizeLine.js
function tokenizeLine(line, rule) {
  const text = line.text;
  const lineLen = line.text.length;
  const parsedText = [];
  let ctx = buildContext({ ...line, offset: 0, anchor: -1 }, rule);
  while (ctx.line.offset <= lineLen) {
    let endMatch = ctx.rule.end?.(ctx.line);
    while (endMatch?.index === ctx.line.offset) {
      parsedText.push(...applyCaptureToEnd(ctx.rule, endMatch));
      ctx = findParentWithEnd(ctx);
      ctx.line.offset = endMatch.index + endMatch.match.length;
      endMatch = ctx.rule.end?.(ctx.line);
    }
    if (ctx.line.offset >= lineLen)
      break;
    const { line: line2, rule: rule2 } = ctx;
    const offset = line2.offset;
    const match = rule2.findNext?.(line2);
    const limit = endMatch?.index ?? lineLen;
    const emitTil = match ? Math.min(match.match.index, limit) : limit;
    if (offset < emitTil) {
      const scope = extractScope(rule2);
      const start = offset;
      const end = emitTil;
      parsedText.push({
        scope,
        text: text.slice(start, end),
        range: [start, end, line2.lineNumber]
      });
      ctx.line.offset = emitTil;
    }
    if (!match || endMatch && endMatch.index <= match.match.index) {
      continue;
    }
    parsedText.push(...applyCaptureToBeginOrMatch(match));
    line2.anchor = match.match.index + match.match.match.length;
    line2.offset = line2.anchor;
    ctx = findNearestWithEnd(buildContext(line2, match.rule));
  }
  return toParseLineResult(line, ctx.rule, parsedText);
}
function* tokenizeTextIterable(text, grammar) {
  const lines = text.split(/(?<=\r\n|\n|\r(?!\n))/);
  const rule = grammar.begin();
  let documentOffset = 0;
  let tr = tokenizeLine({ text: lines[0], lineNumber: 0, documentOffset }, rule);
  documentOffset += lines[0].length;
  yield toParsedLine(tr);
  for (let i = 1;i < lines.length; ++i) {
    const line = { text: lines[i], lineNumber: i, documentOffset };
    documentOffset += line.text.length;
    tr = tr.parse(line);
    yield toParsedLine(tr);
  }
}
function toParsedLine(pr) {
  const { tokens: parsedText, line, offset } = pr;
  return { tokens: parsedText, line, offset };
}
function toParseLineResult(line, rule, parsedText) {
  return {
    tokens: parsedText,
    line,
    offset: line.documentOffset,
    parse: (line2) => tokenizeLine(line2, rule)
  };
}
function buildContext(line, rule) {
  const rules = calcRuleStack(rule);
  const numRules = rules.length;
  const rootNum = numRules - 1;
  const rootRule = rules[rootNum];
  const rootContext = {
    line,
    rule: rootRule
  };
  let ctx = rootContext;
  for (let i = rootNum - 1;i >= 0; --i) {
    const rule2 = rules[i];
    const line2 = ctx.line;
    ctx = {
      line: line2,
      rule: rule2,
      parent: ctx
    };
  }
  return ctx;
}
function calcRuleStack(rule) {
  const rules = [];
  let r = rule;
  while (r) {
    rules.push(r);
    r = r.parent;
  }
  return rules;
}
function must(t, msg = "Must be defined") {
  assert16(t !== undefined && t !== null, msg);
  return t;
}
function findParentWithEnd(ctx) {
  return findNearestWithEnd(must(ctx.parent));
}
function findNearestWithEnd(ctx) {
  while (!ctx.rule.end) {
    ctx = must(ctx.parent);
  }
  return ctx;
}

// node_modules/cspell-grammar/dist/grammars/typescript.js
var repository = {
  statements: {
    name: "code.ts",
    patterns: [
      "#keyword",
      "#regexp",
      "#string",
      "#comment",
      "#braces",
      "#punctuation",
      "#space",
      { name: "identifier", match: /[^\s;,!|&:^%{}[\]()*/+=<>]+/ }
    ]
  },
  keyword: {
    patterns: ["#keywordBase", "#standardTypes", "#standardLib"]
  },
  keywordBase: {
    name: "keyword.typescript.ts",
    match: /\b(?:any|as|async|await|bigint|boolean|break|case|catch|const|continue|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|in|instanceof|interface|import|let|map|module|new|new|null|number|of|package|private|public|require|return|set|static|string|super|switch|this|throw|true|try|type|typeof|unknown|undefined|var|void|while|yield)\b/
  },
  standardTypes: {
    name: "keyword.type.ts",
    match: /\b(?:Promise|Record|Omit|Extract|Exclude|BigInt|Array)\b/
  },
  standardLib: {
    name: "keyword.lib.ts",
    match: /\b(?:console|process|window)\b/
  },
  string: {
    patterns: ["#string_q_single", "#string_q_double", "#string_template"]
  },
  string_q_single: {
    name: "string.quoted.single.ts",
    begin: "'",
    end: /'|((?:[^\\\n])$)/,
    captures: "punctuation.string.ts",
    patterns: [{ include: "#string_character_escape" }]
  },
  string_q_double: {
    name: "string.quoted.double.ts",
    begin: '"',
    end: /"|((?:[^\\\n])$)/,
    captures: "punctuation.string.ts",
    patterns: [{ include: "#string_character_escape" }]
  },
  string_template: {
    name: "string.template.ts",
    begin: "`",
    end: "`",
    captures: "punctuation.string.ts",
    patterns: [
      {
        name: "meta.template.expression.ts",
        contentName: "meta.embedded.line.ts",
        begin: "${",
        end: "}",
        patterns: ["#statements"],
        captures: "punctuation.definition.template.expression.ts"
      },
      { include: "#string_character_escape" }
    ]
  },
  string_character_escape: {
    name: "constant.character.escape.ts",
    match: /\\(x[0-9A-Fa-f]{2}|[0-3][0-7]{0,2}|[4-7][0-7]?|u[0-9A-Fa-f]{4}|.|\r?\n?$)/
  },
  braces: {
    patterns: [
      {
        begin: "(",
        end: ")",
        captures: "punctuation.meta.brace.ts",
        patterns: ["#statements"],
        name: "meta.brace.ts",
        contentName: "code.ts"
      },
      {
        begin: "{",
        end: "}",
        captures: "punctuation.meta.brace.ts",
        patterns: ["#statements"],
        name: "meta.brace.ts",
        contentName: "code.ts"
      },
      {
        begin: "[",
        end: "]",
        captures: "punctuation.meta.brace.ts",
        patterns: ["#statements"],
        name: "meta.brace.ts",
        contentName: "code.ts"
      }
    ]
  },
  punctuation: {
    name: "punctuation.ts",
    match: /[-;:,!|&^%*/+=<>\n\r]/
  },
  space: {
    name: "punctuation.space.ts",
    match: /\s+/
  },
  comment: {
    patterns: [
      {
        name: "comment.line.ts",
        comment: "line comment",
        begin: "//",
        end: /(?=$)/,
        captures: "punctuation.definition.comment.ts"
      },
      {
        name: "comment.block.documentation.ts",
        comment: "DocBlock",
        begin: /\/\*\*(?!\/)/,
        captures: "punctuation.definition.comment.ts",
        end: "*/"
      },
      {
        name: "comment.block.ts",
        begin: "/*",
        end: "*/",
        captures: "punctuation.definition.comment.ts"
      }
    ]
  },
  regexp: {
    name: "regexp.ts",
    begin: /\/(?![/*])/,
    end: /\/([a-z]*)/i,
    beginCaptures: "punctuation.begin.regexp.ts",
    endCaptures: "punctuation.end.regexp.ts",
    patterns: ["#regexp_escape", "#regexp_brace"]
  },
  regexp_escape: {
    name: "escape.regexp.ts",
    match: /\\./
  },
  regexp_brace: {
    name: "brace.regexp.ts",
    begin: "[",
    end: "]",
    contentName: "character-class.regexp.ts",
    patterns: ["#regexp_escape"]
  }
};
var grammar = {
  name: "TypeScript",
  scopeName: "source.ts",
  patterns: [
    {
      name: "comment.line.shebang.ts",
      match: /^#!.*(?=$)/
    },
    {
      include: "#statements"
    }
  ],
  repository
};

// node_modules/cspell-grammar/dist/mappers/appendMappedText.js
import assert17 from "node:assert";
function appendMappedText(a, b) {
  if (!a.map && !b.map) {
    return { text: a.text + b.text };
  }
  const aLen = a.text.length;
  const bLen = b.text.length;
  const aMap = [0, 0, ...a.map || [0, 0, aLen, aLen]];
  const bMap = [0, 0, ...b.map || [0, 0, bLen, bLen]];
  assert17(aMap[aMap.length - 1] === aLen);
  assert17(bMap[bMap.length - 1] === bLen);
  assert17((aMap.length & 1) === 0);
  assert17((bMap.length & 1) === 0);
  return {
    text: a.text + b.text,
    map: joinMaps(aMap, bMap)
  };
}
function joinMaps(aMap, bMap) {
  const n = aMap.length - 1;
  const offsets = [aMap[n - 1], aMap[n]];
  const ab = [...aMap, ...bMap.map((v, i) => v + offsets[i & 1])];
  const r = [0, 0];
  let last0 = 0, last1 = 0;
  for (let i = 0;i < ab.length; i += 2) {
    const v0 = ab[i];
    const v1 = ab[i + 1];
    if (v0 === last0 && v1 === last1) {
      continue;
    }
    r.push(v0, v1);
    last0 = v0;
    last1 = v1;
  }
  return r;
}

// node_modules/cspell-grammar/dist/mappers/typescript.js
var hexChars = {
  "0": 0,
  "1": 1,
  "2": 2,
  "3": 3,
  "4": 4,
  "5": 5,
  "6": 6,
  "7": 7,
  "8": 8,
  "9": 9,
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15,
  a: 10,
  b: 11,
  c: 12,
  d: 13,
  e: 14,
  f: 15
};
var escapeChars = {
  t: "\t",
  n: `
`,
  r: "\r",
  b: "\b",
  "\\": "\\",
  '"': '"',
  "'": "'",
  "\n": ""
};
function mapRawString(text) {
  const end = text.length;
  let t = "";
  const map3 = [];
  const isHex = /^[0-9a-fA-F]+$/;
  let i, j;
  for (i = 0, j = 0;i < end; ++i) {
    let parsed;
    const ti = text[i];
    if (ti === "\\") {
      map3.push(i, j);
      const tc = text[++i];
      const ec = escapeChars[tc];
      if (ec) {
        t += ec;
        j += ec.length;
        map3.push(i, j);
        continue;
      }
      switch (tc) {
        case "u": {
          {
            let char;
            let end2;
            if (text[i + 1] !== "{") {
              const digits = text.slice(i + 1, i + 5);
              parsed = isHex.test(digits) ? Number.parseInt(digits, 16) : Number.NaN;
              char = Number.isNaN(parsed) ? "" : String.fromCodePoint(parsed);
              end2 = i + 4;
            } else {
              for (end2 = i + 2;text[end2] in hexChars; ++end2) {
              }
              if (text[end2] !== "}") {
                char = "";
              } else {
                const digits = text.slice(i + 2, end2);
                parsed = isHex.test(digits) ? Number.parseInt(digits, 16) : Number.NaN;
                char = Number.isNaN(parsed) ? "" : String.fromCodePoint(parsed);
              }
            }
            if (!char) {
              t += tc;
              j += 1;
            } else {
              t += char;
              j += char.length;
              i = end2;
            }
          }
          break;
        }
        case "x": {
          {
            const digits = text.slice(i + 1, i + 3);
            parsed = isHex.test(digits) ? Number.parseInt(digits, 16) : Number.NaN;
            if (Number.isNaN(parsed)) {
              t += tc;
              j += 1;
            } else {
              t += String.fromCodePoint(parsed);
              i += 2;
              ++j;
            }
          }
          break;
        }
        case "0": {
          t += "0";
          j += 1;
          break;
        }
        case "\r": {
          i += text[i + 1] === `
` ? 1 : 0;
          break;
        }
        case `
`: {
          break;
        }
        case undefined: {
          break;
        }
        default: {
          t += tc;
          ++j;
          break;
        }
      }
      map3.push(i + 1, j);
      continue;
    }
    t += ti;
    ++j;
  }
  if (map3.length) {
    const ii = map3[map3.length - 2];
    const jj = map3[map3.length - 1];
    if (ii !== i || jj !== j) {
      map3.push(i, j);
    }
  }
  return {
    text: t,
    map: map3
  };
}

// node_modules/cspell-grammar/dist/parser/parser.js
function mapTokenizedLine(tl) {
  return tl.tokens.map((t) => ({
    text: t.text,
    range: [tl.offset + t.range[0], tl.offset + t.range[1]],
    scope: t.scope
  }));
}
function mapTokenizedLines(itl) {
  return pipeSync(itl, opMapSync(mapTokenizedLine), opFlattenSync());
}
function createParser(grammar2, name, transform = mapTokenizedLines) {
  function parse2(content, filename) {
    const parsedTexts = pipeSync(tokenizeTextIterable(content, grammar2), transform);
    return { content, filename, parsedTexts };
  }
  return { name, parse: parse2 };
}

// node_modules/cspell-grammar/dist/parsers/typescript/TypeScriptParser.js
var tsGrammar = compileGrammar(grammar);
var pool = new ScopePool;
var useScope = new WeakMap;
function* transform(texts) {
  for (const parsed of texts) {
    if (doesScopeMatch(parsed.scope, "constant.character.escape.ts")) {
      const mapped = mapRawString(parsed.text);
      const scope = parsed.scope ? pool.parseScope(parsed.scope) : undefined;
      yield {
        text: mapped.text,
        scope: scope?.parent,
        map: mapped.map,
        range: parsed.range
      };
      continue;
    }
    yield parsed;
  }
}
function* mergeStringResults(results) {
  let last;
  for (const next of results) {
    if (!doesScopeMatch(next.scope, "string.")) {
      if (last) {
        yield last;
        last = undefined;
      }
      yield next;
      continue;
    }
    if (!last) {
      last = next;
      continue;
    }
    if (next.scope !== last.scope || last.range[1] !== next.range[0]) {
      yield last;
      last = next;
      continue;
    }
    last = mergeParsedText(last, next);
  }
  if (last)
    yield last;
}
function mergeParsedText(a, b) {
  const abT = appendMappedText(a, b);
  const ab = {
    text: abT.text,
    scope: a.scope,
    range: [a.range[0], b.range[1]],
    map: abT.map,
    delegate: a.delegate
  };
  return ab;
}
function filterScope(scope) {
  const cached = useScope.get(scope);
  if (cached !== undefined)
    return cached;
  const value = scope.value;
  const use = !value.startsWith("punctuation") && !value.startsWith("keyword.");
  useScope.set(scope, use);
  return use;
}
function mapTokenizedLine2(tl) {
  return tl.tokens.filter((t) => filterScope(t.scope)).map((t) => ({
    text: t.text,
    range: [tl.offset + t.range[0], tl.offset + t.range[1]],
    scope: t.scope
  }));
}
function mapTokenizedLines2(itl) {
  return pipeSync(itl, opMapSync(mapTokenizedLine2), opFlattenSync(), transform, mergeStringResults);
}
var parser2 = createParser(tsGrammar, "typescript", mapTokenizedLines2);
function doesScopeMatch(s, match) {
  if (!s)
    return false;
  return typeof s === "string" ? s.startsWith(match) : s.value.startsWith(match);
}
// node_modules/cspell-grammar/dist/parsers/index.js
var parsers2 = [parser2];
// node_modules/cspell-lib/dist/lib/Models/PatternRegExp.js
class PatternRegExp extends RegExp {
  constructor(pattern) {
    super(pattern);
  }
  toJSON() {
    return this.toString();
  }
}

// node_modules/cspell-lib/dist/lib/Settings/LanguageSettings.js
var defaultLocale = "en";
var defaultLanguageSettings = [];
function getDefaultLanguageSettings() {
  return defaultLanguageSettings;
}
function localesToList(locales) {
  return stringToList(locales.replaceAll(/\s+/g, ","));
}
function stringToList(sList) {
  return sList.replaceAll(/[|;]/g, ",").split(",").map((s) => s.trim()).filter((s) => !!s);
}
function memorizer(resolver) {
  const cache5 = createAutoResolveCache();
  return (k) => cache5.get(k, resolver);
}
var _normalizeLanguageId = memorizer(__normalizeLanguageId);
function __normalizeLanguageId(langId) {
  const langIds = stringToList(langId);
  return new Set(langIds.map((a) => a.toLowerCase()));
}
function normalizeLanguageId(langId) {
  return _normalizeLanguageId(typeof langId === "string" ? langId : langId.join(","));
}
var _normalizeLocale = memorizer(__normalizeLocale);
function __normalizeLocale(locale) {
  const locales = localesToList(locale);
  return new Set(locales.map((locale2) => locale2.toLowerCase().replaceAll(/[^a-z]/g, "")));
}
function normalizeLocale2(locale) {
  locale = typeof locale === "string" ? locale : locale.join(",");
  return _normalizeLocale(locale);
}
function normalizeLocaleIntl(locale) {
  const values = [...normalizeLocale2(locale)].map((locale2) => locale2.replace(/^([a-z]{2})-?([a-z]{2})$/, (_, lang, locale3) => locale3 ? `${lang}-${locale3.toUpperCase()}` : lang));
  return new Set(values);
}
function isLocaleInSet(locale, setOfLocals) {
  const locales = normalizeLocale2(locale);
  return doSetsIntersect(locales, setOfLocals);
}
var regExpValidIntlLocaleStrict = /^[a-z]{2}(-[A-Z]{2})?$/;
var regExpValidIntlLocale = new RegExp(regExpValidIntlLocaleStrict, "i");
function isValidLocaleIntlFormat(locale, strict = false) {
  if (typeof locale === "string")
    return strict ? regExpValidIntlLocaleStrict.test(locale) : regExpValidIntlLocale.test(locale);
  for (const item of locale) {
    if (!isValidLocaleIntlFormat(item, strict))
      return false;
  }
  return locale.length > 0;
}
var cacheCalcSettingsForLanguage = createAutoResolveWeakCache2();
function calcSettingsForLanguage(languageSettings, languageId, locale) {
  return cacheCalcSettingsForLanguage.get(languageSettings, () => new AutoResolveCache2).get(languageId, () => new AutoResolveCache2).get(locale, () => _calcSettingsForLanguage(languageSettings, languageId, locale));
}
function _calcSettingsForLanguage(languageSettings, languageId, locale) {
  languageId = languageId.toLowerCase();
  const allowedLocals = normalizeLocale2(locale);
  const ls = languageSettings.filter((s) => doesLanguageSettingMatchLanguageId(s, languageId)).filter((s) => !s.locale || s.locale === "*" || isLocaleInSet(s.locale, allowedLocals)).map((langSetting) => {
    const { languageId: _languageId, locale: _locale, ...s } = langSetting;
    return s;
  }).reduce((langSetting, setting) => mergeSettings(langSetting, setting), {});
  ls.languageId = languageId;
  ls.locale = locale;
  return ls;
}
var cacheDoesLanguageSettingMatchLanguageId = createAutoResolveWeakCache2();
function doesLanguageSettingMatchLanguageId(s, languageId) {
  return cacheDoesLanguageSettingMatchLanguageId.get(s, () => new AutoResolveCache2).get(languageId, () => _doesLanguageSettingMatchLanguageId(s, languageId));
}
function _doesLanguageSettingMatchLanguageId(s, languageId) {
  const languageSettingsLanguageIds = s.languageId;
  if (!languageSettingsLanguageIds || languageSettingsLanguageIds === "*")
    return true;
  const ids = normalizeLanguageId(languageSettingsLanguageIds);
  if (ids.has(languageId))
    return true;
  if (ids.has("!" + languageId))
    return false;
  const numExcludes = [...ids].filter((id) => id.startsWith("!")).length;
  return numExcludes === ids.size;
}
function calcUserSettingsForLanguage(settings, languageId) {
  const { languageSettings = [], language: locale = defaultLocale, allowCompoundWords, enabled } = settings;
  const langSettings = {
    allowCompoundWords,
    enabled,
    ...calcSettingsForLanguage(languageSettings, languageId, locale)
  };
  return mergeSettings(settings, langSettings);
}
function calcSettingsForLanguageId(baseSettings, languageId) {
  const langIds = ["*", ...normalizeLanguageId(languageId)];
  const langSettings = langIds.reduce((settings, languageId2) => {
    return calcUserSettingsForLanguage(settings, languageId2);
  }, baseSettings);
  return langSettings;
}

// node_modules/cspell-lib/dist/lib/Settings/RegExpPatterns.js
var regExMatchUrls = /(?:https?|ftp):\/\/[^\s"]+/gi;
var regExHRef = /\bhref\s*=\s*".*?"/gi;
var regExMatchCommonHexFormats = /(?:#[0-9a-f]{3,8})|(?:0x[0-9a-f]+)|(?:\\u[0-9a-f]{4})|(?:\\x\{[0-9a-f]{4}\})/gi;
var regExCommitHash = /\b(?![a-f]+\b)(?:0x)?[0-9a-f]{7,}\b/gi;
var regExCommitHashLink = /\[[0-9a-f]{7,}\]/gi;
var regExCStyleHexValue = /\b0x[0-9a-f_]+\b/gi;
var regExCSSHexValue = /#[0-9a-f]{3,8}\b/gi;
var regExUUID = /\b[0-9a-fx]{8}-[0-9a-fx]{4}-[0-9a-fx]{4}-[0-9a-fx]{4}-[0-9a-fx]{12}\b/gi;
var regExUnicodeRef = /\bU\+[0-9a-f]{4,5}(?:-[0-9a-f]{4,5})?/gi;
var regExSpellingGuardBlock = /(\bc?spell(?:-?checker)?::?)\s*disable(?!-line|-next)\b(?!-)[\s\S]*?((?:\1\s*enable\b)|$)/gi;
var regExSpellingGuardNext = /\bc?spell(?:-?checker)?::?\s*disable-next\b.*\s\s?.*/gi;
var regExSpellingGuardLine = /^.*\bc?spell(?:-?checker)?::?\s*disable-line\b.*/gim;
var regExIgnoreSpellingDirectives = /\bc?spell(?:-?checker)?::?\s*ignoreRegExp.*/gim;
var regExPublicKey = /-{5}BEGIN\s+((?:RSA\s+)?PUBLIC\s+KEY)[\w=+\-/=\\\s]+?END\s+\1-{5}/g;
var regExCert = /-{5}BEGIN\s+(CERTIFICATE|(?:RSA\s+)?(?:PRIVATE|PUBLIC)\s+KEY)[\w=+\-/=\\\s]+?END\s+\1-{5}/g;
var regExSshRSA = /ssh-rsa\s+[a-z0-9/+]{28,}={0,3}(?![a-z0-9/+=])/gi;
var regExEscapeCharacters2 = /\\(?:[anrvtbf]|[xu][a-f0-9]+)/gi;
var regExBase64 = /(?<![A-Za-z0-9/+])(?:[A-Za-z0-9/+]{40,})(?:\s^\s*[A-Za-z0-9/+]{40,})*(?:\s^\s*[A-Za-z0-9/+]+=*)?(?![A-Za-z0-9/+=])/gm;
var regExBase64SingleLine = /(?<=[^A-Za-z0-9/+_]|^)(?=[A-Za-z]{0,80}[0-9+/])(?=[A-Za-z0-9/+]{0,80}?[A-Z][a-z][A-Z])(?=[A-Za-z0-9/+]{0,80}?(?:[A-Z][0-9][A-Z]|[a-z][0-9][a-z]|[A-Z][0-9][a-z]|[a-z][0-9][A-Z]|[0-9][A-Za-z][0-9]))(?=[A-Za-z0-9/+]{0,80}?(?:[a-z]{3}|[A-Z]{3}))(?:[A-Za-z0-9/+]{40,})=*/gm;
var regExBase64MultiLine = /(?<![A-Za-z0-9/+])["']?(?:[A-Za-z0-9/+]{40,})["']?(?:\s^\s*["']?[A-Za-z0-9/+]{40,}["']?)+(?:\s^\s*["']?[A-Za-z0-9/+]+={0,3}["']?)?(?![A-Za-z0-9/+=])/gm;
var regExPhpHereDoc = /<<<['"]?(\w+)['"]?[\s\S]+?^\1;/gm;
var regExString = /(?:(['"]).*?(?<![^\\]\\(\\\\)*)\1)|(?:`[\s\S]*?(?<![^\\]\\(\\\\)*)`)/g;
var regExCStyleComments = /(?<!\w:)(?:\/\/.*)|(?:\/\*[\s\S]*?\*\/)/g;
var regExEmail = /<?\b[\w.\-+]{1,128}@\w{1,63}(\.\w{1,63}){1,4}\b>?/gi;
var regExRepeatedChar = /^(\w)\1{3,}$/i;
var regExSha = /\bsha\d+-[a-z0-9+/]{25,}={0,3}/gi;
var regExHashStrings = /(?:\b(?:sha\d+|md5|base64|crypt|bcrypt|scrypt|security-token|assertion)[-,:$=]|#code[/])[-\w/+%.]{25,}={0,3}(?:(['"])\s*\+?\s*\1?[-\w/+%.]+={0,3})*(?![-\w/+=%.])/gi;

// node_modules/cspell-lib/dist/lib/Settings/DefaultSettings.js
var defaultConfigFile = () => resolveConfigModule(defaultConfigFileModuleRef);
var regExpSpellCheckerDisable = [
  new PatternRegExp(regExSpellingGuardBlock),
  new PatternRegExp(regExSpellingGuardLine),
  new PatternRegExp(regExSpellingGuardNext)
];
var predefinedPatterns = [
  { name: "CommitHash", pattern: regExCommitHash },
  { name: "CommitHashLink", pattern: regExCommitHashLink },
  { name: "CStyleHexValue", pattern: regExCStyleHexValue },
  { name: "CSSHexValue", pattern: regExCSSHexValue },
  { name: "Urls", pattern: regExMatchUrls },
  { name: "HexValues", pattern: regExMatchCommonHexFormats },
  { name: "SpellCheckerDisable", pattern: regExpSpellCheckerDisable },
  { name: "PublicKey", pattern: regExPublicKey },
  { name: "RsaCert", pattern: regExCert },
  { name: "SshRsa", pattern: regExSshRSA },
  { name: "EscapeCharacters", pattern: regExEscapeCharacters2 },
  { name: "Base64", pattern: regExBase64 },
  { name: "Base64SingleLine", pattern: regExBase64SingleLine },
  { name: "Base64MultiLine", pattern: regExBase64MultiLine },
  { name: "Email", pattern: regExEmail },
  { name: "SHA", pattern: regExSha },
  { name: "HashStrings", pattern: regExHashStrings },
  { name: "UnicodeRef", pattern: regExUnicodeRef },
  { name: "UUID", pattern: regExUUID },
  { name: "href", pattern: regExHRef },
  { name: "SpellCheckerDisableBlock", pattern: regExSpellingGuardBlock },
  { name: "SpellCheckerDisableLine", pattern: regExSpellingGuardLine },
  { name: "SpellCheckerDisableNext", pattern: regExSpellingGuardNext },
  { name: "SpellCheckerIgnoreInDocSetting", pattern: regExIgnoreSpellingDirectives },
  { name: "PhpHereDoc", pattern: regExPhpHereDoc },
  { name: "string", pattern: regExString },
  { name: "CStyleComment", pattern: regExCStyleComments },
  { name: "Everything", pattern: ".*" }
];
var defaultRegExpPatterns = [...predefinedPatterns].map(normalizePattern2);
var definedDefaultRegExpExcludeList = [
  "SpellCheckerDisable",
  "SpellCheckerIgnoreInDocSetting",
  "Urls",
  "Email",
  "RsaCert",
  "SshRsa",
  "Base64MultiLine",
  "Base64SingleLine",
  "CommitHash",
  "CommitHashLink",
  "CStyleHexValue",
  "CSSHexValue",
  "SHA",
  "HashStrings",
  "UnicodeRef",
  "UUID"
];
var defaultRegExpExcludeList = definedDefaultRegExpExcludeList;
var _defaultSettingsBasis = Object.freeze(createCSpellSettingsInternal({
  id: "static_defaults",
  language: "en",
  name: "Static Defaults",
  enabled: true,
  enabledLanguageIds: [],
  maxNumberOfProblems: 100,
  numSuggestions: 10,
  suggestionsTimeout: 500,
  suggestionNumChanges: 3,
  words: [],
  userWords: [],
  ignorePaths: [],
  allowCompoundWords: false,
  patterns: defaultRegExpPatterns,
  ignoreRegExpList: [],
  languageSettings: [],
  source: { name: "defaultSettings" },
  reporters: [],
  plugins: [{ parsers: parsers2 }]
}));
var _defaultSettings = Object.freeze(createCSpellSettingsInternal({
  ..._defaultSettingsBasis,
  enabledLanguageIds: [
    "ada",
    "csharp",
    "go",
    "javascript",
    "javascriptreact",
    "json",
    "markdown",
    "mdx",
    "php",
    "plaintext",
    "python",
    "text",
    "typescript",
    "typescriptreact",
    "haskell",
    "html",
    "css",
    "less",
    "scss",
    "latex",
    "ruby",
    "rust",
    "shellscript",
    "toml"
  ],
  ignoreRegExpList: defaultRegExpExcludeList,
  languageSettings: getDefaultLanguageSettings()
}));
async function resolveConfigModule(configModuleName) {
  return (await resolveFile(configModuleName, srcDirectory)).filename;
}
function normalizePattern2(pat) {
  const { name, pattern, description } = pat;
  if (!(pattern instanceof RegExp))
    return pat;
  return {
    name,
    pattern: new PatternRegExp(pattern),
    description
  };
}

class DefaultSettingsLoader {
  settings = undefined;
  pending = undefined;
  constructor() {
    this.getDefaultSettingsAsync().catch(() => {
      return;
    });
  }
  getDefaultSettingsAsync(useDefaultDictionaries = true) {
    if (!useDefaultDictionaries) {
      return Promise.resolve(_defaultSettingsBasis);
    }
    if (this.settings)
      return Promise.resolve(this.settings);
    if (this.pending)
      return this.pending;
    this.pending = (async () => {
      const defaultConfigLocation = await defaultConfigFile();
      const jsonSettings = await readSettings(defaultConfigLocation);
      this.settings = mergeSettings(_defaultSettings, jsonSettings);
      if (jsonSettings.name !== undefined) {
        this.settings.name = jsonSettings.name;
      } else {
        delete this.settings.name;
      }
      return this.settings;
    })();
    return this.pending;
  }
}
var defaultSettingsLoader = new DefaultSettingsLoader;
function getDefaultSettings(useDefaultDictionaries = true) {
  return defaultSettingsLoader.getDefaultSettingsAsync(useDefaultDictionaries);
}
// node_modules/cspell-lib/dist/lib/util/search.js
function binarySearch(arr, item, leftOffset, rightOffset) {
  let left = Math.max(leftOffset ?? 0, 0);
  let right = Math.min(rightOffset ?? arr.length, arr.length);
  while (left < right) {
    const pos = left + right >> 1;
    if (arr[pos] < item) {
      left = pos + 1;
    } else {
      right = pos;
    }
  }
  return left;
}

// node_modules/cspell-lib/dist/lib/util/text.js
function splitCamelCaseWordWithOffset(wo) {
  return splitCamelCaseWord(wo.text).map(scanMap((last, text) => ({ text, offset: last.offset + last.text.length }), {
    text: "",
    offset: wo.offset
  }));
}
function splitCamelCaseWord(word) {
  return splitWord(word, regExpCamelCaseWordBreaksWithEnglishSuffix);
}
function splitWordWithOffset(wo, regExpWordBreaks) {
  return splitWord(wo.text, regExpWordBreaks).map(scanMap((last, text) => ({ text, offset: last.offset + last.text.length }), {
    text: "",
    offset: wo.offset
  }));
}
function splitWord(word, regExpWordBreaks) {
  return word.split(regExpWordBreaks);
}
function match(reg, text) {
  if (!text)
    return [];
  reg = reg.global ? reg : new RegExp(reg.source, reg.flags + "g");
  return text.matchAll(reg);
}
function matchStringToTextOffset(reg, text) {
  return matchToTextOffset(reg, { text, offset: 0 });
}
function matchToTextOffset(reg, t) {
  const text = t.text;
  const offset = t.offset;
  return pipeSync(match(reg, text), opMapSync((m) => ({ text: m[0], offset: offset + m.index })));
}
function* extractLinesOfText(text) {
  let i = 0;
  for (let j = text.indexOf(`
`, i);j >= 0; j = text.indexOf(`
`, i)) {
    const end = j + 1;
    yield { text: text.slice(i, end), offset: i };
    i = end;
  }
  yield { text: text.slice(i, text.length), offset: i };
}
function extractWordsFromText(text) {
  return extractWordsFromTextOffset(textOffset(text));
}
function extractWordsFromTextOffset(text) {
  const reg = new RegExp(regExWords);
  return matchToTextOffset(reg, cleanTextOffset(text));
}
function cleanText(text) {
  regExIgnoreCharacters.lastIndex = 0;
  if (!regExIgnoreCharacters.test(text))
    return text;
  text = text.replace(regExIgnoreCharacters, (match2) => " ".repeat(match2.length));
  return text;
}
function cleanTextOffset(text) {
  regExIgnoreCharacters.lastIndex = 0;
  if (!regExIgnoreCharacters.test(text.text))
    return text;
  return {
    text: cleanText(text.text),
    offset: text.offset
  };
}
function extractPossibleWordsFromTextOffset(text) {
  const reg = new RegExp(regExWordsAndDigits);
  return matchToTextOffset(reg, text);
}
function extractWordsFromCode(text) {
  return extractWordsFromCodeTextOffset(textOffset(text));
}
function extractWordsFromCodeTextOffset(textOffset) {
  return pipeSync(extractWordsFromTextOffset(textOffset), opConcatMapSync(splitCamelCaseWordWithOffset));
}
function isUpperCase2(word) {
  return regExAllUpper2.test(word);
}
function isLowerCase(word) {
  return regExAllLower.test(word);
}
function isFirstCharacterUpper(word) {
  return isUpperCase2(word.slice(0, 1));
}
function isFirstCharacterLower(word) {
  return isLowerCase(word.slice(0, 1));
}
function ucFirst2(word) {
  return word.slice(0, 1).toUpperCase() + word.slice(1);
}
function lcFirst(word) {
  return word.slice(0, 1).toLowerCase() + word.slice(1);
}
function snakeToCamel(word) {
  return word.split("_").map(ucFirst2).join("");
}
function camelToSnake(word) {
  return splitCamelCaseWord(word).join("_").toLowerCase();
}
function matchCase(example, word) {
  if (regExFirstUpper.test(example)) {
    return word.slice(0, 1).toUpperCase() + word.slice(1).toLowerCase();
  }
  if (regExAllLower.test(example)) {
    return word.toLowerCase();
  }
  if (regExAllUpper2.test(example)) {
    return word.toUpperCase();
  }
  if (isFirstCharacterUpper(example)) {
    return ucFirst2(word);
  }
  if (isFirstCharacterLower(example)) {
    return lcFirst(word);
  }
  return word;
}
function textOffset(text, offset = 0) {
  return { text, offset };
}
function extractText(textOffset2, startPos, endPos) {
  const { text, offset: orig } = textOffset2;
  const a = Math.max(startPos - orig, 0);
  const b = Math.max(endPos - orig, 0);
  return text.slice(a, b);
}
function calculateTextDocumentOffsets(uri, doc, wordOffsets) {
  const lines = [
    -1,
    ...pipeSync(match(/\n/g, doc), opMapSync((a) => a.index)),
    doc.length
  ];
  let lastRow = -1;
  let lastOffset = doc.length + 1;
  let lastLineRow = -1;
  let lastLine;
  function findRowCol(offset) {
    const row = binarySearch(lines, offset, offset >= lastOffset ? lastRow : undefined);
    const col = offset - lines[Math.max(0, row - 1)];
    lastOffset = offset;
    lastRow = row;
    return [row, col];
  }
  function extractLine(row) {
    const offset = lines[row - 1] + 1;
    const text = doc.slice(offset, lines[row] + 1);
    return { text, offset };
  }
  function calcLine(row) {
    const last = lastLineRow === row ? lastLine : undefined;
    lastLineRow = row;
    const r = last ?? extractLine(row);
    lastLine = r;
    return r;
  }
  const _uri = toUri(uri).toString();
  return wordOffsets.map((wo) => {
    const [row, col] = findRowCol(wo.offset);
    return { ...wo, row, col, doc, uri: _uri, line: calcLine(row) };
  });
}
function removeAccents2(text) {
  return text.normalize("NFD").replace(regExAccents2, "");
}

// node_modules/cspell-lib/dist/lib/Settings/InDocSettings.js
var regExMatchRegEx = /\/.*\/[gimuy]*/;
var regExCSpellInDocDirective = /\b(?:spell-?checker|c?spell)::?(.*)/gi;
var regExCSpellDirectiveKey = /(?<=\b(?:spell-?checker|c?spell)::?)(?!:)(.*)/i;
var regExInFileSettings = [regExCSpellInDocDirective, /\b(LocalWords:?.*)/g];
var officialDirectives = [
  "enable",
  "disable",
  "disable-line",
  "disable-next",
  "disable-next-line",
  "word",
  "words",
  "ignore",
  "ignoreWord",
  "ignoreWords",
  "ignore-word",
  "ignore-words",
  "includeRegExp",
  "ignoreRegExp",
  "local",
  "locale",
  "language",
  "dictionaries",
  "dictionary",
  "forbid",
  "forbidWord",
  "forbid-word",
  "flag",
  "flagWord",
  "flag-word",
  "enableCompoundWords",
  "enableAllowCompoundWords",
  "disableCompoundWords",
  "disableAllowCompoundWords",
  "enableCaseSensitive",
  "disableCaseSensitive"
];
var noSuggestDirectives = new Set(["local"]);
var preferredDirectives = [
  "enable",
  "disable",
  "disable-line",
  "disable-next-line",
  "words",
  "ignore",
  "forbid",
  "locale",
  "dictionary",
  "dictionaries",
  "enableCaseSensitive",
  "disableCaseSensitive"
];
var allDirectives = new Set([...preferredDirectives, ...officialDirectives]);
var allDirectiveSuggestions = [
  ...pipeSync(allDirectives, opMapSync((word) => ({ word })))
];
var dictInDocSettings = createSpellingDictionary(allDirectives, "Directives", "Directive List", {
  supportNonStrictSearches: false
});
var EmptyWords = [];
Object.freeze(EmptyWords);
var staticInDocumentDictionaryName = `[in-document-dict]`;
function collectInDocumentDirectives(text) {
  const dirs = [...getPossibleInDocSettings(text)].flatMap((a) => associateDirectivesWithParsers(a));
  return dirs;
}
var baseInDocSettings = { id: "in-doc-settings" };
Object.freeze(baseInDocSettings);
function getInDocumentSettings(text) {
  const found = collectInDocumentDirectives(text);
  if (!found.length)
    return { ...baseInDocSettings };
  const collectedSettings = reducePossibleMatchesToSettings(found, { ...baseInDocSettings });
  const { words, flagWords, ignoreWords, suggestWords, dictionaries = [], dictionaryDefinitions = [], ...rest } = collectedSettings;
  const dict = (words || flagWords || ignoreWords || suggestWords) && clean5({
    name: staticInDocumentDictionaryName,
    words,
    flagWords,
    ignoreWords,
    suggestWords
  });
  const dictSettings = dict ? {
    dictionaries: [...dictionaries, staticInDocumentDictionaryName],
    dictionaryDefinitions: [...dictionaryDefinitions, dict]
  } : clean5({
    dictionaries: dictionaries.length ? dictionaries : undefined,
    dictionaryDefinitions: dictionaryDefinitions.length ? dictionaryDefinitions : undefined
  });
  const settings = {
    ...rest,
    ...dictSettings
  };
  return settings;
}
function validateInDocumentSettings(docText, _settings) {
  return pipeSync(getPossibleInDocSettings(docText), opMapSync(parseSettingMatchValidation), opFilterSync(isDefined6));
}
var settingParsers = [
  [/^(?:enable|disable)(?:allow)?CompoundWords\b(?!-)/i, parseCompoundWords, "CompoundWords"],
  [/^(?:enable|disable)CaseSensitive\b(?!-)/i, parseCaseSensitive, "CaseSensitive"],
  [/^enable\b(?!-)/i, parseEnable, "Enable"],
  [/^disable(-line|-next(-line)?)?\b(?!-)/i, parseDisable, "Disable"],
  [/^words?\b(?!-)/i, parseWords, "Words"],
  [/^ignore(?:-?words?)?\b(?!-)/i, parseIgnoreWords, "Ignore"],
  [/^(?:flag|forbid)(?:-?words?)?\b(?!-)/i, parseFlagWords, "Flag"],
  [/^ignore_?Reg_?Exp\s+.+$/i, parseIgnoreRegExp, "IgnoreRegExp"],
  [/^include_?Reg_?Exp\s+.+$/i, parseIncludeRegExp, "IncludeRegExp"],
  [/^locale?\b(?!-)/i, parseLocale2, "Locale"],
  [/^language\s\b(?!-)/i, parseLocale2, "Locale"],
  [/^dictionar(?:y|ies)\b(?!-)/i, parseDictionaries, "Dictionaries"],
  [/^LocalWords:/, (acc, m) => reduceWordList(acc, m.replaceAll(/^LocalWords:?/gi, " "), "words"), "Words"]
];
var issueMessages = {
  unknownDirective: "Unknown CSpell directive"
};
function parseSettingMatchValidation(possibleMatch) {
  const { fullDirective, offset } = possibleMatch;
  const directiveMatch = fullDirective.match(regExCSpellDirectiveKey);
  if (!directiveMatch)
    return;
  const match2 = directiveMatch[1];
  const possibleSetting = match2.trim();
  if (!possibleSetting)
    return;
  const start = offset + (directiveMatch.index || 0) + (match2.length - match2.trimStart().length);
  const text = possibleSetting.replace(/^([-\w]+)?.*/, "$1");
  const end = start + text.length;
  if (!text)
    return;
  const matchingParsers = settingParsers.filter(([regex]) => regex.test(possibleSetting));
  if (matchingParsers.length > 0)
    return;
  const dictSugs = dictInDocSettings.suggest(text, { ignoreCase: false }).map(({ word, isPreferred }) => isPreferred ? { word, isPreferred } : { word }).filter((a) => !noSuggestDirectives.has(a.word));
  const sugs = pipeSync(dictSugs, opAppendSync(allDirectiveSuggestions), filterUniqueSuggestions);
  const suggestionsEx = [...sugs].slice(0, 8);
  const suggestions = suggestionsEx.map((s) => s.word);
  const issue = {
    range: [start, end],
    text,
    message: issueMessages.unknownDirective,
    suggestions,
    suggestionsEx
  };
  return issue;
}
function* filterUniqueSuggestions(sugs) {
  const map3 = new Map;
  for (const sug of sugs) {
    const existing = map3.get(sug.word);
    if (existing && sug.isPreferred) {
      existing.isPreferred = true;
    }
    yield sug;
  }
}
function associateDirectivesWithParsers(possibleMatch) {
  const { match: match2 } = possibleMatch;
  const possibleSetting = match2.trim();
  return settingParsers.filter(([regex]) => regex.test(possibleSetting)).map(([, fn, directive]) => ({ ...possibleMatch, directive, fn }));
}
function mergeDirectiveIntoSettings(settings, directive) {
  return directive.fn(settings, directive.match);
}
function reducePossibleMatchesToSettings(directives, settings) {
  for (const directive of directives) {
    settings = mergeDirectiveIntoSettings(settings, directive);
  }
  return settings;
}
function parseCompoundWords(acc, match2) {
  acc.allowCompoundWords = /enable/i.test(match2);
  return acc;
}
function parseCaseSensitive(acc, match2) {
  acc.caseSensitive = /enable/i.test(match2);
  return acc;
}
function splitWords(match2) {
  return match2.split(/[,\s;]+/g).slice(1).filter((a) => !!a);
}
function mergeList2(a, b) {
  if (!a)
    return b;
  if (!b)
    return a;
  return [...a, ...b];
}
function reduceWordList(acc, match2, key) {
  const words = splitWords(match2);
  if (words.length) {
    acc[key] = mergeList2(acc[key], words);
  }
  return acc;
}
function parseWords(acc, match2) {
  return reduceWordList(acc, match2, "words");
}
function parseLocale2(acc, match2) {
  const parts = match2.trim().split(/[\s,]+/);
  const language = parts.slice(1).join(",");
  if (language) {
    acc.language = language;
  }
  return acc;
}
function parseIgnoreWords(acc, match2) {
  return reduceWordList(acc, match2, "ignoreWords");
}
function parseFlagWords(acc, match2) {
  return reduceWordList(acc, match2, "flagWords");
}
function parseRegEx(match2) {
  const patterns = [match2.replace(/^[^\s]+\s+/, "")].map((a) => {
    const m = a.match(regExMatchRegEx);
    if (m && m[0]) {
      return m[0];
    }
    return a.replace(/((?:[^\s]|\\ )+).*/, "$1");
  });
  return patterns;
}
function parseIgnoreRegExp(acc, match2) {
  const ignoreRegExpList = parseRegEx(match2);
  if (ignoreRegExpList.length) {
    acc.ignoreRegExpList = mergeList2(acc.ignoreRegExpList, ignoreRegExpList);
  }
  return acc;
}
function parseIncludeRegExp(acc, match2) {
  const includeRegExpList = parseRegEx(match2);
  if (includeRegExpList.length) {
    acc.includeRegExpList = mergeList2(acc.includeRegExpList, includeRegExpList);
  }
  return acc;
}
function parseDictionaries(acc, match2) {
  const dictionaries = match2.split(/[,\s]+/g).slice(1);
  if (dictionaries.length) {
    acc.dictionaries = mergeList2(acc.dictionaries, dictionaries);
  }
  return acc;
}
function getPossibleInDocSettings(text) {
  return pipeSync(regExInFileSettings, opMapSync((regexp) => match(regexp, text)), opFlattenSync(), opMapSync((match2) => ({ fullDirective: match2[0], offset: match2.index, match: match2[1].trim() })));
}
function parseEnable(acc, _match) {
  return acc;
}
function parseDisable(acc, _match) {
  return acc;
}

// node_modules/cspell-lib/dist/lib/Settings/TextDocumentSettings.js
function combineTextAndLanguageSettings(settings, text, languageId) {
  if (!text) {
    return toInternalSettings(calcSettingsForLanguageId(settings, languageId));
  }
  const docSettings = extractSettingsFromText(text);
  const settingsForText = mergeSettings(settings, docSettings);
  const langSettings = calcSettingsForLanguageId(settingsForText, languageId);
  const final = mergeSettings(langSettings, docSettings);
  return final;
}
function extractSettingsFromText(text) {
  return getInDocumentSettings(text);
}
// node_modules/cspell-lib/dist/lib/textValidation/determineTextDocumentSettings.js
import * as path11 from "node:path";
async function determineTextDocumentSettings(doc, settings) {
  const filename = uriToFilePath(doc.uri);
  const settingsWithDefaults = mergeSettings(await getDefaultSettings(settings.loadDefaultConfiguration ?? true), await getGlobalSettingsAsync(), settings);
  const fileSettings = calcOverrideSettings(settingsWithDefaults, filename);
  const languageIds2 = fileSettings?.languageId?.length ? fileSettings.languageId : doc.languageId ? doc.languageId : getLanguageForFilename(filename);
  if (doc.locale) {
    fileSettings.language = doc.locale;
  }
  return combineTextAndLanguageSettings(fileSettings, doc.text, languageIds2);
}
function getLanguageForFilename(filename) {
  const basename5 = path11.basename(filename);
  return findMatchingFileTypes(basename5);
}

// node_modules/cspell-lib/dist/lib/textValidation/docValidator.js
import assert21 from "node:assert";

// node_modules/@cspell/cspell-types/dist/index.mjs
var IssueType = /* @__PURE__ */ ((IssueType2) => {
  IssueType2[IssueType2["spelling"] = 0] = "spelling";
  IssueType2[IssueType2["directive"] = 1] = "directive";
  return IssueType2;
})(IssueType || {});
var defaultCSpellSettings = {
  ignoreRandomStrings: true,
  minRandomLength: 40
};

// node_modules/cspell-lib/dist/lib/suggestions.js
import assert18 from "node:assert";

// node_modules/cspell-lib/dist/lib/util/memorizeLastCall.js
function memorizeLastCall2(fn) {
  let last;
  return (...p) => {
    if (last && isArrayEqual(last.args, p)) {
      return last.value;
    }
    const args = p;
    const value = fn(...args);
    last = { args, value };
    return value;
  };
}

// node_modules/cspell-lib/dist/lib/suggestions.js
var emptySuggestionOptions = Object.freeze({});
var emptyCSpellSettings = Object.freeze({});
var memorizeSuggestions = memorizeLastCall2(cacheSuggestionsForWord);
function cacheSuggestionsForWord(options, settings) {
  const cache5 = createAutoResolveCache();
  return (word) => cache5.get(word, (word2) => _suggestionsForWord(word2, options, settings));
}
async function _suggestionsForWord(word, options, settings) {
  const { languageId, locale: language, includeDefaultConfig = true, dictionaries } = options;
  async function determineDictionaries(config2) {
    const withLocale = mergeSettings(config2, clean5({
      language: language || config2.language
    }));
    const withLanguageId = calcSettingsForLanguageId(withLocale, languageId ?? withLocale.languageId ?? "plaintext");
    const settings2 = finalizeSettings(withLanguageId);
    settings2.dictionaries = dictionaries?.length ? dictionaries : settings2.dictionaries || [];
    validateDictionaries(settings2, dictionaries);
    const dictionaryCollection2 = await getDictionaryInternal(settings2);
    settings2.dictionaries = settings2.dictionaryDefinitions?.map((def) => def.name) || [];
    const allDictionaryCollection2 = await getDictionaryInternal(settings2);
    return {
      dictionaryCollection: dictionaryCollection2,
      allDictionaryCollection: allDictionaryCollection2
    };
  }
  await refreshDictionaryCache();
  const config = includeDefaultConfig ? mergeSettings(await getDefaultSettings(settings.loadDefaultConfiguration ?? true), await getGlobalSettingsAsync(), settings) : settings;
  const { dictionaryCollection, allDictionaryCollection } = await determineDictionaries(config);
  return _suggestionsForWordAsync(word, options, settings, dictionaryCollection, allDictionaryCollection);
}
async function _suggestionsForWordAsync(word, options, settings, dictionaryCollection, allDictionaryCollection) {
  const extendsDictionaryCollection = allDictionaryCollection || dictionaryCollection;
  const { locale: language, strict = true, numChanges = 4, numSuggestions = 8, includeTies = true, includeDefaultConfig = true } = options;
  const ignoreCase2 = !strict;
  const config = includeDefaultConfig ? mergeSettings(await getDefaultSettings(settings.loadDefaultConfiguration ?? true), await getGlobalSettingsAsync(), settings) : settings;
  const opts = { ignoreCase: ignoreCase2, numChanges, numSuggestions, includeTies };
  const suggestionsByDictionary = dictionaryCollection.dictionaries.flatMap((dict) => dict.suggest(word, opts).map((r) => ({ ...r, dictName: dict.name })));
  const locale = adjustLocale(language || config.language || undefined);
  const collator2 = Intl.Collator(locale);
  const combined = limitResults(combine3(suggestionsByDictionary.sort((a, b) => a.cost - b.cost || collator2.compare(a.word, b.word))), numSuggestions, includeTies);
  const sugsAdjusted = calcSuggestionAdjustedToToMatchCase(word, combined, locale, ignoreCase2, extendsDictionaryCollection);
  const allSugs = sugsAdjusted.map((sug) => {
    const found = extendsDictionaryCollection.find(sug.word);
    return {
      ...sug,
      forbidden: found?.forbidden || false,
      noSuggest: found?.noSuggest || false
    };
  });
  return {
    word,
    suggestions: limitResults(allSugs, numSuggestions, includeTies)
  };
}
function combine3(suggestions) {
  const words = new Map;
  for (const sug of suggestions) {
    const { word, cost, dictName, ...rest } = sug;
    const f = words.get(word) || { word, cost, ...rest, dictionaries: [] };
    f.cost = Math.min(f.cost, cost);
    f.dictionaries.push(dictName);
    f.dictionaries.sort();
    words.set(word, f);
  }
  return [...words.values()];
}
function adjustLocale(locale) {
  if (!locale)
    return;
  const locales = [...normalizeLocaleIntl(locale)].filter((locale2) => isValidLocaleIntlFormat(locale2));
  if (!locales.length)
    return;
  if (locales.length === 1)
    return locales[0];
  return locales;
}
function calcSuggestionAdjustedToToMatchCase(originalWord, sugs, locale, ignoreCase2, dict) {
  locale = adjustLocale(locale);
  const knownSugs = new Set(sugs.map((sug) => sug.word));
  const matchStyle = { ...analyzeCase(originalWord), locale, ignoreCase: ignoreCase2 };
  return sugs.map((sug) => {
    const alt = matchCase2(sug.word, !!sug.isPreferred, matchStyle);
    if (alt === sug.word || knownSugs.has(alt))
      return sug;
    const found = dict.find(alt);
    if (!found || !found.forbidden || !found.noSuggest) {
      knownSugs.add(alt);
      return { ...sug, wordAdjustedToMatchCase: alt };
    }
    return sug;
  });
}
function limitResults(suggestions, numSuggestions, includeTies) {
  let cost = suggestions[0]?.cost;
  let i = 0;
  for (;i < suggestions.length; ++i) {
    if (i >= numSuggestions && (!includeTies || suggestions[i].cost > cost)) {
      break;
    }
    cost = suggestions[i].cost;
  }
  return suggestions.slice(0, i);
}
function validateDictionaries(settings, dictionaries) {
  if (!dictionaries?.length)
    return;
  const knownDicts2 = new Set(settings.dictionaryDefinitions?.map((def) => def.name) || []);
  for (const dict of dictionaries) {
    if (!knownDicts2.has(dict)) {
      throw new SuggestionError(`Unknown dictionary: "${dict}"`, "E_dictionary_unknown");
    }
  }
}
function matchCase2(word, isPreferred, style) {
  const locale = style.locale;
  if (style.isMixedCaps) {
    return word;
  }
  if (hasCaps(word)) {
    if (style.isAllCaps)
      return word.toLocaleUpperCase(locale);
    if (!style.ignoreCase || style.hasCaps || isPreferred)
      return word;
    if (isTitleCase(word) || isAllCaps(word))
      return word.toLocaleLowerCase(locale);
    return word;
  }
  if (!style.hasCaps)
    return word;
  if (style.isAllCaps)
    return word.toLocaleUpperCase(locale);
  assert18(style.isTitleCase);
  return word.replace(/^\p{L}/u, (firstLetter) => firstLetter.toLocaleUpperCase(locale));
}
var regExpHasCaps = /\p{Lu}/u;
var regExpIsAllCaps = /^[\P{L}\p{Lu}]+$/u;
var regExpIsTitleCase = /^\p{Lu}[\P{L}\p{Ll}]+$/u;
function analyzeCase(word) {
  const hasCaps = regExpHasCaps.test(word);
  const isAllCaps = hasCaps && regExpIsAllCaps.test(word);
  const isTitleCase = hasCaps && !isAllCaps && regExpIsTitleCase.test(word);
  const isMixedCaps = hasCaps && !isAllCaps && !isTitleCase;
  return { hasCaps, isAllCaps, isMixedCaps, isTitleCase };
}
function hasCaps(word) {
  return regExpHasCaps.test(word);
}
function isTitleCase(word) {
  return regExpIsTitleCase.test(word);
}
function isAllCaps(word) {
  return regExpIsAllCaps.test(word);
}

class SuggestionError extends Error {
  code;
  constructor(message, code) {
    super(message);
    this.code = code;
  }
}

// node_modules/cspell-lib/dist/lib/textValidation/defaultConstants.js
var defaultMaxNumberOfProblems = 200;
var defaultMaxDuplicateProblems = 5;
var defaultMinWordLength = 4;

// node_modules/cspell-lib/dist/lib/textValidation/lineValidatorFactory.js
import assert20 from "node:assert";

// node_modules/cspell-lib/dist/lib/util/PairingHeap.js
class PairingHeap2 {
  compare;
  _heap;
  _size = 0;
  constructor(compare4) {
    this.compare = compare4;
  }
  add(v) {
    this._heap = insert3(this.compare, this._heap, v);
    ++this._size;
    return this;
  }
  dequeue() {
    const n = this.next();
    if (n.done)
      return;
    return n.value;
  }
  append(i) {
    for (const v of i) {
      this.add(v);
    }
    return this;
  }
  next() {
    if (!this._heap) {
      return { value: undefined, done: true };
    }
    const value = this._heap.v;
    --this._size;
    this._heap = removeHead2(this.compare, this._heap);
    return { value };
  }
  peek() {
    return this._heap?.v;
  }
  [Symbol.iterator]() {
    return this;
  }
  get length() {
    return this._size;
  }
}
function removeHead2(compare4, heap) {
  if (!heap || !heap.c)
    return;
  return mergeSiblings2(compare4, heap.c);
}
function insert3(compare4, heap, v) {
  const n = {
    v,
    s: undefined,
    c: undefined
  };
  if (!heap || compare4(v, heap.v) <= 0) {
    n.c = heap;
    return n;
  }
  n.s = heap.c;
  heap.c = n;
  return heap;
}
function merge3(compare4, a, b) {
  if (compare4(a.v, b.v) <= 0) {
    a.s = undefined;
    b.s = a.c;
    a.c = b;
    return a;
  }
  b.s = undefined;
  a.s = b.c;
  b.c = a;
  return b;
}
function mergeSiblings2(compare4, n) {
  if (!n.s)
    return n;
  const s = n.s;
  const ss = s.s;
  const m = merge3(compare4, n, s);
  return ss ? merge3(compare4, m, mergeSiblings2(compare4, ss)) : m;
}

// node_modules/cspell-lib/dist/lib/util/regexHelper.js
function escapeRegEx3(s) {
  return s.replaceAll(/[|\\{}()[\]^$+*?.]/g, "\\$&").replaceAll("-", "\\x2d");
}

// node_modules/cspell-lib/dist/lib/util/wordSplitter.js
var ignoreBreak = Object.freeze([]);
function split(line, offset, isValidWord, options = {}) {
  const relWordToSplit = findNextWordText({ text: line.text, offset: offset - line.offset });
  const lineOffset = line.offset;
  const requested = new Map;
  const regExpIgnoreSegment = /^[-.+\d_eE'`\\\s]+$/;
  if (!relWordToSplit.text) {
    const text = rebaseTextOffset(relWordToSplit);
    return {
      line,
      offset,
      text,
      words: [],
      endOffset: text.offset + text.text.length
    };
  }
  const lineSegment = {
    line,
    relStart: relWordToSplit.offset,
    relEnd: relWordToSplit.offset + relWordToSplit.text.length
  };
  const possibleBreaks = generateWordBreaks(lineSegment, options);
  if (!possibleBreaks.length) {
    const text = rebaseTextOffset(relWordToSplit);
    return {
      line,
      offset,
      text,
      words: [{ ...text, isFound: isValidWord(text) }],
      endOffset: text.offset + text.text.length
    };
  }
  function rebaseTextOffset(relText) {
    return {
      ...relText,
      offset: relText.offset + lineOffset
    };
  }
  function has(word) {
    if (regExpIgnoreSegment.test(word.text)) {
      return true;
    }
    const i = word.offset;
    const j = word.text.length;
    let v = i + (j << 20);
    if (i < 1 << 20 && j < 1 << 11) {
      const b = requested.get(v);
      if (b !== undefined)
        return b;
    } else {
      v = -1;
    }
    const r = isValidWord(rebaseTextOffset(word));
    if (v >= 0) {
      requested.set(v, r);
    }
    return r;
  }
  possibleBreaks.push({
    offset: lineSegment.relEnd,
    breaks: [ignoreBreak]
  });
  const result = {
    line,
    offset,
    text: rebaseTextOffset(relWordToSplit),
    words: splitIntoWords(lineSegment, possibleBreaks, has).map(rebaseTextOffset),
    endOffset: lineOffset + lineSegment.relEnd
  };
  return result;
}
function findNextWordText({ text, offset }) {
  const reg = new RegExp(regExWordsAndDigits);
  reg.lastIndex = offset;
  const m = reg.exec(text);
  if (!m) {
    return {
      text: "",
      offset: offset + text.length
    };
  }
  if (regExNumericLiteral.test(m[0])) {
    return findNextWordText({ text, offset: offset + m[0].length });
  }
  return {
    text: m[0],
    offset: m.index
  };
}
function generateWordBreaks(line, options) {
  const camelBreaks = genWordBreakCamel(line);
  const symbolBreaks = genSymbolBreaks(line);
  const optionalBreaks = genOptionalWordBreaks(line, options.optionalWordBreakCharacters);
  return mergeSortedBreaks(...camelBreaks, ...symbolBreaks, ...optionalBreaks);
}
function offsetRegEx(reg, offset) {
  const r = new RegExp(reg);
  r.lastIndex = offset;
  return r;
}
function genWordBreakCamel(line) {
  const breaksCamel1 = [];
  const text = line.line.text.slice(0, line.relEnd);
  for (const m of text.matchAll(offsetRegEx(regExSplitWords, line.relStart))) {
    if (m.index === undefined)
      break;
    const i = m.index + m[1].length;
    breaksCamel1.push({
      offset: m.index,
      breaks: [[i, i], ignoreBreak]
    });
  }
  const breaksCamel2 = [];
  for (const m of text.matchAll(offsetRegEx(regExSplitWords2, line.relStart))) {
    if (m.index === undefined)
      break;
    const i = m.index + m[1].length;
    const j = i + m[3].length;
    breaksCamel2.push({
      offset: m.index,
      breaks: [[i, i], [j, j], ignoreBreak]
    });
  }
  return [breaksCamel1, breaksCamel2];
}
function calcBreaksForRegEx(line, reg, calcBreak) {
  const sb = [];
  const text = line.line.text.slice(0, line.relEnd);
  for (const m of text.matchAll(offsetRegEx(reg, line.relStart))) {
    const b = calcBreak(m);
    if (b) {
      sb.push(b);
    }
  }
  return sb;
}
function genOptionalWordBreaks(line, optionalBreakCharacters) {
  function calcBreaks(m) {
    const i = m.index;
    if (i === undefined)
      return;
    const j = i + m[0].length;
    return {
      offset: i,
      breaks: [
        [i, j],
        ignoreBreak
      ]
    };
  }
  const breaks = [
    calcBreaksForRegEx(line, regExDanglingQuote, calcBreaks),
    calcBreaksForRegEx(line, regExTrailingEndings, calcBreaks)
  ];
  if (optionalBreakCharacters) {
    const regex = new RegExp(`[${escapeRegEx3(optionalBreakCharacters)}]`, "gu");
    breaks.push(calcBreaksForRegEx(line, regex, calcBreaks));
  }
  return breaks;
}
function genSymbolBreaks(line) {
  function calcBreaks(m) {
    const i = m.index;
    if (i === undefined)
      return;
    const j = i + m[0].length;
    return {
      offset: i,
      breaks: [
        [i, j],
        [i, i],
        [j, j],
        ignoreBreak
      ]
    };
  }
  return [
    calcBreaksForRegEx(line, regExPossibleWordBreaks, calcBreaks),
    calcBreaksForRegEx(line, /\d+/g, calcBreaks),
    calcBreaksForRegEx(line, regExEscapeCharacters, calcBreaks)
  ];
}
function splitIntoWords(lineSeg, breaks, has) {
  const maxIndex = lineSeg.relEnd;
  const maxAttempts = 1000;
  const knownPathsByIndex = new Map;
  function makeCandidates(p, i, bi, currentCost) {
    const len = maxIndex;
    while (bi < breaks.length && breaks[bi].offset < i) {
      bi += 1;
    }
    if (bi >= breaks.length) {
      return [];
    }
    const br = breaks[bi];
    function c(bp) {
      const d = bp.length < 2 ? len - i : (bp[0] - i) * 0.5 + len - bp[1];
      const ec = currentCost + d;
      return {
        p,
        i,
        bi,
        bp,
        c: currentCost,
        ec,
        text: undefined
      };
    }
    return br.breaks.map(c);
  }
  function checkTextOffset(text2, offset) {
    const valid = has({ text: text2, offset });
    return {
      text: text2,
      offset,
      isFound: valid
    };
  }
  function compare4(a, b) {
    return a.ec - b.ec || b.i - a.i;
  }
  function pathToWords(node) {
    const results = [];
    for (let p = node;p; p = p.n) {
      if (p.text) {
        results.push(p.text);
      }
    }
    return results;
  }
  function addToKnownPaths(candidate, path12) {
    for (let can = candidate;can !== undefined; can = can.p) {
      const t = can.text;
      const i = can.i;
      const cost = (!t || t.isFound ? 0 : t.text.length) + (path12?.c ?? 0);
      const exitingPath = knownPathsByIndex.get(i);
      if (exitingPath && exitingPath.c <= cost) {
        return;
      }
      const node = {
        n: path12,
        i,
        c: cost,
        text: t
      };
      knownPathsByIndex.set(i, node);
      path12 = node;
    }
    return path12;
  }
  let maxCost = lineSeg.relEnd - lineSeg.relStart;
  const candidates = new PairingHeap2(compare4);
  const text = lineSeg.line.text;
  candidates.append(makeCandidates(undefined, lineSeg.relStart, 0, 0));
  let attempts = 0;
  let bestPath;
  while (maxCost && candidates.length && attempts++ < maxAttempts) {
    const best = candidates.dequeue();
    if (!best || best.c >= maxCost) {
      continue;
    }
    if (best.bp.length) {
      const i = best.bp[0];
      const j = best.bp[1];
      const t = i > best.i ? checkTextOffset(text.slice(best.i, i), best.i) : undefined;
      const cost = !t || t.isFound ? 0 : t.text.length;
      const mc = maxIndex - j;
      best.c += cost;
      best.ec = best.c + mc;
      best.text = t;
      const possiblePath = knownPathsByIndex.get(j);
      if (possiblePath) {
        const f = addToKnownPaths(best, possiblePath);
        bestPath = !bestPath || f && f.c < bestPath.c ? f : bestPath;
      } else if (best.c < maxCost) {
        const c = makeCandidates(t ? best : best.p, j, best.bi + 1, best.c);
        candidates.append(c);
      }
    } else {
      const c = makeCandidates(best.p, best.i, best.bi + 1, best.c);
      candidates.append(c);
      if (!c.length) {
        const t = maxIndex > best.i ? checkTextOffset(text.slice(best.i, maxIndex), best.i) : undefined;
        const cost = !t || t.isFound ? 0 : t.text.length;
        best.c += cost;
        best.ec = best.c;
        best.text = t;
        const segText = t || best.p?.text || checkTextOffset("", best.i);
        const can = t ? { ...best, text: segText } : { ...best, ...best.p, text: segText };
        const f = addToKnownPaths(can, undefined);
        bestPath = !bestPath || f && f.c < bestPath.c ? f : bestPath;
      }
    }
    if (bestPath && bestPath.c < maxCost) {
      maxCost = bestPath.c;
    }
  }
  return pathToWords(bestPath);
}
function mergeSortedBreaks(...maps) {
  return maps.flat().sort((a, b) => a.offset - b.offset);
}

// node_modules/cspell-lib/dist/lib/textValidation/isRandomString.js
var maxRadio = 0.5;
function isRandomString(s, maxNoiseToLengthRatio = maxRadio) {
  return scoreRandomString(s) >= maxNoiseToLengthRatio;
}
function scoreRandomString(s) {
  if (!s.length)
    return 0;
  const n = categorizeString(s);
  return n.length / s.length;
}
function categorizeString(s) {
  const n = s.replaceAll(/\d+/g, "0").replaceAll(/\p{Ll}\p{M}+/gu, "a").replaceAll(/\p{Lu}\p{M}+/gu, "A").replaceAll(/\p{Lu}?\p{Ll}+/gu, "1").replaceAll(/\p{Lu}+/gu, "2").replaceAll(/\p{M}/gu, "4").replaceAll("_", "").replaceAll(/[-_.']+/g, "3");
  return n;
}
var hexSequence = /(?:\b|(?<=[\W_]))[0-9a-fA-F][-0-9a-fA-F]*[0-9a-fA-F](?:\b|(?=[\W_]))/g;
var isLetter = /\p{L}/uy;
function isLetterAt(s, idx2) {
  isLetter.lastIndex = idx2;
  return isLetter.test(s);
}
var MIN_HEX_SEQUENCE_LENGTH = 4;
function extractHexSequences(s, minLength = MIN_HEX_SEQUENCE_LENGTH) {
  return [...s.matchAll(hexSequence)].filter((m) => m[0].length >= minLength && (m.index === 0 || !isLetterAt(s, m.index - 1)) && !isLetterAt(s, m.index + m[0].length)).map((m) => ({ text: m[0], offset: m.index }));
}

// node_modules/cspell-lib/dist/lib/textValidation/isWordValid.js
function hasWordCheck(dict, word) {
  word = word.includes("\\") ? word.replaceAll("\\", "") : word;
  return dict.has(word);
}
function isWordValidWithEscapeRetry(dict, wo, line) {
  const firstTry = hasWordCheck(dict, wo.text);
  return firstTry || line.text[wo.offset - line.offset - 1] === "\\" && hasWordCheck(dict, wo.text.slice(1));
}

// node_modules/cspell-lib/dist/lib/util/TextMap.js
import assert19 from "node:assert";
function extractTextMapRangeOrigin(textMap, extractRange) {
  const { text: srcTxt, range: srcRange, map: srcMap } = textMap;
  const [r0, r1] = srcRange;
  const startOrig = Math.min(Math.max(extractRange[0], r0), r1);
  const endOrig = Math.min(Math.max(extractRange[1], r0), r1);
  const a = startOrig - r0;
  const b = endOrig - r0;
  const range = [startOrig, endOrig];
  if (!srcMap || !srcMap.length || a === b) {
    const text2 = srcTxt.slice(a, b);
    return { text: text2, range };
  }
  assert19((srcMap.length & 1) === 0, "Map must be pairs of values.");
  const mapLen = srcMap.length;
  const mapEndSrc = srcMap[mapLen - 2];
  const mapEndDst = srcMap[mapLen - 1];
  const endDiff = srcTxt.length - mapEndDst;
  const head = !srcMap[0] && !srcMap[1] ? [] : [0, 0];
  const tail = [mapEndSrc + endDiff, mapEndDst + endDiff];
  const sMap = [...head, ...srcMap, ...tail];
  let idx2 = 0;
  for (;idx2 < sMap.length && a >= sMap[idx2]; idx2 += 2) {
  }
  const aIdx = idx2;
  idx2 -= 2;
  const a0 = a - sMap[idx2];
  const a1 = a0 + sMap[idx2 + 1];
  for (;idx2 < sMap.length && b > sMap[idx2]; idx2 += 2) {
  }
  const bIdx = idx2;
  const b0 = b - sMap[idx2];
  const b1 = b0 + sMap[idx2 + 1];
  const text = srcTxt.slice(a1, b1);
  if (bIdx === aIdx) {
    return { text, range };
  }
  const ab = [a0, a1];
  const map3 = sMap.slice(aIdx, bIdx + 2).map((v, i) => v - ab[i & 1]);
  return { text, range, map: map3 };
}

// node_modules/cspell-lib/dist/lib/textValidation/parsedText.js
function mapRangeBackToOriginalPos(offRange, map3) {
  if (!map3 || !map3.length)
    return offRange;
  const [start, end] = offRange;
  let i = 0, j = 0, p = 1;
  while (p < map3.length && map3[p] < start) {
    i = map3[p - 1];
    j = map3[p];
    p += 2;
  }
  const iA = start - j + i;
  while (p < map3.length && map3[p] < end) {
    i = map3[p - 1];
    j = map3[p];
    p += 2;
  }
  const iB = end - j + i;
  return [iA, iB];
}
function createMappedTextSegmenter(includeRanges) {
  let rangePos = 0;
  function* segmenter(pText) {
    if (!includeRanges.length) {
      return;
    }
    const range = pText.range;
    const textEndPos = range[1];
    let textStartPos = range[0];
    while (rangePos && (rangePos >= includeRanges.length || includeRanges[rangePos].startPos > textStartPos)) {
      rangePos -= 1;
    }
    const cur = includeRanges[rangePos];
    if (textEndPos <= cur.endPos && textStartPos >= cur.startPos) {
      yield pText;
      return;
    }
    while (textStartPos < textEndPos) {
      while (includeRanges[rangePos] && includeRanges[rangePos].endPos <= textStartPos) {
        rangePos += 1;
      }
      if (!includeRanges[rangePos]) {
        break;
      }
      const { startPos, endPos } = includeRanges[rangePos];
      if (textEndPos < startPos) {
        break;
      }
      const a = Math.max(textStartPos, startPos);
      const b = Math.min(textEndPos, endPos);
      if (a !== b) {
        yield extractTextMapRangeOrigin(pText, [a, b]);
      }
      textStartPos = b;
    }
  }
  return segmenter;
}

// node_modules/cspell-lib/dist/lib/textValidation/lineValidatorFactory.js
var MIN_HEX_SEQUENCE_LENGTH2 = 8;
function lineValidatorFactory(sDict, options) {
  const { minWordLength = defaultMinWordLength, flagWords = [], allowCompoundWords = false, ignoreCase: ignoreCase2 = true, ignoreRandomStrings = defaultCSpellSettings.ignoreRandomStrings, minRandomLength = defaultCSpellSettings.minRandomLength } = options;
  const hasWordOptions = {
    ignoreCase: ignoreCase2,
    useCompounds: allowCompoundWords || undefined
  };
  const dictCol = createCachingDictionary(sDict, hasWordOptions);
  const knownWords = new Map;
  const setOfFlagWords = new Set(flagWords);
  const setOfKnownIssues = new Map;
  const setOfKnownSuccessfulWords = new Set;
  const rememberFilter = (fn2) => (v) => {
    const keep = fn2(v);
    if (!keep) {
      setOfKnownSuccessfulWords.add(v.text);
    }
    return keep;
  };
  const filterAlreadyChecked = (wo) => {
    return !setOfKnownSuccessfulWords.has(wo.text);
  };
  const hasDict = {
    has(word) {
      const info = getWordInfo(word);
      if (info.isFound !== undefined)
        return info.isFound;
      if (info.isFlagged)
        return true;
      if (info.isFlagged)
        return false;
      info.isFound = dictCol.has(word);
      return info.isFound;
    }
  };
  function calcIgnored(info) {
    info.isIgnored ??= dictCol.isNoSuggestWord(info.word);
    return info.isIgnored;
  }
  function calcFlagged(info) {
    if (info.isFlagged !== undefined)
      return info.isFlagged;
    const word = info.word;
    info.isFlagged = (setOfFlagWords.has(word) || setOfFlagWords.has(word.toLowerCase()) || dictCol.isForbidden(word)) && !calcIgnored(info);
    return info.isFlagged;
  }
  function isWordIgnored(word) {
    return calcIgnored(getWordInfo(word));
  }
  function getSuggestions(word) {
    return dictCol.getPreferredSuggestions(word);
  }
  function isWordFlagged(wo) {
    return calcFlagged(getWordInfo(wo.text));
  }
  function annotateIsFlagged(word) {
    word.isFlagged = isWordFlagged(word);
    return word;
  }
  function annotateIssue(issue) {
    const sugs = getSuggestions(issue.text);
    if (sugs && sugs.length) {
      issue.suggestionsEx = sugs;
    }
    return issue;
  }
  const isFlaggedOrMinLength = (wo) => wo.text.length >= minWordLength || !!wo.isFlagged;
  const isFlaggedOrNotFound = rememberFilter((wo) => wo.isFlagged || !wo.isFound);
  const isNotRepeatingChar = rememberFilter((wo) => !regExRepeatedChar.test(wo.text));
  function checkWord(issue) {
    const info = getWordInfo(issue.text);
    if (info.fin) {
      const { isFlagged: isForbidden, isFound, isIgnored: isIgnored2 } = info;
      const isFlagged2 = issue.isFlagged ?? (!isIgnored2 && isForbidden);
      issue.isFlagged = isFlagged2;
      issue.isFound = isFlagged2 ? undefined : isFound;
      return issue;
    }
    const isIgnored = calcIgnored(info);
    const isFlagged = issue.isFlagged ?? calcFlagged(info);
    info.isFound ??= isFlagged ? false : isIgnored || isWordValidWithEscapeRetry(hasDict, issue, issue.line);
    info.isFlagged = !!isFlagged;
    info.fin = true;
    issue.isFlagged = isFlagged;
    issue.isFound = isFlagged ? undefined : info.isFound;
    return issue;
  }
  const regExUpperCaseWithTrailingCommonEnglishSuffix = /^([\p{Lu}\p{M}]{2,})[']?(?:s|ing|ies|es|ings|ize|ed|ning)$/u;
  const regExpIsLetter = /\p{L}/u;
  const fn = (lineSegment) => {
    const line = lineSegment.line;
    function isWordTooShort(word, ignoreSuffix = false) {
      if (word.text.length >= minWordLength * 2 || [...word.text].length >= minWordLength)
        return false;
      const offset = word.offset - line.offset;
      assert20.equal(line.text.slice(offset, offset + word.text.length), word.text);
      const prefix = [...line.text.slice(Math.max(0, offset - 2), offset)];
      const hasLetterPrefix = !!prefix.length && regExpIsLetter.test(prefix[prefix.length - 1]);
      if (hasLetterPrefix)
        return false;
      if (ignoreSuffix)
        return true;
      const suffix = [...line.text.slice(offset + word.text.length, offset + word.text.length + 2)];
      const hasLetterSuffix = !!suffix.length && regExpIsLetter.test(suffix[0]);
      return !hasLetterSuffix;
    }
    function splitterIsValid(word) {
      if (setOfKnownSuccessfulWords.has(word.text))
        return true;
      if (isWordFlagged(word))
        return false;
      if (isWordValidWithEscapeRetry(hasDict, word, lineSegment.line))
        return true;
      if (isWordTooShort(word))
        return true;
      return isAllCapsWithTrailingCommonEnglishSuffixOk(word);
    }
    function isAllCapsWithTrailingCommonEnglishSuffixOk(tWord) {
      if (!regExUpperCaseWithTrailingCommonEnglishSuffix.test(tWord.text))
        return false;
      const m = tWord.text.match(regExUpperCaseWithTrailingCommonEnglishSuffix);
      if (!m)
        return false;
      const offset = tWord.offset;
      const v = { offset, text: m[1], line };
      const check = checkWord(v);
      if (check.isFlagged)
        return false;
      if (check.isFound)
        return true;
      if (isWordTooShort(v, true))
        return true;
      return false;
    }
    function checkFullWord(vr) {
      if (vr.isFlagged) {
        return [vr];
      }
      if (isAllCapsWithTrailingCommonEnglishSuffixOk(vr))
        return [];
      if (isWordIgnored(vr.text) || checkWord(vr).isFound) {
        rememberFilter((_) => false)(vr);
        return [];
      }
      if (vr.isFlagged)
        return [vr];
      const codeWordResults = checkCamelCaseWord(vr);
      if (!codeWordResults.length) {
        rememberFilter((_) => false)(vr);
        return [];
      }
      return codeWordResults;
    }
    function checkCamelCaseWord(vr) {
      return _checkCamelCaseWord(vr, regExpCamelCaseWordBreaksWithEnglishSuffix);
    }
    function _checkCamelCaseWord(vr, regExpWordBreaks) {
      const codeWordResults = [];
      for (const wo of splitWordWithOffset(vr, regExpWordBreaks)) {
        if (setOfKnownSuccessfulWords.has(wo.text))
          continue;
        const issue = wo;
        issue.line = vr.line;
        issue.isFlagged = undefined;
        issue.isFound = undefined;
        annotateIsFlagged(issue);
        if (!isFlaggedOrMinLength(issue))
          continue;
        checkWord(issue);
        if (!isFlaggedOrNotFound(issue) || !isNotRepeatingChar(issue))
          continue;
        issue.text = extractText(lineSegment.segment, issue.offset, issue.offset + issue.text.length);
        codeWordResults.push(issue);
      }
      return codeWordResults;
    }
    function rebaseKnownIssues(possibleWord, known) {
      const { issues } = known;
      const adjOffset = possibleWord.offset - known.possibleWord.offset;
      return issues.map((issue) => {
        issue = { ...issue };
        issue.offset += adjOffset;
        issue.line = lineSegment.line;
        return issue;
      });
    }
    function checkForFlaggedWord(possibleWord) {
      if (isWordFlagged(possibleWord)) {
        const vr = {
          ...possibleWord,
          line: lineSegment.line,
          isFlagged: true
        };
        return vr;
      }
      if (possibleWord.text.endsWith(".") && possibleWord.text.length > 1) {
        const pw = { ...possibleWord, text: possibleWord.text.slice(0, -1) };
        if (isWordFlagged(pw)) {
          const vr = {
            ...pw,
            line: lineSegment.line,
            isFlagged: true
          };
          return vr;
        }
      }
      return;
    }
    function checkPossibleWords(possibleWord) {
      const known = setOfKnownIssues.get(possibleWord.text);
      if (known) {
        if (!known.issues.length)
          return known.issues;
        const adjusted = rebaseKnownIssues(possibleWord, known);
        return adjusted;
      }
      const issues = _checkPossibleWords(possibleWord).map(annotateIssue);
      setOfKnownIssues.set(possibleWord.text, { possibleWord, issues });
      return issues;
    }
    function _checkPossibleWords(possibleWord) {
      const flagged = checkForFlaggedWord(possibleWord);
      if (flagged)
        return [flagged];
      let mismatches = [];
      for (const wo of extractWordsFromTextOffset(possibleWord)) {
        if (setOfKnownSuccessfulWords.has(wo.text))
          continue;
        const issue = wo;
        issue.line = lineSegment.line;
        annotateIsFlagged(issue);
        if (!isFlaggedOrMinLength(issue))
          continue;
        for (const w of checkFullWord(issue)) {
          mismatches.push(w);
        }
      }
      if (!mismatches.length)
        return mismatches;
      const hexSequences = !ignoreRandomStrings ? [] : extractHexSequences(possibleWord.text, MIN_HEX_SEQUENCE_LENGTH2).filter((w) => (w.text === w.text.toLowerCase() || w.text === w.text.toUpperCase()) && /[\d-]/.test(w.text)).map((w) => (w.offset += possibleWord.offset, w));
      if (hexSequences.length) {
        mismatches = filterExcludedTextOffsets(mismatches, hexSequences);
      }
      if (mismatches.length) {
        const splitResult = split(lineSegment.segment, possibleWord.offset, splitterIsValid);
        const nonMatching = splitResult.words.filter((w) => !w.isFound).filter((w) => {
          const m = w.text.match(regExUpperCaseWithTrailingCommonEnglishSuffix);
          if (!m)
            return true;
          const v = checkWord({ ...w, text: m[1], line: lineSegment.line });
          return v.isFlagged || !v.isFound;
        });
        const filtered = filterExcludedTextOffsets(nonMatching.map((w) => ({ ...w, line: lineSegment.line })).map(annotateIsFlagged), hexSequences);
        if (filtered.length < mismatches.length) {
          return filtered;
        }
      }
      return mismatches;
    }
    function isNotRandom(textOff) {
      if (textOff.text.length < minRandomLength || !ignoreRandomStrings)
        return true;
      return !isRandomString(textOff.text);
    }
    const checkedPossibleWords = pipeSync(extractPossibleWordsFromTextOffset(lineSegment.segment), opFilterSync(isNotRandom), opFilterSync(filterAlreadyChecked), opConcatMapSync(checkPossibleWords));
    return checkedPossibleWords;
  };
  function getWordInfo(word) {
    const info = knownWords.get(word);
    if (info)
      return info;
    const result = { word, isFound: undefined, isFlagged: undefined, isIgnored: undefined, fin: false };
    knownWords.set(word, result);
    return result;
  }
  return { fn, dict: dictCol };
}
function textValidatorFactory(dict, options) {
  const lineValidator = lineValidatorFactory(dict, options);
  const lineValidatorFn = lineValidator.fn;
  function validate(pText) {
    const { text, range: srcRange, map: map3 } = pText;
    const srcOffset = srcRange[0];
    const segment = { text, offset: 0 };
    const lineSegment = { line: segment, segment };
    function mapBackToOriginSimple(vr) {
      const { text: text2, offset, isFlagged, isFound, suggestionsEx } = vr;
      const r = mapRangeBackToOriginalPos([offset, offset + text2.length], map3);
      const range = [r[0] + srcOffset, r[1] + srcOffset];
      return { text: text2, range, isFlagged, isFound, suggestionsEx };
    }
    return [...lineValidatorFn(lineSegment)].map(mapBackToOriginSimple);
  }
  return {
    validate,
    lineValidator
  };
}
function filterExcludedTextOffsets(issues, excluded) {
  if (!excluded.length)
    return issues;
  const keep = [];
  let i = 0;
  let j = 0;
  for (i = 0;i < issues.length && j < excluded.length; i++) {
    const issue = issues[i];
    while (j < excluded.length && excluded[j].offset + excluded[j].text.length <= issue.offset) {
      j++;
    }
    if (j >= excluded.length) {
      break;
    }
    if (issue.isFlagged || issue.offset < excluded[j].offset) {
      keep.push(issue);
    }
  }
  if (i < issues.length) {
    keep.push(...issues.slice(i));
  }
  return keep;
}

// node_modules/cspell-lib/dist/lib/textValidation/settingsToValidateOptions.js
function settingsToValidateOptions(settings) {
  const opt = {
    ...settings,
    ignoreCase: !(settings.caseSensitive ?? false),
    ignoreRandomStrings: settings.ignoreRandomStrings,
    minRandomLength: settings.minRandomLength
  };
  return opt;
}

// node_modules/cspell-lib/dist/lib/util/TextRange.js
function toMatchRangeWithText(m) {
  const index = m.index || 0;
  const _text = m[0];
  return {
    startPos: index,
    endPos: index + _text.length,
    text: _text
  };
}
function findMatchingRanges(pattern, text) {
  if (pattern.source === ".*") {
    return [{ startPos: 0, endPos: text.length }];
  }
  const regex = new RegExp(pattern);
  if (!regex.global) {
    const m = text.match(regex);
    if (!m)
      return [];
    return [toMatchRangeWithText(m)];
  }
  return [...text.matchAll(regex)].map(toMatchRangeWithText);
}
function compareRanges(a, b) {
  return a.startPos - b.startPos || a.endPos - b.endPos;
}
function unionRanges(ranges) {
  const sortedRanges = sortMatchRangeArray(ranges);
  ranges = sortedRanges.values;
  if (!ranges.length)
    return sortedRanges;
  let i = 0;
  let j = 0;
  let { startPos, endPos } = ranges[i++];
  for (;i < ranges.length; ++i) {
    const r = ranges[i];
    if (r.startPos > endPos) {
      ranges[j++] = { startPos, endPos };
      startPos = r.startPos;
      endPos = r.endPos;
      continue;
    }
    endPos = Math.max(endPos, r.endPos);
  }
  if (startPos < endPos) {
    ranges[j++] = { startPos, endPos };
  }
  ranges.length = j;
  return sortedRanges;
}
function findMatchingRangesForPatterns(patterns, text) {
  const nested = patterns.map((pattern) => findMatchingRanges(pattern, text));
  return unionRanges(flatten(nested)).values;
}
function excludeRanges(includeRanges, excludeRanges2) {
  return _excludeRanges(sortMatchRangeArray(includeRanges), sortMatchRangeArray(excludeRanges2));
}
function _excludeRanges(sortedIncludeRanges, sortedExcludeRanges) {
  const includeRanges = sortedIncludeRanges.values;
  const excludeRanges2 = sortedExcludeRanges.values;
  if (!includeRanges.length)
    return includeRanges;
  if (!excludeRanges2.length) {
    return includeRanges;
  }
  const ranges = [];
  ranges.length = includeRanges.length + excludeRanges2.length + 1;
  let i = 0;
  let exIndex = 0;
  const limit = excludeRanges2.length;
  for (const incRange of includeRanges) {
    const endPos = incRange.endPos;
    let startPos = incRange.startPos;
    for (;exIndex < limit; ++exIndex) {
      const ex = excludeRanges2[exIndex];
      if (ex.startPos >= endPos)
        break;
      if (ex.endPos <= startPos)
        continue;
      if (ex.startPos > startPos) {
        ranges[i++] = { startPos, endPos: ex.startPos };
      }
      startPos = ex.endPos;
      if (startPos >= endPos)
        break;
    }
    if (startPos < endPos) {
      ranges[i++] = { startPos, endPos };
    }
  }
  ranges.length = i;
  return ranges;
}
function sortMatchRangeArray(values) {
  values.sort(compareRanges);
  return { values };
}
function flatten(data) {
  let size = 0;
  for (let i = data.length - 1;i >= 0; --i) {
    size += data[i].length;
  }
  const result = new Array(size);
  let k = 0;
  for (let i = 0;i < data.length; ++i) {
    const d = data[i];
    for (let j = 0;j < d.length; ++j) {
      result[k++] = d[j];
    }
  }
  return result;
}

// node_modules/cspell-lib/dist/lib/textValidation/textValidator.js
function calcTextInclusionRanges(text, options) {
  const { ignoreRegExpList = [], includeRegExpList = [] } = options;
  const filteredIncludeList = includeRegExpList.filter((a) => !!a);
  const finalIncludeList = filteredIncludeList.length ? filteredIncludeList : [/.*/gim];
  const includeRanges = excludeRanges(findMatchingRangesForPatterns(finalIncludeList, text), findMatchingRangesForPatterns(ignoreRegExpList, text));
  return includeRanges;
}

// node_modules/cspell-lib/dist/lib/textValidation/traceWord.js
function traceWord(word, dictCollection, config) {
  const opts = {
    ignoreCase: config.ignoreCase ?? true,
    useCompounds: config.allowCompoundWords || false
  };
  const splits = split({ text: word, offset: 0 }, 0, checkWord);
  const wfSplits = splits.words.map((s) => ({ word: s.text, found: s.isFound }));
  const unique2 = uniqueFn((w) => w.word + "|" + w.found);
  const wsFound = { word, found: dictCollection.has(word, opts) };
  const wordSplits = wfSplits.some((s) => s.word === word) ? wfSplits : [wsFound, ...wfSplits];
  const traces = wordSplits.filter(unique2).map((s) => s.word).flatMap((word2) => dictCollection.dictionaries.map((dict) => ({ dict, word: word2 }))).map(({ dict, word: word2 }) => ({ dict, findResult: dict.find(word2, opts), word: word2 })).flatMap((r2) => unpackDictionaryFindResult(r2, config));
  const r = new CTraceResult(...traces);
  r.splits = wordSplits;
  return r;
  function checkWord(wo) {
    return dictCollection.has(wo.text, opts);
  }
}
function unpackDictionaryFindResult(found, config) {
  const { word, dict, findResult } = found;
  const dictPreferred = getPreferred(dict, word);
  const baseResult = {
    word,
    found: !!findResult?.found,
    foundWord: findResult?.found || undefined,
    forbidden: findResult?.forbidden || false,
    noSuggest: findResult?.noSuggest || false,
    dictName: dict.name,
    dictSource: dict.source,
    configSource: undefined,
    preferredSuggestions: dictPreferred,
    errors: normalizeErrors(dict.getErrors?.())
  };
  const configFieldName = mapSpecialDictionaryNamesToSettings.get(dict.name);
  if (!findResult?.found || !configFieldName || !config.source) {
    return [baseResult];
  }
  const opts = {
    ignoreCase: true,
    useCompounds: config.allowCompoundWords || false
  };
  const sources = getSources(config);
  const results = [];
  for (const src of sources) {
    if (!src[configFieldName] || !Array.isArray(src[configFieldName]) || !src[configFieldName]?.length || !src.source?.filename) {
      continue;
    }
    const configSource = toFileUrl(src.source.filename).href;
    const cfg = { [configFieldName]: src[configFieldName] };
    const cfgDict = createCollection(getInlineConfigDictionaries(cfg), dict.name, configSource);
    const findResult2 = cfgDict.find(word, opts);
    const preferredSuggestions = getPreferred(cfgDict, word);
    if (!findResult2?.found && !preferredSuggestions)
      continue;
    const result = {
      word,
      found: !!findResult2?.found,
      foundWord: findResult2?.found || undefined,
      forbidden: findResult2?.forbidden || false,
      noSuggest: findResult2?.noSuggest || false,
      dictName: dict.name,
      dictSource: configSource,
      configSource,
      preferredSuggestions,
      errors: normalizeErrors(dict.getErrors?.())
    };
    results.push(result);
  }
  return results.length ? results : [baseResult];
}
function normalizeErrors(errors2) {
  return errors2?.length ? errors2 : undefined;
}
function getPreferred(dict, word) {
  const sugs = dict.getPreferredSuggestions?.(word);
  const preferred = sugs?.length ? sugs.filter((s) => s.isPreferred).map((s) => s.word) : undefined;
  return preferred;
}

class CTraceResult extends Array {
  splits = [];
  constructor(...items) {
    super(...items);
  }
}

// node_modules/cspell-lib/dist/lib/textValidation/docValidator.js
var ERROR_NOT_PREPARED = "Validator Must be prepared before calling this function.";

class DocumentValidator {
  settings;
  _document;
  _ready = false;
  errors = [];
  _prepared;
  _preparations;
  _preparationTime = -1;
  _suggestions = new AutoCache((text) => this.genSuggestions(text), 1000);
  options;
  perfTiming = {};
  skipValidation;
  static async create(doc, options, settingsOrConfigFile) {
    const settings = satisfiesCSpellConfigFile(settingsOrConfigFile) ? await resolveConfigFileImports(settingsOrConfigFile) : settingsOrConfigFile;
    const validator = new DocumentValidator(doc, options, settings);
    await validator.prepare();
    return validator;
  }
  constructor(doc, options, settings) {
    this.settings = settings;
    this._document = doc;
    this.options = { ...options };
    const numSuggestions = this.options.numSuggestions ?? settings.numSuggestions;
    if (numSuggestions !== undefined) {
      this.options.numSuggestions = numSuggestions;
    }
    this.skipValidation = !!options.skipValidation;
  }
  get ready() {
    return this._ready;
  }
  prepare() {
    if (this._ready)
      return Promise.resolve();
    if (this._prepared)
      return this._prepared;
    this._prepared = this._prepareAsync();
    return this._prepared;
  }
  async _prepareAsync() {
    assert21(!this._ready);
    const timer = createPerfTimer2("_prepareAsync");
    const { options, settings: rawSettings } = this;
    const resolveImportsRelativeTo = toFileURL(options.resolveImportsRelativeTo || toFileURL("./virtual.settings.json"));
    const settings = rawSettings.import?.length ? await resolveSettingsImports(rawSettings, resolveImportsRelativeTo) : rawSettings;
    const useSearchForConfig = !options.noConfigSearch && !settings.noConfigSearch || options.noConfigSearch === false;
    const pLocalConfig = options.configFile ? loadConfig(options.configFile, settings) : useSearchForConfig ? timePromise(this.perfTiming, "__searchForDocumentConfig", searchForDocumentConfig(this._document, settings, settings)) : undefined;
    pLocalConfig && timePromise(this.perfTiming, "_loadConfig", pLocalConfig);
    const localConfig = await catchPromiseError(pLocalConfig, (e) => this.addPossibleError(e)) || {};
    this.addPossibleError(localConfig?.__importRef?.error);
    const config = mergeSettings(settings, localConfig);
    const docSettings = await timePromise(this.perfTiming, "_determineTextDocumentSettings", determineTextDocumentSettings(this._document, config));
    const dict = await timePromise(this.perfTiming, "_getDictionaryInternal", getDictionaryInternal(docSettings));
    const recGlobMatcherTime = recordPerfTime(this.perfTiming, "_GlobMatcher");
    const matcher = getGlobMatcherForExcluding(localConfig?.ignorePaths);
    const uri = this._document.uri;
    recGlobMatcherTime();
    const recShouldCheckTime = recordPerfTime(this.perfTiming, "_shouldCheck");
    const shouldCheck = !matcher.match(uriToFilePath(uri)) && (docSettings.enabled ?? true);
    recShouldCheckTime();
    const recFinalizeTime = recordPerfTime(this.perfTiming, "_finalizeSettings");
    const finalSettings = finalizeSettings(docSettings);
    const validateOptions = settingsToValidateOptions(finalSettings);
    const includeRanges = calcTextInclusionRanges(this._document.text, validateOptions);
    const segmenter = createMappedTextSegmenter(includeRanges);
    const textValidator = textValidatorFactory(dict, validateOptions);
    recFinalizeTime();
    this._preparations = {
      config,
      dictionary: dict,
      docSettings,
      finalSettings,
      shouldCheck,
      validateOptions,
      includeRanges,
      segmenter,
      textValidator,
      localConfig,
      localConfigFilepath: localConfig?.__importRef?.filename
    };
    this._ready = true;
    this._preparationTime = timer.elapsed;
    this.perfTiming.prepTime = this._preparationTime;
  }
  async _updatePrep() {
    assert21(this._preparations, ERROR_NOT_PREPARED);
    const timer = createPerfTimer2("_updatePrep");
    const prep = this._preparations;
    const docSettings = await determineTextDocumentSettings(this._document, prep.config);
    const dict = await getDictionaryInternal(docSettings);
    const shouldCheck = docSettings.enabled ?? true;
    const finalSettings = finalizeSettings(docSettings);
    const validateOptions = settingsToValidateOptions(finalSettings);
    const includeRanges = calcTextInclusionRanges(this._document.text, validateOptions);
    const segmenter = createMappedTextSegmenter(includeRanges);
    const textValidator = textValidatorFactory(dict, validateOptions);
    this._preparations = {
      ...prep,
      dictionary: dict,
      docSettings,
      shouldCheck,
      validateOptions,
      includeRanges,
      segmenter,
      textValidator
    };
    this._preparationTime = timer.elapsed;
  }
  get prepTime() {
    return this._preparationTime;
  }
  get validateDirectives() {
    return this.options.validateDirectives ?? this._preparations?.config.validateDirectives ?? false;
  }
  checkText(range, _text, scope) {
    const text = this._document.text.slice(range[0], range[1]);
    return this.check({ text, range, scope: scope.join(" ") });
  }
  check(parsedText) {
    assert21(this._ready);
    assert21(this._preparations, ERROR_NOT_PREPARED);
    const { segmenter, textValidator } = this._preparations;
    const document = this._document;
    let line = undefined;
    function mapToIssue(issue) {
      const { range, text, isFlagged, isFound, suggestionsEx } = issue;
      const offset = range[0];
      const length = range[1] - range[0];
      assert21(!line || line.offset <= offset);
      if (!line || line.offset + line.text.length <= offset) {
        line = document.lineAt(offset);
      }
      return { text, offset, line, length, isFlagged, isFound, suggestionsEx };
    }
    const issues = [...pipeSync(segmenter(parsedText), opConcatMapSync(textValidator.validate), opMapSync(mapToIssue))];
    if (!this.options.generateSuggestions) {
      return issues.map((issue) => {
        if (!issue.suggestionsEx)
          return issue;
        const suggestionsEx = this.adjustSuggestions(issue.text, issue.suggestionsEx);
        const suggestions = suggestionsEx.map((s) => s.word);
        return { ...issue, suggestionsEx, suggestions };
      });
    }
    const withSugs = issues.map((t) => {
      const text = t.text;
      const suggestionsEx = this.getSuggestions(text);
      t.suggestionsEx = suggestionsEx;
      t.suggestions = suggestionsEx.map((s) => s.word);
      return t;
    });
    return withSugs;
  }
  async checkDocumentAsync(forceCheck) {
    await this.prepare();
    return this.checkDocument(forceCheck);
  }
  checkDocument(forceCheck = false) {
    const timerDone = recordPerfTime(this.perfTiming, "checkDocument");
    try {
      if (this.skipValidation)
        return [];
      assert21(this._ready);
      assert21(this._preparations, ERROR_NOT_PREPARED);
      const spellingIssues = forceCheck || this.shouldCheckDocument() ? [...this._checkParsedText(this._parse())] : [];
      const directiveIssues = this.checkDocumentDirectives();
      const allIssues = [...spellingIssues, ...directiveIssues].sort((a, b) => a.offset - b.offset);
      return allIssues;
    } finally {
      timerDone();
    }
  }
  checkDocumentDirectives(forceCheck = false) {
    assert21(this._ready);
    assert21(this._preparations, ERROR_NOT_PREPARED);
    const validateDirectives = forceCheck || this.validateDirectives;
    if (!validateDirectives)
      return [];
    const document = this.document;
    const issueType = IssueType.directive;
    function toValidationIssue(dirIssue) {
      const { text, range, suggestions, suggestionsEx, message } = dirIssue;
      const offset = range[0];
      const pos = document.positionAt(offset);
      const line = document.getLine(pos.line);
      const issue = { text, offset, line, suggestions, suggestionsEx, message, issueType };
      return issue;
    }
    return [...validateInDocumentSettings(this.document.text, this._preparations.config)].map(toValidationIssue);
  }
  get document() {
    return this._document;
  }
  async updateDocumentText(text) {
    updateTextDocument(this._document, [{ text }]);
    await this._updatePrep();
  }
  getCheckedTextRanges() {
    assert21(this._preparations, ERROR_NOT_PREPARED);
    return this._preparations.includeRanges;
  }
  traceWord(word) {
    assert21(this._preparations, ERROR_NOT_PREPARED);
    return traceWord(word, this._preparations.dictionary, this._preparations.config);
  }
  defaultParser() {
    return pipeSync(this.document.getLines(), opMapSync((line) => {
      const { text, offset } = line;
      const range = [offset, offset + text.length];
      return { text, range };
    }));
  }
  *_checkParsedText(parsedTexts) {
    assert21(this._preparations, ERROR_NOT_PREPARED);
    const { maxNumberOfProblems = defaultMaxNumberOfProblems, maxDuplicateProblems = defaultMaxDuplicateProblems } = this._preparations.validateOptions;
    let numProblems = 0;
    const mapOfProblems = new Map;
    for (const pText of parsedTexts) {
      for (const issue of this.check(pText)) {
        const { text } = issue;
        const n = (mapOfProblems.get(text) || 0) + 1;
        mapOfProblems.set(text, n);
        if (n > maxDuplicateProblems)
          continue;
        yield issue;
        if (++numProblems >= maxNumberOfProblems)
          return;
      }
    }
  }
  addPossibleError(error) {
    if (!error)
      return;
    error = this.errors.push(toError(error));
  }
  _parse() {
    assert21(this._preparations, ERROR_NOT_PREPARED);
    const parser3 = this._preparations.finalSettings.parserFn;
    if (typeof parser3 !== "object")
      return this.defaultParser();
    return parser3.parse(this.document.text, toFilePathOrHref(documentUriToURL(this.document.uri))).parsedTexts;
  }
  getSuggestions(text) {
    return this._suggestions.get(text);
  }
  genSuggestions(text) {
    assert21(this._preparations, ERROR_NOT_PREPARED);
    const settings = this._preparations.docSettings;
    const dict = this._preparations.dictionary;
    const sugOptions = {
      compoundMethod: 0,
      numSuggestions: this.options.numSuggestions,
      includeTies: false,
      ignoreCase: !(settings.caseSensitive ?? false),
      timeout: settings.suggestionsTimeout,
      numChanges: settings.suggestionNumChanges
    };
    const rawSuggestions = dict.suggest(text, sugOptions);
    return this.adjustSuggestions(text, rawSuggestions);
  }
  adjustSuggestions(text, rawSuggestions) {
    assert21(this._preparations, ERROR_NOT_PREPARED);
    const settings = this._preparations.docSettings;
    const ignoreCase2 = !(settings.caseSensitive ?? false);
    const locale = this._preparations.config.language;
    const dict = this._preparations.dictionary;
    const sugsWithAlt = calcSuggestionAdjustedToToMatchCase(text, rawSuggestions.map(mapSug), locale, ignoreCase2, dict);
    return sugsWithAlt.map(sanitizeSuggestion);
  }
  getFinalizedDocSettings() {
    assert21(this._ready);
    assert21(this._preparations, ERROR_NOT_PREPARED);
    return this._preparations.docSettings;
  }
  shouldCheckDocument() {
    assert21(this._preparations, ERROR_NOT_PREPARED);
    return this._preparations.shouldCheck;
  }
  _getPreparations() {
    return this._preparations;
  }
}
function sanitizeSuggestion(sug) {
  const { word, isPreferred, wordAdjustedToMatchCase } = sug;
  if (isPreferred && wordAdjustedToMatchCase)
    return { word, wordAdjustedToMatchCase, isPreferred };
  if (isPreferred)
    return { word, isPreferred };
  if (wordAdjustedToMatchCase)
    return { word, wordAdjustedToMatchCase };
  return { word };
}
async function searchForDocumentConfig(document, defaultConfig, pnpSettings) {
  const url2 = documentUriToURL(document.uri);
  try {
    return await searchForConfig(url2, pnpSettings).then((s) => s || defaultConfig);
  } catch (e) {
    if (url2.protocol !== "file:")
      return defaultConfig;
    throw e;
  }
}
function mapSug(sug) {
  return { cost: 999, ...sug };
}
function recordPerfTime(timings, name) {
  const timer = createPerfTimer2(name, (elapsed) => timings[name] = elapsed);
  return () => timer.end();
}
function timePromise(timings, name, p) {
  return p.finally(recordPerfTime(timings, name));
}
// node_modules/cspell-lib/dist/lib/util/textApi.js
var exports_textApi = {};
__export(exports_textApi, {
  ucFirst: () => ucFirst2,
  textOffset: () => textOffset,
  stringToRegExp: () => stringToRegExp,
  splitCamelCaseWordWithOffset: () => splitCamelCaseWordWithOffset,
  splitCamelCaseWord: () => splitCamelCaseWord,
  snakeToCamel: () => snakeToCamel,
  removeAccents: () => removeAccents2,
  matchToTextOffset: () => matchToTextOffset,
  matchStringToTextOffset: () => matchStringToTextOffset,
  matchCase: () => matchCase,
  match: () => match,
  lcFirst: () => lcFirst,
  isUpperCase: () => isUpperCase2,
  isLowerCase: () => isLowerCase,
  isFirstCharacterUpper: () => isFirstCharacterUpper,
  isFirstCharacterLower: () => isFirstCharacterLower,
  extractWordsFromTextOffset: () => extractWordsFromTextOffset,
  extractWordsFromText: () => extractWordsFromText,
  extractWordsFromCodeTextOffset: () => extractWordsFromCodeTextOffset,
  extractWordsFromCode: () => extractWordsFromCode,
  extractText: () => extractText,
  extractPossibleWordsFromTextOffset: () => extractPossibleWordsFromTextOffset,
  extractLinesOfText: () => extractLinesOfText,
  cleanTextOffset: () => cleanTextOffset,
  cleanText: () => cleanText,
  camelToSnake: () => camelToSnake,
  calculateTextDocumentOffsets: () => calculateTextDocumentOffsets
});
// node_modules/vscode-languageserver-types/lib/esm/main.js
var DocumentUri;
(function(DocumentUri2) {
  function is(value) {
    return typeof value === "string";
  }
  DocumentUri2.is = is;
})(DocumentUri || (DocumentUri = {}));
var URI2;
(function(URI3) {
  function is(value) {
    return typeof value === "string";
  }
  URI3.is = is;
})(URI2 || (URI2 = {}));
var integer;
(function(integer2) {
  integer2.MIN_VALUE = -2147483648;
  integer2.MAX_VALUE = 2147483647;
  function is(value) {
    return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
  }
  integer2.is = is;
})(integer || (integer = {}));
var uinteger;
(function(uinteger2) {
  uinteger2.MIN_VALUE = 0;
  uinteger2.MAX_VALUE = 2147483647;
  function is(value) {
    return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
  }
  uinteger2.is = is;
})(uinteger || (uinteger = {}));
var Position;
(function(Position2) {
  function create(line, character) {
    if (line === Number.MAX_VALUE) {
      line = uinteger.MAX_VALUE;
    }
    if (character === Number.MAX_VALUE) {
      character = uinteger.MAX_VALUE;
    }
    return { line, character };
  }
  Position2.create = create;
  function is(value) {
    let candidate = value;
    return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
  }
  Position2.is = is;
})(Position || (Position = {}));
var Range;
(function(Range2) {
  function create(one, two, three, four) {
    if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
      return { start: Position.create(one, two), end: Position.create(three, four) };
    } else if (Position.is(one) && Position.is(two)) {
      return { start: one, end: two };
    } else {
      throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);
    }
  }
  Range2.create = create;
  function is(value) {
    let candidate = value;
    return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
  }
  Range2.is = is;
})(Range || (Range = {}));
var Location;
(function(Location2) {
  function create(uri, range) {
    return { uri, range };
  }
  Location2.create = create;
  function is(value) {
    let candidate = value;
    return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
  }
  Location2.is = is;
})(Location || (Location = {}));
var LocationLink;
(function(LocationLink2) {
  function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
    return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
  }
  LocationLink2.create = create;
  function is(value) {
    let candidate = value;
    return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
  }
  LocationLink2.is = is;
})(LocationLink || (LocationLink = {}));
var Color;
(function(Color2) {
  function create(red, green, blue, alpha) {
    return {
      red,
      green,
      blue,
      alpha
    };
  }
  Color2.create = create;
  function is(value) {
    const candidate = value;
    return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
  }
  Color2.is = is;
})(Color || (Color = {}));
var ColorInformation;
(function(ColorInformation2) {
  function create(range, color) {
    return {
      range,
      color
    };
  }
  ColorInformation2.create = create;
  function is(value) {
    const candidate = value;
    return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
  }
  ColorInformation2.is = is;
})(ColorInformation || (ColorInformation = {}));
var ColorPresentation;
(function(ColorPresentation2) {
  function create(label, textEdit, additionalTextEdits) {
    return {
      label,
      textEdit,
      additionalTextEdits
    };
  }
  ColorPresentation2.create = create;
  function is(value) {
    const candidate = value;
    return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
  }
  ColorPresentation2.is = is;
})(ColorPresentation || (ColorPresentation = {}));
var FoldingRangeKind;
(function(FoldingRangeKind2) {
  FoldingRangeKind2.Comment = "comment";
  FoldingRangeKind2.Imports = "imports";
  FoldingRangeKind2.Region = "region";
})(FoldingRangeKind || (FoldingRangeKind = {}));
var FoldingRange;
(function(FoldingRange2) {
  function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
    const result = {
      startLine,
      endLine
    };
    if (Is.defined(startCharacter)) {
      result.startCharacter = startCharacter;
    }
    if (Is.defined(endCharacter)) {
      result.endCharacter = endCharacter;
    }
    if (Is.defined(kind)) {
      result.kind = kind;
    }
    if (Is.defined(collapsedText)) {
      result.collapsedText = collapsedText;
    }
    return result;
  }
  FoldingRange2.create = create;
  function is(value) {
    const candidate = value;
    return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
  }
  FoldingRange2.is = is;
})(FoldingRange || (FoldingRange = {}));
var DiagnosticRelatedInformation;
(function(DiagnosticRelatedInformation2) {
  function create(location, message) {
    return {
      location,
      message
    };
  }
  DiagnosticRelatedInformation2.create = create;
  function is(value) {
    let candidate = value;
    return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
  }
  DiagnosticRelatedInformation2.is = is;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
var DiagnosticSeverity;
(function(DiagnosticSeverity2) {
  DiagnosticSeverity2.Error = 1;
  DiagnosticSeverity2.Warning = 2;
  DiagnosticSeverity2.Information = 3;
  DiagnosticSeverity2.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
var DiagnosticTag;
(function(DiagnosticTag2) {
  DiagnosticTag2.Unnecessary = 1;
  DiagnosticTag2.Deprecated = 2;
})(DiagnosticTag || (DiagnosticTag = {}));
var CodeDescription;
(function(CodeDescription2) {
  function is(value) {
    const candidate = value;
    return Is.objectLiteral(candidate) && Is.string(candidate.href);
  }
  CodeDescription2.is = is;
})(CodeDescription || (CodeDescription = {}));
var Diagnostic;
(function(Diagnostic2) {
  function create(range, message, severity, code, source, relatedInformation) {
    let result = { range, message };
    if (Is.defined(severity)) {
      result.severity = severity;
    }
    if (Is.defined(code)) {
      result.code = code;
    }
    if (Is.defined(source)) {
      result.source = source;
    }
    if (Is.defined(relatedInformation)) {
      result.relatedInformation = relatedInformation;
    }
    return result;
  }
  Diagnostic2.create = create;
  function is(value) {
    var _a;
    let candidate = value;
    return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === undefined ? undefined : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
  }
  Diagnostic2.is = is;
})(Diagnostic || (Diagnostic = {}));
var Command;
(function(Command2) {
  function create(title, command, ...args) {
    let result = { title, command };
    if (Is.defined(args) && args.length > 0) {
      result.arguments = args;
    }
    return result;
  }
  Command2.create = create;
  function is(value) {
    let candidate = value;
    return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
  }
  Command2.is = is;
})(Command || (Command = {}));
var TextEdit;
(function(TextEdit2) {
  function replace(range, newText) {
    return { range, newText };
  }
  TextEdit2.replace = replace;
  function insert4(position, newText) {
    return { range: { start: position, end: position }, newText };
  }
  TextEdit2.insert = insert4;
  function del(range) {
    return { range, newText: "" };
  }
  TextEdit2.del = del;
  function is(value) {
    const candidate = value;
    return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
  }
  TextEdit2.is = is;
})(TextEdit || (TextEdit = {}));
var ChangeAnnotation;
(function(ChangeAnnotation2) {
  function create(label, needsConfirmation, description) {
    const result = { label };
    if (needsConfirmation !== undefined) {
      result.needsConfirmation = needsConfirmation;
    }
    if (description !== undefined) {
      result.description = description;
    }
    return result;
  }
  ChangeAnnotation2.create = create;
  function is(value) {
    const candidate = value;
    return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
  }
  ChangeAnnotation2.is = is;
})(ChangeAnnotation || (ChangeAnnotation = {}));
var ChangeAnnotationIdentifier;
(function(ChangeAnnotationIdentifier2) {
  function is(value) {
    const candidate = value;
    return Is.string(candidate);
  }
  ChangeAnnotationIdentifier2.is = is;
})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
var AnnotatedTextEdit;
(function(AnnotatedTextEdit2) {
  function replace(range, newText, annotation) {
    return { range, newText, annotationId: annotation };
  }
  AnnotatedTextEdit2.replace = replace;
  function insert4(position, newText, annotation) {
    return { range: { start: position, end: position }, newText, annotationId: annotation };
  }
  AnnotatedTextEdit2.insert = insert4;
  function del(range, annotation) {
    return { range, newText: "", annotationId: annotation };
  }
  AnnotatedTextEdit2.del = del;
  function is(value) {
    const candidate = value;
    return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
  }
  AnnotatedTextEdit2.is = is;
})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
var TextDocumentEdit;
(function(TextDocumentEdit2) {
  function create(textDocument, edits) {
    return { textDocument, edits };
  }
  TextDocumentEdit2.create = create;
  function is(value) {
    let candidate = value;
    return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
  }
  TextDocumentEdit2.is = is;
})(TextDocumentEdit || (TextDocumentEdit = {}));
var CreateFile;
(function(CreateFile2) {
  function create(uri, options, annotation) {
    let result = {
      kind: "create",
      uri
    };
    if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
      result.options = options;
    }
    if (annotation !== undefined) {
      result.annotationId = annotation;
    }
    return result;
  }
  CreateFile2.create = create;
  function is(value) {
    let candidate = value;
    return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
  }
  CreateFile2.is = is;
})(CreateFile || (CreateFile = {}));
var RenameFile;
(function(RenameFile2) {
  function create(oldUri, newUri, options, annotation) {
    let result = {
      kind: "rename",
      oldUri,
      newUri
    };
    if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
      result.options = options;
    }
    if (annotation !== undefined) {
      result.annotationId = annotation;
    }
    return result;
  }
  RenameFile2.create = create;
  function is(value) {
    let candidate = value;
    return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
  }
  RenameFile2.is = is;
})(RenameFile || (RenameFile = {}));
var DeleteFile;
(function(DeleteFile2) {
  function create(uri, options, annotation) {
    let result = {
      kind: "delete",
      uri
    };
    if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
      result.options = options;
    }
    if (annotation !== undefined) {
      result.annotationId = annotation;
    }
    return result;
  }
  DeleteFile2.create = create;
  function is(value) {
    let candidate = value;
    return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
  }
  DeleteFile2.is = is;
})(DeleteFile || (DeleteFile = {}));
var WorkspaceEdit;
(function(WorkspaceEdit2) {
  function is(value) {
    let candidate = value;
    return candidate && (candidate.changes !== undefined || candidate.documentChanges !== undefined) && (candidate.documentChanges === undefined || candidate.documentChanges.every((change) => {
      if (Is.string(change.kind)) {
        return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
      } else {
        return TextDocumentEdit.is(change);
      }
    }));
  }
  WorkspaceEdit2.is = is;
})(WorkspaceEdit || (WorkspaceEdit = {}));
var TextDocumentIdentifier;
(function(TextDocumentIdentifier2) {
  function create(uri) {
    return { uri };
  }
  TextDocumentIdentifier2.create = create;
  function is(value) {
    let candidate = value;
    return Is.defined(candidate) && Is.string(candidate.uri);
  }
  TextDocumentIdentifier2.is = is;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
var VersionedTextDocumentIdentifier;
(function(VersionedTextDocumentIdentifier2) {
  function create(uri, version2) {
    return { uri, version: version2 };
  }
  VersionedTextDocumentIdentifier2.create = create;
  function is(value) {
    let candidate = value;
    return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
  }
  VersionedTextDocumentIdentifier2.is = is;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
var OptionalVersionedTextDocumentIdentifier;
(function(OptionalVersionedTextDocumentIdentifier2) {
  function create(uri, version2) {
    return { uri, version: version2 };
  }
  OptionalVersionedTextDocumentIdentifier2.create = create;
  function is(value) {
    let candidate = value;
    return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
  }
  OptionalVersionedTextDocumentIdentifier2.is = is;
})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
var TextDocumentItem;
(function(TextDocumentItem2) {
  function create(uri, languageId, version2, text) {
    return { uri, languageId, version: version2, text };
  }
  TextDocumentItem2.create = create;
  function is(value) {
    let candidate = value;
    return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
  }
  TextDocumentItem2.is = is;
})(TextDocumentItem || (TextDocumentItem = {}));
var MarkupKind;
(function(MarkupKind2) {
  MarkupKind2.PlainText = "plaintext";
  MarkupKind2.Markdown = "markdown";
  function is(value) {
    const candidate = value;
    return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
  }
  MarkupKind2.is = is;
})(MarkupKind || (MarkupKind = {}));
var MarkupContent;
(function(MarkupContent2) {
  function is(value) {
    const candidate = value;
    return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
  }
  MarkupContent2.is = is;
})(MarkupContent || (MarkupContent = {}));
var CompletionItemKind;
(function(CompletionItemKind2) {
  CompletionItemKind2.Text = 1;
  CompletionItemKind2.Method = 2;
  CompletionItemKind2.Function = 3;
  CompletionItemKind2.Constructor = 4;
  CompletionItemKind2.Field = 5;
  CompletionItemKind2.Variable = 6;
  CompletionItemKind2.Class = 7;
  CompletionItemKind2.Interface = 8;
  CompletionItemKind2.Module = 9;
  CompletionItemKind2.Property = 10;
  CompletionItemKind2.Unit = 11;
  CompletionItemKind2.Value = 12;
  CompletionItemKind2.Enum = 13;
  CompletionItemKind2.Keyword = 14;
  CompletionItemKind2.Snippet = 15;
  CompletionItemKind2.Color = 16;
  CompletionItemKind2.File = 17;
  CompletionItemKind2.Reference = 18;
  CompletionItemKind2.Folder = 19;
  CompletionItemKind2.EnumMember = 20;
  CompletionItemKind2.Constant = 21;
  CompletionItemKind2.Struct = 22;
  CompletionItemKind2.Event = 23;
  CompletionItemKind2.Operator = 24;
  CompletionItemKind2.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
var InsertTextFormat;
(function(InsertTextFormat2) {
  InsertTextFormat2.PlainText = 1;
  InsertTextFormat2.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
var CompletionItemTag;
(function(CompletionItemTag2) {
  CompletionItemTag2.Deprecated = 1;
})(CompletionItemTag || (CompletionItemTag = {}));
var InsertReplaceEdit;
(function(InsertReplaceEdit2) {
  function create(newText, insert4, replace) {
    return { newText, insert: insert4, replace };
  }
  InsertReplaceEdit2.create = create;
  function is(value) {
    const candidate = value;
    return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
  }
  InsertReplaceEdit2.is = is;
})(InsertReplaceEdit || (InsertReplaceEdit = {}));
var InsertTextMode;
(function(InsertTextMode2) {
  InsertTextMode2.asIs = 1;
  InsertTextMode2.adjustIndentation = 2;
})(InsertTextMode || (InsertTextMode = {}));
var CompletionItemLabelDetails;
(function(CompletionItemLabelDetails2) {
  function is(value) {
    const candidate = value;
    return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
  }
  CompletionItemLabelDetails2.is = is;
})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
var CompletionItem;
(function(CompletionItem2) {
  function create(label) {
    return { label };
  }
  CompletionItem2.create = create;
})(CompletionItem || (CompletionItem = {}));
var CompletionList;
(function(CompletionList2) {
  function create(items, isIncomplete) {
    return { items: items ? items : [], isIncomplete: !!isIncomplete };
  }
  CompletionList2.create = create;
})(CompletionList || (CompletionList = {}));
var MarkedString;
(function(MarkedString2) {
  function fromPlainText(plainText) {
    return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
  }
  MarkedString2.fromPlainText = fromPlainText;
  function is(value) {
    const candidate = value;
    return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
  }
  MarkedString2.is = is;
})(MarkedString || (MarkedString = {}));
var Hover;
(function(Hover2) {
  function is(value) {
    let candidate = value;
    return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));
  }
  Hover2.is = is;
})(Hover || (Hover = {}));
var ParameterInformation;
(function(ParameterInformation2) {
  function create(label, documentation) {
    return documentation ? { label, documentation } : { label };
  }
  ParameterInformation2.create = create;
})(ParameterInformation || (ParameterInformation = {}));
var SignatureInformation;
(function(SignatureInformation2) {
  function create(label, documentation, ...parameters) {
    let result = { label };
    if (Is.defined(documentation)) {
      result.documentation = documentation;
    }
    if (Is.defined(parameters)) {
      result.parameters = parameters;
    } else {
      result.parameters = [];
    }
    return result;
  }
  SignatureInformation2.create = create;
})(SignatureInformation || (SignatureInformation = {}));
var DocumentHighlightKind;
(function(DocumentHighlightKind2) {
  DocumentHighlightKind2.Text = 1;
  DocumentHighlightKind2.Read = 2;
  DocumentHighlightKind2.Write = 3;
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
var DocumentHighlight;
(function(DocumentHighlight2) {
  function create(range, kind) {
    let result = { range };
    if (Is.number(kind)) {
      result.kind = kind;
    }
    return result;
  }
  DocumentHighlight2.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
var SymbolKind;
(function(SymbolKind2) {
  SymbolKind2.File = 1;
  SymbolKind2.Module = 2;
  SymbolKind2.Namespace = 3;
  SymbolKind2.Package = 4;
  SymbolKind2.Class = 5;
  SymbolKind2.Method = 6;
  SymbolKind2.Property = 7;
  SymbolKind2.Field = 8;
  SymbolKind2.Constructor = 9;
  SymbolKind2.Enum = 10;
  SymbolKind2.Interface = 11;
  SymbolKind2.Function = 12;
  SymbolKind2.Variable = 13;
  SymbolKind2.Constant = 14;
  SymbolKind2.String = 15;
  SymbolKind2.Number = 16;
  SymbolKind2.Boolean = 17;
  SymbolKind2.Array = 18;
  SymbolKind2.Object = 19;
  SymbolKind2.Key = 20;
  SymbolKind2.Null = 21;
  SymbolKind2.EnumMember = 22;
  SymbolKind2.Struct = 23;
  SymbolKind2.Event = 24;
  SymbolKind2.Operator = 25;
  SymbolKind2.TypeParameter = 26;
})(SymbolKind || (SymbolKind = {}));
var SymbolTag;
(function(SymbolTag2) {
  SymbolTag2.Deprecated = 1;
})(SymbolTag || (SymbolTag = {}));
var SymbolInformation;
(function(SymbolInformation2) {
  function create(name, kind, range, uri, containerName) {
    let result = {
      name,
      kind,
      location: { uri, range }
    };
    if (containerName) {
      result.containerName = containerName;
    }
    return result;
  }
  SymbolInformation2.create = create;
})(SymbolInformation || (SymbolInformation = {}));
var WorkspaceSymbol;
(function(WorkspaceSymbol2) {
  function create(name, kind, uri, range) {
    return range !== undefined ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
  }
  WorkspaceSymbol2.create = create;
})(WorkspaceSymbol || (WorkspaceSymbol = {}));
var DocumentSymbol;
(function(DocumentSymbol2) {
  function create(name, detail, kind, range, selectionRange, children) {
    let result = {
      name,
      detail,
      kind,
      range,
      selectionRange
    };
    if (children !== undefined) {
      result.children = children;
    }
    return result;
  }
  DocumentSymbol2.create = create;
  function is(value) {
    let candidate = value;
    return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === undefined || Is.string(candidate.detail)) && (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) && (candidate.children === undefined || Array.isArray(candidate.children)) && (candidate.tags === undefined || Array.isArray(candidate.tags));
  }
  DocumentSymbol2.is = is;
})(DocumentSymbol || (DocumentSymbol = {}));
var CodeActionKind;
(function(CodeActionKind2) {
  CodeActionKind2.Empty = "";
  CodeActionKind2.QuickFix = "quickfix";
  CodeActionKind2.Refactor = "refactor";
  CodeActionKind2.RefactorExtract = "refactor.extract";
  CodeActionKind2.RefactorInline = "refactor.inline";
  CodeActionKind2.RefactorRewrite = "refactor.rewrite";
  CodeActionKind2.Source = "source";
  CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
  CodeActionKind2.SourceFixAll = "source.fixAll";
})(CodeActionKind || (CodeActionKind = {}));
var CodeActionTriggerKind;
(function(CodeActionTriggerKind2) {
  CodeActionTriggerKind2.Invoked = 1;
  CodeActionTriggerKind2.Automatic = 2;
})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
var CodeActionContext;
(function(CodeActionContext2) {
  function create(diagnostics, only, triggerKind) {
    let result = { diagnostics };
    if (only !== undefined && only !== null) {
      result.only = only;
    }
    if (triggerKind !== undefined && triggerKind !== null) {
      result.triggerKind = triggerKind;
    }
    return result;
  }
  CodeActionContext2.create = create;
  function is(value) {
    let candidate = value;
    return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
  }
  CodeActionContext2.is = is;
})(CodeActionContext || (CodeActionContext = {}));
var CodeAction;
(function(CodeAction2) {
  function create(title, kindOrCommandOrEdit, kind) {
    let result = { title };
    let checkKind = true;
    if (typeof kindOrCommandOrEdit === "string") {
      checkKind = false;
      result.kind = kindOrCommandOrEdit;
    } else if (Command.is(kindOrCommandOrEdit)) {
      result.command = kindOrCommandOrEdit;
    } else {
      result.edit = kindOrCommandOrEdit;
    }
    if (checkKind && kind !== undefined) {
      result.kind = kind;
    }
    return result;
  }
  CodeAction2.create = create;
  function is(value) {
    let candidate = value;
    return candidate && Is.string(candidate.title) && (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === undefined || Is.string(candidate.kind)) && (candidate.edit !== undefined || candidate.command !== undefined) && (candidate.command === undefined || Command.is(candidate.command)) && (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) && (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
  }
  CodeAction2.is = is;
})(CodeAction || (CodeAction = {}));
var CodeLens;
(function(CodeLens2) {
  function create(range, data) {
    let result = { range };
    if (Is.defined(data)) {
      result.data = data;
    }
    return result;
  }
  CodeLens2.create = create;
  function is(value) {
    let candidate = value;
    return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
  }
  CodeLens2.is = is;
})(CodeLens || (CodeLens = {}));
var FormattingOptions;
(function(FormattingOptions2) {
  function create(tabSize, insertSpaces) {
    return { tabSize, insertSpaces };
  }
  FormattingOptions2.create = create;
  function is(value) {
    let candidate = value;
    return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
  }
  FormattingOptions2.is = is;
})(FormattingOptions || (FormattingOptions = {}));
var DocumentLink;
(function(DocumentLink2) {
  function create(range, target, data) {
    return { range, target, data };
  }
  DocumentLink2.create = create;
  function is(value) {
    let candidate = value;
    return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
  }
  DocumentLink2.is = is;
})(DocumentLink || (DocumentLink = {}));
var SelectionRange;
(function(SelectionRange2) {
  function create(range, parent) {
    return { range, parent };
  }
  SelectionRange2.create = create;
  function is(value) {
    let candidate = value;
    return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange2.is(candidate.parent));
  }
  SelectionRange2.is = is;
})(SelectionRange || (SelectionRange = {}));
var SemanticTokenTypes;
(function(SemanticTokenTypes2) {
  SemanticTokenTypes2["namespace"] = "namespace";
  SemanticTokenTypes2["type"] = "type";
  SemanticTokenTypes2["class"] = "class";
  SemanticTokenTypes2["enum"] = "enum";
  SemanticTokenTypes2["interface"] = "interface";
  SemanticTokenTypes2["struct"] = "struct";
  SemanticTokenTypes2["typeParameter"] = "typeParameter";
  SemanticTokenTypes2["parameter"] = "parameter";
  SemanticTokenTypes2["variable"] = "variable";
  SemanticTokenTypes2["property"] = "property";
  SemanticTokenTypes2["enumMember"] = "enumMember";
  SemanticTokenTypes2["event"] = "event";
  SemanticTokenTypes2["function"] = "function";
  SemanticTokenTypes2["method"] = "method";
  SemanticTokenTypes2["macro"] = "macro";
  SemanticTokenTypes2["keyword"] = "keyword";
  SemanticTokenTypes2["modifier"] = "modifier";
  SemanticTokenTypes2["comment"] = "comment";
  SemanticTokenTypes2["string"] = "string";
  SemanticTokenTypes2["number"] = "number";
  SemanticTokenTypes2["regexp"] = "regexp";
  SemanticTokenTypes2["operator"] = "operator";
  SemanticTokenTypes2["decorator"] = "decorator";
})(SemanticTokenTypes || (SemanticTokenTypes = {}));
var SemanticTokenModifiers;
(function(SemanticTokenModifiers2) {
  SemanticTokenModifiers2["declaration"] = "declaration";
  SemanticTokenModifiers2["definition"] = "definition";
  SemanticTokenModifiers2["readonly"] = "readonly";
  SemanticTokenModifiers2["static"] = "static";
  SemanticTokenModifiers2["deprecated"] = "deprecated";
  SemanticTokenModifiers2["abstract"] = "abstract";
  SemanticTokenModifiers2["async"] = "async";
  SemanticTokenModifiers2["modification"] = "modification";
  SemanticTokenModifiers2["documentation"] = "documentation";
  SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
var SemanticTokens;
(function(SemanticTokens2) {
  function is(value) {
    const candidate = value;
    return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
  }
  SemanticTokens2.is = is;
})(SemanticTokens || (SemanticTokens = {}));
var InlineValueText;
(function(InlineValueText2) {
  function create(range, text) {
    return { range, text };
  }
  InlineValueText2.create = create;
  function is(value) {
    const candidate = value;
    return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
  }
  InlineValueText2.is = is;
})(InlineValueText || (InlineValueText = {}));
var InlineValueVariableLookup;
(function(InlineValueVariableLookup2) {
  function create(range, variableName, caseSensitiveLookup) {
    return { range, variableName, caseSensitiveLookup };
  }
  InlineValueVariableLookup2.create = create;
  function is(value) {
    const candidate = value;
    return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === undefined);
  }
  InlineValueVariableLookup2.is = is;
})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
var InlineValueEvaluatableExpression;
(function(InlineValueEvaluatableExpression2) {
  function create(range, expression) {
    return { range, expression };
  }
  InlineValueEvaluatableExpression2.create = create;
  function is(value) {
    const candidate = value;
    return candidate !== undefined && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === undefined);
  }
  InlineValueEvaluatableExpression2.is = is;
})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
var InlineValueContext;
(function(InlineValueContext2) {
  function create(frameId, stoppedLocation) {
    return { frameId, stoppedLocation };
  }
  InlineValueContext2.create = create;
  function is(value) {
    const candidate = value;
    return Is.defined(candidate) && Range.is(value.stoppedLocation);
  }
  InlineValueContext2.is = is;
})(InlineValueContext || (InlineValueContext = {}));
var InlayHintKind;
(function(InlayHintKind2) {
  InlayHintKind2.Type = 1;
  InlayHintKind2.Parameter = 2;
  function is(value) {
    return value === 1 || value === 2;
  }
  InlayHintKind2.is = is;
})(InlayHintKind || (InlayHintKind = {}));
var InlayHintLabelPart;
(function(InlayHintLabelPart2) {
  function create(value) {
    return { value };
  }
  InlayHintLabelPart2.create = create;
  function is(value) {
    const candidate = value;
    return Is.objectLiteral(candidate) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === undefined || Location.is(candidate.location)) && (candidate.command === undefined || Command.is(candidate.command));
  }
  InlayHintLabelPart2.is = is;
})(InlayHintLabelPart || (InlayHintLabelPart = {}));
var InlayHint;
(function(InlayHint2) {
  function create(position, label, kind) {
    const result = { position, label };
    if (kind !== undefined) {
      result.kind = kind;
    }
    return result;
  }
  InlayHint2.create = create;
  function is(value) {
    const candidate = value;
    return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === undefined || InlayHintKind.is(candidate.kind)) && candidate.textEdits === undefined || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));
  }
  InlayHint2.is = is;
})(InlayHint || (InlayHint = {}));
var StringValue;
(function(StringValue2) {
  function createSnippet(value) {
    return { kind: "snippet", value };
  }
  StringValue2.createSnippet = createSnippet;
})(StringValue || (StringValue = {}));
var InlineCompletionItem;
(function(InlineCompletionItem2) {
  function create(insertText, filterText, range, command) {
    return { insertText, filterText, range, command };
  }
  InlineCompletionItem2.create = create;
})(InlineCompletionItem || (InlineCompletionItem = {}));
var InlineCompletionList;
(function(InlineCompletionList2) {
  function create(items) {
    return { items };
  }
  InlineCompletionList2.create = create;
})(InlineCompletionList || (InlineCompletionList = {}));
var InlineCompletionTriggerKind;
(function(InlineCompletionTriggerKind2) {
  InlineCompletionTriggerKind2.Invoked = 0;
  InlineCompletionTriggerKind2.Automatic = 1;
})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
var SelectedCompletionInfo;
(function(SelectedCompletionInfo2) {
  function create(range, text) {
    return { range, text };
  }
  SelectedCompletionInfo2.create = create;
})(SelectedCompletionInfo || (SelectedCompletionInfo = {}));
var InlineCompletionContext;
(function(InlineCompletionContext2) {
  function create(triggerKind, selectedCompletionInfo) {
    return { triggerKind, selectedCompletionInfo };
  }
  InlineCompletionContext2.create = create;
})(InlineCompletionContext || (InlineCompletionContext = {}));
var WorkspaceFolder;
(function(WorkspaceFolder2) {
  function is(value) {
    const candidate = value;
    return Is.objectLiteral(candidate) && URI2.is(candidate.uri) && Is.string(candidate.name);
  }
  WorkspaceFolder2.is = is;
})(WorkspaceFolder || (WorkspaceFolder = {}));
var TextDocument2;
(function(TextDocument3) {
  function create(uri, languageId, version2, content) {
    return new FullTextDocument2(uri, languageId, version2, content);
  }
  TextDocument3.create = create;
  function is(value) {
    let candidate = value;
    return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
  }
  TextDocument3.is = is;
  function applyEdits2(document, edits) {
    let text = document.getText();
    let sortedEdits = mergeSort2(edits, (a, b) => {
      let diff = a.range.start.line - b.range.start.line;
      if (diff === 0) {
        return a.range.start.character - b.range.start.character;
      }
      return diff;
    });
    let lastModifiedOffset = text.length;
    for (let i = sortedEdits.length - 1;i >= 0; i--) {
      let e = sortedEdits[i];
      let startOffset = document.offsetAt(e.range.start);
      let endOffset = document.offsetAt(e.range.end);
      if (endOffset <= lastModifiedOffset) {
        text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
      } else {
        throw new Error("Overlapping edit");
      }
      lastModifiedOffset = startOffset;
    }
    return text;
  }
  TextDocument3.applyEdits = applyEdits2;
  function mergeSort2(data, compare4) {
    if (data.length <= 1) {
      return data;
    }
    const p = data.length / 2 | 0;
    const left = data.slice(0, p);
    const right = data.slice(p);
    mergeSort2(left, compare4);
    mergeSort2(right, compare4);
    let leftIdx = 0;
    let rightIdx = 0;
    let i = 0;
    while (leftIdx < left.length && rightIdx < right.length) {
      let ret = compare4(left[leftIdx], right[rightIdx]);
      if (ret <= 0) {
        data[i++] = left[leftIdx++];
      } else {
        data[i++] = right[rightIdx++];
      }
    }
    while (leftIdx < left.length) {
      data[i++] = left[leftIdx++];
    }
    while (rightIdx < right.length) {
      data[i++] = right[rightIdx++];
    }
    return data;
  }
})(TextDocument2 || (TextDocument2 = {}));

class FullTextDocument2 {
  constructor(uri, languageId, version2, content) {
    this._uri = uri;
    this._languageId = languageId;
    this._version = version2;
    this._content = content;
    this._lineOffsets = undefined;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(range) {
    if (range) {
      let start = this.offsetAt(range.start);
      let end = this.offsetAt(range.end);
      return this._content.substring(start, end);
    }
    return this._content;
  }
  update(event, version2) {
    this._content = event.text;
    this._version = version2;
    this._lineOffsets = undefined;
  }
  getLineOffsets() {
    if (this._lineOffsets === undefined) {
      let lineOffsets = [];
      let text = this._content;
      let isLineStart = true;
      for (let i = 0;i < text.length; i++) {
        if (isLineStart) {
          lineOffsets.push(i);
          isLineStart = false;
        }
        let ch = text.charAt(i);
        isLineStart = ch === "\r" || ch === `
`;
        if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === `
`) {
          i++;
        }
      }
      if (isLineStart && text.length > 0) {
        lineOffsets.push(text.length);
      }
      this._lineOffsets = lineOffsets;
    }
    return this._lineOffsets;
  }
  positionAt(offset) {
    offset = Math.max(Math.min(offset, this._content.length), 0);
    let lineOffsets = this.getLineOffsets();
    let low = 0, high = lineOffsets.length;
    if (high === 0) {
      return Position.create(0, offset);
    }
    while (low < high) {
      let mid = Math.floor((low + high) / 2);
      if (lineOffsets[mid] > offset) {
        high = mid;
      } else {
        low = mid + 1;
      }
    }
    let line = low - 1;
    return Position.create(line, offset - lineOffsets[line]);
  }
  offsetAt(position) {
    let lineOffsets = this.getLineOffsets();
    if (position.line >= lineOffsets.length) {
      return this._content.length;
    } else if (position.line < 0) {
      return 0;
    }
    let lineOffset = lineOffsets[position.line];
    let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
    return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
}
var Is;
(function(Is2) {
  const toString = Object.prototype.toString;
  function defined(value) {
    return typeof value !== "undefined";
  }
  Is2.defined = defined;
  function undefined2(value) {
    return typeof value === "undefined";
  }
  Is2.undefined = undefined2;
  function boolean(value) {
    return value === true || value === false;
  }
  Is2.boolean = boolean;
  function string(value) {
    return toString.call(value) === "[object String]";
  }
  Is2.string = string;
  function number(value) {
    return toString.call(value) === "[object Number]";
  }
  Is2.number = number;
  function numberRange(value, min3, max4) {
    return toString.call(value) === "[object Number]" && min3 <= value && value <= max4;
  }
  Is2.numberRange = numberRange;
  function integer2(value) {
    return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
  }
  Is2.integer = integer2;
  function uinteger2(value) {
    return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
  }
  Is2.uinteger = uinteger2;
  function func(value) {
    return toString.call(value) === "[object Function]";
  }
  Is2.func = func;
  function objectLiteral(value) {
    return value !== null && typeof value === "object";
  }
  Is2.objectLiteral = objectLiteral;
  function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
  }
  Is2.typedArray = typedArray;
})(Is || (Is = {}));

// src/validator.ts
var defaultCheckLimit = 1 << 20;
async function validateTextDocument(textDocument, settings) {
  const severity = DiagnosticSeverity.Information;
  const severityFlaggedWords = DiagnosticSeverity.Information;
  const limit = defaultCheckLimit;
  const content = textDocument.getText().slice(0, limit);
  const docInfo = {
    uri: textDocument.uri,
    content,
    languageId: textDocument.languageId,
    version: textDocument.version
  };
  const doc = createTextDocument(docInfo);
  const docVal = new DocumentValidator(doc, { noConfigSearch: true }, settings);
  await docVal.prepare();
  const r = await docVal.checkDocumentAsync(true);
  const diags = r.map((issue) => ({ ...issue, position: textDocument.positionAt(issue.offset) })).map((issue) => ({
    ...issue,
    range: {
      start: issue.position,
      end: { ...issue.position, character: issue.position.character + (issue.length ?? issue.text.length) }
    },
    severity: issue.isFlagged ? severityFlaggedWords : severity
  })).map(({ text, range, isFlagged, message, issueType, suggestions, suggestionsEx, severity: severity2 }) => {
    const diagMessage = `"${text}": ${message ?? `${isFlagged ? "Forbidden" : "Unknown"} word`}.`;
    const sugs = suggestionsEx || suggestions?.map((word) => ({ word }));
    const data = {
      text,
      issueType,
      isFlagged,
      isSuggestion: undefined,
      suggestions: haveSuggestionsMatchCase(text, sugs)
    };
    const diag = { severity: severity2, range, message: diagMessage, source: "cSpell", data };
    return diag;
  }).filter((diag) => !!diag.severity);
  return diags;
}
function haveSuggestionsMatchCase(example, suggestions) {
  if (!suggestions || exports_textApi.isLowerCase(example))
    return suggestions;
  return suggestions.map((sug) => exports_textApi.isLowerCase(sug.word) ? { ...sug, word: exports_textApi.matchCase(example, sug.word) } : sug);
}

// src/codeActions.ts
var import_node = __toESM(require_main4(), 1);
function extractText2(textDocument, range) {
  return textDocument.getText(range);
}
function extractDiagnosticData(diag) {
  const { data } = diag;
  if (!data || typeof data !== "object" || Array.isArray(data))
    return {};
  return data;
}
function createOnCodeActionHandler(documents) {
  const codeActionHandler = new CodeActionHandler(documents);
  return (params) => codeActionHandler.handler(params);
}

class CodeActionHandler {
  documents;
  sugGen;
  constructor(documents) {
    this.documents = documents;
    this.sugGen = new SuggestionGenerator;
  }
  async handler(params) {
    const {
      context,
      textDocument: { uri }
    } = params;
    const { diagnostics } = context;
    const spellCheckerDiags = diagnostics;
    if (!spellCheckerDiags.length)
      return [];
    const textDocument = this.documents.get(uri);
    if (!textDocument)
      return [];
    const rangeIntersectDiags = [...spellCheckerDiags].map((diag) => diag.range).reduce((a, _) => a, params.range);
    if (!rangeIntersectDiags || !isWordLikeSelection(textDocument, params.range)) {
      return [];
    }
    const ctx = {
      params,
      textDocument
    };
    const actions = await this.handlerCSpell({ ...ctx, diags: spellCheckerDiags });
    const codeAction = {
      title: "Add to dictrionary",
      kind: CodeActionKind.QuickFix,
      diagnostics,
      command: {
        title: "Add to dictrionary",
        command: "AddToDictionary",
        arguments: [
          {
            uri: params.textDocument.uri,
            range: diagnostics[0].range,
            message: diagnostics[0].message
          }
        ]
      }
    };
    actions.push(codeAction);
    return actions;
  }
  async handlerCSpell(handlerContext) {
    const { textDocument, diags: spellCheckerDiags } = handlerContext;
    const actions = [];
    const uri = textDocument.uri;
    if (!spellCheckerDiags.length)
      return [];
    if (spellCheckerDiags.length > 1)
      return [];
    function replaceText(range, text) {
      return TextEdit.replace(range, text || "");
    }
    const getSuggestions = (word) => {
      return this.sugGen.genWordSuggestions(textDocument, word);
    };
    async function genCodeActionsForSuggestions(_dictionary) {
      let diagWord;
      for (const diag of spellCheckerDiags) {
        const { issueType = IssueType.spelling, suggestions } = extractDiagnosticData(diag);
        const srcWord = extractText2(textDocument, diag.range);
        diagWord = diagWord || srcWord;
        const sugs = suggestions ?? await getSuggestions(srcWord);
        sugs.map(({ word, isPreferred }) => ({ word: exports_textApi.isLowerCase(word) ? exports_textApi.matchCase(srcWord, word) : word, isPreferred })).forEach((sug) => {
          const sugWord = sug.word;
          const title = suggestionToTitle(sug, issueType);
          if (!title)
            return;
          var workspaceEdit = {
            changes: { [uri]: [replaceText(diag.range, sugWord)] }
          };
          const action = crateWorkspaceAction(title, workspaceEdit, [diag], sug.isPreferred);
          actions.push(action);
        });
      }
      return actions;
    }
    const dictionary = await getDictionary({});
    return genCodeActionsForSuggestions(dictionary);
  }
}
function suggestionToTitle(sug, _) {
  return sug.word + (sug.isPreferred ? " (preferred)" : "");
}
function crateWorkspaceAction(title, workspaceEdit, diags, isPreferred) {
  const action = CodeAction.create(title, workspaceEdit, CodeActionKind.QuickFix);
  action.diagnostics = diags;
  if (isPreferred) {
    action.isPreferred = true;
  }
  return action;
}
function isWordLikeSelection(doc, range) {
  if (range.start.line !== range.end.line)
    return false;
  const text = doc.getText(range);
  const hasSpace = /\s/.test(text.trim());
  return !hasSpace;
}
var wordLengthForLimitingSuggestions = 15;
var maxNumberOfSuggestionsForLongWords = 1;
var regexJoinedWords = /[+]/g;

class SuggestionGenerator {
  async genSuggestions(doc, word) {
    const settings = await getSettigsForDocument(doc);
    const dictionary = await getDictionary(settings);
    const numSuggestions = 5;
    if (word.length > 20) {
      return [];
    }
    const numSugs = word.length > wordLengthForLimitingSuggestions ? Math.min(maxNumberOfSuggestionsForLongWords, numSuggestions) : numSuggestions;
    const options = {
      numChanges: 3,
      numSuggestions: numSugs,
      compoundMethod: CompoundWordsMethod.NONE,
      ignoreCase: false,
      includeTies: false
    };
    return dictionary.suggest(word, options).map((s) => ({ ...s, word: s.word.replace(regexJoinedWords, "") }));
  }
  async genWordSuggestions(doc, word) {
    return (await this.genSuggestions(doc, word)).map(({ word: word2, isPreferred }) => ({ word: word2, isPreferred }));
  }
}

// src/main.ts
var args = process.argv.slice(2);
var dictionaryPath = null;
var settingsCache = new Map;
var userWords = [];
for (let i = 0;i < args.length; i++) {
  if (args[i] === "--dictionary" && args[i + 1]) {
    try {
      dictionaryPath = args[i + 1];
      let stream = fs7.createReadStream(dictionaryPath);
      const rl = readline.createInterface({
        input: stream,
        crlfDelay: Infinity
      });
      for await (const line of rl) {
        userWords.push(line);
      }
      break;
    } catch (err) {
      console.error(`An error occurred while processing the file: ${err}`);
    }
  }
}
if (dictionaryPath) {
  console.log(`Dictionary path: ${dictionaryPath}`);
} else {
  console.log("No dictionary path provided");
}
var connection = import_node2.createConnection(import_node2.ProposedFeatures.all);
var documents = new import_node2.TextDocuments(TextDocument);
var hasConfigurationCapability = false;
var hasWorkspaceFolderCapability = false;
connection.onInitialize((_) => {
  const result = {
    capabilities: {
      textDocumentSync: {
        openClose: true,
        change: import_node2.TextDocumentSyncKind.Incremental,
        willSave: true,
        save: { includeText: true }
      },
      codeActionProvider: {
        codeActionKinds: [import_node2.CodeActionKind.QuickFix]
      },
      executeCommandProvider: {
        commands: ["AddToDictionary"]
      }
    }
  };
  return result;
});
connection.onInitialized(() => {
  if (hasConfigurationCapability) {
    connection.client.register(import_node2.DidChangeConfigurationNotification.type, undefined);
  }
  if (hasWorkspaceFolderCapability) {
    connection.workspace.onDidChangeWorkspaceFolders((_event) => {
      connection.console.log("Workspace folder change event received.");
    });
  }
});
connection.onCodeAction(createOnCodeActionHandler(documents));
documents.onDidChangeContent((change) => {
  validateTextDocument2(change.document);
});
async function validateTextDocument2(textDocument) {
  const settings = await getSettigsForDocument(textDocument);
  const diagnostics = await validateTextDocument(textDocument, settings);
  connection.sendDiagnostics({ uri: textDocument.uri, diagnostics });
}
async function getSettigsForDocument(textDocument) {
  let cached = settingsCache.get(textDocument.uri);
  if (cached) {
    return cached;
  }
  const settings = combineTextAndLanguageSettings(await getDefaultSettings(), undefined, textDocument.languageId);
  settings.userWords = [...userWords];
  settingsCache.set(textDocument.uri, settings);
  return settings;
}
connection.onExecuteCommand(async (params) => {
  const { command, arguments: args2 } = params;
  if (command == "AddToDictionary") {
    const diagnosticInfo = args2[0];
    const { uri, range } = diagnosticInfo;
    const document = documents.get(uri);
    if (!document) {
      return { error: `Could not get document for ${uri}` };
    }
    const word = document.getText(range);
    if (word) {
      userWords.push(word);
      if (dictionaryPath) {
        fs7.appendFile(dictionaryPath, word + `
`, () => {
        });
      }
      await validateTextDocument2(document);
      settingsCache = new Map;
      return { result: `Added "${word}" to the dictionary.` };
    }
    return { error: "Could not extract the word from the message." };
  }
});
documents.listen(connection);
connection.listen();
export {
  userWords,
  getSettigsForDocument
};
